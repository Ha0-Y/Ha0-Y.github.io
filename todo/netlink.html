<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="linux kernl netlink">
<meta property="og:type" content="website">
<meta property="og:title" content="{{title}}">
<meta property="og:url" content="https://ha0-y.github.io/todo/netlink.html">
<meta property="og:site_name" content="chips">
<meta property="og:description" content="linux kernl netlink">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-07-28T14:20:27.435Z">
<meta property="article:modified_time" content="2024-06-06T10:55:42.685Z">
<meta property="article:author" content="chips">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>{{title}}</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">chips</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">Home</a></li><!--
   --><!--
     --><li><a href="/about/">About</a></li><!--
   --><!--
     --><li><a href="/archives/">Writing</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/Ha0-Y">Projects</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <blockquote>
<p>linux kernl netlink</p>
</blockquote>
<span id="more"></span>


<p>netlink: 用户进程和内核进程进行交互，是一种特殊的 socket，它是 Linux 所特有的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ man netlink</span><br><span class="line">$ man 7 netlink</span><br></pre></td></tr></table></figure>

<p>IOCTL vs netlink</p>
<ul>
<li>netlink使用简单</li>
<li>异步通信：在内核与用户态应用之间传递的消息保存在socket缓存队列中，发送消息只是把消息保存在接收者的socket的接收队列，而不需要等待接收者收到消息</li>
<li>支持多播：内核模块或应用可以把消息多播给一个netlink组，属于该 netlink 组的任何内核模块或应用都能接收到该消息，内核事件向用户态的通知机制就使用了这一特性</li>
<li>…</li>
</ul>
<p>ifconfig 使用 IOCTL 进行通信<br>iptables 使用 netlink 进行通信</p>
<h2 id="UAPI"><a href="#UAPI" class="headerlink" title="UAPI"></a>UAPI</h2><p>socket: 其地址簇和类型比较固定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> domain,  <span class="comment">// AF_NETLINK</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> type,    <span class="comment">// SOCK_RAW or SOCK_DGRAM</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> protocol <span class="comment">// defined in include/uapi/linux/netlink.h</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>bind: sockaddr_nl 结构体，这个pid可以指定发送方和接收方的pid。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sockaddr =&gt; sockaddr_nl</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_nl</span> &#123;</span><br><span class="line">  <span class="type">sa_family_t</span>    nl_family;  <span class="comment">// AF_NETLINK</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nl_pad;     <span class="comment">// always zero</span></span><br><span class="line">  __u32          nl_pid;     <span class="comment">// port ID </span></span><br><span class="line">  __u32          nl_groups;  <span class="comment">// multicast groups mask</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_nl</span> nladdr;</span><br><span class="line">nladdr.nl_family = AF_NETLINK;</span><br><span class="line">nladdr.nl_pid = <span class="built_in">getpid</span>();</span><br><span class="line">nladdr.nl_groups = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;nladdr, <span class="built_in">sizeof</span>(nladdr));</span><br></pre></td></tr></table></figure>

<p>message: 我们发送消息的格式：header + data，发送连续的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// flags</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLM_F_REQUEST 1 <span class="comment">/* It is request message.         */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLM_F_MULTI 2   <span class="comment">/* Multipart message, terminated by NLMSG_DONE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLM_F_ACK 4     <span class="comment">/* Reply with ack, with zero or error code */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLM_F_ECHO 8    <span class="comment">/* Echo this request                 */</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_NOOP 0x1    <span class="comment">/* Nothing.                */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_ERROR 0x2   <span class="comment">/* Error                */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_DONE 0x3    <span class="comment">/* End of a dump        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_OVERRUN 0x4 <span class="comment">/* Data lost                */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nlmsghdr</span></span><br><span class="line">&#123;</span><br><span class="line">    __u32 nlmsg_len;   <span class="comment">/* Length of message */</span></span><br><span class="line">    __u16 nlmsg_type;  <span class="comment">/* Message type*/</span></span><br><span class="line">    __u16 nlmsg_flags; <span class="comment">/* Additional flags */</span></span><br><span class="line">    __u32 nlmsg_seq;   <span class="comment">/* Sequence number */</span></span><br><span class="line">    __u32 nlmsg_pid;   <span class="comment">/* Sending process PID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方便我们使用的宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4字节对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_ALIGNTO	4U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) &amp; ~(NLMSG_ALIGNTO-1) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// header 大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))</span></span><br><span class="line"><span class="comment">// 消息大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对齐后消息大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息体的位置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_DATA(nlh)  ((void *)(((char *)nlh) + NLMSG_HDRLEN))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送多个消息，下一个消息的位置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)-&gt;nlmsg_len), \</span></span><br><span class="line"><span class="meta">				  (struct nlmsghdr *)(((char *)(nlh)) + \</span></span><br><span class="line"><span class="meta">				  NLMSG_ALIGN((nlh)-&gt;nlmsg_len)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_OK(nlh,len) ((len) &gt;= (int)sizeof(struct nlmsghdr) &amp;&amp; \</span></span><br><span class="line"><span class="meta">			   (nlh)-&gt;nlmsg_len &gt;= sizeof(struct nlmsghdr) &amp;&amp; \</span></span><br><span class="line"><span class="meta">			   (nlh)-&gt;nlmsg_len &lt;= (len))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余消息的长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLMSG_PAYLOAD(nlh,len) ((nlh)-&gt;nlmsg_len - NLMSG_SPACE((len)))</span></span><br></pre></td></tr></table></figure>

<p>发送&#x2F;接收消息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendto 和 recvmsg 在 netlink中的buf，是nlmsghdr</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> sockfd, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="type">void</span> buf[.len], </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">size_t</span> len, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">socklen_t</span> addrler</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> sockfd, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">void</span> buf[restrict .len], </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">struct</span> sockaddr *_Nullable restrict src_addr,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">socklen_t</span> *_Nullable restrict addrlen</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// msgname: 数据的目的地址，网络包指向sockaddr_in, netlink则指向sockaddr_nl;</span></span><br><span class="line"><span class="comment">// msg_iov  iov: base 是 nlmsghdr 地址</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msghdr</span> &#123;</span><br><span class="line">   <span class="type">void</span>         *msg_name;       <span class="comment">/* Optional address */</span></span><br><span class="line">   <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">/* Size of address */</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">iovec</span> *msg_iov;        <span class="comment">/* Scatter/gather array */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="type">void</span>         *msg_control;    <span class="comment">/* Ancillary data, see below */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_controllen; <span class="comment">/* Ancillary data buffer len */</span></span><br><span class="line">   <span class="type">int</span>           msg_flags;      <span class="comment">/* Flags on received message */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> sockfd, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> flags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> sockfd, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">struct</span> msghdr *msg, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> flags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以接收多个消息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *nh;</span><br><span class="line">len = <span class="built_in">recvmsg</span>(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (nh = (<span class="keyword">struct</span> nlmsghdr *) buf; <span class="built_in">NLMSG_OK</span> (nh, len); nh = <span class="built_in">NLMSG_NEXT</span> (nh, len)) &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>netlink_kernel_create</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unit为协议号，与用户空间的protocol相同</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sock</span> *</span><br><span class="line"><span class="built_in">netlink_kernel_create</span>(<span class="keyword">struct</span> net *net, <span class="type">int</span> unit, <span class="keyword">struct</span> netlink_kernel_cfg *cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* optional Netlink kernel configuration parameters */</span></span><br><span class="line"><span class="comment">// input : 处理通信内容</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">netlink_kernel_cfg</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	groups;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	flags;</span><br><span class="line">	<span class="built_in">void</span>		    (*input)(<span class="keyword">struct</span> sk_buff *skb);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mutex</span>	*cb_mutex;</span><br><span class="line">	<span class="built_in">int</span>		        (*bind)(<span class="keyword">struct</span> net *net, <span class="type">int</span> group);</span><br><span class="line">	<span class="built_in">void</span>		    (*unbind)(<span class="keyword">struct</span> net *net, <span class="type">int</span> group);</span><br><span class="line">	<span class="built_in">void</span>            (*release) (<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">long</span> *groups);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>nl_table</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><h3 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h3><p><a target="_blank" rel="noopener" href="https://github.com/0voice/linux_kernel_wiki/blob/main/%E6%96%87%E7%AB%A0/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/%E9%A9%BE%E9%A9%ADLinux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20sk_buff.md">驾驭Linux内部网络实现</a></p>
<p><code>net_device</code>: 这个数据结构将用来代表网络设备，它会包含设备的硬件和软件配置信息。</p>
<p><code>sk_buff</code>: <a target="_blank" rel="noopener" href="https://www.llcblog.cn/2020/10/26/how-sk-buff-work/">sk_buff 简介</a><br>通常这个data是我们send的数据。这是一个比较大的结构体，可以抽象为如下的格式。一个双链表结构偶</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">                                ---------------</span><br><span class="line">                               | sk_buff       | &lt;--------&gt; sk_buff_head</span><br><span class="line">                                ---------------</span><br><span class="line">   ,---------------------------  + head</span><br><span class="line">  /          ,-----------------  + data</span><br><span class="line"> /          /      ,-----------  + tail</span><br><span class="line">|          |      |            , + end</span><br><span class="line">|          |      |           |</span><br><span class="line">v          v      v           v</span><br><span class="line"> -----------------------------------------------</span><br><span class="line">| headroom | data |  tailroom | skb_shared_info |</span><br><span class="line"> -----------------------------------------------</span><br><span class="line">                               + [page frag]</span><br><span class="line">                               + [page frag]</span><br><span class="line">                               + [page frag]</span><br><span class="line">                               + [page frag]       ---------</span><br><span class="line">                               + frag_list    --&gt; | sk_buff |</span><br><span class="line">                                                   ---------</span><br><span class="line"><span class="comment">// 核心内容</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sk_buff</span> &#123;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="comment">/* These two members must be first. */</span></span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">sk_buff</span>		*next;</span><br><span class="line">			<span class="keyword">struct</span> <span class="title class_">sk_buff</span>		*prev;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		tail;</span><br><span class="line">	<span class="type">sk_buff_data_t</span>		end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		*head,</span><br><span class="line">				*data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		truesize;</span><br><span class="line">	<span class="type">refcount_t</span>		users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line">	<span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">skb_ext</span>		*extensions;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sk_buff有着其单独的slab进行分配，但是其data使用通用slab，并且在data后有一个<code>skb_shared_info</code>结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alloc_skb</span>(...)</span><br><span class="line"><span class="built_in">dev_alloc_skb</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/skbuff.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SKB_HEAD_ALIGN(X) (SKB_DATA_ALIGN(X) + \</span></span><br><span class="line"><span class="meta">	SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// net/core/skbuff.c</span></span><br><span class="line">__alloc_skb(...)</span><br><span class="line">	skb = <span class="built_in">kmem_cache_alloc_node</span>(...); <span class="comment">// cache =&gt; skb_init =&gt; /proc/slabinfo </span></span><br><span class="line">	data = <span class="built_in">kmalloc_reserve</span>(...)</span><br><span class="line">	__build_skb_around(...)</span><br><span class="line">		__finalize_skb_around(...)</span><br><span class="line">			skb-&gt;data = data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="built_in">kmalloc_reserve</span>(<span class="type">unsigned</span> <span class="type">int</span> *size, <span class="type">gfp_t</span> flags, <span class="type">int</span> node,</span><br><span class="line">			     <span class="type">bool</span> *pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret_pfmemalloc = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">size_t</span> obj_size;</span><br><span class="line">	<span class="type">void</span> *obj;</span><br><span class="line"></span><br><span class="line">	obj_size = <span class="built_in">SKB_HEAD_ALIGN</span>(*size);</span><br><span class="line">	<span class="keyword">if</span> (obj_size &lt;= SKB_SMALL_HEAD_CACHE_SIZE &amp;&amp;</span><br><span class="line">	    !(flags &amp; KMALLOC_NOT_NORMAL_BITS)) &#123;</span><br><span class="line">		obj = <span class="built_in">kmem_cache_alloc_node</span>(net_hotdata.skb_small_head_cache,</span><br><span class="line">				flags | __GFP_NOMEMALLOC | __GFP_NOWARN,</span><br><span class="line">				node);</span><br><span class="line">		*size = SKB_SMALL_HEAD_CACHE_SIZE;</span><br><span class="line">		<span class="keyword">if</span> (obj || !(<span class="built_in">gfp_pfmemalloc_allowed</span>(flags)))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="comment">/* Try again but now we are using pfmemalloc reserves */</span></span><br><span class="line">		ret_pfmemalloc = <span class="literal">true</span>;</span><br><span class="line">		obj = <span class="built_in">kmem_cache_alloc_node</span>(net_hotdata.skb_small_head_cache, flags, node);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	obj_size = <span class="built_in">kmalloc_size_roundup</span>(obj_size);</span><br><span class="line">	<span class="comment">/* The following cast might truncate high-order bits of obj_size, this</span></span><br><span class="line"><span class="comment">	 * is harmless because kmalloc(obj_size &gt;= 2^32) will fail anyway.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*size = (<span class="type">unsigned</span> <span class="type">int</span>)obj_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try a regular allocation, when that fails and we&#x27;re not entitled</span></span><br><span class="line"><span class="comment">	 * to the reserves, fail.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	obj = <span class="built_in">kmalloc_node_track_caller</span>(obj_size,</span><br><span class="line">					flags | __GFP_NOMEMALLOC | __GFP_NOWARN,</span><br><span class="line">					node);</span><br><span class="line">	<span class="keyword">if</span> (obj || !(<span class="built_in">gfp_pfmemalloc_allowed</span>(flags)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try again but now we are using pfmemalloc reserves */</span></span><br><span class="line">	ret_pfmemalloc = <span class="literal">true</span>;</span><br><span class="line">	obj = <span class="built_in">kmalloc_node_track_caller</span>(obj_size, flags, node);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (pfmemalloc)</span><br><span class="line">		*pfmemalloc = ret_pfmemalloc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>skb_put：在数据域尾部追加一段空间</li>
<li>skb_push：在数据域的头部追加一段空间</li>
<li>skb_pull：将 skb-&gt;data 指针在数据域下移指定字节</li>
<li>skb_reserve：在 sk_buff 中 skb-&gt;data 之前的空间追加一段空间（在每层追加自己的协议头时常用到）</li>
</ul>
<p>skb_shared_info 用于记录frag 相关的信息。因为数据包可以无序发送，但是拼接必须有序。</p>
<p>Linux socketpair: 创建一个类似pipe的socket，双端通信，进行读写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>


<h3 id="generic-netlink"><a href="#generic-netlink" class="headerlink" title="generic netlink"></a>generic netlink</h3><p>netlink使用中，内核可以用来分配给 family 的 id 资源比较紧张。因此 generic netlink 协议在 netlink 协议上又做了一些拓展，即在 netlink message 的 payload 上又做了一层封装，也就是我们介绍的generic netlink</p>
<h4 id="UAPI-1"><a href="#UAPI-1" class="headerlink" title="UAPI"></a>UAPI</h4><p>发送的消息是如下的布局</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nlmsghdr</span>:</span><br><span class="line">  __u32 nlmsg_len    </span><br><span class="line">  __u16 nlmsg_type </span><br><span class="line">  __u16 nlmsg_flags</span><br><span class="line">  __u32 nlmsg_seq  </span><br><span class="line">  __u32 nlmsg_pid  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">genlmsghdr</span>:</span><br><span class="line">  __u8 cmd:           CTRL_CMD_GETFAMILY       <span class="comment">// 自定义cmd  </span></span><br><span class="line">  __u8 version      </span><br><span class="line">  __u16 reserved</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nlattr</span>:         <span class="comment">// 可以是多个 netlinkattr                         </span></span><br><span class="line">  __u16 nla_len</span><br><span class="line">  __u16 nla_type</span><br><span class="line">  <span class="type">char</span> data[]</span><br><span class="line"></span><br><span class="line">(padding:)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>msgtype: 存在一个默认的命令族 GENL_ID_CTRL，用户态程序便可以先向该命令族发送 CTRL_CMD_GETFAMILY 命令来获取某个命令族的 id</p>
<p>genmsghdr 有关计算的宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// genlmsg header 对齐后大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENL_HDRLEN	NLMSG_ALIGN(sizeof(struct genlmsghdr))</span></span><br></pre></td></tr></table></figure>

<p>attr 有关计算的宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NLA_ALIGNTO		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) &amp; ~(NLA_ALIGNTO - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))</span></span><br></pre></td></tr></table></figure>

<p>attr: netlink message data 也可以是某些attr，比如说rtattr(route)，这一部分需要查看一下 netfilter 相关的源码。</p>
<p>发送消息的方式和netlink基本类似。</p>
<h4 id="Kernel-1"><a href="#Kernel-1" class="headerlink" title="Kernel"></a>Kernel</h4><p>genl_family用于注册到generic netlink中，需要使用静态数据，因为后续处理需要该结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">genl_family</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hdrsize;       <span class="comment">// 自定义协议头大小</span></span><br><span class="line">  <span class="type">char</span> name[GENL_NAMSIZ];     <span class="comment">// 自定义协议名字</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> version;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> maxattr;       <span class="comment">// nla_type 最大值，超出该值的nlattr，不会被解析填充到genl_info中，也不会被policy校验。</span></span><br><span class="line">  u8 netnsok : <span class="number">1</span>;</span><br><span class="line">  u8 parallel_ops : <span class="number">1</span>;</span><br><span class="line">  u8 n_ops;                  <span class="comment">// ops数组长度。</span></span><br><span class="line">  u8 n_small_ops;</span><br><span class="line">  u8 n_split_ops;</span><br><span class="line">  u8 n_mcgrps;</span><br><span class="line">  u8 resv_start_op;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">nla_policy</span> *policy;</span><br><span class="line">  <span class="comment">// 如果非NULL，将在genl_ops的doit函数指针前执行。</span></span><br><span class="line">  <span class="built_in">int</span> (*pre_doit)(<span class="type">const</span> <span class="keyword">struct</span> genl_split_ops *ops, <span class="keyword">struct</span> sk_buff *skb,</span><br><span class="line">                  <span class="keyword">struct</span> genl_info *info);</span><br><span class="line">  <span class="comment">// 如果非NULL，将在genl_ops的doit函数指针执行。</span></span><br><span class="line">  <span class="built_in">void</span> (*post_doit)(<span class="type">const</span> <span class="keyword">struct</span> genl_split_ops *ops, <span class="keyword">struct</span> sk_buff *skb,</span><br><span class="line">                    <span class="keyword">struct</span> genl_info *info);</span><br><span class="line">  <span class="built_in">int</span> (*bind)(<span class="type">int</span> mcgrp);</span><br><span class="line">  <span class="built_in">void</span> (*unbind)(<span class="type">int</span> mcgrp);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">genl_ops</span> *ops;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">genl_small_ops</span> *small_ops;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">genl_split_ops</span> *split_ops;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">genl_multicast_group</span> *mcgrps;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">module</span> *<span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> sock_priv_size;</span><br><span class="line">  <span class="built_in">void</span> (*sock_priv_init)(<span class="type">void</span> *priv);</span><br><span class="line">  <span class="built_in">void</span> (*sock_priv_destroy)(<span class="type">void</span> *priv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* private: internal use only */</span></span><br><span class="line">  <span class="comment">/* protocol family identifier */</span></span><br><span class="line">  <span class="type">int</span> id;    <span class="comment">// ! family注册后最终确定的id，内核保留字段，自定义协议注册该字段保留0。</span></span><br><span class="line">  <span class="comment">/* starting number of multicast group IDs in this family */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> mcgrp_offset;</span><br><span class="line">  <span class="comment">/* list of per-socket privs */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">xarray</span> *sock_privs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其存在3个<code>genl_&#123;x&#125;_ops</code>结构体: 对传递的CMD进行处理，我们可以选择需要的op，内核存在对应的处理函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/genetlink.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">genl_ops</span> *ops;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">genl_small_ops</span> *small_ops;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">genl_split_ops</span> *split_ops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">genl_ops</span> &#123;</span><br><span class="line">  <span class="comment">// cmd 传入的处理函数</span></span><br><span class="line">  <span class="built_in">int</span> (*doit)(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> genl_info *info);</span><br><span class="line">  <span class="built_in">int</span> (*start)(<span class="keyword">struct</span> netlink_callback *cb);</span><br><span class="line">  <span class="comment">// 该cmd的请求nlmsg_flags中如果包含NLM_F_DUMP，将由该处理函数处理</span></span><br><span class="line">  <span class="built_in">int</span> (*dumpit)(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> netlink_callback *cb);</span><br><span class="line">  <span class="comment">// 在dumpit的一个完整逻辑完成后将会调用该处理函数</span></span><br><span class="line">  <span class="built_in">int</span> (*done)(<span class="keyword">struct</span> netlink_callback *cb);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">nla_policy</span> *policy;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> maxattr;</span><br><span class="line">  <span class="comment">// 处理的cmd，对应genlmsghdr中的cmd。</span></span><br><span class="line">  u8 cmd;</span><br><span class="line">  u8 internal_flags;</span><br><span class="line">  u8 flags;</span><br><span class="line">  u8 validate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/netlink/genetlink.c</span></span><br><span class="line"><span class="comment">// 会针对三种op进行处理</span></span><br><span class="line"><span class="built_in">genl_get_cmd</span>(...)</span><br></pre></td></tr></table></figure>

<p>genl_info: 传入的信息结构，我们可以解析<code>skb-&gt;data</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">genl_info</span> &#123;</span><br><span class="line">	u32			snd_seq;</span><br><span class="line">	u32			snd_portid;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">genl_family</span> *family;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *	nlhdr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">genlmsghdr</span> *	genlhdr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">nlattr</span> **	attrs;</span><br><span class="line">	<span class="type">possible_net_t</span>		_net;</span><br><span class="line">	<span class="type">void</span> *			user_ptr[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">netlink_ext_ack</span> *extack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>nla_policy</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nla_policy</span> &#123;</span><br><span class="line">	u8		type;</span><br><span class="line">	u8		validation_type;</span><br><span class="line">	u16		len;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		u16 strict_start_type;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* private: use NLA_POLICY_*() to set */</span></span><br><span class="line">		<span class="type">const</span> u32 bitfield32_valid;</span><br><span class="line">		<span class="type">const</span> u32 mask;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *reject_message;</span><br><span class="line">		<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">nla_policy</span> *nested_policy;</span><br><span class="line">		<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">netlink_range_validation</span> *range;</span><br><span class="line">		<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">netlink_range_validation_signed</span> *range_signed;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			s16 min, max;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">int</span> (*validate)(<span class="type">const</span> <span class="keyword">struct</span> nlattr *attr,</span><br><span class="line">				<span class="keyword">struct</span> netlink_ext_ack *extack);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核态定义 CMD 和 ATTRTYPE，然后内核进行处理，这样就可以定义很多netlink</p>
<p>注册流程: <code>net/netlink/genetlink.c</code> 源码 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	<span class="comment">// ATTR</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	<span class="comment">// CMD</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">genl_ops</span> ops_demo[] = &#123;</span><br><span class="line">	<span class="comment">// init</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">nla_policy</span> policy_demo = &#123;</span><br><span class="line">	<span class="comment">// init</span></span><br><span class="line">	[ATTR_XXX] = &#123;</span><br><span class="line">		.type = NLA_STRING</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">genl_family</span> family_demo = &#123;</span><br><span class="line">	<span class="comment">// init</span></span><br><span class="line">	<span class="comment">// op = </span></span><br><span class="line">	<span class="comment">// policy = </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">genl_register_family</span>(...)</span><br></pre></td></tr></table></figure>


<h3 id="libmnl-使用"><a href="#libmnl-使用" class="headerlink" title="libmnl 使用"></a>libmnl 使用</h3><p>netfilter 官方也是实现了一些库，可以简化这个过程。</p>
<ul>
<li>libmnl: <a target="_blank" rel="noopener" href="https://www.netfilter.org/projects/libmnl/">The netfilter.org “libmnl” project</a>；m表示<code>minimalistic</code></li>
</ul>
<p>安装</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libmnl-dev</span><br></pre></td></tr></table></figure>

<p>libmnl 核心就4个文件，很简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libmnl/libmnl.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>socket</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mnl_socket_open</span>(<span class="type">int</span> bus);</span><br><span class="line"><span class="built_in">mnl_socket_close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mnl_socket</span> &#123;</span><br><span class="line">	<span class="type">int</span> 			fd;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_nl</span>	addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">mnl_socket</span> *__mnl_socket_open(<span class="type">int</span> bus, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mnl_socket</span> *nl;</span><br><span class="line"></span><br><span class="line">	nl = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> mnl_socket));</span><br><span class="line">	<span class="keyword">if</span> (nl == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// flag 恒为0, bus 我们输入</span></span><br><span class="line">	nl-&gt;fd = <span class="built_in">socket</span>(AF_NETLINK, SOCK_RAW | flags, bus);</span><br><span class="line">	<span class="keyword">if</span> (nl-&gt;fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(nl);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind wrapper</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">int</span> <span class="title">mnl_socket_bind</span><span class="params">(<span class="keyword">struct</span> mnl_socket *nl, <span class="type">unsigned</span> <span class="type">int</span> groups,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="type">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">socklen_t</span> addr_len;</span><br><span class="line"></span><br><span class="line">	nl-&gt;addr.nl_family = AF_NETLINK;</span><br><span class="line">	nl-&gt;addr.nl_groups = groups;</span><br><span class="line">	nl-&gt;addr.nl_pid = pid;   <span class="comment">// MNL_SOCKET_AUTOPID</span></span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">bind</span>(nl-&gt;fd, (<span class="keyword">struct</span> sockaddr *) &amp;nl-&gt;addr, <span class="built_in">sizeof</span> (nl-&gt;addr));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	addr_len = <span class="built_in">sizeof</span>(nl-&gt;addr);</span><br><span class="line">	ret = <span class="built_in">getsockname</span>(nl-&gt;fd, (<span class="keyword">struct</span> sockaddr *) &amp;nl-&gt;addr, &amp;addr_len);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)	</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr_len != <span class="built_in">sizeof</span>(nl-&gt;addr)) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nl-&gt;addr.nl_family != AF_NETLINK) &#123;</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nlmsghdr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[MNL_SOCKET_BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 nlmsghdr 不包含任意data</span></span><br><span class="line">EXPORT_SYMBOL <span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *<span class="built_in">mnl_nlmsg_put_header</span>(<span class="type">void</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">MNL_ALIGN</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> nlmsghdr));</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *nlh = buf;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, len);</span><br><span class="line">	nlh-&gt;nlmsg_len = len;</span><br><span class="line">	<span class="keyword">return</span> nlh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加data</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得data的地址，然后可以进行输入</span></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">void</span> *<span class="title">mnl_nlmsg_get_payload_tail</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)nlh + <span class="built_in">MNL_ALIGN</span>(nlh-&gt;nlmsg_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加一个 genlmsghdr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个header地址, 然后就可以进行赋值</span></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">void</span> *<span class="title">mnl_nlmsg_put_extra_header</span><span class="params">(<span class="keyword">struct</span> nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="params"><span class="function">					       <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *ptr = (<span class="type">char</span> *)nlh + nlh-&gt;nlmsg_len;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="built_in">MNL_ALIGN</span>(size);</span><br><span class="line">	nlh-&gt;nlmsg_len += len;</span><br><span class="line">	<span class="built_in">memset</span>(ptr, <span class="number">0</span>, len);</span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nlmsg data 起始地址</span></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">void</span> *<span class="title">mnl_nlmsg_get_payload</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)nlh + MNL_NLMSG_HDRLEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加attr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mnl_attr_&#123;get|put&#125;_&#123;u8|u16|u32|u64|str|strz&#125;(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// strz: str with &#x27;\0&#x27;</span></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">void</span> <span class="title">mnl_attr_put_strz</span><span class="params">(<span class="keyword">struct</span> nlmsghdr *nlh, <span class="type">uint16_t</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">				     <span class="type">const</span> <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mnl_attr_put</span>(nlh, type, <span class="built_in">strlen</span>(data)+<span class="number">1</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">void</span> <span class="title">mnl_attr_put</span><span class="params">(<span class="keyword">struct</span> nlmsghdr *nlh, <span class="type">uint16_t</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">size_t</span> len, <span class="type">const</span> <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">nlattr</span> *attr = <span class="built_in">mnl_nlmsg_get_payload_tail</span>(nlh);</span><br><span class="line">	<span class="type">uint16_t</span> payload_len = <span class="built_in">MNL_ALIGN</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> nlattr)) + len;</span><br><span class="line">	<span class="type">int</span> pad;</span><br><span class="line"></span><br><span class="line">	attr-&gt;nla_type = type;</span><br><span class="line">	attr-&gt;nla_len = payload_len;</span><br><span class="line">	<span class="built_in">memcpy</span>(<span class="built_in">mnl_attr_get_payload</span>(attr), data, len);</span><br><span class="line">	pad = <span class="built_in">MNL_ALIGN</span>(len) - len;</span><br><span class="line">	<span class="keyword">if</span> (pad &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">memset</span>(<span class="built_in">mnl_attr_get_payload</span>(attr) + len, <span class="number">0</span>, pad);</span><br><span class="line"></span><br><span class="line">	nlh-&gt;nlmsg_len += <span class="built_in">MNL_ALIGN</span>(payload_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对type的检查</span></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">int</span> <span class="title">mnl_attr_type_valid</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *attr, <span class="type">uint16_t</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mnl_attr_get_type</span>(attr) &gt; max) &#123;</span><br><span class="line">		errno = EOPNOTSUPP;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">uint16_t</span> <span class="title">mnl_attr_get_type</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> attr-&gt;nla_type &amp; NLA_TYPE_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收发,sendto 和 recvmsg 的 wrapper</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">ssize_t</span> <span class="title">mnl_socket_sendto</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mnl_socket *nl,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">sockaddr_nl</span> snl = &#123;</span><br><span class="line">		.nl_family = AF_NETLINK</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sendto</span>(nl-&gt;fd, buf, len, <span class="number">0</span>, </span><br><span class="line">		      (<span class="keyword">struct</span> sockaddr *) &amp;snl, <span class="built_in">sizeof</span>(snl));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mnl_socket_recvfrom</span>(...)</span><br></pre></td></tr></table></figure>

<p>接收的消息是否合法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXPORT_SYMBOL <span class="type">int</span> <span class="title">mnl_cb_run</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> numbytes, <span class="type">unsigned</span> <span class="type">int</span> seq,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="type">unsigned</span> <span class="type">int</span> portid, <span class="type">mnl_cb_t</span> cb_data, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __mnl_cb_run(buf, numbytes, seq, portid, cb_data, data, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __mnl_cb_run(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> numbytes,</span><br><span class="line">			       <span class="type">unsigned</span> <span class="type">int</span> seq, <span class="type">unsigned</span> <span class="type">int</span> portid,</span><br><span class="line">			       <span class="type">mnl_cb_t</span> cb_data, <span class="type">void</span> *data,</span><br><span class="line">			       <span class="type">const</span> <span class="type">mnl_cb_t</span> *cb_ctl_array,</span><br><span class="line">			       <span class="type">unsigned</span> <span class="type">int</span> cb_ctl_array_len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = MNL_CB_OK, len = numbytes;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *nlh = buf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">mnl_nlmsg_ok</span>(nlh, len)) &#123;</span><br><span class="line">		<span class="comment">/* check message source */</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">mnl_nlmsg_portid_ok</span>(nlh, portid)) &#123;</span><br><span class="line">			errno = ESRCH;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* perform sequence tracking */</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">mnl_nlmsg_seq_ok</span>(nlh, seq)) &#123;</span><br><span class="line">			errno = EPROTO;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* dump was interrupted */</span></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP_INTR) &#123;</span><br><span class="line">			errno = EINTR;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* netlink data message handling */</span></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_type &gt;= NLMSG_MIN_TYPE) &#123; </span><br><span class="line">			<span class="keyword">if</span> (cb_data)&#123;</span><br><span class="line">				ret = <span class="built_in">cb_data</span>(nlh, data);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt;= MNL_CB_STOP)</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nlh-&gt;nlmsg_type &lt; cb_ctl_array_len) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cb_ctl_array &amp;&amp; cb_ctl_array[nlh-&gt;nlmsg_type]) &#123;</span><br><span class="line">				ret = cb_ctl_array[nlh-&gt;nlmsg_type](nlh, data);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt;= MNL_CB_STOP)</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (default_cb_array[nlh-&gt;nlmsg_type]) &#123;</span><br><span class="line">			ret = default_cb_array[nlh-&gt;nlmsg_type](nlh, data);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= MNL_CB_STOP)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		nlh = <span class="built_in">mnl_nlmsg_next</span>(nlh, &amp;len);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    chips
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/Ha0-Y">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
