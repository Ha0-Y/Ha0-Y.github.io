<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="AMD-V  AMD-VAMD Virtualization SVM（security virtual machine） 代码 包含相关教程  SimpleSvm: A minimalistic educational hypervisor for Windows on AMD processors.  相关文章  AMD-V Hypervisor Development - A Brief E">
<meta property="og:type" content="website">
<meta property="og:title" content="{{title}}">
<meta property="og:url" content="https://ha0-y.github.io/todo/hypervisor-in-rust-1.html">
<meta property="og:site_name" content="chips">
<meta property="og:description" content="AMD-V  AMD-VAMD Virtualization SVM（security virtual machine） 代码 包含相关教程  SimpleSvm: A minimalistic educational hypervisor for Windows on AMD processors.  相关文章  AMD-V Hypervisor Development - A Brief E">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-21T12:21:42.308Z">
<meta property="article:modified_time" content="2024-05-21T12:21:42.308Z">
<meta property="article:author" content="chips">
<meta property="article:tag" content="Fuzz">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>{{title}}</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">chips</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">Home</a></li><!--
   --><!--
     --><li><a href="/about/">About</a></li><!--
   --><!--
     --><li><a href="/archives/">Writing</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/Ha0-Y">Projects</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <blockquote>
<p>AMD-V</p>
</blockquote>
<h2 id="AMD-V"><a href="#AMD-V" class="headerlink" title="AMD-V"></a>AMD-V</h2><p>AMD Virtualization</p>
<p>SVM（security virtual machine）</p>
<p>代码 包含相关教程</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/tandasat/SimpleSvm/tree/master">SimpleSvm: A minimalistic educational hypervisor for Windows on AMD processors.</a></li>
</ul>
<p>相关文章</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.back.engineering/04/08/2022/">AMD-V Hypervisor Development - A Brief Explanation</a></li>
</ul>
<h3 id="检查是否支持"><a href="#检查是否支持" class="headerlink" title="检查是否支持"></a>检查是否支持</h3><p>首先，任然是cpuid这个函数查询硬件的支持情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  可查询处理器，以获取有关支持的功能和 CPU 类型的信息</span></span><br><span class="line"><span class="type">void</span> __cpuid(</span><br><span class="line">   <span class="type">int</span> cpuInfo[<span class="number">4</span>],</span><br><span class="line">   <span class="type">int</span> function_id</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __cpuidex(</span><br><span class="line">   <span class="type">int</span> cpuInfo[<span class="number">4</span>],</span><br><span class="line">   <span class="type">int</span> function_id,</span><br><span class="line">   <span class="type">int</span> subfunction_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/intrinsics/cpuid-cpuidex?view=msvc-170&devlangs=cpp&f1url=?appId=Dev17IDEF1&l=ZH-CN&k=k(__cpuid);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">cpuid, cpuidex | Microsoft Learn</a></p>
<p>首先，确保是一个AMD CPU</p>
<ul>
<li>function_id 为 0 时检测CPU厂商 <code>AuthenticAMD</code></li>
</ul>
<p>文档指出</p>
<ul>
<li>function_id 为 <code>0x80000001</code>，ECX SVM位为1代表CPU可以开启SVM</li>
<li>function_id 为 <code>0x8000000A</code>, EDX SVML 为0，代表bios开启SVM</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CPUID Fn8000_0001_ECX[SVM] == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> SVM_NOT_AVAIL;</span><br><span class="line"> <span class="keyword">if</span> (VM_CR.SVMDIS == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> SVM_ALLOWED;</span><br><span class="line"> <span class="function">AMD64 Technology</span></span><br><span class="line"><span class="function"> <span class="title">if</span> <span class="params">(CPUID Fn8000_000A_EDX[SVML]==<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">return</span> SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE</span></span><br><span class="line"><span class="function">  <span class="comment">// the user must change a platform firmware setting to enable SVM</span></span></span><br><span class="line"><span class="function"> <span class="keyword">else</span> <span class="keyword">return</span> SVM_DISABLED_WITH_KEY</span>;</span><br><span class="line">  <span class="comment">// SVMLock may be unlockable; consult platform firmware or TPM to obtain the </span></span><br><span class="line">key</span><br></pre></td></tr></table></figure>

<p>表现为如下的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CPUID_FN8000_0001_ECX_SVM                   (1UL &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPUID_FN8000_000A_EDX_SVML                  (1UL &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVM_MSR_VM_CR                               0xc0010114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVM_VM_CR_SVMDIS                            (1UL &lt;&lt; 4)</span></span><br><span class="line"><span class="function"><span class="type">static</span></span></span><br><span class="line"><span class="function">BOOLEAN</span></span><br><span class="line"><span class="function"><span class="title">SvmIsSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	VOID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOLEAN support = FALSE;</span><br><span class="line">	<span class="type">int</span> cpuInfo[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ULONG64 vmcr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// vendor = AuthenticAMD ?</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	__cpuid(cpuInfo, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> ((cpuInfo[<span class="number">1</span>] != <span class="string">&#x27;htuA&#x27;</span>) ||</span><br><span class="line">		(cpuInfo[<span class="number">3</span>] != <span class="string">&#x27;itne&#x27;</span>) ||</span><br><span class="line">		(cpuInfo[<span class="number">2</span>] != <span class="string">&#x27;DMAc&#x27;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[-] Not AMD CPU! \r\n&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> NotSupport;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[*] AMD CPU \r\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// CPU support SVM ?</span></span><br><span class="line">	<span class="comment">//if (CPUID Fn8000_0001_ECX[SVM] == 0)</span></span><br><span class="line">	<span class="comment">//	return SVM_NOT_AVAIL;</span></span><br><span class="line">	<span class="comment">//if (VM_CR.SVMDIS == 0)</span></span><br><span class="line">	<span class="comment">//	return SVM_ALLOWED;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	__cpuid(cpuInfo, <span class="number">0x80000001</span>);</span><br><span class="line">	<span class="keyword">if</span> ((cpuInfo[<span class="number">2</span>] &amp; CPUID_FN8000_0001_ECX_SVM) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[-] Not support SVM&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> NotSupport;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[*] Support SVM \r\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// SVM enable in BIOS ?</span></span><br><span class="line">	<span class="comment">//if (CPUID Fn8000_000A_EDX[SVML] == 0)</span></span><br><span class="line">	<span class="comment">//	return SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE</span></span><br><span class="line">	<span class="comment">//else return SVM_DISABLED_WITH_KEY;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	__cpuid(cpuInfo, <span class="number">0x8000000a</span>);</span><br><span class="line">	<span class="keyword">if</span> ((cpuInfo[<span class="number">3</span>] &amp; CPUID_FN8000_000A_EDX_SVML) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[-] Need startup SVM in BIOS \r\n&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> NotSupport;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[*] Startup SVM in BIOS \r\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// if (VM_CR.SVMDIS == 0)</span></span><br><span class="line">	<span class="comment">// 	return SVM_ALLOWED;</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	vmcr = __readmsr(SVM_MSR_VM_CR);</span><br><span class="line">	<span class="keyword">if</span> ((vmcr &amp; SVM_VM_CR_SVMDIS) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">KdPrint</span>((<span class="string">&quot;[-] VM_CR.SVMDIS != 0 \r\n&quot;</span>));</span><br><span class="line">		<span class="keyword">goto</span> NotSupport;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">KdPrint</span>((<span class="string">&quot;[+] VM_CR.SVMDIS == 0 \r\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">	support = TRUE;</span><br><span class="line"></span><br><span class="line">NotSupport:</span><br><span class="line">	<span class="keyword">return</span> support;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机做测试，开启SVM需要关闭Hyper-V才行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off   <span class="comment">// off -&gt; on 打开</span></span><br><span class="line">shutdown /r</span><br></pre></td></tr></table></figure>


<p>保留的CPUID</p>
<blockquote>
<p>The CPUID function numbers 4000_0000h–4000_00FFh have been reserved for software use.</p>
</blockquote>
<p>我们可以在VMM里自定义这些保留的CPUID</p>
<h3 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h3><h4 id="enable-SVM"><a href="#enable-SVM" class="headerlink" title="enable SVM"></a>enable SVM</h4><p><code>#VMRUN</code></p>
<blockquote>
<p>MSR（Model Specific Register）是x86架构中的概念，指的是在x86架构处理器中，一系列用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。</p>
</blockquote>
<p>enable SVM，文档中指出: </p>
<ul>
<li><code>EFER.SVME</code>被设置为1</li>
</ul>
<blockquote>
<p>IA32_EFER，全称为 <code>IA-32e Mode Extended Feature Register</code>。它是在处理器进入 64 位长模式（IA-32e 或 AMD64 模式）时引入的。这个寄存器包含了一些控制和状态位，用于管理和控制 64 位长模式的一些扩展功能，比如启用或禁用 No-Execute (NX) 位、启用或禁用 Supervisor Execution Disable (SMEP) 位等。通过修改 IA32_EFER 寄存器的值，可以对这些功能进行配置和控制。</p>
</blockquote>
<p>代码表示</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EFER_SVME: <span class="type">u64</span> = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">__writemsr(IA32_MSR_EFER, __readmsr(IA32_MSR_EFER) | EFER_SVME);</span><br></pre></td></tr></table></figure>

<h5 id="Virtual-Machine-Control-Block"><a href="#Virtual-Machine-Control-Block" class="headerlink" title="Virtual Machine Control Block"></a>Virtual Machine Control Block</h5><p>和Intel VMCS类似的概念， 该数据结构包含了启动和控制一个虚拟机的全部信息，每个guest os都包含一个这样的信息</p>
<p>文档中指出，<code>VMRUN</code> 存在一个参数，4K 对齐page - VMCB - guest </p>
<blockquote>
<p>VMRUN takes, as a single argument, the physical address of a 4KB-aligned page, the virtual machine control block (VMCB), which describes a virtual machine (guest) to be executed. </p>
</blockquote>
<p>文档后面的附录 Appendix B VMCB Layout，还可以查看Linux相关代码</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/svm.h">arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;svm.h</a></li>
<li><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/uapi/asm/svm.h">arch&#x2F;x86&#x2F;include&#x2F;uapi&#x2F;asm&#x2F;svm.h</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">vmcb</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vmcb_control_area</span> control;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vmcb_save_area</span> save;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></figure>

<p>vmsave 保存vmcb的物理地址</p>
<ul>
<li>vmlanuch: guest vmcb</li>
<li>VMEXIT: 退回host vmcb</li>
</ul>
<p>其定义了一个每个CPU core共享的内容，Msr和页表，可以映射512G内存（512 * 512 页）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SHARED_VIRTUAL_PROCESSOR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID MsrPermissionsMap;</span><br><span class="line">    <span class="built_in">DECLSPEC_ALIGN</span>(PAGE_SIZE) PML4_ENTRY_2MB Pml4Entries[<span class="number">1</span>];    <span class="comment">// Just for 512 GB</span></span><br><span class="line">    <span class="built_in">DECLSPEC_ALIGN</span>(PAGE_SIZE) PDP_ENTRY_2MB PdpEntries[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">DECLSPEC_ALIGN</span>(PAGE_SIZE) PD_ENTRY_2MB PdeEntries[<span class="number">512</span>][<span class="number">512</span>];</span><br><span class="line">&#125; SHARED_VIRTUAL_PROCESSOR_DATA, *PSHARED_VIRTUAL_PROCESSOR_DATA;</span><br></pre></td></tr></table></figure>

<p>SvVirtualizeAllProcessors: 虚拟化所有的处理器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 检查硬件支持</span></span><br><span class="line"><span class="built_in">SvIsSvmSupported</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 处理器共享的内容</span></span><br><span class="line"><span class="built_in">SvAllocatePageAlingedPhysicalMemory</span>(<span class="built_in">sizeof</span>(SHARED_VIRTUAL_PROCESSOR_DATA)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建VM的页表</span></span><br><span class="line"><span class="built_in">SvBuildNestedPageTables</span>(sharedVpData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. VM Msr</span></span><br><span class="line"><span class="built_in">SvBuildMsrPermissionsMap</span>(sharedVpData-&gt;MsrPermissionsMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 回调函数，虚拟化每一个处理器</span></span><br><span class="line"><span class="built_in">SvExecuteOnEachProcessor</span>(SvVirtualizeProcessor, sharedVpData, &amp;numOfProcessorsCompleted);</span><br></pre></td></tr></table></figure>

<p>SvVirtualizeProcessor: 对每一个CPU进行虚拟化，context就是 <code>sharedVpData</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span></span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">SvVirtualizeProcessor</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PVOID Context</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status;</span><br><span class="line">    PSHARED_VIRTUAL_PROCESSOR_DATA sharedVpData;</span><br><span class="line">    PVIRTUAL_PROCESSOR_DATA vpData;</span><br><span class="line">    PCONTEXT contextRecord;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SV_DEBUG_BREAK</span>();</span><br><span class="line"></span><br><span class="line">    vpData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NT_ASSERT</span>(<span class="built_in">ARGUMENT_PRESENT</span>(Context));</span><br><span class="line">    _Analysis_assume_(<span class="built_in">ARGUMENT_PRESENT</span>(Context));</span><br><span class="line"></span><br><span class="line">    contextRecord = <span class="built_in">static_cast</span>&lt;PCONTEXT&gt;(<span class="built_in">ExAllocatePoolWithTag</span>(</span><br><span class="line">                                                        NonPagedPool,</span><br><span class="line">                                                        <span class="built_in">sizeof</span>(*contextRecord),</span><br><span class="line">                                                        <span class="string">&#x27;MVSS&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (contextRecord == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SvDebugPrint</span>(<span class="string">&quot;Insufficient memory.\n&quot;</span>);</span><br><span class="line">        status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Allocate per processor data.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> prefast(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> prefast(disable : __WARNING_MEMORY_LEAK, <span class="string">&quot;Ownership is taken on success.&quot;</span>)</span></span><br><span class="line">    vpData = <span class="built_in">static_cast</span>&lt;PVIRTUAL_PROCESSOR_DATA&gt;(</span><br><span class="line">            <span class="built_in">SvAllocatePageAlingedPhysicalMemory</span>(<span class="built_in">sizeof</span>(VIRTUAL_PROCESSOR_DATA)));</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> prefast(pop)</span></span><br><span class="line">    <span class="keyword">if</span> (vpData == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SvDebugPrint</span>(<span class="string">&quot;Insufficient memory.\n&quot;</span>);</span><br><span class="line">        status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Capture the current RIP, RSP, RFLAGS, and segment selectors. This</span></span><br><span class="line">    <span class="comment">// captured state is used as an initial state of the guest mode; therefore</span></span><br><span class="line">    <span class="comment">// when virtualization starts by the later call of SvLaunchVm, a processor</span></span><br><span class="line">    <span class="comment">// resume its execution at this location and state.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">RtlCaptureContext</span>(contextRecord);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// First time of this execution, the SimpleSvm hypervisor is not installed</span></span><br><span class="line">    <span class="comment">// yet. Therefore, the branch is taken, and virtualization is attempted.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// At the second execution of here, after SvLaunchVm virtualized the</span></span><br><span class="line">    <span class="comment">// processor, SvIsSimpleSvmHypervisorInstalled returns TRUE, and this</span></span><br><span class="line">    <span class="comment">// function exits with STATUS_SUCCESS.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SvIsSimpleSvmHypervisorInstalled</span>() == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SvDebugPrint</span>(<span class="string">&quot;Attempting to virtualize the processor.\n&quot;</span>);</span><br><span class="line">        sharedVpData = <span class="built_in">static_cast</span>&lt;PSHARED_VIRTUAL_PROCESSOR_DATA&gt;(Context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Enable SVM by setting EFER.SVME. It has already been verified that this</span></span><br><span class="line">        <span class="comment">// bit was writable with SvIsSvmSupported.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        __writemsr(IA32_MSR_EFER, __readmsr(IA32_MSR_EFER) | EFER_SVME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Set up VMCB, the structure describes the guest state and what events</span></span><br><span class="line">        <span class="comment">// within the guest should be intercepted, ie, triggers #VMEXIT.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">SvPrepareForVirtualization</span>(vpData, sharedVpData, contextRecord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Switch to the host RSP to run as the host (hypervisor), and then</span></span><br><span class="line">        <span class="comment">// enters loop that executes code as a guest until #VMEXIT happens and</span></span><br><span class="line">        <span class="comment">// handles #VMEXIT as the host.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This function should never return to here.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">SvLaunchVm</span>(&amp;vpData-&gt;HostStackLayout.GuestVmcbPa);</span><br><span class="line">        <span class="built_in">SV_DEBUG_BREAK</span>();</span><br><span class="line">        <span class="built_in">KeBugCheck</span>(MANUALLY_INITIATED_CRASH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SvDebugPrint</span>(<span class="string">&quot;The processor has been virtualized.\n&quot;</span>);</span><br><span class="line">    status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="keyword">if</span> (contextRecord != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>(contextRecord, <span class="string">&#x27;MVSS&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!<span class="built_in">NT_SUCCESS</span>(status)) &amp;&amp; (vpData != <span class="literal">nullptr</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Frees per processor data if allocated and this function is</span></span><br><span class="line">        <span class="comment">// unsuccessful.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">SvFreePageAlingedPhysicalMemory</span>(vpData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化工作：gdt, idt, guest VMCB，页表，描述符，寄存器。然后调用 VMSAVE 保存 guest VMCB。最后保存host VMCB的物理地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span></span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">SvPrepareForVirtualization</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ PVIRTUAL_PROCESSOR_DATA VpData,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ PSHARED_VIRTUAL_PROCESSOR_DATA SharedVpData,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="type">const</span> CONTEXT* ContextRecord</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DESCRIPTOR_TABLE_REGISTER gdtr, idtr;</span><br><span class="line">    PHYSICAL_ADDRESS guestVmcbPa, hostVmcbPa, hostStateAreaPa, pml4BasePa, msrpmPa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Capture the current GDTR and IDTR to use as initial values of the guest</span></span><br><span class="line">    <span class="comment">// mode.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _sgdt(&amp;gdtr);</span><br><span class="line">    __sidt(&amp;idtr);</span><br><span class="line"></span><br><span class="line">    guestVmcbPa = <span class="built_in">MmGetPhysicalAddress</span>(&amp;VpData-&gt;GuestVmcb);</span><br><span class="line">    hostVmcbPa = <span class="built_in">MmGetPhysicalAddress</span>(&amp;VpData-&gt;HostVmcb);</span><br><span class="line">    hostStateAreaPa = <span class="built_in">MmGetPhysicalAddress</span>(&amp;VpData-&gt;HostStateArea);</span><br><span class="line">    pml4BasePa = <span class="built_in">MmGetPhysicalAddress</span>(&amp;SharedVpData-&gt;Pml4Entries);</span><br><span class="line">    msrpmPa = <span class="built_in">MmGetPhysicalAddress</span>(SharedVpData-&gt;MsrPermissionsMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Configure to trigger #VMEXIT with CPUID and VMRUN instructions. CPUID is</span></span><br><span class="line">    <span class="comment">// intercepted to present existence of the SimpleSvm hypervisor and provide</span></span><br><span class="line">    <span class="comment">// an interface to ask it to unload itself.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// VMRUN is intercepted because it is required by the processor to enter the</span></span><br><span class="line">    <span class="comment">// guest mode; otherwise, #VMEXIT occurs due to VMEXIT_INVALID when a</span></span><br><span class="line">    <span class="comment">// processor attempts to enter the guest mode. See &quot;Canonicalization and</span></span><br><span class="line">    <span class="comment">// Consistency Checks&quot; on &quot;VMRUN Instruction&quot;.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    VpData-&gt;GuestVmcb.ControlArea.InterceptMisc1 |= SVM_INTERCEPT_MISC1_CPUID;</span><br><span class="line">    VpData-&gt;GuestVmcb.ControlArea.InterceptMisc2 |= SVM_INTERCEPT_MISC2_VMRUN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Also, configure to trigger #VMEXIT on MSR access as configured by the</span></span><br><span class="line">    <span class="comment">// MSRPM. In our case, write to IA32_MSR_EFER is intercepted.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    VpData-&gt;GuestVmcb.ControlArea.InterceptMisc1 |= SVM_INTERCEPT_MISC1_MSR_PROT;</span><br><span class="line">    VpData-&gt;GuestVmcb.ControlArea.MsrpmBasePa = msrpmPa.QuadPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Specify guest&#x27;s address space ID (ASID). TLB is maintained by the ID for</span></span><br><span class="line">    <span class="comment">// guests. Use the same value for all processors since all of them run a</span></span><br><span class="line">    <span class="comment">// single guest in our case. Use 1 as the most likely supported ASID by the</span></span><br><span class="line">    <span class="comment">// processor. The actual the supported number of ASID can be obtained with</span></span><br><span class="line">    <span class="comment">// CPUID. See &quot;CPUID Fn8000_000A_EBX SVM Revision and Feature</span></span><br><span class="line">    <span class="comment">// Identification&quot;. Zero of ASID is reserved and illegal.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    VpData-&gt;GuestVmcb.ControlArea.GuestAsid = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Enable Nested Page Tables. By enabling this, the processor performs the</span></span><br><span class="line">    <span class="comment">// nested page walk, that involves with an additional page walk to translate</span></span><br><span class="line">    <span class="comment">// a guest physical address to a system physical address. An address of</span></span><br><span class="line">    <span class="comment">// nested page tables is specified by the NCr3 field of VMCB.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We have already build the nested page tables with SvBuildNestedPageTables.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that our hypervisor does not trigger any additional #VMEXIT due to</span></span><br><span class="line">    <span class="comment">// the use of Nested Page Tables since all physical addresses from 0-512 GB</span></span><br><span class="line">    <span class="comment">// are configured to be accessible from the guest.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    VpData-&gt;GuestVmcb.ControlArea.NpEnable |= SVM_NP_ENABLE_NP_ENABLE;</span><br><span class="line">    VpData-&gt;GuestVmcb.ControlArea.NCr3 = pml4BasePa.QuadPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set up the initial guest state based on the current system state. Those</span></span><br><span class="line">    <span class="comment">// values are loaded into the processor as guest state when the VMRUN</span></span><br><span class="line">    <span class="comment">// instruction is executed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.GdtrBase = gdtr.Base;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.GdtrLimit = gdtr.Limit;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.IdtrBase = idtr.Base;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.IdtrLimit = idtr.Limit;</span><br><span class="line"></span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.CsLimit = <span class="built_in">GetSegmentLimit</span>(ContextRecord-&gt;SegCs);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.DsLimit = <span class="built_in">GetSegmentLimit</span>(ContextRecord-&gt;SegDs);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.EsLimit = <span class="built_in">GetSegmentLimit</span>(ContextRecord-&gt;SegEs);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.SsLimit = <span class="built_in">GetSegmentLimit</span>(ContextRecord-&gt;SegSs);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.CsSelector = ContextRecord-&gt;SegCs;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.DsSelector = ContextRecord-&gt;SegDs;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.EsSelector = ContextRecord-&gt;SegEs;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.SsSelector = ContextRecord-&gt;SegSs;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.CsAttrib = <span class="built_in">SvGetSegmentAccessRight</span>(ContextRecord-&gt;SegCs, gdtr.Base);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.DsAttrib = <span class="built_in">SvGetSegmentAccessRight</span>(ContextRecord-&gt;SegDs, gdtr.Base);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.EsAttrib = <span class="built_in">SvGetSegmentAccessRight</span>(ContextRecord-&gt;SegEs, gdtr.Base);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.SsAttrib = <span class="built_in">SvGetSegmentAccessRight</span>(ContextRecord-&gt;SegSs, gdtr.Base);</span><br><span class="line"></span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Efer = __readmsr(IA32_MSR_EFER);</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Cr0 = __readcr0();</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Cr2 = __readcr2();</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Cr3 = __readcr3();</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Cr4 = __readcr4();</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Rflags = ContextRecord-&gt;EFlags;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Rsp = ContextRecord-&gt;Rsp;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.Rip = ContextRecord-&gt;Rip;</span><br><span class="line">    VpData-&gt;GuestVmcb.StateSaveArea.GPat = __readmsr(IA32_MSR_PAT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Save some of the current state on VMCB. Some of those states are:</span></span><br><span class="line">    <span class="comment">// - FS, GS, TR, LDTR (including all hidden state)</span></span><br><span class="line">    <span class="comment">// - KernelGsBase</span></span><br><span class="line">    <span class="comment">// - STAR, LSTAR, CSTAR, SFMASK</span></span><br><span class="line">    <span class="comment">// - SYSENTER_CS, SYSENTER_ESP, SYSENTER_EIP</span></span><br><span class="line">    <span class="comment">// See &quot;VMSAVE and VMLOAD Instructions&quot; for mode details.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Those are restored to the processor right before #VMEXIT with the VMLOAD</span></span><br><span class="line">    <span class="comment">// instruction so that the guest can start its execution with saved state,</span></span><br><span class="line">    <span class="comment">// and also, re-saved to the VMCS with right after #VMEXIT with the VMSAVE</span></span><br><span class="line">    <span class="comment">// instruction so that the host (hypervisor) do not destroy guest&#x27;s state.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    __svm_vmsave(guestVmcbPa.QuadPart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Store data to stack so that the host (hypervisor) can use those values.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    VpData-&gt;HostStackLayout.Reserved1 = MAXUINT64;</span><br><span class="line">    VpData-&gt;HostStackLayout.SharedVpData = SharedVpData;</span><br><span class="line">    VpData-&gt;HostStackLayout.Self = VpData;</span><br><span class="line">    VpData-&gt;HostStackLayout.HostVmcbPa = hostVmcbPa.QuadPart;</span><br><span class="line">    VpData-&gt;HostStackLayout.GuestVmcbPa = guestVmcbPa.QuadPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set an address of the host state area to VM_HSAVE_PA MSR. The processor</span></span><br><span class="line">    <span class="comment">// saves some of the current state on VMRUN and loads them on #VMEXIT. See</span></span><br><span class="line">    <span class="comment">// &quot;VM_HSAVE_PA MSR (C001_0117h)&quot;.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    __writemsr(SVM_MSR_VM_HSAVE_PA, hostStateAreaPa.QuadPart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Also, save some of the current state to VMCB for the host. This is loaded</span></span><br><span class="line">    <span class="comment">// after #VMEXIT to reproduce the current state for the host (hypervisor).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    __svm_vmsave(hostVmcbPa.QuadPart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内存布局</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_VIRTUAL_PROCESSOR_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  Low     HostStackLimit[0]                        StackLimit</span></span><br><span class="line">        <span class="comment">//  ^       ...</span></span><br><span class="line">        <span class="comment">//  ^       HostStackLimit[KERNEL_STACK_SIZE - 2]    StackBase</span></span><br><span class="line">        <span class="comment">//  High    HostStackLimit[KERNEL_STACK_SIZE - 1]    StackBase</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">DECLSPEC_ALIGN</span>(PAGE_SIZE) UINT8 HostStackLimit[KERNEL_STACK_SIZE];</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            UINT8 StackContents[KERNEL_STACK_SIZE - (<span class="built_in">sizeof</span>(PVOID) * <span class="number">6</span>) - <span class="built_in">sizeof</span>(KTRAP_FRAME)];</span><br><span class="line">            KTRAP_FRAME TrapFrame;</span><br><span class="line">            UINT64 GuestVmcbPa;     <span class="comment">// HostRsp</span></span><br><span class="line">            UINT64 HostVmcbPa;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_VIRTUAL_PROCESSOR_DATA</span>* Self;</span><br><span class="line">            PSHARED_VIRTUAL_PROCESSOR_DATA SharedVpData;</span><br><span class="line">            UINT64 Padding1;        <span class="comment">// To keep HostRsp 16 bytes aligned</span></span><br><span class="line">            UINT64 Reserved1;</span><br><span class="line">        &#125; HostStackLayout;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DECLSPEC_ALIGN</span>(PAGE_SIZE) VMCB GuestVmcb;</span><br><span class="line">    <span class="built_in">DECLSPEC_ALIGN</span>(PAGE_SIZE) VMCB HostVmcb;</span><br><span class="line">    <span class="built_in">DECLSPEC_ALIGN</span>(PAGE_SIZE) UINT8 HostStateArea[PAGE_SIZE];</span><br><span class="line">&#125; VIRTUAL_PROCESSOR_DATA, *PVIRTUAL_PROCESSOR_DATA;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(VIRTUAL_PROCESSOR_DATA) == KERNEL_STACK_SIZE + PAGE_SIZE * <span class="number">3</span>,</span><br><span class="line">              <span class="string">&quot;VIRTUAL_PROCESSOR_DATA Size Mismatch&quot;</span>);</span><br><span class="line">    </span><br><span class="line">+--------------------+ &lt;- 高地址</span><br><span class="line">| HostStateArea      |</span><br><span class="line">+--------------------+  </span><br><span class="line">| VMCB               |</span><br><span class="line">+--------------------+  </span><br><span class="line">| HostStackLayout    |</span><br><span class="line">+                    +</span><br></pre></td></tr></table></figure>

<p>SvLaunchVm: </p>
<ul>
<li>rsp 移动到 guest os 的栈上进行运行（rcx是 &#96;&amp;vpData-&gt;HostStackLayout.GuestVmcbPa）</li>
<li>vmload: 上一次运行的状态</li>
<li>vmrun 一个参数，guest os vmcb的物理地址</li>
<li>发生VMEXIT后，vmrun结束，vmsave保存现在的状态</li>
<li>保存通用寄存器</li>
<li>SvHandleVmExit: vmload 进入host os，处理来自vm的请求</li>
<li>当前vm没有退出：恢复寄存器的值，继续运行</li>
<li>退出 SvLV20: jmp 到 rbx, 更新ecx值，代表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">SvLaunchVm proc frame</span><br><span class="line">        ;</span><br><span class="line">        ; Update the current stack pointer with the host RSP. This protects</span><br><span class="line">        ; values stored on stack <span class="keyword">for</span> the hypervisor from being overwritten by</span><br><span class="line">        ; the guest due to a use of the same stack memory.</span><br><span class="line">        ;</span><br><span class="line">        mov rsp, rcx    ; Rsp &lt;= HostRsp</span><br><span class="line"></span><br><span class="line">SvLV10: ;</span><br><span class="line">        ; Run the loop to executed the guest <span class="keyword">and</span> handle #VMEXIT. Below is the</span><br><span class="line">        ; current stack leyout.</span><br><span class="line">        ; ----</span><br><span class="line">        ; Rsp          =&gt; <span class="number">0</span>x...fd0 GuestVmcbPa       ; HostStackLayout</span><br><span class="line">        ;                 <span class="number">0</span>x...fd8 HostVmcbPa        ;</span><br><span class="line">        ;                 <span class="number">0</span>x...fe0 Self              ;</span><br><span class="line">        ;                 <span class="number">0</span>x...fe8 SharedVpData      ;</span><br><span class="line">        ;                 <span class="number">0</span>x...ff0 Padding1          ;</span><br><span class="line">        ;                 <span class="number">0</span>x...ff8 Reserved1         ;</span><br><span class="line">        ; ----</span><br><span class="line">        ;</span><br><span class="line">        mov rax, [rsp]  ; RAX &lt;= VpData-&gt;HostStackLayout.GuestVmcbPa</span><br><span class="line">        vmload rax      ; load previously saved guest state from VMCB</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; Start the guest. The VMRUN instruction resumes execution of the guest</span><br><span class="line">        ; <span class="function">with state described in <span class="title">VMCB</span> <span class="params">(specified by RAX by its physical address)</span></span></span><br><span class="line"><span class="function">        </span>; until #VMEXI is triggered. On #VMEXIT, the VMRUN instruction completes</span><br><span class="line">        ; <span class="function"><span class="keyword">and</span> resumes the next <span class="title">instruction</span> <span class="params">(ie, vmsave in our <span class="keyword">case</span>)</span>.</span></span><br><span class="line"><span class="function">        </span>;</span><br><span class="line">        ; The VMRUN instruction does the following things in <span class="keyword">this</span> order:</span><br><span class="line">        ; - <span class="function">saves some current <span class="title">state</span> <span class="params">(ie. host state)</span> into the host state-save</span></span><br><span class="line"><span class="function">        </span>;   area specified in IA32_MSR_VM_HSAVE_PA</span><br><span class="line">        ; - loads guest state from the VMCB state-save area</span><br><span class="line">        ; - <span class="function">enables interrupts by setting the the global interrupt <span class="title">flag</span> <span class="params">(GIF)</span></span></span><br><span class="line"><span class="function">        </span>; - resumes execution of the guest until #VMEXIT occurs</span><br><span class="line">        ; See <span class="string">&quot;Basic Operation&quot;</span> <span class="keyword">for</span> more details.</span><br><span class="line">        ;</span><br><span class="line">        ; On #VMEXIT:</span><br><span class="line">        ; - <span class="function">disables interrupts by clearing the the global interrupt <span class="title">flag</span> <span class="params">(GIF)</span></span></span><br><span class="line"><span class="function">        </span>; - saves current guest state into <span class="keyword">and</span> update VMCB to provide information</span><br><span class="line">        ;   to handle #VMEXIT</span><br><span class="line">        ; - loads the host state previously saved by the VMRUN instruction</span><br><span class="line">        ; See <span class="string">&quot;#VMEXIT&quot;</span> in the volume <span class="number">2</span> <span class="keyword">and</span> <span class="string">&quot;VMRUN&quot;</span> in the volume <span class="number">3</span> <span class="keyword">for</span> more</span><br><span class="line">        ; details.</span><br><span class="line">        ;</span><br><span class="line">        vmrun rax       ; Switch to the guest until #VMEXIT</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; #VMEXIT occured. Now, some of guest state has been saved to VMCB, but</span><br><span class="line">        ; <span class="keyword">not</span> all of it. Save some of unsaved state with the VMSAVE instruction.</span><br><span class="line">        ;</span><br><span class="line">        ; <span class="built_in">RAX</span> (<span class="keyword">and</span> some other state like RSP) has been restored from the host</span><br><span class="line">        ; state-save, so it has the same value as before <span class="keyword">and</span> <span class="keyword">not</span> guest<span class="number">&#x27;</span>s one.</span><br><span class="line">        ;</span><br><span class="line">        vmsave rax      ; Save current guest state to VMCB</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; Optionally, allocate the trap frame so that Windbg can display stack</span><br><span class="line">        ; trace of the guest <span class="keyword">while</span> SvHandleVmExit is being executed. The trap</span><br><span class="line">        ; frame fields necessary <span class="keyword">for</span> <span class="keyword">this</span> are initialized in SvHandleVmExit.</span><br><span class="line">        ;</span><br><span class="line">        .pushframe</span><br><span class="line">        sub     rsp, KTRAP_FRAME_SIZE</span><br><span class="line">        .allocstack KTRAP_FRAME_SIZE - MACHINE_FRAME_SIZE + <span class="number">100</span>h</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; Also save guest<span class="number">&#x27;</span>s GPRs since those are <span class="keyword">not</span> saved anywhere by the</span><br><span class="line">        ; processor on #VMEXIT <span class="keyword">and</span> will be destroyed by subsequent host code.</span><br><span class="line">        ;</span><br><span class="line">        PUSHAQ          ; Stack pointer decreased <span class="number">8</span> * <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; Set parameters <span class="keyword">for</span> SvHandleVmExit. Below is the current stack leyout.</span><br><span class="line">        ; ----</span><br><span class="line">        ; Rsp                             =&gt; <span class="number">0</span>x...dc0 R15               ; GUEST_REGISTERS</span><br><span class="line">        ;                                    <span class="number">0</span>x...dc8 R14               ;</span><br><span class="line">        ;                                             ...               ;</span><br><span class="line">        ;                                    <span class="number">0</span>x...e38 RAX               ;</span><br><span class="line">        ; Rsp + <span class="number">8</span> * <span class="number">16</span>                    =&gt; <span class="number">0</span>x...e40 TrapFrame         ; HostStackLayout</span><br><span class="line">        ;                                             ...               ;</span><br><span class="line">        ; Rsp + <span class="number">8</span> * <span class="number">16</span> + KTRAP_FRAME_SIZE =&gt; <span class="number">0</span>x...fd0 GuestVmcbPa       ;</span><br><span class="line">        ;                                    <span class="number">0</span>x...fd8 HostVmcbPa        ;</span><br><span class="line">        ; Rsp + <span class="number">8</span> * <span class="number">18</span> + KTRAP_FRAME_SIZE =&gt; <span class="number">0</span>x...fe0 Self              ;</span><br><span class="line">        ;                                    <span class="number">0</span>x...fe8 SharedVpData      ;</span><br><span class="line">        ;                                    <span class="number">0</span>x...ff0 Padding1          ;</span><br><span class="line">        ;                                    <span class="number">0</span>x...ff8 Reserved1         ;</span><br><span class="line">        ; ----</span><br><span class="line">        ;</span><br><span class="line">        mov rdx, rsp                                ; Rdx &lt;= GuestRegisters</span><br><span class="line">        mov rcx, [rsp + <span class="number">8</span> * <span class="number">18</span> + KTRAP_FRAME_SIZE]  ; Rcx &lt;= VpData  rcx==Self</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; <span class="function">Allocate stack <span class="keyword">for</span> homing <span class="title">space</span> <span class="params">(<span class="number">0x20</span>)</span> <span class="keyword">and</span> <span class="keyword">volatile</span> XMM registers</span></span><br><span class="line"><span class="function">        </span>; (<span class="number">0x60</span>). Save those registers because subsequent host code may destroy</span><br><span class="line">        ; any of those registers. XMM6<span class="number">-15</span> are <span class="keyword">not</span> saved because those should be</span><br><span class="line">        ; <span class="built_in">preserved</span> (those are non <span class="keyword">volatile</span> registers). Finally, indicates the</span><br><span class="line">        ; end of the function prolog as stack pointer changes are all done. This</span><br><span class="line">        ; is <span class="keyword">for</span> Windbg to reconstruct stack trace.</span><br><span class="line">        ;</span><br><span class="line">        sub rsp, <span class="number">80</span>h</span><br><span class="line">        movaps xmmword ptr [rsp + <span class="number">20</span>h], xmm0</span><br><span class="line">        movaps xmmword ptr [rsp + <span class="number">30</span>h], xmm1</span><br><span class="line">        movaps xmmword ptr [rsp + <span class="number">40</span>h], xmm2</span><br><span class="line">        movaps xmmword ptr [rsp + <span class="number">50</span>h], xmm3</span><br><span class="line">        movaps xmmword ptr [rsp + <span class="number">60</span>h], xmm4</span><br><span class="line">        movaps xmmword ptr [rsp + <span class="number">70</span>h], xmm5</span><br><span class="line">        .endprolog</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; Handle #VMEXIT.</span><br><span class="line">        ;</span><br><span class="line">        call SvHandleVmExit</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; Restore XMM registers <span class="keyword">and</span> roll back stack pointer.</span><br><span class="line">        ;</span><br><span class="line">        movaps xmm5, xmmword ptr [rsp + <span class="number">70</span>h]</span><br><span class="line">        movaps xmm4, xmmword ptr [rsp + <span class="number">60</span>h]</span><br><span class="line">        movaps xmm3, xmmword ptr [rsp + <span class="number">50</span>h]</span><br><span class="line">        movaps xmm2, xmmword ptr [rsp + <span class="number">40</span>h]</span><br><span class="line">        movaps xmm1, xmmword ptr [rsp + <span class="number">30</span>h]</span><br><span class="line">        movaps xmm0, xmmword ptr [rsp + <span class="number">20</span>h]</span><br><span class="line">        add rsp, <span class="number">80</span>h</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; <span class="function">Test a <span class="keyword">return</span> value of <span class="title">SvHandleVmExit</span> <span class="params">(RAX)</span>, then POPAQ to restore the</span></span><br><span class="line"><span class="function">        </span>; original guest<span class="number">&#x27;</span>s GPRs.</span><br><span class="line">        ;</span><br><span class="line">        test al, al</span><br><span class="line">        POPAQ</span><br><span class="line"></span><br><span class="line">        ;</span><br><span class="line">        ; If non zero value is returned from SvHandleVmExit, <span class="keyword">this</span> function exits</span><br><span class="line">        ; the loop. Otherwise, <span class="keyword">continue</span> the loop <span class="keyword">and</span> resume the guest.</span><br><span class="line">        ;</span><br><span class="line">        jnz SvLV20                  ; <span class="keyword">if</span> (ExitVm != <span class="number">0</span>) jmp SvLV20</span><br><span class="line">        add rsp, KTRAP_FRAME_SIZE   ; <span class="keyword">else</span>, restore RSP <span class="keyword">and</span></span><br><span class="line">        jmp SvLV10                  ; jmp SvLV10</span><br><span class="line"></span><br><span class="line">SvLV20: ;</span><br><span class="line">        ; Virtualization has been terminated. <span class="function">Restore an <span class="title">original</span> <span class="params">(guest<span class="string">&#x27;s,</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ; although it is no longer the &quot;guest&quot;) stack pointer and return to the</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ; next instruction of CPUID triggered this #VMEXIT.</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ; Here is contents of certain registers:</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ;   RBX     = An address to return</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ;   RCX     = An original stack pointer to restore</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ;   EDX:EAX = An address of per processor data for this processor</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        mov rsp, rcx</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ; Update RCX with the magic value indicating that the SimpleSvm</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ; hypervisor has been unloaded.</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        ;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">        mov ecx, &#x27;</span>SSVM<span class="number">&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        ;</span></span></span><br><span class="line"><span class="params"><span class="function">        ; Return to the next instruction of CPUID triggered <span class="keyword">this</span> #VMEXIT. The</span></span></span><br><span class="line"><span class="params"><span class="function">        ; registry values to be returned are:</span></span></span><br><span class="line"><span class="params"><span class="function">        ;   EBX     = Undefined</span></span></span><br><span class="line"><span class="params"><span class="function">        ;   ECX     = <span class="string">&#x27;SSVM&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ;   EDX:EAX = An address of per processor data <span class="keyword">for</span> <span class="keyword">this</span> processor</span></span></span><br><span class="line"><span class="params"><span class="function">        ;</span></span></span><br><span class="line"><span class="params"><span class="function">        jmp rbx</span></span></span><br><span class="line"><span class="params"><span class="function">SvLaunchVm endp</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        end</span></span></span><br></pre></td></tr></table></figure>

<h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><p>NPT: nested page table</p>
<p>建立一个页表映射</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">SvBuildNestedPageTables</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PSHARED_VIRTUAL_PROCESSOR_DATA SharedVpData</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG64 pdpBasePa, pdeBasePa, translationPa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Build only one PML4 entry. This entry has subtables that control up to</span></span><br><span class="line">    <span class="comment">// 512GB physical memory. PFN points to a base physical address of the page</span></span><br><span class="line">    <span class="comment">// directory pointer table.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    pdpBasePa = <span class="built_in">MmGetPhysicalAddress</span>(&amp;SharedVpData-&gt;PdpEntries).QuadPart;</span><br><span class="line">    SharedVpData-&gt;Pml4Entries[<span class="number">0</span>].Fields.PageFrameNumber = pdpBasePa &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The US (User) bit of all nested page table entries to be translated</span></span><br><span class="line">    <span class="comment">// without #VMEXIT, as all guest accesses are treated as user accesses at</span></span><br><span class="line">    <span class="comment">// the nested level. Also, the RW (Write) bit of nested page table entries</span></span><br><span class="line">    <span class="comment">// that corresponds to guest page tables must be 1 since all guest page</span></span><br><span class="line">    <span class="comment">// table accesses are threated as write access. See &quot;Nested versus Guest</span></span><br><span class="line">    <span class="comment">// Page Faults, Fault Ordering&quot; for more details.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Nested page tables built here set 1 to those bits for all entries, so</span></span><br><span class="line">    <span class="comment">// that all translation can complete without triggering #VMEXIT. This does</span></span><br><span class="line">    <span class="comment">// not lower security since security checks are done twice independently:</span></span><br><span class="line">    <span class="comment">// based on guest page tables, and nested page tables. See &quot;Nested versus</span></span><br><span class="line">    <span class="comment">// Guest Page Faults, Fault Ordering&quot; for more details.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SharedVpData-&gt;Pml4Entries[<span class="number">0</span>].Fields.Valid = <span class="number">1</span>;</span><br><span class="line">    SharedVpData-&gt;Pml4Entries[<span class="number">0</span>].Fields.Write = <span class="number">1</span>;</span><br><span class="line">    SharedVpData-&gt;Pml4Entries[<span class="number">0</span>].Fields.User = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// One PML4 entry controls 512 page directory pointer entires.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG64 i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// PFN points to a base physical address of the page directory table.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        pdeBasePa = <span class="built_in">MmGetPhysicalAddress</span>(&amp;SharedVpData-&gt;PdeEntries[i][<span class="number">0</span>]).QuadPart;</span><br><span class="line">        SharedVpData-&gt;PdpEntries[i].Fields.PageFrameNumber = pdeBasePa &gt;&gt; PAGE_SHIFT;</span><br><span class="line">        SharedVpData-&gt;PdpEntries[i].Fields.Valid = <span class="number">1</span>;</span><br><span class="line">        SharedVpData-&gt;PdpEntries[i].Fields.Write = <span class="number">1</span>;</span><br><span class="line">        SharedVpData-&gt;PdpEntries[i].Fields.User = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// One page directory entry controls 512 page directory entries.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// We do not explicitly configure PAT in the NPT entry. The consequences</span></span><br><span class="line">        <span class="comment">// of this are: 1) pages whose PAT (Page Attribute Table) type is the</span></span><br><span class="line">        <span class="comment">// Write-Combining (WC) memory type could be treated as the</span></span><br><span class="line">        <span class="comment">// Write-Combining Plus (WC+) while it should be WC when the MTRR type is</span></span><br><span class="line">        <span class="comment">// either Write Protect (WP), Writethrough (WT) or Writeback (WB), and</span></span><br><span class="line">        <span class="comment">// 2) pages whose PAT type is Uncacheable Minus (UC-) could be treated</span></span><br><span class="line">        <span class="comment">// as Cache Disabled (CD) while it should be WC, when MTRR type is WC.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// While those are not desirable, this is acceptable given that 1) only</span></span><br><span class="line">        <span class="comment">// introduces additional cache snooping and associated performance</span></span><br><span class="line">        <span class="comment">// penalty, which would not be significant since WC+ still lets</span></span><br><span class="line">        <span class="comment">// processors combine multiple writes into one and avoid large</span></span><br><span class="line">        <span class="comment">// performance penalty due to frequent writes to memory without caching.</span></span><br><span class="line">        <span class="comment">// 2) might be worse but I have not seen MTRR ranges configured as WC</span></span><br><span class="line">        <span class="comment">// on testing, hence the unintentional UC- will just results in the same</span></span><br><span class="line">        <span class="comment">// effective memory type as what would be with UC.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// See &quot;Memory Types&quot; (7.4), for details of memory types,</span></span><br><span class="line">        <span class="comment">// &quot;PAT-Register PA-Field Indexing&quot;, &quot;Combining Guest and Host PAT Types&quot;,</span></span><br><span class="line">        <span class="comment">// and &quot;Combining PAT and MTRR Types&quot; for how the effective memory type</span></span><br><span class="line">        <span class="comment">// is determined based on Guest PAT type, Host PAT type, and the MTRR</span></span><br><span class="line">        <span class="comment">// type.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The correct approach may be to look up the guest PTE and copy the</span></span><br><span class="line">        <span class="comment">// caching related bits (PAT, PCD, and PWT) when constructing NTP</span></span><br><span class="line">        <span class="comment">// entries for non RAM regions, so the combined PAT will always be the</span></span><br><span class="line">        <span class="comment">// same as the guest PAT type. This may be done when any issue manifests</span></span><br><span class="line">        <span class="comment">// with the current implementation.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (ULONG64 j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// PFN points to a base physical address of system physical address</span></span><br><span class="line">            <span class="comment">// to be translated from a guest physical address. Set the PS</span></span><br><span class="line">            <span class="comment">// (LargePage) bit to indicate that this is a large page and no</span></span><br><span class="line">            <span class="comment">// subtable exists.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            translationPa = (i * <span class="number">512</span>) + j;</span><br><span class="line">            SharedVpData-&gt;PdeEntries[i][j].Fields.PageFrameNumber = translationPa;</span><br><span class="line">            SharedVpData-&gt;PdeEntries[i][j].Fields.Valid = <span class="number">1</span>;</span><br><span class="line">            SharedVpData-&gt;PdeEntries[i][j].Fields.Write = <span class="number">1</span>;</span><br><span class="line">            SharedVpData-&gt;PdeEntries[i][j].Fields.User = <span class="number">1</span>;</span><br><span class="line">            SharedVpData-&gt;PdeEntries[i][j].Fields.LargePage = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>借助rust的某些crate，可以更快的开发</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.rs/x86/latest/x86/">x86 crate</a></li>
</ul>
<p>一个trait，代表了SVM的行为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> fmt::<span class="built_in">Debug</span>;</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">trait</span> <span class="title class_">HardwareVt</span>: fmt::<span class="built_in">Debug</span> &#123;</span><br><span class="line">    <span class="comment">/// Enables HW VT on the current processor. It has to be called exactly once</span></span><br><span class="line">    <span class="comment">/// before calling any other method.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">enable</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Configures HW VT such as enabling nested paging and exception</span></span><br><span class="line">    <span class="comment">/// interception.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">initialize</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, nested_pml4_addr: <span class="type">u64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Configures the guest states based on the snapshot.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">revert_registers</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, snapshot: &amp;Snapshot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Updates the guest states to make the guest use input data.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">adjust_registers</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, input_addr: <span class="type">u64</span>, input_size: <span class="type">u64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Executes the guest until it triggers VM exit.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> VmExitReason;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Invalidates caches of the nested paging structures.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">invalidate_caches</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Gets a flag value to be set to nested paging structure entries for the</span></span><br><span class="line">    <span class="comment">/// given entry types (eg, permissions).</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">nps_entry_flags</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>,</span><br><span class="line">        entry_type: NestedPagingStructureEntryType,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> NestedPagingStructureEntryFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>检查支持情况，硬件支持以及是否可以开启nPT。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">platform_support</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), SvmError&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">cpuid</span> = CpuId::<span class="title function_ invoke__">new</span>();</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(vi) = cpuid.<span class="title function_ invoke__">get_vendor_info</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> vi.<span class="title function_ invoke__">as_str</span>() != <span class="string">&quot;AuthenticAMD&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SvmError::CPUUnSupport);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// has_svm</span></span><br><span class="line">	<span class="comment">// self.vendor == Vendor::Amd &amp;&amp; self.ecx.contains(ExtendedFunctionInfoEcx::SVM)</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(fi) = cpuid.<span class="title function_ invoke__">get_extended_processor_and_feature_identifiers</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> !fi.<span class="title function_ invoke__">has_svm</span>() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SvmError::SVMUnsupport);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(si) = cpuid.<span class="title function_ invoke__">get_svm_info</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> !si.<span class="title function_ invoke__">has_nested_paging</span>() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SvmError::NPTUnsupport);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !si.<span class="title function_ invoke__">has_svm_lock</span>() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SvmError::SVMLock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后enable svm；初始化，svm保存host_area的物理地址，初始化几个寄存器</p>
<p>这里需要学习一下快照技术，因为启动机器一次比较浪费时间，追求性能。</p>
<ul>
<li>简单来说就是保存初始的状态</li>
<li>这个状态包含了内存，寄存器，文件等信息</li>
</ul>
<p>可以逆向自己编写的程序，进行逆向</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure>

<p><code>xchg bx, bx</code> 是bochs的魔术断点，如果不使用bochs，这一段代码也不会产生太多影响。</p>
<p>我们测试时需要一个0环的权限，因此还是写驱动</p>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    chips
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/Ha0-Y">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
